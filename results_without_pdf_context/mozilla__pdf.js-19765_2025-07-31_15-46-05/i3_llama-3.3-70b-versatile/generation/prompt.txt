Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
There should be a separator space between radio buttons/checkboxes and their labels/strings
</issue>

Patch:
<patch>
diff --git a/src/core/xfa/template.js b/src/core/xfa/template.js
--- a/src/core/xfa/template.js
+++ b/src/core/xfa/template.js
@@ -1321,7 +1321,7 @@ class CheckButton extends XFAObject {
   [$toHTML](availableSpace) {
     // TODO: border, shape and mark.
 
-    const style = toStyle("margin");
+    const style = toStyle(this, "margin");
     const size = measureToString(this.size);
 
     style.width = style.height = size;


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.10
- @babel/preset-env: ^7.26.9
- @babel/runtime: ^7.27.0
- @fluent/bundle: ^0.19.0
- @fluent/dom: ^0.10.1
- @metalsmith/layouts: ^3.0.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.68
- @types/node: ^22.13.14
- autoprefixer: ^10.4.21
- babel-loader: ^10.0.0
- caniuse-lite: ^1.0.30001707
- core-js: ^3.41.0
- eslint: ^9.23.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.10.1
- eslint-plugin-prettier: ^5.2.5
- eslint-plugin-unicorn: ^58.0.0
- globals: ^16.0.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.6.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.5.3
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.5.3
- puppeteer: ^24.4.0
- stylelint: ^16.17.0
- stylelint-prettier: ^5.0.3
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.14
- tsc-alias: ^1.8.13
- ttest: ^4.0.0
- typescript: ^5.8.2
- vinyl: ^3.0.0
- webpack: ^5.98.0
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/calculate_md5.js`: calculateMD5
- `../../src/core/calculate_sha256.js`: calculateSHA256
- `../../src/core/calculate_sha_other.js`: calculateSHA384, calculateSHA512
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/colorspace_utils.js`: ColorSpaceUtils
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalColorSpaceCache, GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, isValidExplicitDest, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/cmap_reader_factory.js`: DOMCMapReaderFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, SupportedImageMimeTypes, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/drawers/signaturedraw.js`: SignatureExtractor
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodeCMapReaderFactory, NodeStandardFontDataFactory, fetchData
- `../../src/display/standard_fontdata_factory.js`: DOMStandardFontDataFactory
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, DrawOPS, FeatureTest, FormatError, ImageKind, InvalidPDFException, MathClamp, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, ResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/autolinker.js`: Autolinker
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultCMapReaderFactory, DefaultFileReaderFactory, DefaultStandardFontDataFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/core/xfa/template.js
1 /* Copyright 2021 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   $acceptWhitespace,
18   $addHTML,
19   $appendChild,
20   $childrenToHTML,
21   $clean,
22   $cleanPage,
23   $content,
24   $data,
25   $extra,
26   $finalize,
27   $flushHTML,
28   $getAvailableSpace,
29   $getChildren,
30   $getContainedChildren,
31   $getExtra,
32   $getNextPage,
33   $getParent,
34   $getSubformParent,
35   $getTemplateRoot,
36   $globalData,
37   $hasSettableValue,
38   $ids,
39   $isBindable,
40   $isCDATAXml,
41   $isSplittable,
42   $isThereMoreWidth,
43   $isTransparent,
44   $isUsable,
45   $namespaceId,
46   $nodeName,
47   $onChild,
48   $onText,
49   $popPara,
50   $pushPara,
51   $removeChild,
52   $searchNode,
53   $setSetAttributes,
54   $setValue,
55   $tabIndex,
56   $text,
57   $toHTML,
58   $toPages,
59   $toStyle,
60   $uid,
61 } from "./symbol_utils.js";
62 import { $buildXFAObject, NamespaceIds } from "./namespaces.js";
63 import {
64   addHTML,
65   checkDimensions,
66   flushHTML,
67   getAvailableSpace,
68 } from "./layout.js";
69 import {
70   computeBbox,
71   createWrapper,
72   fixDimensions,
73   fixTextIndent,
74   fixURL,
75   isPrintOnly,
76   layoutClass,
77   layoutNode,
78   measureToString,
79   setAccess,
80   setFontFamily,
81   setMinMaxDimensions,
82   setPara,
83   toStyle,
84 } from "./html_utils.js";
85 import {
86   ContentObject,
87   Option01,
88   OptionObject,
89   StringObject,
90   XFAObject,
91   XFAObjectArray,
92 } from "./xfa_object.js";
93 import { fromBase64Util, Util, warn } from "../../shared/util.js";
94 import {
95   getBBox,
96   getColor,
97   getFloat,
98   getInteger,
99   getKeyword,
100   getMeasurement,
101   getRatio,
102   getRelevant,
103   getStringOption,
104   HTMLResult,
105 } from "./utils.js";
106 import { getMetrics } from "./fonts.js";
107 import { recoverJsURL } from "../core_utils.js";
108 import { searchNode } from "./som.js";
109 
110 const TEMPLATE_NS_ID = NamespaceIds.template.id;
111 const SVG_NS = "http://www.w3.org/2000/svg";
112 
113 // In case of lr-tb (and rl-tb) layouts, we try:
114 //  - to put the container at the end of a line
115 //  - and if it fails we try on the next line.
116 // If both tries failed then it's up to the parent
117 // to handle the situation.
118 const MAX_ATTEMPTS_FOR_LRTB_LAYOUT = 2;
119 
120 // It's possible to have a bug in the layout and so as
121 // a consequence we could loop for ever in Template::toHTML()
122 // so in order to avoid that (and avoid a OOM crash) we break
123 // the loop after having MAX_EMPTY_PAGES empty pages.
124 const MAX_EMPTY_PAGES = 3;
125 
126 // Default value to start with for the tabIndex property.
127 const DEFAULT_TAB_INDEX = 5000;
128 
129 const HEADING_PATTERN = /^H(\d+)$/;
130 
131 // Allowed mime types for images
132 const MIMES = new Set([
133   "image/gif",
134   "image/jpeg",
135   "image/jpg",
136   "image/pjpeg",
137   "image/png",
138   "image/apng",
139   "image/x-png",
140   "image/bmp",
141   "image/x-ms-bmp",
142   "image/tiff",
143   "image/tif",
144   "application/octet-stream",
145 ]);
146 
147 const IMAGES_HEADERS = [
148   [[0x42, 0x4d], "image/bmp"],
149   [[0xff, 0xd8, 0xff], "image/jpeg"],
150   [[0x49, 0x49, 0x2a, 0x00], "image/tiff"],
151   [[0x4d, 0x4d, 0x00, 0x2a], "image/tiff"],
152   [[0x47, 0x49, 0x46, 0x38, 0x39, 0x61], "image/gif"],
153   [[0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a], "image/png"],
154 ];
155 
156 function getBorderDims(node) {
157   if (!node || !node.border) {
158     return { w: 0, h: 0 };
159   }
160 
161   const borderExtra = node.border[$getExtra]();
162   if (!borderExtra) {
163     return { w: 0, h: 0 };
164   }
165 
166   return {
167     w:
168       borderExtra.widths[0] +
169       borderExtra.widths[2] +
170       borderExtra.insets[0] +
171       borderExtra.insets[2],
172     h:
173       borderExtra.widths[1] +
174       borderExtra.widths[3] +
175       borderExtra.insets[1] +
176       borderExtra.insets[3],
177   };
178 }
179 
180 function hasMargin(node) {
181   return (
182     node.margin &&
183     (node.margin.topInset ||
184       node.margin.rightInset ||
185       node.margin.bottomInset ||
186       node.margin.leftInset)
187   );
188 }
189 
190 function _setValue(templateNode, value) {
191   if (!templateNode.value) {
192     const nodeValue = new Value({});
193     templateNode[$appendChild](nodeValue);
194     templateNode.value = nodeValue;
195   }
196   templateNode.value[$setValue](value);
197 }
198 
199 function* getContainedChildren(node) {
200   for (const child of node[$getChildren]()) {
201     if (child instanceof SubformSet) {
202       yield* child[$getContainedChildren]();
203       continue;
204     }
205     yield child;
206   }
207 }
208 
209 function isRequired(node) {
210   return node.validate?.nullTest === "error";
211 }
212 
213 function setTabIndex(node) {
214   while (node) {
215     if (!node.traversal) {
216       node[$tabIndex] = node[$getParent]()[$tabIndex];
217       return;
218     }
219 
220     if (node[$tabIndex]) {
221       return;
222     }
223 
224     let next = null;
225     for (const child of node.traversal[$getChildren]()) {
226       if (child.operation === "next") {
227         next = child;
228         break;
229       }
230     }
231 
232     if (!next || !next.ref) {
233       node[$tabIndex] = node[$getParent]()[$tabIndex];
234       return;
235     }
236 
237     const root = node[$getTemplateRoot]();
238     node[$tabIndex] = ++root[$tabIndex];
239 
240     const ref = root[$searchNode](next.ref, node);
241     if (!ref) {
242       return;
243     }
244 
245     node = ref[0];
246   }
247 }
248 
249 function applyAssist(obj, attributes) {
250   const assist = obj.assist;
251   if (assist) {
252     const assistTitle = assist[$toHTML]();
253     if (assistTitle) {
254       attributes.title = assistTitle;
255     }
256     const role = assist.role;
257     const match = role.match(HEADING_PATTERN);
258     if (match) {
259       const ariaRole = "heading";
260       const ariaLevel = match[1];
261       attributes.role = ariaRole;
262       attributes["aria-level"] = ariaLevel;
263     }
264   }
265   // XXX: We could end up in a situation where the obj has a heading role and
266   // is also a table. For now prioritize the table role.
267   if (obj.layout === "table") {
268     attributes.role = "table";
269   } else if (obj.layout === "row") {
270     attributes.role = "row";
271   } else {
272     const parent = obj[$getParent]();
273     if (parent.layout === "row") {
274       attributes.role = parent.assist?.role === "TH" ? "columnheader" : "cell";
275     }
276   }
277 }
278 
279 function ariaLabel(obj) {
280   if (!obj.assist) {
281     return null;
282   }
283   const assist = obj.assist;
284   if (assist.speak && assist.speak[$content] !== "") {
285     return assist.speak[$content];
286   }
287   if (assist.toolTip) {
288     return assist.toolTip[$content];
289   }
290   // TODO: support finding the related caption element. See xfa_bug1718037.pdf
291   // for an example.
292   return null;
293 }
294 
295 function valueToHtml(value) {
296   return HTMLResult.success({
297     name: "div",
298     attributes: {
299       class: ["xfaRich"],
300       style: Object.create(null),
301     },
302     children: [
303       {
304         name: "span",
305         attributes: {
306           style: Object.create(null),
307         },
308         value,
309       },
310     ],
311   });
312 }
313 
314 function setFirstUnsplittable(node) {
315   const root = node[$getTemplateRoot]();
316   if (root[$extra].firstUnsplittable === null) {
317     root[$extra].firstUnsplittable = node;
318     root[$extra].noLayoutFailure = true;
319   }
320 }
321 
322 function unsetFirstUnsplittable(node) {
323   const root = node[$getTemplateRoot]();
324   if (root[$extra].firstUnsplittable === node) {
325     root[$extra].noLayoutFailure = false;
326   }
327 }
328 
329 function handleBreak(node) {
330   if (node[$extra]) {
331     return false;
332   }
333 
334   node[$extra] = Object.create(null);
335 
336   if (node.targetType === "auto") {
337     return false;
338   }
339 
340   const root = node[$getTemplateRoot]();
341   let target = null;
342   if (node.target) {
343     target = root[$searchNode](node.target, node[$getParent]());
344     if (!target) {
345       return false;
346     }
347     target = target[0];
348   }
349 
350   const { currentPageArea, currentContentArea } = root[$extra];
351 
352   if (node.targetType === "pageArea") {
353     if (!(target instanceof PageArea)) {
354       target = null;
355     }
356 
357     if (node.startNew) {
358       node[$extra].target = target || currentPageArea;
359       return true;
360     } else if (target && target !== currentPageArea) {
361       node[$extra].target = target;
362       return true;
363     }
364 
365     return false;
366   }
367 
368   if (!(target instanceof ContentArea)) {
369     target = null;
370   }
371 
372   const pageArea = target && target[$getParent]();
373 
374   let index;
375   let nextPageArea = pageArea;
376   if (node.startNew) {
377     // startNew === 1 so we must create a new container (pageArea or
378     // contentArea).
379     if (target) {
380       const contentAreas = pageArea.contentArea.children;
381       const indexForCurrent = contentAreas.indexOf(currentContentArea);
382       const indexForTarget = contentAreas.indexOf(target);
383       if (indexForCurrent !== -1 && indexForCurrent < indexForTarget) {
384         // The next container is after the current container so
385         // we can stay on the same page.
386         nextPageArea = null;
387       }
388       index = indexForTarget - 1;
389     } else {
390       index = currentPageArea.contentArea.children.indexOf(currentContentArea);
391     }
392   } else if (target && target !== currentContentArea) {
393     const contentAreas = pageArea.contentArea.children;
394     index = contentAreas.indexOf(target) - 1;
395     nextPageArea = pageArea === currentPageArea ? null : pageArea;
396   } else {
397     return false;
398   }
399 
400   node[$extra].target = nextPageArea;
401   node[$extra].index = index;
402   return true;
403 }
404 
405 function handleOverflow(node, extraNode, space) {
406   const root = node[$getTemplateRoot]();
407   const saved = root[$extra].noLayoutFailure;
408   const savedMethod = extraNode[$getSubformParent];
409 
410   // Replace $getSubformParent to emulate that extraNode is just
411   // under node.
412   extraNode[$getSubformParent] = () => node;
413 
414   root[$extra].noLayoutFailure = true;
415   const res = extraNode[$toHTML](space);
416   node[$addHTML](res.html, res.bbox);
417   root[$extra].noLayoutFailure = saved;
418   extraNode[$getSubformParent] = savedMethod;
419 }
420 
421 class AppearanceFilter extends StringObject {
422   constructor(attributes) {
423     super(TEMPLATE_NS_ID, "appearanceFilter");
424     this.id = attributes.id || "";
425     this.type = getStringOption(attributes.type, ["optional", "required"]);
426     this.use = attributes.use || "";
427     this.usehref = attributes.usehref || "";
428   }
429 }
430 
431 class Arc extends XFAObject {
432   constructor(attributes) {
433     super(TEMPLATE_NS_ID, "arc", /* hasChildren = */ true);
434     this.circular = getInteger({
435       data: attributes.circular,
436       defaultValue: 0,
437       validate: x => x === 1,
438     });
439     this.hand = getStringOption(attributes.hand, ["even", "left", "right"]);
440     this.id = attributes.id || "";
441     this.startAngle = getFloat({
442       data: attributes.startAngle,
443       defaultValue: 0,
444       validate: x => true,
445     });
446     this.sweepAngle = getFloat({
447       data: attributes.sweepAngle,
448       defaultValue: 360,
449       validate: x => true,
450     });
451     this.use = attributes.use || "";
452     this.usehref = attributes.usehref || "";
453     this.edge = null;
454     this.fill = null;
455   }
456 
457   [$toHTML]() {
458     const edge = this.edge || new Edge({});
459     const edgeStyle = edge[$toStyle]();
460     const style = Object.create(null);
461     if (this.fill?.presence === "visible") {
462       Object.assign(style, this.fill[$toStyle]());
463     } else {
464       style.fill = "transparent";
465     }
466     style.strokeWidth = measureToString(
467       edge.presence === "visible" ? edge.thickness : 0
468     );
469     style.stroke = edgeStyle.color;
470     let arc;
471     const attributes = {
472       xmlns: SVG_NS,
473       style: {
474         width: "100%",
475         height: "100%",
476         overflow: "visible",
477       },
478     };
479 
480     if (this.sweepAngle === 360) {
481       arc = {
482         name: "ellipse",
483         attributes: {
484           xmlns: SVG_NS,
485           cx: "50%",
486           cy: "50%",
487           rx: "50%",
488           ry: "50%",
489           style,
490         },
491       };
492     } else {
493       const startAngle = (this.startAngle * Math.PI) / 180;
494       const sweepAngle = (this.sweepAngle * Math.PI) / 180;
495       const largeArc = this.sweepAngle > 180 ? 1 : 0;
496       const [x1, y1, x2, y2] = [
497         50 * (1 + Math.cos(startAngle)),
498         50 * (1 - Math.sin(startAngle)),
499         50 * (1 + Math.cos(startAngle + sweepAngle)),
500         50 * (1 - Math.sin(startAngle + sweepAngle)),
501       ];
502 
503       arc = {
504         name: "path",
505         attributes: {
506           xmlns: SVG_NS,
507           d: `M ${x1} ${y1} A 50 50 0 ${largeArc} 0 ${x2} ${y2}`,
508           vectorEffect: "non-scaling-stroke",
509           style,
510         },
511       };
512 
513       Object.assign(attributes, {
514         viewBox: "0 0 100 100",
515         preserveAspectRatio: "none",
516       });
517     }
518 
519     const svg = {
520       name: "svg",
521       children: [arc],
522       attributes,
523     };
524 
525     const parent = this[$getParent]()[$getParent]();
526     if (hasMargin(parent)) {
527       return HTMLResult.success({
528         name: "div",
529         attributes: {
530           style: {
531             display: "inline",
532             width: "100%",
533             height: "100%",
534           },
535         },
536         children: [svg],
537       });
538     }
539 
540     svg.attributes.style.position = "absolute";
541     return HTMLResult.success(svg);
542   }
543 }
544 
545 class Area extends XFAObject {
546   constructor(attributes) {
547     super(TEMPLATE_NS_ID, "area", /* hasChildren = */ true);
548     this.colSpan = getInteger({
549       data: attributes.colSpan,
550       defaultValue: 1,
551       validate: n => n >= 1 || n === -1,
552     });
553     this.id = attributes.id || "";
554     this.name = attributes.name || "";
555     this.relevant = getRelevant(attributes.relevant);
556     this.use = attributes.use || "";
557     this.usehref = attributes.usehref || "";
558     this.x = getMeasurement(attributes.x, "0pt");
559     this.y = getMeasurement(attributes.y, "0pt");
560     this.desc = null;
561     this.extras = null;
562     this.area = new XFAObjectArray();
563     this.draw = new XFAObjectArray();
564     this.exObject = new XFAObjectArray();
565     this.exclGroup = new XFAObjectArray();
566     this.field = new XFAObjectArray();
567     this.subform = new XFAObjectArray();
568     this.subformSet = new XFAObjectArray();
569   }
570 
571   *[$getContainedChildren]() {
572     // This function is overriden in order to fake that subforms under
573     // this set are in fact under parent subform.
574     yield* getContainedChildren(this);
575   }
576 
577   [$isTransparent]() {
578     return true;
579   }
580 
581   [$isBindable]() {
582     return true;
583   }
584 
585   [$addHTML](html, bbox) {
586     const [x, y, w, h] = bbox;
587     this[$extra].width = Math.max(this[$extra].width, x + w);
588     this[$extra].height = Math.max(this[$extra].height, y + h);
589 
590     this[$extra].children.push(html);
591   }
592 
593   [$getAvailableSpace]() {
594     return this[$extra].availableSpace;
595   }
596 
597   [$toHTML](availableSpace) {
598     // TODO: incomplete.
599     const style = toStyle(this, "position");
600     const attributes = {
601       style,
602       id: this[$uid],
603       class: ["xfaArea"],
604     };
605 
606     if (isPrintOnly(this)) {
607       attributes.class.push("xfaPrintOnly");
608     }
609 
610     if (this.name) {
611       attributes.xfaName = this.name;
612     }
613 
614     const children = [];
615     this[$extra] = {
616       children,
617       width: 0,
618       height: 0,
619       availableSpace,
620     };
621 
622     const result = this[$childrenToHTML]({
623       filter: new Set([
624         "area",
625         "draw",
626         "field",
627         "exclGroup",
628         "subform",
629         "subformSet",
630       ]),
631       include: true,
632     });
633 
634     if (!result.success) {
635       if (result.isBreak()) {
636         return result;
637       }
638       // Nothing to propose for the element which doesn't fit the
639       // available space.
640       delete this[$extra];
641       return HTMLResult.FAILURE;
642     }
643 
644     style.width = measureToString(this[$extra].width);
645     style.height = measureToString(this[$extra].height);
646 
647     const html = {
648       name: "div",
649       attributes,
650       children,
651     };
652 
653     const bbox = [this.x, this.y, this[$extra].width, this[$extra].height];
654     delete this[$extra];
655 
656     return HTMLResult.success(html, bbox);
657   }
658 }
659 
660 class Assist extends XFAObject {
661   constructor(attributes) {
662     super(TEMPLATE_NS_ID, "assist", /* hasChildren = */ true);
663     this.id = attributes.id || "";
664     this.role = attributes.role || "";
665     this.use = attributes.use || "";
666     this.usehref = attributes.usehref || "";
667     this.speak = null;
668     this.toolTip = null;
669   }
670 
671   [$toHTML]() {
672     return this.toolTip?.[$content] || null;
673   }
674 }
675 
676 class Barcode extends XFAObject {
677   constructor(attributes) {
678     super(TEMPLATE_NS_ID, "barcode", /* hasChildren = */ true);
679     this.charEncoding = getKeyword({
680       data: attributes.charEncoding
681         ? attributes.charEncoding.toLowerCase()
682         : "",
683       defaultValue: "",
684       validate: k =>
685         [
686           "utf-8",
687           "big-five",
688           "fontspecific",
689           "gbk",
690           "gb-18030",
691           "gb-2312",
692           "ksc-5601",
693           "none",
694           "shift-jis",
695           "ucs-2",
696           "utf-16",
697         ].includes(k) || k.match(/iso-8859-\d{2}/),
698     });
699     this.checksum = getStringOption(attributes.checksum, [
700       "none",
701       "1mod10",
702       "1mod10_1mod11",
703       "2mod10",
704       "auto",
705     ]);
706     this.dataColumnCount = getInteger({
707       data: attributes.dataColumnCount,
708       defaultValue: -1,
709       validate: x => x >= 0,
710     });
711     this.dataLength = getInteger({
712       data: attributes.dataLength,
713       defaultValue: -1,
714       validate: x => x >= 0,
715     });
716     this.dataPrep = getStringOption(attributes.dataPrep, [
717       "none",
718       "flateCompress",
719     ]);
720     this.dataRowCount = getInteger({
721       data: attributes.dataRowCount,
722       defaultValue: -1,
723       validate: x => x >= 0,
724     });
725     this.endChar = attributes.endChar || "";
726     this.errorCorrectionLevel = getInteger({
727       data: attributes.errorCorrectionLevel,
728       defaultValue: -1,
729       validate: x => x >= 0 && x <= 8,
730     });
731     this.id = attributes.id || "";
732     this.moduleHeight = getMeasurement(attributes.moduleHeight, "5mm");
733     this.moduleWidth = getMeasurement(attributes.moduleWidth, "0.25mm");
734     this.printCheckDigit = getInteger({
735       data: attributes.printCheckDigit,
736       defaultValue: 0,
737       validate: x => x === 1,
738     });
739     this.rowColumnRatio = getRatio(attributes.rowColumnRatio);
740     this.startChar = attributes.startChar || "";
741     this.textLocation = getStringOption(attributes.textLocation, [
742       "below",
743       "above",
744       "aboveEmbedded",
745       "belowEmbedded",
746       "none",
747     ]);
748     this.truncate = getInteger({
749       data: attributes.truncate,
750       defaultValue: 0,
751       validate: x => x === 1,
752     });
753     this.type = getStringOption(
754       attributes.type ? attributes.type.toLowerCase() : "",
755       [
756         "aztec",
757         "codabar",
758         "code2of5industrial",
759         "code2of5interleaved",
760         "code2of5matrix",
761         "code2of5standard",
762         "code3of9",
763         "code3of9extended",
764         "code11",
765         "code49",
766         "code93",
767         "code128",
768         "code128a",
769         "code128b",
770         "code128c",
771         "code128sscc",
772         "datamatrix",
773         "ean8",
774         "ean8add2",
775         "ean8add5",
776         "ean13",
777         "ean13add2",
778         "ean13add5",
779         "ean13pwcd",
780         "fim",
781         "logmars",
782         "maxicode",
783         "msi",
784         "pdf417",
785         "pdf417macro",
786         "plessey",
787         "postauscust2",
788         "postauscust3",
789         "postausreplypaid",
790         "postausstandard",
791         "postukrm4scc",
792         "postusdpbc",
793         "postusimb",
794         "postusstandard",
795         "postus5zip",
796         "qrcode",
797         "rfid",
798         "rss14",
799         "rss14expanded",
800         "rss14limited",
801         "rss14stacked",
802         "rss14stackedomni",
803         "rss14truncated",
804         "telepen",
805         "ucc128",
806         "ucc128random",
807         "ucc128sscc",
808         "upca",
809         "upcaadd2",
810         "upcaadd5",
811         "upcapwcd",
812         "upce",
813         "upceadd2",
814         "upceadd5",
815         "upcean2",
816         "upcean5",
817         "upsmaxicode",
818       ]
819     );
820     this.upsMode = getStringOption(attributes.upsMode, [
821       "usCarrier",
822       "internationalCarrier",
823       "secureSymbol",
824       "standardSymbol",
825     ]);
826     this.use = attributes.use || "";
827     this.usehref = attributes.usehref || "";
828     this.wideNarrowRatio = getRatio(attributes.wideNarrowRatio);
829     this.encrypt = null;
830     this.extras = null;
831   }
832 }
833 
834 class Bind extends XFAObject {
835   constructor(attributes) {
836     super(TEMPLATE_NS_ID, "bind", /* hasChildren = */ true);
837     this.match = getStringOption(attributes.match, [
838       "once",
839       "dataRef",
840       "global",
841       "none",
842     ]);
843     this.ref = attributes.ref || "";
844     this.picture = null;
845   }
846 }
847 
848 class BindItems extends XFAObject {
849   constructor(attributes) {
850     super(TEMPLATE_NS_ID, "bindItems");
851     this.connection = attributes.connection || "";
852     this.labelRef = attributes.labelRef || "";
853     this.ref = attributes.ref || "";
854     this.valueRef = attributes.valueRef || "";
855   }
856 }
857 
858 class Bookend extends XFAObject {
859   constructor(attributes) {
860     super(TEMPLATE_NS_ID, "bookend");
861     this.id = attributes.id || "";
862     this.leader = attributes.leader || "";
863     this.trailer = attributes.trailer || "";
864     this.use = attributes.use || "";
865     this.usehref = attributes.usehref || "";
866   }
867 }
868 
869 class BooleanElement extends Option01 {
870   constructor(attributes) {
871     super(TEMPLATE_NS_ID, "boolean");
872     this.id = attributes.id || "";
873     this.name = attributes.name || "";
874     this.use = attributes.use || "";
875     this.usehref = attributes.usehref || "";
876   }
877 
878   [$toHTML](availableSpace) {
879     return valueToHtml(this[$content] === 1 ? "1" : "0");
880   }
881 }
882 
883 class Border extends XFAObject {
884   constructor(attributes) {
885     super(TEMPLATE_NS_ID, "border", /* hasChildren = */ true);
886     this.break = getStringOption(attributes.break, ["close", "open"]);
887     this.hand = getStringOption(attributes.hand, ["even", "left", "right"]);
888     this.id = attributes.id || "";
889     this.presence = getStringOption(attributes.presence, [
890       "visible",
891       "hidden",
892       "inactive",
893       "invisible",
894     ]);
895     this.relevant = getRelevant(attributes.relevant);
896     this.use = attributes.use || "";
897     this.usehref = attributes.usehref || "";
898     this.corner = new XFAObjectArray(4);
899     this.edge = new XFAObjectArray(4);
900     this.extras = null;
901     this.fill = null;
902     this.margin = null;
903   }
904 
905   [$getExtra]() {
906     if (!this[$extra]) {
907       const edges = this.edge.children.slice();
908       if (edges.length < 4) {
909         const defaultEdge = edges.at(-1) || new Edge({});
910         for (let i = edges.length; i < 4; i++) {
911           edges.push(defaultEdge);
912         }
913       }
914 
915       const widths = edges.map(edge => edge.thickness);
916       const insets = [0, 0, 0, 0];
917       if (this.margin) {
918         insets[0] = this.margin.topInset;
919         insets[1] = this.margin.rightInset;
920         insets[2] = this.margin.bottomInset;
921         insets[3] = this.margin.leftInset;
922       }
923       this[$extra] = { widths, insets, edges };
924     }
925     return this[$extra];
926   }
927 
928   [$toStyle]() {
929     // TODO: incomplete (hand).
930     const { edges } = this[$getExtra]();
931     const edgeStyles = edges.map(node => {
932       const style = node[$toStyle]();
933       style.color ||= "#000000";
934       return style;
935     });
936 
937     const style = Object.create(null);
938     if (this.margin) {
939       Object.assign(style, this.margin[$toStyle]());
940     }
941 
942     if (this.fill?.presence === "visible") {
943       Object.assign(style, this.fill[$toStyle]());
944     }
945 
946     if (this.corner.children.some(node => node.radius !== 0)) {
947       const cornerStyles = this.corner.children.map(node => node[$toStyle]());
948       if (cornerStyles.length === 2 || cornerStyles.length === 3) {
949         const last = cornerStyles.at(-1);
950         for (let i = cornerStyles.length; i < 4; i++) {
951           cornerStyles.push(last);
952         }
953       }
954 
955       style.borderRadius = cornerStyles.map(s => s.radius).join(" ");
956     }
957 
958     switch (this.presence) {
959       case "invisible":
960       case "hidden":
961         style.borderStyle = "";
962         break;
963       case "inactive":
964         style.borderStyle = "none";
965         break;
966       default:
967         style.borderStyle = edgeStyles.map(s => s.style).join(" ");
968         break;
969     }
970 
971     style.borderWidth = edgeStyles.map(s => s.width).join(" ");
972     style.borderColor = edgeStyles.map(s => s.color).join(" ");
973 
974     return style;
975   }
976 }
977 
978 class Break extends XFAObject {
979   constructor(attributes) {
980     super(TEMPLATE_NS_ID, "break", /* hasChildren = */ true);
981     this.after = getStringOption(attributes.after, [
982       "auto",
983       "contentArea",
984       "pageArea",
985       "pageEven",
986       "pageOdd",
987     ]);
988     this.afterTarget = attributes.afterTarget || "";
989     this.before = getStringOption(attributes.before, [
990       "auto",
991       "contentArea",
992       "pageArea",
993       "pageEven",
994       "pageOdd",
995     ]);
996     this.beforeTarget = attributes.beforeTarget || "";
997     this.bookendLeader = attributes.bookendLeader || "";
998     this.bookendTrailer = attributes.bookendTrailer || "";
999     this.id = attributes.id || "";
1000     this.overflowLeader = attributes.overflowLeader || "";
1001     this.overflowTarget = attributes.overflowTarget || "";
1002     this.overflowTrailer = attributes.overflowTrailer || "";
1003     this.startNew = getInteger({
1004       data: attributes.startNew,
1005       defaultValue: 0,
1006       validate: x => x === 1,
1007     });
1008     this.use = attributes.use || "";
1009     this.usehref = attributes.usehref || "";
1010     this.extras = null;
1011   }
1012 }
1013 
1014 class BreakAfter extends XFAObject {
1015   constructor(attributes) {
1016     super(TEMPLATE_NS_ID, "breakAfter", /* hasChildren = */ true);
1017     this.id = attributes.id || "";
1018     this.leader = attributes.leader || "";
1019     this.startNew = getInteger({
1020       data: attributes.startNew,
1021       defaultValue: 0,
1022       validate: x => x === 1,
1023     });
1024     this.target = attributes.target || "";
1025     this.targetType = getStringOption(attributes.targetType, [
1026       "auto",
1027       "contentArea",
1028       "pageArea",
1029     ]);
1030     this.trailer = attributes.trailer || "";
1031     this.use = attributes.use || "";
1032     this.usehref = attributes.usehref || "";
1033     this.script = null;
1034   }
1035 }
1036 
1037 class BreakBefore extends XFAObject {
1038   constructor(attributes) {
1039     super(TEMPLATE_NS_ID, "breakBefore", /* hasChildren = */ true);
1040     this.id = attributes.id || "";
1041     this.leader = attributes.leader || "";
1042     this.startNew = getInteger({
1043       data: attributes.startNew,
1044       defaultValue: 0,
1045       validate: x => x === 1,
1046     });
1047     this.target = attributes.target || "";
1048     this.targetType = getStringOption(attributes.targetType, [
1049       "auto",
1050       "contentArea",
1051       "pageArea",
1052     ]);
1053     this.trailer = attributes.trailer || "";
1054     this.use = attributes.use || "";
1055     this.usehref = attributes.usehref || "";
1056     this.script = null;
1057   }
1058 
1059   [$toHTML](availableSpace) {
1060     this[$extra] = {};
1061     return HTMLResult.FAILURE;
1062   }
1063 }
1064 
1065 class Button extends XFAObject {
1066   constructor(attributes) {
1067     super(TEMPLATE_NS_ID, "button", /* hasChildren = */ true);
1068     this.highlight = getStringOption(attributes.highlight, [
1069       "inverted",
1070       "none",
1071       "outline",
1072       "push",
1073     ]);
1074     this.id = attributes.id || "";
1075     this.use = attributes.use || "";
1076     this.usehref = attributes.usehref || "";
1077     this.extras = null;
1078   }
1079 
1080   [$toHTML](availableSpace) {
1081     // TODO: highlight.
1082 
1083     const parent = this[$getParent]();
1084     const grandpa = parent[$getParent]();
1085     const htmlButton = {
1086       name: "button",
1087       attributes: {
1088         id: this[$uid],
1089         class: ["xfaButton"],
1090         style: {},
1091       },
1092       children: [],
1093     };
1094 
1095     for (const event of grandpa.event.children) {
1096       // if (true) break;
1097       if (event.activity !== "click" || !event.script) {
1098         continue;
1099       }
1100       const jsURL = recoverJsURL(event.script[$content]);
1101       if (!jsURL) {
1102         continue;
1103       }
1104       const href = fixURL(jsURL.url);
1105       if (!href) {
1106         continue;
1107       }
1108 
1109       // we've an url so generate a <a>
1110       htmlButton.children.push({
1111         name: "a",
1112         attributes: {
1113           id: "link" + this[$uid],
1114           href,
1115           newWindow: jsURL.newWindow,
1116           class: ["xfaLink"],
1117           style: {},
1118         },
1119         children: [],
1120       });
1121     }
1122 
1123     return HTMLResult.success(htmlButton);
1124   }
1125 }
1126 
1127 class Calculate extends XFAObject {
1128   constructor(attributes) {
1129     super(TEMPLATE_NS_ID, "calculate", /* hasChildren = */ true);
1130     this.id = attributes.id || "";
1131     this.override = getStringOption(attributes.override, [
1132       "disabled",
1133       "error",
1134       "ignore",
1135       "warning",
1136     ]);
1137     this.use = attributes.use || "";
1138     this.usehref = attributes.usehref || "";
1139     this.extras = null;
1140     this.message = null;
1141     this.script = null;
1142   }
1143 }
1144 
1145 class Caption extends XFAObject {
1146   constructor(attributes) {
1147     super(TEMPLATE_NS_ID, "caption", /* hasChildren = */ true);
1148     this.id = attributes.id || "";
1149     this.placement = getStringOption(attributes.placement, [
1150       "left",
1151       "bottom",
1152       "inline",
1153       "right",
1154       "top",
1155     ]);
1156     this.presence = getStringOption(attributes.presence, [
1157       "visible",
1158       "hidden",
1159       "inactive",
1160       "invisible",
1161     ]);
1162     this.reserve = Math.ceil(getMeasurement(attributes.reserve));
1163     this.use = attributes.use || "";
1164     this.usehref = attributes.usehref || "";
1165     this.extras = null;
1166     this.font = null;
1167     this.margin = null;
1168     this.para = null;
1169     this.value = null;
1170   }
1171 
1172   [$setValue](value) {
1173     _setValue(this, value);
1174   }
1175 
1176   [$getExtra](availableSpace) {
1177     if (!this[$extra]) {
1178       let { width, height } = availableSpace;
1179       switch (this.placement) {
1180         case "left":
1181         case "right":
1182         case "inline":
1183           width = this.reserve <= 0 ? width : this.reserve;
1184           break;
1185         case "top":
1186         case "bottom":
1187           height = this.reserve <= 0 ? height : this.reserve;
1188           break;
1189       }
1190 
1191       this[$extra] = layoutNode(this, { width, height });
1192     }
1193     return this[$extra];
1194   }
1195 
1196   [$toHTML](availableSpace) {
1197     // TODO: incomplete.
1198     if (!this.value) {
1199       return HTMLResult.EMPTY;
1200     }
1201 
1202     this[$pushPara]();
1203     const value = this.value[$toHTML](availableSpace).html;
1204 
1205     if (!value) {
1206       this[$popPara]();
1207       return HTMLResult.EMPTY;
1208     }
1209 
1210     const savedReserve = this.reserve;
1211     if (this.reserve <= 0) {
1212       const { w, h } = this[$getExtra](availableSpace);
1213       switch (this.placement) {
1214         case "left":
1215         case "right":
1216         case "inline":
1217           this.reserve = w;
1218           break;
1219         case "top":
1220         case "bottom":
1221           this.reserve = h;
1222           break;
1223       }
1224     }
1225 
1226     const children = [];
1227     if (typeof value === "string") {
1228       children.push({
1229         name: "#text",
1230         value,
1231       });
1232     } else {
1233       children.push(value);
1234     }
1235 
1236     const style = toStyle(this, "font", "margin", "visibility");
1237     switch (this.placement) {
1238       case "left":
1239       case "right":
1240         if (this.reserve > 0) {
1241           style.width = measureToString(this.reserve);
1242         }
1243         break;
1244       case "top":
1245       case "bottom":
1246         if (this.reserve > 0) {
1247           style.height = measureToString(this.reserve);
1248         }
1249         break;
1250     }
1251 
1252     setPara(this, null, value);
1253     this[$popPara]();
1254 
1255     this.reserve = savedReserve;
1256 
1257     return HTMLResult.success({
1258       name: "div",
1259       attributes: {
1260         style,
1261         class: ["xfaCaption"],
1262       },
1263       children,
1264     });
1265   }
1266 }
1267 
1268 class Certificate extends StringObject {
1269   constructor(attributes) {
1270     super(TEMPLATE_NS_ID, "certificate");
1271     this.id = attributes.id || "";
1272     this.name = attributes.name || "";
1273     this.use = attributes.use || "";
1274     this.usehref = attributes.usehref || "";
1275   }
1276 }
1277 
1278 class Certificates extends XFAObject {
1279   constructor(attributes) {
1280     super(TEMPLATE_NS_ID, "certificates", /* hasChildren = */ true);
1281     this.credentialServerPolicy = getStringOption(
1282       attributes.credentialServerPolicy,
1283       ["optional", "required"]
1284     );
1285     this.id = attributes.id || "";
1286     this.url = attributes.url || "";
1287     this.urlPolicy = attributes.urlPolicy || "";
1288     this.use = attributes.use || "";
1289     this.usehref = attributes.usehref || "";
1290     this.encryption = null;
1291     this.issuers = null;
1292     this.keyUsage = null;
1293     this.oids = null;
1294     this.signing = null;
1295     this.subjectDNs = null;
1296   }
1297 }
1298 
1299 class CheckButton extends XFAObject {
1300   constructor(attributes) {
1301     super(TEMPLATE_NS_ID, "checkButton", /* hasChildren = */ true);
1302     this.id = attributes.id || "";
1303     this.mark = getStringOption(attributes.mark, [
1304       "default",
1305       "check",
1306       "circle",
1307       "cross",
1308       "diamond",
1309       "square",
1310       "star",
1311     ]);
1312     this.shape = getStringOption(attributes.shape, ["square", "round"]);
1313     this.size = getMeasurement(attributes.size, "10pt");
1314     this.use = attributes.use || "";
1315     this.usehref = attributes.usehref || "";
1316     this.border = null;
1317     this.extras = null;
1318     this.margin = null;
1319   }
1320 
1321   [$toHTML](availableSpace) {
1322     // TODO: border, shape and mark.
1323 
1324     const style = toStyle("margin");
1325     const size = measureToString(this.size);
1326 
1327     style.width = style.height = size;
1328 
1329     let type;
1330     let className;
1331     let groupId;
1332     const field = this[$getParent]()[$getParent]();
1333     const items =
1334       (field.items.children.length &&
1335         field.items.children[0][$toHTML]().html) ||
1336       [];
1337     const exportedValue = {
1338       on: (items[0] !== undefined ? items[0] : "on").toString(),
1339       off: (items[1] !== undefined ? items[1] : "off").toString(),
1340     };
1341 
1342     const value = field.value?.[$text]() || "off";
1343     const checked = value === exportedValue.on || undefined;
1344     const container = field[$getSubformParent]();
1345     const fieldId = field[$uid];
1346     let dataId;
1347 
1348     if (container instanceof ExclGroup) {
1349       groupId = container[$uid];
1350       type = "radio";
1351       className = "xfaRadio";
1352       dataId = container[$data]?.[$uid] || container[$uid];
1353     } else {
1354       type = "checkbox";
1355       className = "xfaCheckbox";
1356       dataId = field[$data]?.[$uid] || field[$uid];
1357     }
1358 
1359     const input = {
1360       name: "input",
1361       attributes: {
1362         class: [className],
1363         style,
1364         fieldId,
1365         dataId,
1366         type,
1367         checked,
1368         xfaOn: exportedValue.on,
1369         xfaOff: exportedValue.off,
1370         "aria-label": ariaLabel(field),
1371         "aria-required": false,
1372       },
1373     };
1374 
1375     if (groupId) {
1376       input.attributes.name = groupId;
1377     }
1378 
1379     if (isRequired(field)) {
1380       input.attributes["aria-required"] = true;
1381       input.attributes.required = true;
1382     }
1383 
1384     return HTMLResult.success({
1385       name: "label",
1386       attributes: {
1387         class: ["xfaLabel"],
1388       },
1389       children: [input],
1390     });
1391   }
1392 }
1393 
1394 class ChoiceList extends XFAObject {
1395   constructor(attributes) {
1396     super(TEMPLATE_NS_ID, "choiceList", /* hasChildren = */ true);
1397     this.commitOn = getStringOption(attributes.commitOn, ["select", "exit"]);
1398     this.id = attributes.id || "";
1399     this.open = getStringOption(attributes.open, [
1400       "userControl",
1401       "always",
1402       "multiSelect",
1403       "onEntry",
1404     ]);
1405     this.textEntry = getInteger({
1406       data: attributes.textEntry,
1407       defaultValue: 0,
1408       validate: x => x === 1,
1409     });
1410     this.use = attributes.use || "";
1411     this.usehref = attributes.usehref || "";
1412     this.border = null;
1413     this.extras = null;
1414     this.margin = null;
1415   }
1416 
1417   [$toHTML](availableSpace) {
1418     // TODO: incomplete.
1419     const style = toStyle(this, "border", "margin");
1420     const ui = this[$getParent]();
1421     const field = ui[$getParent]();
1422     const fontSize = field.font?.size || 10;
1423     const optionStyle = {
1424       fontSize: `calc(${fontSize}px * var(--total-scale-factor))`,
1425     };
1426     const children = [];
1427 
1428     if (field.items.children.length > 0) {
1429       const items = field.items;
1430       let displayedIndex = 0;
1431       let saveIndex = 0;
1432       if (items.children.length === 2) {
1433         displayedIndex = items.children[0].save;
1434         saveIndex = 1 - displayedIndex;
1435       }
1436       const displayed = items.children[displayedIndex][$toHTML]().html;
1437       const values = items.children[saveIndex][$toHTML]().html;
1438 
1439       let selected = false;
1440       const value = field.value?.[$text]() || "";
1441       for (let i = 0, ii = displayed.length; i < ii; i++) {
1442         const option = {
1443           name: "option",
1444           attributes: {
1445             value: values[i] || displayed[i],
1446             style: optionStyle,
1447           },
1448           value: displayed[i],
1449         };
1450         if (values[i] === value) {
1451           option.attributes.selected = selected = true;
1452         }
1453         children.push(option);
1454       }
1455 
1456       if (!selected) {
1457         children.splice(0, 0, {
1458           name: "option",
1459           attributes: {
1460             hidden: true,
1461             selected: true,
1462           },
1463           value: " ",
1464         });
1465       }
1466     }
1467 
1468     const selectAttributes = {
1469       class: ["xfaSelect"],
1470       fieldId: field[$uid],
1471       dataId: field[$data]?.[$uid] || field[$uid],
1472       style,
1473       "aria-label": ariaLabel(field),
1474       "aria-required": false,
1475     };
1476 
1477     if (isRequired(field)) {
1478       selectAttributes["aria-required"] = true;
1479       selectAttributes.required = true;
1480     }
1481 
1482     if (this.open === "multiSelect") {
1483       selectAttributes.multiple = true;
1484     }
1485 
1486     return HTMLResult.success({
1487       name: "label",
1488       attributes: {
1489         class: ["xfaLabel"],
1490       },
1491       children: [
1492         {
1493           name: "select",
1494           children,
1495           attributes: selectAttributes,
1496         },
1497       ],
1498     });
1499   }
1500 }
1501 
1502 class Color extends XFAObject {
1503   constructor(attributes) {
1504     super(TEMPLATE_NS_ID, "color", /* hasChildren = */ true);
1505     this.cSpace = getStringOption(attributes.cSpace, ["SRGB"]);
1506     this.id = attributes.id || "";
1507     this.use = attributes.use || "";
1508     this.usehref = attributes.usehref || "";
1509     this.value = attributes.value ? getColor(attributes.value) : "";
1510     this.extras = null;
1511   }
1512 
1513   [$hasSettableValue]() {
1514     return false;
1515   }
1516 
1517   [$toStyle]() {
1518     return this.value
1519       ? Util.makeHexColor(this.value.r, this.value.g, this.value.b)
1520       : null;
1521   }
1522 }
1523 
1524 class Comb extends XFAObject {
1525   constructor(attributes) {
1526     super(TEMPLATE_NS_ID, "comb");
1527     this.id = attributes.id || "";
1528     this.numberOfCells = getInteger({
1529       data: attributes.numberOfCells,
1530       defaultValue: 0,
1531       validate: x => x >= 0,
1532     });
1533     this.use = attributes.use || "";
1534     this.usehref = attributes.usehref || "";
1535   }
1536 }
1537 
1538 class Connect extends XFAObject {
1539   constructor(attributes) {
1540     super(TEMPLATE_NS_ID, "connect", /* hasChildren = */ true);
1541     this.connection = attributes.connection || "";
1542     this.id = attributes.id || "";
1543     this.ref = attributes.ref || "";
1544     this.usage = getStringOption(attributes.usage, [
1545       "exportAndImport",
1546       "exportOnly",
1547       "importOnly",
1548     ]);
1549     this.use = attributes.use || "";
1550     this.usehref = attributes.usehref || "";
1551     this.picture = null;
1552   }
1553 }
1554 
1555 class ContentArea extends XFAObject {
1556   constructor(attributes) {
1557     super(TEMPLATE_NS_ID, "contentArea", /* hasChildren = */ true);
1558     this.h = getMeasurement(attributes.h);
1559     this.id = attributes.id || "";
1560     this.name = attributes.name || "";
1561     this.relevant = getRelevant(attributes.relevant);
1562     this.use = attributes.use || "";
1563     this.usehref = attributes.usehref || "";
1564     this.w = getMeasurement(attributes.w);
1565     this.x = getMeasurement(attributes.x, "0pt");
1566     this.y = getMeasurement(attributes.y, "0pt");
1567     this.desc = null;
1568     this.extras = null;
1569   }
1570 
1571   [$toHTML](availableSpace) {
1572     // TODO: incomplete.
1573     const left = measureToString(this.x);
1574     const top = measureToString(this.y);
1575 
1576     const style = {
1577       left,
1578       top,
1579       width: measureToString(this.w),
1580       height: measureToString(this.h),
1581     };
1582 
1583     const classNames = ["xfaContentarea"];
1584 
1585     if (isPrintOnly(this)) {
1586       classNames.push("xfaPrintOnly");
1587     }
1588 
1589     return HTMLResult.success({
1590       name: "div",
1591       children: [],
1592       attributes: {
1593         style,
1594         class: classNames,
1595         id: this[$uid],
1596       },
1597     });
1598   }
1599 }
1600 
1601 class Corner extends XFAObject {
1602   constructor(attributes) {
1603     super(TEMPLATE_NS_ID, "corner", /* hasChildren = */ true);
1604     this.id = attributes.id || "";
1605     this.inverted = getInteger({
1606       data: attributes.inverted,
1607       defaultValue: 0,
1608       validate: x => x === 1,
1609     });
1610     this.join = getStringOption(attributes.join, ["square", "round"]);
1611     this.presence = getStringOption(attributes.presence, [
1612       "visible",
1613       "hidden",
1614       "inactive",
1615       "invisible",
1616     ]);
1617     this.radius = getMeasurement(attributes.radius);
1618     this.stroke = getStringOption(attributes.stroke, [
1619       "solid",
1620       "dashDot",
1621       "dashDotDot",
1622       "dashed",
1623       "dotted",
1624       "embossed",
1625       "etched",
1626       "lowered",
1627       "raised",
1628     ]);
1629     this.thickness = getMeasurement(attributes.thickness, "0.5pt");
1630     this.use = attributes.use || "";
1631     this.usehref = attributes.usehref || "";
1632     this.color = null;
1633     this.extras = null;
1634   }
1635 
1636   [$toStyle]() {
1637     // In using CSS it's only possible to handle radius
1638     // (at least with basic css).
1639     // Is there a real use (interest ?) of all these properties ?
1640     // Maybe it's possible to implement them using svg and border-image...
1641     // TODO: implement all the missing properties.
1642     const style = toStyle(this, "visibility");
1643     style.radius = measureToString(this.join === "square" ? 0 : this.radius);
1644     return style;
1645   }
1646 }
1647 
1648 class DateElement extends ContentObject {
1649   constructor(attributes) {
1650     super(TEMPLATE_NS_ID, "date");
1651     this.id = attributes.id || "";
1652     this.name = attributes.name || "";
1653     this.use = attributes.use || "";
1654     this.usehref = attributes.usehref || "";
1655   }
1656 
1657   [$finalize]() {
1658     const date = this[$content].trim();
1659     this[$content] = date ? new Date(date) : null;
1660   }
1661 
1662   [$toHTML](availableSpace) {
1663     return valueToHtml(this[$content] ? this[$content].toString() : "");
1664   }
1665 }
1666 
1667 class DateTime extends ContentObject {
1668   constructor(attributes) {
1669     super(TEMPLATE_NS_ID, "dateTime");
1670     this.id = attributes.id || "";
1671     this.name = attributes.name || "";
1672     this.use = attributes.use || "";
1673     this.usehref = attributes.usehref || "";
1674   }
1675 
1676   [$finalize]() {
1677     const date = this[$content].trim();
1678     this[$content] = date ? new Date(date) : null;
1679   }
1680 
1681   [$toHTML](availableSpace) {
1682     return valueToHtml(this[$content] ? this[$content].toString() : "");
1683   }
1684 }
1685 
1686 class DateTimeEdit extends XFAObject {
1687   constructor(attributes) {
1688     super(TEMPLATE_NS_ID, "dateTimeEdit", /* hasChildren = */ true);
1689     this.hScrollPolicy = getStringOption(attributes.hScrollPolicy, [
1690       "auto",
1691       "off",
1692       "on",
1693     ]);
1694     this.id = attributes.id || "";
1695     this.picker = getStringOption(attributes.picker, ["host", "none"]);
1696     this.use = attributes.use || "";
1697     this.usehref = attributes.usehref || "";
1698     this.border = null;
1699     this.comb = null;
1700     this.extras = null;
1701     this.margin = null;
1702   }
1703 
1704   [$toHTML](availableSpace) {
1705     // TODO: incomplete.
1706     // When the picker is host we should use type=date for the input
1707     // but we need to put the buttons outside the text-field.
1708     const style = toStyle(this, "border", "font", "margin");
1709     const field = this[$getParent]()[$getParent]();
1710     const html = {
1711       name: "input",
1712       attributes: {
1713         type: "text",
1714         fieldId: field[$uid],
1715         dataId: field[$data]?.[$uid] || field[$uid],
1716         class: ["xfaTextfield"],
1717         style,
1718         "aria-label": ariaLabel(field),
1719         "aria-required": false,
1720       },
1721     };
1722 
1723     if (isRequired(field)) {
1724       html.attributes["aria-required"] = true;
1725       html.attributes.required = true;
1726     }
1727 
1728     return HTMLResult.success({
1729       name: "label",
1730       attributes: {
1731         class: ["xfaLabel"],
1732       },
1733       children: [html],
1734     });
1735   }
1736 }
1737 
1738 class Decimal extends ContentObject {
1739   constructor(attributes) {
1740     super(TEMPLATE_NS_ID, "decimal");
1741     this.fracDigits = getInteger({
1742       data: attributes.fracDigits,
1743       defaultValue: 2,
1744       validate: x => true,
1745     });
1746     this.id = attributes.id || "";
1747     this.leadDigits = getInteger({
1748       data: attributes.leadDigits,
1749       defaultValue: -1,
1750       validate: x => true,
1751     });
1752     this.name = attributes.name || "";
1753     this.use = attributes.use || "";
1754     this.usehref = attributes.usehref || "";
1755   }
1756 
1757   [$finalize]() {
1758     const number = parseFloat(this[$content].trim());
1759     this[$content] = isNaN(number) ? null : number;
1760   }
1761 
1762   [$toHTML](availableSpace) {
1763     return valueToHtml(
1764       this[$content] !== null ? this[$content].toString() : ""
1765     );
1766   }
1767 }
1768 
1769 class DefaultUi extends XFAObject {
1770   constructor(attributes) {
1771     super(TEMPLATE_NS_ID, "defaultUi", /* hasChildren = */ true);
1772     this.id = attributes.id || "";
1773     this.use = attributes.use || "";
1774     this.usehref = attributes.usehref || "";
1775     this.extras = null;
1776   }
1777 }
1778 
1779 class Desc extends XFAObject {
1780   constructor(attributes) {
1781     super(TEMPLATE_NS_ID, "desc", /* hasChildren = */ true);
1782     this.id = attributes.id || "";
1783     this.use = attributes.use || "";
1784     this.usehref = attributes.usehref || "";
1785     this.boolean = new XFAObjectArray();
1786     this.date = new XFAObjectArray();
1787     this.dateTime = new XFAObjectArray();
1788     this.decimal = new XFAObjectArray();
1789     this.exData = new XFAObjectArray();
1790     this.float = new XFAObjectArray();
1791     this.image = new XFAObjectArray();
1792     this.integer = new XFAObjectArray();
1793     this.text = new XFAObjectArray();
1794     this.time = new XFAObjectArray();
1795   }
1796 }
1797 
1798 class DigestMethod extends OptionObject {
1799   constructor(attributes) {
1800     super(TEMPLATE_NS_ID, "digestMethod", [
1801       "",
1802       "SHA1",
1803       "SHA256",
1804       "SHA512",
1805       "RIPEMD160",
1806     ]);
1807     this.id = attributes.id || "";
1808     this.use = attributes.use || "";
1809     this.usehref = attributes.usehref || "";
1810   }
1811 }
1812 
1813 class DigestMethods extends XFAObject {
1814   constructor(attributes) {
1815     super(TEMPLATE_NS_ID, "digestMethods", /* hasChildren = */ true);
1816     this.id = attributes.id || "";
1817     this.type = getStringOption(attributes.type, ["optional", "required"]);
1818     this.use = attributes.use || "";
1819     this.usehref = attributes.usehref || "";
1820     this.digestMethod = new XFAObjectArray();
1821   }
1822 }
1823 
1824 class Draw extends XFAObject {
1825   constructor(attributes) {
1826     super(TEMPLATE_NS_ID, "draw", /* hasChildren = */ true);
1827     this.anchorType = getStringOption(attributes.anchorType, [
1828       "topLeft",
1829       "bottomCenter",
1830       "bottomLeft",
1831       "bottomRight",
1832       "middleCenter",
1833       "middleLeft",
1834       "middleRight",
1835       "topCenter",
1836       "topRight",
1837     ]);
1838     this.colSpan = getInteger({
1839       data: attributes.colSpan,
1840       defaultValue: 1,
1841       validate: n => n >= 1 || n === -1,
1842     });
1843     this.h = attributes.h ? getMeasurement(attributes.h) : "";
1844     this.hAlign = getStringOption(attributes.hAlign, [
1845       "left",
1846       "center",
1847       "justify",
1848       "justifyAll",
1849       "radix",
1850       "right",
1851     ]);
1852     this.id = attributes.id || "";
1853     this.locale = attributes.locale || "";
1854     this.maxH = getMeasurement(attributes.maxH, "0pt");
1855     this.maxW = getMeasurement(attributes.maxW, "0pt");
1856     this.minH = getMeasurement(attributes.minH, "0pt");
1857     this.minW = getMeasurement(attributes.minW, "0pt");
1858     this.name = attributes.name || "";
1859     this.presence = getStringOption(attributes.presence, [
1860       "visible",
1861       "hidden",
1862       "inactive",
1863       "invisible",
1864     ]);
1865     this.relevant = getRelevant(attributes.relevant);
1866     this.rotate = getInteger({
1867       data: attributes.rotate,
1868       defaultValue: 0,
1869       validate: x => x % 90 === 0,
1870     });
1871     this.use = attributes.use || "";
1872     this.usehref = attributes.usehref || "";
1873     this.w = attributes.w ? getMeasurement(attributes.w) : "";
1874     this.x = getMeasurement(attributes.x, "0pt");
1875     this.y = getMeasurement(attributes.y, "0pt");
1876     this.assist = null;
1877     this.border = null;
1878     this.caption = null;
1879     this.desc = null;
1880     this.extras = null;
1881     this.font = null;
1882     this.keep = null;
1883     this.margin = null;
1884     this.para = null;
1885     this.traversal = null;
1886     this.ui = null;
1887     this.value = null;
1888     this.setProperty = new XFAObjectArray();
1889   }
1890 
1891   [$setValue](value) {
1892     _setValue(this, value);
1893   }
1894 
1895   [$toHTML](availableSpace) {
1896     setTabIndex(this);
1897 
1898     if (this.presence === "hidden" || this.presence === "inactive") {
1899       return HTMLResult.EMPTY;
1900     }
1901 
1902     fixDimensions(this);
1903     this[$pushPara]();
1904 
1905     // If at least one dimension is missing and we've a text
1906     // then we can guess it in laying out the text.
1907     const savedW = this.w;
1908     const savedH = this.h;
1909     const { w, h, isBroken } = layoutNode(this, availableSpace);
1910     if (w && this.w === "") {
1911       // If the parent layout is lr-tb with a w=100 and we already have a child
1912       // which takes 90 on the current line.
1913       // If we have a text with a length (in px) equal to 100 then it'll be
1914       // splitted into almost 10 chunks: so it won't be nice.
1915       // So if we've potentially more width to provide in some parent containers
1916       // let's increase it to give a chance to have a better rendering.
1917       if (isBroken && this[$getSubformParent]()[$isThereMoreWidth]()) {
1918         this[$popPara]();
1919         return HTMLResult.FAILURE;
1920       }
1921 
1922       this.w = w;
1923     }
1924     if (h && this.h === "") {
1925       this.h = h;
1926     }
1927 
1928     setFirstUnsplittable(this);
1929     if (!checkDimensions(this, availableSpace)) {
1930       this.w = savedW;
1931       this.h = savedH;
1932       this[$popPara]();
1933       return HTMLResult.FAILURE;
1934     }
1935     unsetFirstUnsplittable(this);
1936 
1937     const style = toStyle(
1938       this,
1939       "font",
1940       "hAlign",
1941       "dimensions",
1942       "position",
1943       "presence",
1944       "rotate",
1945       "anchorType",
1946       "border",
1947       "margin"
1948     );
1949 
1950     setMinMaxDimensions(this, style);
1951 
1952     if (style.margin) {
1953       style.padding = style.margin;
1954       delete style.margin;
1955     }
1956 
1957     const classNames = ["xfaDraw"];
1958     if (this.font) {
1959       classNames.push("xfaFont");
1960     }
1961     if (isPrintOnly(this)) {
1962       classNames.push("xfaPrintOnly");
1963     }
1964 
1965     const attributes = {
1966       style,
1967       id: this[$uid],
1968       class: classNames,
1969     };
1970 
1971     if (this.name) {
1972       attributes.xfaName = this.name;
1973     }
1974 
1975     const html = {
1976       name: "div",
1977       attributes,
1978       children: [],
1979     };
1980 
1981     applyAssist(this, attributes);
1982 
1983     const bbox = computeBbox(this, html, availableSpace);
1984 
1985     const value = this.value ? this.value[$toHTML](availableSpace).html : null;
1986     if (value === null) {
1987       this.w = savedW;
1988       this.h = savedH;
1989       this[$popPara]();
1990       return HTMLResult.success(createWrapper(this, html), bbox);
1991     }
1992 
1993     html.children.push(value);
1994     setPara(this, style, value);
1995 
1996     this.w = savedW;
1997     this.h = savedH;
1998 
1999     this[$popPara]();
2000     return HTMLResult.success(createWrapper(this, html), bbox);
2001   }
2002 }
2003 
2004 class Edge extends XFAObject {
2005   constructor(attributes) {
2006     super(TEMPLATE_NS_ID, "edge", /* hasChildren = */ true);
2007     this.cap = getStringOption(attributes.cap, ["square", "butt", "round"]);
2008     this.id = attributes.id || "";
2009     this.presence = getStringOption(attributes.presence, [
2010       "visible",
2011       "hidden",
2012       "inactive",
2013       "invisible",
2014     ]);
2015     this.stroke = getStringOption(attributes.stroke, [
2016       "solid",
2017       "dashDot",
2018       "dashDotDot",
2019       "dashed",
2020       "dotted",
2021       "embossed",
2022       "etched",
2023       "lowered",
2024       "raised",
2025     ]);
2026     this.thickness = getMeasurement(attributes.thickness, "0.5pt");
2027     this.use = attributes.use || "";
2028     this.usehref = attributes.usehref || "";
2029     this.color = null;
2030     this.extras = null;
2031   }
2032 
2033   [$toStyle]() {
2034     // TODO: dashDot & dashDotDot.
2035     const style = toStyle(this, "visibility");
2036     Object.assign(style, {
2037       linecap: this.cap,
2038       width: measureToString(this.thickness),
2039       color: this.color ? this.color[$toStyle]() : "#000000",
2040       style: "",
2041     });
2042 
2043     if (this.presence !== "visible") {
2044       style.style = "none";
2045     } else {
2046       switch (this.stroke) {
2047         case "solid":
2048           style.style = "solid";
2049           break;
2050         case "dashDot":
2051           style.style = "dashed";
2052           break;
2053         case "dashDotDot":
2054           style.style = "dashed";
2055           break;
2056         case "dashed":
2057           style.style = "dashed";
2058           break;
2059         case "dotted":
2060           style.style = "dotted";
2061           break;
2062         case "embossed":
2063           style.style = "ridge";
2064           break;
2065         case "etched":
2066           style.style = "groove";
2067           break;
2068         case "lowered":
2069           style.style = "inset";
2070           break;
2071         case "raised":
2072           style.style = "outset";
2073           break;
2074       }
2075     }
2076     return style;
2077   }
2078 }
2079 
2080 class Encoding extends OptionObject {
2081   constructor(attributes) {
2082     super(TEMPLATE_NS_ID, "encoding", [
2083       "adbe.x509.rsa_sha1",
2084       "adbe.pkcs7.detached",
2085       "adbe.pkcs7.sha1",
2086     ]);
2087     this.id = attributes.id || "";
2088     this.use = attributes.use || "";
2089     this.usehref = attributes.usehref || "";
2090   }
2091 }
2092 
2093 class Encodings extends XFAObject {
2094   constructor(attributes) {
2095     super(TEMPLATE_NS_ID, "encodings", /* hasChildren = */ true);
2096     this.id = attributes.id || "";
2097     this.type = getStringOption(attributes.type, ["optional", "required"]);
2098     this.use = attributes.use || "";
2099     this.usehref = attributes.usehref || "";
2100     this.encoding = new XFAObjectArray();
2101   }
2102 }
2103 
2104 class Encrypt extends XFAObject {
2105   constructor(attributes) {
2106     super(TEMPLATE_NS_ID, "encrypt", /* hasChildren = */ true);
2107     this.id = attributes.id || "";
2108     this.use = attributes.use || "";
2109     this.usehref = attributes.usehref || "";
2110     this.certificate = null;
2111   }
2112 }
2113 
2114 class EncryptData extends XFAObject {
2115   constructor(attributes) {
2116     super(TEMPLATE_NS_ID, "encryptData", /* hasChildren = */ true);
2117     this.id = attributes.id || "";
2118     this.operation = getStringOption(attributes.operation, [
2119       "encrypt",
2120       "decrypt",
2121     ]);
2122     this.target = attributes.target || "";
2123     this.use = attributes.use || "";
2124     this.usehref = attributes.usehref || "";
2125     this.filter = null;
2126     this.manifest = null;
2127   }
2128 }
2129 
2130 class Encryption extends XFAObject {
2131   constructor(attributes) {
2132     super(TEMPLATE_NS_ID, "encryption", /* hasChildren = */ true);
2133     this.id = attributes.id || "";
2134     this.type = getStringOption(attributes.type, ["optional", "required"]);
2135     this.use = attributes.use || "";
2136     this.usehref = attributes.usehref || "";
2137     this.certificate = new XFAObjectArray();
2138   }
2139 }
2140 
2141 class EncryptionMethod extends OptionObject {
2142   constructor(attributes) {
2143     super(TEMPLATE_NS_ID, "encryptionMethod", [
2144       "",
2145       "AES256-CBC",
2146       "TRIPLEDES-CBC",
2147       "AES128-CBC",
2148       "AES192-CBC",
2149     ]);
2150     this.id = attributes.id || "";
2151     this.use = attributes.use || "";
2152     this.usehref = attributes.usehref || "";
2153   }
2154 }
2155 
2156 class EncryptionMethods extends XFAObject {
2157   constructor(attributes) {
2158     super(TEMPLATE_NS_ID, "encryptionMethods", /* hasChildren = */ true);
2159     this.id = attributes.id || "";
2160     this.type = getStringOption(attributes.type, ["optional", "required"]);
2161     this.use = attributes.use || "";
2162     this.usehref = attributes.usehref || "";
2163     this.encryptionMethod = new XFAObjectArray();
2164   }
2165 }
2166 
2167 class Event extends XFAObject {
2168   constructor(attributes) {
2169     super(TEMPLATE_NS_ID, "event", /* hasChildren = */ true);
2170     this.activity = getStringOption(attributes.activity, [
2171       "click",
2172       "change",
2173       "docClose",
2174       "docReady",
2175       "enter",
2176       "exit",
2177       "full",
2178       "indexChange",
2179       "initialize",
2180       "mouseDown",
2181       "mouseEnter",
2182       "mouseExit",
2183       "mouseUp",
2184       "postExecute",
2185       "postOpen",
2186       "postPrint",
2187       "postSave",
2188       "postSign",
2189       "postSubmit",
2190       "preExecute",
2191       "preOpen",
2192       "prePrint",
2193       "preSave",
2194       "preSign",
2195       "preSubmit",
2196       "ready",
2197       "validationState",
2198     ]);
2199     this.id = attributes.id || "";
2200     this.listen = getStringOption(attributes.listen, [
2201       "refOnly",
2202       "refAndDescendents",
2203     ]);
2204     this.name = attributes.name || "";
2205     this.ref = attributes.ref || "";
2206     this.use = attributes.use || "";
2207     this.usehref = attributes.usehref || "";
2208     this.extras = null;
2209 
2210     // One-of properties
2211     this.encryptData = null;
2212     this.execute = null;
2213     this.script = null;
2214     this.signData = null;
2215     this.submit = null;
2216   }
2217 }
2218 
2219 class ExData extends ContentObject {
2220   constructor(attributes) {
2221     super(TEMPLATE_NS_ID, "exData");
2222     this.contentType = attributes.contentType || "";
2223     this.href = attributes.href || "";
2224     this.id = attributes.id || "";
2225     this.maxLength = getInteger({
2226       data: attributes.maxLength,
2227       defaultValue: -1,
2228       validate: x => x >= -1,
2229     });
2230     this.name = attributes.name || "";
2231     this.rid = attributes.rid || "";
2232     this.transferEncoding = getStringOption(attributes.transferEncoding, [
2233       "none",
2234       "base64",
2235       "package",
2236     ]);
2237     this.use = attributes.use || "";
2238     this.usehref = attributes.usehref || "";
2239   }
2240 
2241   [$isCDATAXml]() {
2242     return this.contentType === "text/html";
2243   }
2244 
2245   [$onChild](child) {
2246     if (
2247       this.contentType === "text/html" &&
2248       child[$namespaceId] === NamespaceIds.xhtml.id
2249     ) {
2250       this[$content] = child;
2251       return true;
2252     }
2253 
2254     if (this.contentType === "text/xml") {
2255       this[$content] = child;
2256       return true;
2257     }
2258 
2259     return false;
2260   }
2261 
2262   [$toHTML](availableSpace) {
2263     if (this.contentType !== "text/html" || !this[$content]) {
2264       // TODO: fix other cases.
2265       return HTMLResult.EMPTY;
2266     }
2267 
2268     return this[$content][$toHTML](availableSpace);
2269   }
2270 }
2271 
2272 class ExObject extends XFAObject {
2273   constructor(attributes) {
2274     super(TEMPLATE_NS_ID, "exObject", /* hasChildren = */ true);
2275     this.archive = attributes.archive || "";
2276     this.classId = attributes.classId || "";
2277     this.codeBase = attributes.codeBase || "";
2278     this.codeType = attributes.codeType || "";
2279     this.id = attributes.id || "";
2280     this.name = attributes.name || "";
2281     this.use = attributes.use || "";
2282     this.usehref = attributes.usehref || "";
2283     this.extras = null;
2284     this.boolean = new XFAObjectArray();
2285     this.date = new XFAObjectArray();
2286     this.dateTime = new XFAObjectArray();
2287     this.decimal = new XFAObjectArray();
2288     this.exData = new XFAObjectArray();
2289     this.exObject = new XFAObjectArray();
2290     this.float = new XFAObjectArray();
2291     this.image = new XFAObjectArray();
2292     this.integer = new XFAObjectArray();
2293     this.text = new XFAObjectArray();
2294     this.time = new XFAObjectArray();
2295   }
2296 }
2297 
2298 class ExclGroup extends XFAObject {
2299   constructor(attributes) {
2300     super(TEMPLATE_NS_ID, "exclGroup", /* hasChildren = */ true);
2301     this.access = getStringOption(attributes.access, [
2302       "open",
2303       "nonInteractive",
2304       "protected",
2305       "readOnly",
2306     ]);
2307     this.accessKey = attributes.accessKey || "";
2308     this.anchorType = getStringOption(attributes.anchorType, [
2309       "topLeft",
2310       "bottomCenter",
2311       "bottomLeft",
2312       "bottomRight",
2313       "middleCenter",
2314       "middleLeft",
2315       "middleRight",
2316       "topCenter",
2317       "topRight",
2318     ]);
2319     this.colSpan = getInteger({
2320       data: attributes.colSpan,
2321       defaultValue: 1,
2322       validate: n => n >= 1 || n === -1,
2323     });
2324     this.h = attributes.h ? getMeasurement(attributes.h) : "";
2325     this.hAlign = getStringOption(attributes.hAlign, [
2326       "left",
2327       "center",
2328       "justify",
2329       "justifyAll",
2330       "radix",
2331       "right",
2332     ]);
2333     this.id = attributes.id || "";
2334     this.layout = getStringOption(attributes.layout, [
2335       "position",
2336       "lr-tb",
2337       "rl-row",
2338       "rl-tb",
2339       "row",
2340       "table",
2341       "tb",
2342     ]);
2343     this.maxH = getMeasurement(attributes.maxH, "0pt");
2344     this.maxW = getMeasurement(attributes.maxW, "0pt");
2345     this.minH = getMeasurement(attributes.minH, "0pt");
2346     this.minW = getMeasurement(attributes.minW, "0pt");
2347     this.name = attributes.name || "";
2348     this.presence = getStringOption(attributes.presence, [
2349       "visible",
2350       "hidden",
2351       "inactive",
2352       "invisible",
2353     ]);
2354     this.relevant = getRelevant(attributes.relevant);
2355     this.use = attributes.use || "";
2356     this.usehref = attributes.usehref || "";
2357     this.w = attributes.w ? getMeasurement(attributes.w) : "";
2358     this.x = getMeasurement(attributes.x, "0pt");
2359     this.y = getMeasurement(attributes.y, "0pt");
2360     this.assist = null;
2361     this.bind = null;
2362     this.border = null;
2363     this.calculate = null;
2364     this.caption = null;
2365     this.desc = null;
2366     this.extras = null;
2367     this.margin = null;
2368     this.para = null;
2369     this.traversal = null;
2370     this.validate = null;
2371     this.connect = new XFAObjectArray();
2372     this.event = new XFAObjectArray();
2373     this.field = new XFAObjectArray();
2374     this.setProperty = new XFAObjectArray();
2375   }
2376 
2377   [$isBindable]() {
2378     return true;
2379   }
2380 
2381   [$hasSettableValue]() {
2382     return true;
2383   }
2384 
2385   [$setValue](value) {
2386     for (const field of this.field.children) {
2387       if (!field.value) {
2388         const nodeValue = new Value({});
2389         field[$appendChild](nodeValue);
2390         field.value = nodeValue;
2391       }
2392 
2393       field.value[$setValue](value);
2394     }
2395   }
2396 
2397   [$isThereMoreWidth]() {
2398     return (
2399       (this.layout.endsWith("-tb") &&
2400         this[$extra].attempt === 0 &&
2401         this[$extra].numberInLine > 0) ||
2402       this[$getParent]()[$isThereMoreWidth]()
2403     );
2404   }
2405 
2406   [$isSplittable]() {
2407     // We cannot cache the result here because the contentArea
2408     // can change.
2409     const parent = this[$getSubformParent]();
2410     if (!parent[$isSplittable]()) {
2411       return false;
2412     }
2413 
2414     if (this[$extra]._isSplittable !== undefined) {
2415       return this[$extra]._isSplittable;
2416     }
2417 
2418     if (this.layout === "position" || this.layout.includes("row")) {
2419       this[$extra]._isSplittable = false;
2420       return false;
2421     }
2422 
2423     if (parent.layout?.endsWith("-tb") && parent[$extra].numberInLine !== 0) {
2424       // See comment in Subform::[$isSplittable] for an explanation.
2425       return false;
2426     }
2427 
2428     this[$extra]._isSplittable = true;
2429     return true;
2430   }
2431 
2432   [$flushHTML]() {
2433     return flushHTML(this);
2434   }
2435 
2436   [$addHTML](html, bbox) {
2437     addHTML(this, html, bbox);
2438   }
2439 
2440   [$getAvailableSpace]() {
2441     return getAvailableSpace(this);
2442   }
2443 
2444   [$toHTML](availableSpace) {
2445     setTabIndex(this);
2446     if (
2447       this.presence === "hidden" ||
2448       this.presence === "inactive" ||
2449       this.h === 0 ||
2450       this.w === 0
2451     ) {
2452       return HTMLResult.EMPTY;
2453     }
2454 
2455     fixDimensions(this);
2456 
2457     const children = [];
2458     const attributes = {
2459       id: this[$uid],
2460       class: [],
2461     };
2462 
2463     setAccess(this, attributes.class);
2464 
2465     if (!this[$extra]) {
2466       this[$extra] = Object.create(null);
2467     }
2468 
2469     Object.assign(this[$extra], {
2470       children,
2471       attributes,
2472       attempt: 0,
2473       line: null,
2474       numberInLine: 0,
2475       availableSpace: {
2476         width: Math.min(this.w || Infinity, availableSpace.width),
2477         height: Math.min(this.h || Infinity, availableSpace.height),
2478       },
2479       width: 0,
2480       height: 0,
2481       prevHeight: 0,
2482       currentWidth: 0,
2483     });
2484 
2485     const isSplittable = this[$isSplittable]();
2486     if (!isSplittable) {
2487       setFirstUnsplittable(this);
2488     }
2489 
2490     if (!checkDimensions(this, availableSpace)) {
2491       return HTMLResult.FAILURE;
2492     }
2493     const filter = new Set(["field"]);
2494 
2495     if (this.layout.includes("row")) {
2496       const columnWidths = this[$getSubformParent]().columnWidths;
2497       if (Array.isArray(columnWidths) && columnWidths.length > 0) {
2498         this[$extra].columnWidths = columnWidths;
2499         this[$extra].currentColumn = 0;
2500       }
2501     }
2502 
2503     const style = toStyle(
2504       this,
2505       "anchorType",
2506       "dimensions",
2507       "position",
2508       "presence",
2509       "border",
2510       "margin",
2511       "hAlign"
2512     );
2513     const classNames = ["xfaExclgroup"];
2514     const cl = layoutClass(this);
2515     if (cl) {
2516       classNames.push(cl);
2517     }
2518 
2519     if (isPrintOnly(this)) {
2520       classNames.push("xfaPrintOnly");
2521     }
2522 
2523     attributes.style = style;
2524     attributes.class = classNames;
2525 
2526     if (this.name) {
2527       attributes.xfaName = this.name;
2528     }
2529 
2530     this[$pushPara]();
2531     const isLrTb = this.layout === "lr-tb" || this.layout === "rl-tb";
2532     const maxRun = isLrTb ? MAX_ATTEMPTS_FOR_LRTB_LAYOUT : 1;
2533     for (; this[$extra].attempt < maxRun; this[$extra].attempt++) {
2534       if (isLrTb && this[$extra].attempt === MAX_ATTEMPTS_FOR_LRTB_LAYOUT - 1) {
2535         // If the layout is lr-tb then having attempt equals to
2536         // MAX_ATTEMPTS_FOR_LRTB_LAYOUT-1 means that we're trying to layout
2537         // on the next line so this on is empty.
2538         this[$extra].numberInLine = 0;
2539       }
2540       const result = this[$childrenToHTML]({
2541         filter,
2542         include: true,
2543       });
2544       if (result.success) {
2545         break;
2546       }
2547       if (result.isBreak()) {
2548         this[$popPara]();
2549         return result;
2550       }
2551       if (
2552         isLrTb &&
2553         this[$extra].attempt === 0 &&
2554         this[$extra].numberInLine === 0 &&
2555         !this[$getTemplateRoot]()[$extra].noLayoutFailure
2556       ) {
2557         // See comment in Subform::[$toHTML].
2558         this[$extra].attempt = maxRun;
2559         break;
2560       }
2561     }
2562 
2563     this[$popPara]();
2564 
2565     if (!isSplittable) {
2566       unsetFirstUnsplittable(this);
2567     }
2568 
2569     if (this[$extra].attempt === maxRun) {
2570       if (!isSplittable) {
2571         delete this[$extra];
2572       }
2573       return HTMLResult.FAILURE;
2574     }
2575 
2576     let marginH = 0;
2577     let marginV = 0;
2578     if (this.margin) {
2579       marginH = this.margin.leftInset + this.margin.rightInset;
2580       marginV = this.margin.topInset + this.margin.bottomInset;
2581     }
2582 
2583     const width = Math.max(this[$extra].width + marginH, this.w || 0);
2584     const height = Math.max(this[$extra].height + marginV, this.h || 0);
2585     const bbox = [this.x, this.y, width, height];
2586 
2587     if (this.w === "") {
2588       style.width = measureToString(width);
2589     }
2590     if (this.h === "") {
2591       style.height = measureToString(height);
2592     }
2593 
2594     const html = {
2595       name: "div",
2596       attributes,
2597       children,
2598     };
2599 
2600     applyAssist(this, attributes);
2601 
2602     delete this[$extra];
2603 
2604     return HTMLResult.success(createWrapper(this, html), bbox);
2605   }
2606 }
2607 
2608 class Execute extends XFAObject {
2609   constructor(attributes) {
2610     super(TEMPLATE_NS_ID, "execute");
2611     this.connection = attributes.connection || "";
2612     this.executeType = getStringOption(attributes.executeType, [
2613       "import",
2614       "remerge",
2615     ]);
2616     this.id = attributes.id || "";
2617     this.runAt = getStringOption(attributes.runAt, [
2618       "client",
2619       "both",
2620       "server",
2621     ]);
2622     this.use = attributes.use || "";
2623     this.usehref = attributes.usehref || "";
2624   }
2625 }
2626 
2627 class Extras extends XFAObject {
2628   constructor(attributes) {
2629     super(TEMPLATE_NS_ID, "extras", /* hasChildren = */ true);
2630     this.id = attributes.id || "";
2631     this.name = attributes.name || "";
2632     this.use = attributes.use || "";
2633     this.usehref = attributes.usehref || "";
2634     this.boolean = new XFAObjectArray();
2635     this.date = new XFAObjectArray();
2636     this.dateTime = new XFAObjectArray();
2637     this.decimal = new XFAObjectArray();
2638     this.exData = new XFAObjectArray();
2639     this.extras = new XFAObjectArray();
2640     this.float = new XFAObjectArray();
2641     this.image = new XFAObjectArray();
2642     this.integer = new XFAObjectArray();
2643     this.text = new XFAObjectArray();
2644     this.time = new XFAObjectArray();
2645   }
2646 
2647   // (Spec) The XFA template grammar defines the extras and desc elements,
2648   // which can be used to add human-readable or machine-readable
2649   // data to a template.
2650 }
2651 
2652 class Field extends XFAObject {
2653   constructor(attributes) {
2654     super(TEMPLATE_NS_ID, "field", /* hasChildren = */ true);
2655     this.access = getStringOption(attributes.access, [
2656       "open",
2657       "nonInteractive",
2658       "protected",
2659       "readOnly",
2660     ]);
2661     this.accessKey = attributes.accessKey || "";
2662     this.anchorType = getStringOption(attributes.anchorType, [
2663       "topLeft",
2664       "bottomCenter",
2665       "bottomLeft",
2666       "bottomRight",
2667       "middleCenter",
2668       "middleLeft",
2669       "middleRight",
2670       "topCenter",
2671       "topRight",
2672     ]);
2673     this.colSpan = getInteger({
2674       data: attributes.colSpan,
2675       defaultValue: 1,
2676       validate: n => n >= 1 || n === -1,
2677     });
2678     this.h = attributes.h ? getMeasurement(attributes.h) : "";
2679     this.hAlign = getStringOption(attributes.hAlign, [
2680       "left",
2681       "center",
2682       "justify",
2683       "justifyAll",
2684       "radix",
2685       "right",
2686     ]);
2687     this.id = attributes.id || "";
2688     this.locale = attributes.locale || "";
2689     this.maxH = getMeasurement(attributes.maxH, "0pt");
2690     this.maxW = getMeasurement(attributes.maxW, "0pt");
2691     this.minH = getMeasurement(attributes.minH, "0pt");
2692     this.minW = getMeasurement(attributes.minW, "0pt");
2693     this.name = attributes.name || "";
2694     this.presence = getStringOption(attributes.presence, [
2695       "visible",
2696       "hidden",
2697       "inactive",
2698       "invisible",
2699     ]);
2700     this.relevant = getRelevant(attributes.relevant);
2701     this.rotate = getInteger({
2702       data: attributes.rotate,
2703       defaultValue: 0,
2704       validate: x => x % 90 === 0,
2705     });
2706     this.use = attributes.use || "";
2707     this.usehref = attributes.usehref || "";
2708     this.w = attributes.w ? getMeasurement(attributes.w) : "";
2709     this.x = getMeasurement(attributes.x, "0pt");
2710     this.y = getMeasurement(attributes.y, "0pt");
2711     this.assist = null;
2712     this.bind = null;
2713     this.border = null;
2714     this.calculate = null;
2715     this.caption = null;
2716     this.desc = null;
2717     this.extras = null;
2718     this.font = null;
2719     this.format = null;
2720     // For a choice list, one list is used to have display entries
2721     // and the other for the exported values
2722     this.items = new XFAObjectArray(2);
2723     this.keep = null;
2724     this.margin = null;
2725     this.para = null;
2726     this.traversal = null;
2727     this.ui = null;
2728     this.validate = null;
2729     this.value = null;
2730     this.bindItems = new XFAObjectArray();
2731     this.connect = new XFAObjectArray();
2732     this.event = new XFAObjectArray();
2733     this.setProperty = new XFAObjectArray();
2734   }
2735 
2736   [$isBindable]() {
2737     return true;
2738   }
2739 
2740   [$setValue](value) {
2741     _setValue(this, value);
2742   }
2743 
2744   [$toHTML](availableSpace) {
2745     setTabIndex(this);
2746 
2747     if (!this.ui) {
2748       // It's allowed to not have an ui, specs say:
2749       //   If the UI element contains no children or is not present,
2750       //   the application chooses a default user interface for the
2751       //   container, based on the type of the container's content.
2752 
2753       this.ui = new Ui({});
2754       this.ui[$globalData] = this[$globalData];
2755       this[$appendChild](this.ui);
2756       let node;
2757 
2758       // The items element can have 2 element max and
2759       // according to the items specs it's likely a good
2760       // way to guess the correct ui type.
2761       switch (this.items.children.length) {
2762         case 0:
2763           node = new TextEdit({});
2764           this.ui.textEdit = node;
2765           break;
2766         case 1:
2767           node = new CheckButton({});
2768           this.ui.checkButton = node;
2769           break;
2770         case 2:
2771           node = new ChoiceList({});
2772           this.ui.choiceList = node;
2773           break;
2774       }
2775       this.ui[$appendChild](node);
2776     }
2777 
2778     if (
2779       !this.ui ||
2780       this.presence === "hidden" ||
2781       this.presence === "inactive" ||
2782       this.h === 0 ||
2783       this.w === 0
2784     ) {
2785       return HTMLResult.EMPTY;
2786     }
2787 
2788     if (this.caption) {
2789       // Maybe we already tried to layout this field with
2790       // another availableSpace, so to avoid to use the cached
2791       // value just delete it.
2792       delete this.caption[$extra];
2793     }
2794 
2795     this[$pushPara]();
2796 
2797     const caption = this.caption
2798       ? this.caption[$toHTML](availableSpace).html
2799       : null;
2800     const savedW = this.w;
2801     const savedH = this.h;
2802     let marginH = 0;
2803     let marginV = 0;
2804     if (this.margin) {
2805       marginH = this.margin.leftInset + this.margin.rightInset;
2806       marginV = this.margin.topInset + this.margin.bottomInset;
2807     }
2808 
2809     let borderDims = null;
2810     if (this.w === "" || this.h === "") {
2811       let width = null;
2812       let height = null;
2813 
2814       let uiW = 0;
2815       let uiH = 0;
2816       if (this.ui.checkButton) {
2817         uiW = uiH = this.ui.checkButton.size;
2818       } else {
2819         const { w, h } = layoutNode(this, availableSpace);
2820         if (w !== null) {
2821           uiW = w;
2822           uiH = h;
2823         } else {
2824           uiH = getMetrics(this.font, /* real = */ true).lineNoGap;
2825         }
2826       }
2827 
2828       borderDims = getBorderDims(this.ui[$getExtra]());
2829       uiW += borderDims.w;
2830       uiH += borderDims.h;
2831 
2832       if (this.caption) {
2833         const { w, h, isBroken } = this.caption[$getExtra](availableSpace);
2834         // See comment in Draw::[$toHTML] to have an explanation
2835         // about this line.
2836         if (isBroken && this[$getSubformParent]()[$isThereMoreWidth]()) {
2837           this[$popPara]();
2838           return HTMLResult.FAILURE;
2839         }
2840 
2841         width = w;
2842         height = h;
2843 
2844         switch (this.caption.placement) {
2845           case "left":
2846           case "right":
2847           case "inline":
2848             width += uiW;
2849             break;
2850           case "top":
2851           case "bottom":
2852             height += uiH;
2853             break;
2854         }
2855       } else {
2856         width = uiW;
2857         height = uiH;
2858       }
2859 
2860       if (width && this.w === "") {
2861         width += marginH;
2862         this.w = Math.min(
2863           this.maxW <= 0 ? Infinity : this.maxW,
2864           this.minW + 1 < width ? width : this.minW
2865         );
2866       }
2867 
2868       if (height && this.h === "") {
2869         height += marginV;
2870         this.h = Math.min(
2871           this.maxH <= 0 ? Infinity : this.maxH,
2872           this.minH + 1 < height ? height : this.minH
2873         );
2874       }
2875     }
2876 
2877     this[$popPara]();
2878 
2879     fixDimensions(this);
2880 
2881     setFirstUnsplittable(this);
2882     if (!checkDimensions(this, availableSpace)) {
2883       this.w = savedW;
2884       this.h = savedH;
2885       this[$popPara]();
2886       return HTMLResult.FAILURE;
2887     }
2888     unsetFirstUnsplittable(this);
2889 
2890     const style = toStyle(
2891       this,
2892       "font",
2893       "dimensions",
2894       "position",
2895       "rotate",
2896       "anchorType",
2897       "presence",
2898       "margin",
2899       "hAlign"
2900     );
2901 
2902     setMinMaxDimensions(this, style);
2903 
2904     const classNames = ["xfaField"];
2905     // If no font, font properties are inherited.
2906     if (this.font) {
2907       classNames.push("xfaFont");
2908     }
2909 
2910     if (isPrintOnly(this)) {
2911       classNames.push("xfaPrintOnly");
2912     }
2913 
2914     const attributes = {
2915       style,
2916       id: this[$uid],
2917       class: classNames,
2918     };
2919 
2920     if (style.margin) {
2921       style.padding = style.margin;
2922       delete style.margin;
2923     }
2924 
2925     setAccess(this, classNames);
2926 
2927     if (this.name) {
2928       attributes.xfaName = this.name;
2929     }
2930 
2931     const children = [];
2932     const html = {
2933       name: "div",
2934       attributes,
2935       children,
2936     };
2937 
2938     applyAssist(this, attributes);
2939 
2940     const borderStyle = this.border ? this.border[$toStyle]() : null;
2941     const bbox = computeBbox(this, html, availableSpace);
2942     const ui = this.ui[$toHTML]().html;
2943     if (!ui) {
2944       Object.assign(style, borderStyle);
2945       return HTMLResult.success(createWrapper(this, html), bbox);
2946     }
2947 
2948     if (this[$tabIndex]) {
2949       if (ui.children?.[0]) {
2950         ui.children[0].attributes.tabindex = this[$tabIndex];
2951       } else {
2952         ui.attributes.tabindex = this[$tabIndex];
2953       }
2954     }
2955 
2956     if (!ui.attributes.style) {
2957       ui.attributes.style = Object.create(null);
2958     }
2959 
2960     let aElement = null;
2961 
2962     if (this.ui.button) {
2963       if (ui.children.length === 1) {
2964         [aElement] = ui.children.splice(0, 1);
2965       }
2966       Object.assign(ui.attributes.style, borderStyle);
2967     } else {
2968       Object.assign(style, borderStyle);
2969     }
2970 
2971     children.push(ui);
2972 
2973     if (this.value) {
2974       if (this.ui.imageEdit) {
2975         ui.children.push(this.value[$toHTML]().html);
2976       } else if (!this.ui.button) {
2977         let value = "";
2978         if (this.value.exData) {
2979           value = this.value.exData[$text]();
2980         } else if (this.value.text) {
2981           value = this.value.text[$getExtra]();
2982         } else {
2983           const htmlValue = this.value[$toHTML]().html;
2984           if (htmlValue !== null) {
2985             value = htmlValue.children[0].value;
2986           }
2987         }
2988         if (this.ui.textEdit && this.value.text?.maxChars) {
2989           ui.children[0].attributes.maxLength = this.value.text.maxChars;
2990         }
2991 
2992         if (value) {
2993           if (this.ui.numericEdit) {
2994             value = parseFloat(value);
2995             value = isNaN(value) ? "" : value.toString();
2996           }
2997 
2998           if (ui.children[0].name === "textarea") {
2999             ui.children[0].attributes.textContent = value;
3000           } else {
3001             ui.children[0].attributes.value = value;
3002           }
3003         }
3004       }
3005     }
3006 
3007     if (!this.ui.imageEdit && ui.children?.[0] && this.h) {
3008       borderDims = borderDims || getBorderDims(this.ui[$getExtra]());
3009 
3010       let captionHeight = 0;
3011       if (this.caption && ["top", "bottom"].includes(this.caption.placement)) {
3012         captionHeight = this.caption.reserve;
3013         if (captionHeight <= 0) {
3014           captionHeight = this.caption[$getExtra](availableSpace).h;
3015         }
3016         const inputHeight = this.h - captionHeight - marginV - borderDims.h;
3017         ui.children[0].attributes.style.height = measureToString(inputHeight);
3018       } else {
3019         ui.children[0].attributes.style.height = "100%";
3020       }
3021     }
3022 
3023     if (aElement) {
3024       ui.children.push(aElement);
3025     }
3026 
3027     if (!caption) {
3028       if (ui.attributes.class) {
3029         // Even if no caption this class will help to center the ui.
3030         ui.attributes.class.push("xfaLeft");
3031       }
3032       this.w = savedW;
3033       this.h = savedH;
3034 
3035       return HTMLResult.success(createWrapper(this, html), bbox);
3036     }
3037 
3038     if (this.ui.button) {
3039       if (style.padding) {
3040         delete style.padding;
3041       }
3042       if (caption.name === "div") {
3043         caption.name = "span";
3044       }
3045       ui.children.push(caption);
3046       return HTMLResult.success(html, bbox);
3047     } else if (this.ui.checkButton) {
3048       caption.attributes.class[0] = "xfaCaptionForCheckButton";
3049     }
3050 
3051     if (!ui.attributes.class) {
3052       ui.attributes.class = [];
3053     }
3054 
3055     ui.children.splice(0, 0, caption);
3056 
3057     switch (this.caption.placement) {
3058       case "left":
3059         ui.attributes.class.push("xfaLeft");
3060         break;
3061       case "right":
3062         ui.attributes.class.push("xfaRight");
3063         break;
3064       case "top":
3065         ui.attributes.class.push("xfaTop");
3066         break;
3067       case "bottom":
3068         ui.attributes.class.push("xfaBottom");
3069         break;
3070       case "inline":
3071         // TODO;
3072         ui.attributes.class.push("xfaLeft");
3073         break;
3074     }
3075 
3076     this.w = savedW;
3077     this.h = savedH;
3078     return HTMLResult.success(createWrapper(this, html), bbox);
3079   }
3080 }
3081 
3082 class Fill extends XFAObject {
3083   constructor(attributes) {
3084     super(TEMPLATE_NS_ID, "fill", /* hasChildren = */ true);
3085     this.id = attributes.id || "";
3086     this.presence = getStringOption(attributes.presence, [
3087       "visible",
3088       "hidden",
3089       "inactive",
3090       "invisible",
3091     ]);
3092     this.use = attributes.use || "";
3093     this.usehref = attributes.usehref || "";
3094     this.color = null;
3095     this.extras = null;
3096 
3097     // One-of properties or none
3098     this.linear = null;
3099     this.pattern = null;
3100     this.radial = null;
3101     this.solid = null;
3102     this.stipple = null;
3103   }
3104 
3105   [$toStyle]() {
3106     const parent = this[$getParent]();
3107     const grandpa = parent[$getParent]();
3108     const ggrandpa = grandpa[$getParent]();
3109     const style = Object.create(null);
3110 
3111     // Use for color, i.e. #...
3112     let propName = "color";
3113 
3114     // Use for non-color, i.e. gradient, radial-gradient...
3115     let altPropName = propName;
3116 
3117     if (parent instanceof Border) {
3118       propName = "background-color";
3119       altPropName = "background";
3120       if (ggrandpa instanceof Ui) {
3121         // The default fill color is white.
3122         style.backgroundColor = "white";
3123       }
3124     }
3125     if (parent instanceof Rectangle || parent instanceof Arc) {
3126       propName = altPropName = "fill";
3127       style.fill = "white";
3128     }
3129 
3130     for (const name of Object.getOwnPropertyNames(this)) {
3131       if (name === "extras" || name === "color") {
3132         continue;
3133       }
3134       const obj = this[name];
3135       if (!(obj instanceof XFAObject)) {
3136         continue;
3137       }
3138 
3139       const color = obj[$toStyle](this.color);
3140       if (color) {
3141         style[color.startsWith("#") ? propName : altPropName] = color;
3142       }
3143       return style;
3144     }
3145 
3146     if (this.color?.value) {
3147       const color = this.color[$toStyle]();
3148       style[color.startsWith("#") ? propName : altPropName] = color;
3149     }
3150 
3151     return style;
3152   }
3153 }
3154 
3155 class Filter extends XFAObject {
3156   constructor(attributes) {
3157     super(TEMPLATE_NS_ID, "filter", /* hasChildren = */ true);
3158     this.addRevocationInfo = getStringOption(attributes.addRevocationInfo, [
3159       "",
3160       "required",
3161       "optional",
3162       "none",
3163     ]);
3164     this.id = attributes.id || "";
3165     this.name = attributes.name || "";
3166     this.use = attributes.use || "";
3167     this.usehref = attributes.usehref || "";
3168     this.version = getInteger({
3169       data: this.version,
3170       defaultValue: 5,
3171       validate: x => x >= 1 && x <= 5,
3172     });
3173     this.appearanceFilter = null;
3174     this.certificates = null;
3175     this.digestMethods = null;
3176     this.encodings = null;
3177     this.encryptionMethods = null;
3178     this.handler = null;
3179     this.lockDocument = null;
3180     this.mdp = null;
3181     this.reasons = null;
3182     this.timeStamp = null;
3183   }
3184 }
3185 
3186 class Float extends ContentObject {
3187   constructor(attributes) {
3188     super(TEMPLATE_NS_ID, "float");
3189     this.id = attributes.id || "";
3190     this.name = attributes.name || "";
3191     this.use = attributes.use || "";
3192     this.usehref = attributes.usehref || "";
3193   }
3194 
3195   [$finalize]() {
3196     const number = parseFloat(this[$content].trim());
3197     this[$content] = isNaN(number) ? null : number;
3198   }
3199 
3200   [$toHTML](availableSpace) {
3201     return valueToHtml(
3202       this[$content] !== null ? this[$content].toString() : ""
3203     );
3204   }
3205 }
3206 
3207 class Font extends XFAObject {
3208   constructor(attributes) {
3209     super(TEMPLATE_NS_ID, "font", /* hasChildren = */ true);
3210     this.baselineShift = getMeasurement(attributes.baselineShift);
3211     this.fontHorizontalScale = getFloat({
3212       data: attributes.fontHorizontalScale,
3213       defaultValue: 100,
3214       validate: x => x >= 0,
3215     });
3216     this.fontVerticalScale = getFloat({
3217       data: attributes.fontVerticalScale,
3218       defaultValue: 100,
3219       validate: x => x >= 0,
3220     });
3221     this.id = attributes.id || "";
3222     this.kerningMode = getStringOption(attributes.kerningMode, [
3223       "none",
3224       "pair",
3225     ]);
3226     this.letterSpacing = getMeasurement(attributes.letterSpacing, "0");
3227     this.lineThrough = getInteger({
3228       data: attributes.lineThrough,
3229       defaultValue: 0,
3230       validate: x => x === 1 || x === 2,
3231     });
3232     this.lineThroughPeriod = getStringOption(attributes.lineThroughPeriod, [
3233       "all",
3234       "word",
3235     ]);
3236     this.overline = getInteger({
3237       data: attributes.overline,
3238       defaultValue: 0,
3239       validate: x => x === 1 || x === 2,
3240     });
3241     this.overlinePeriod = getStringOption(attributes.overlinePeriod, [
3242       "all",
3243       "word",
3244     ]);
3245     this.posture = getStringOption(attributes.posture, ["normal", "italic"]);
3246     this.size = getMeasurement(attributes.size, "10pt");
3247     this.typeface = attributes.typeface || "Courier";
3248     this.underline = getInteger({
3249       data: attributes.underline,
3250       defaultValue: 0,
3251       validate: x => x === 1 || x === 2,
3252     });
3253     this.underlinePeriod = getStringOption(attributes.underlinePeriod, [
3254       "all",
3255       "word",
3256     ]);
3257     this.use = attributes.use || "";
3258     this.usehref = attributes.usehref || "";
3259     this.weight = getStringOption(attributes.weight, ["normal", "bold"]);
3260     this.extras = null;
3261     this.fill = null;
3262   }
3263 
3264   [$clean](builder) {
3265     super[$clean](builder);
3266     this[$globalData].usedTypefaces.add(this.typeface);
3267   }
3268 
3269   [$toStyle]() {
3270     const style = toStyle(this, "fill");
3271     const color = style.color;
3272     if (color) {
3273       if (color === "#000000") {
3274         // Default font color.
3275         delete style.color;
3276       } else if (!color.startsWith("#")) {
3277         // We've a gradient which is not possible for a font color
3278         // so use a workaround.
3279         style.background = color;
3280         style.backgroundClip = "text";
3281         style.color = "transparent";
3282       }
3283     }
3284 
3285     if (this.baselineShift) {
3286       style.verticalAlign = measureToString(this.baselineShift);
3287     }
3288 
3289     // TODO: fontHorizontalScale
3290     // TODO: fontVerticalScale
3291 
3292     style.fontKerning = this.kerningMode === "none" ? "none" : "normal";
3293     style.letterSpacing = measureToString(this.letterSpacing);
3294 
3295     if (this.lineThrough !== 0) {
3296       style.textDecoration = "line-through";
3297       if (this.lineThrough === 2) {
3298         style.textDecorationStyle = "double";
3299       }
3300     }
3301 
3302     // TODO: lineThroughPeriod
3303 
3304     if (this.overline !== 0) {
3305       style.textDecoration = "overline";
3306       if (this.overline === 2) {
3307         style.textDecorationStyle = "double";
3308       }
3309     }
3310 
3311     // TODO: overlinePeriod
3312 
3313     style.fontStyle = this.posture;
3314     style.fontSize = measureToString(0.99 * this.size);
3315 
3316     setFontFamily(this, this, this[$globalData].fontFinder, style);
3317 
3318     if (this.underline !== 0) {
3319       style.textDecoration = "underline";
3320       if (this.underline === 2) {
3321         style.textDecorationStyle = "double";
3322       }
3323     }
3324 
3325     // TODO: underlinePeriod
3326 
3327     style.fontWeight = this.weight;
3328 
3329     return style;
3330   }
3331 }
3332 
3333 class Format extends XFAObject {
3334   constructor(attributes) {
3335     super(TEMPLATE_NS_ID, "format", /* hasChildren = */ true);
3336     this.id = attributes.id || "";
3337     this.use = attributes.use || "";
3338     this.usehref = attributes.usehref || "";
3339     this.extras = null;
3340     this.picture = null;
3341   }
3342 }
3343 
3344 class Handler extends StringObject {
3345   constructor(attributes) {
3346     super(TEMPLATE_NS_ID, "handler");
3347     this.id = attributes.id || "";
3348     this.type = getStringOption(attributes.type, ["optional", "required"]);
3349     this.use = attributes.use || "";
3350     this.usehref = attributes.usehref || "";
3351   }
3352 }
3353 
3354 class Hyphenation extends XFAObject {
3355   constructor(attributes) {
3356     super(TEMPLATE_NS_ID, "hyphenation");
3357     this.excludeAllCaps = getInteger({
3358       data: attributes.excludeAllCaps,
3359       defaultValue: 0,
3360       validate: x => x === 1,
3361     });
3362     this.excludeInitialCap = getInteger({
3363       data: attributes.excludeInitialCap,
3364       defaultValue: 0,
3365       validate: x => x === 1,
3366     });
3367     this.hyphenate = getInteger({
3368       data: attributes.hyphenate,
3369       defaultValue: 0,
3370       validate: x => x === 1,
3371     });
3372     this.id = attributes.id || "";
3373     this.pushCharacterCount = getInteger({
3374       data: attributes.pushCharacterCount,
3375       defaultValue: 3,
3376       validate: x => x >= 0,
3377     });
3378     this.remainCharacterCount = getInteger({
3379       data: attributes.remainCharacterCount,
3380       defaultValue: 3,
3381       validate: x => x >= 0,
3382     });
3383     this.use = attributes.use || "";
3384     this.usehref = attributes.usehref || "";
3385     this.wordCharacterCount = getInteger({
3386       data: attributes.wordCharacterCount,
3387       defaultValue: 7,
3388       validate: x => x >= 0,
3389     });
3390   }
3391 }
3392 
3393 class Image extends StringObject {
3394   constructor(attributes) {
3395     super(TEMPLATE_NS_ID, "image");
3396     this.aspect = getStringOption(attributes.aspect, [
3397       "fit",
3398       "actual",
3399       "height",
3400       "none",
3401       "width",
3402     ]);
3403     this.contentType = attributes.contentType || "";
3404     this.href = attributes.href || "";
3405     this.id = attributes.id || "";
3406     this.name = attributes.name || "";
3407     this.transferEncoding = getStringOption(attributes.transferEncoding, [
3408       "base64",
3409       "none",
3410       "package",
3411     ]);
3412     this.use = attributes.use || "";
3413     this.usehref = attributes.usehref || "";
3414   }
3415 
3416   [$toHTML]() {
3417     if (this.contentType && !MIMES.has(this.contentType.toLowerCase())) {
3418       return HTMLResult.EMPTY;
3419     }
3420 
3421     let buffer =
3422       this[$globalData].images && this[$globalData].images.get(this.href);
3423     if (!buffer && (this.href || !this[$content])) {
3424       // In general, we don't get remote data and use what we have
3425       // in the pdf itself, so no picture for non null href.
3426       return HTMLResult.EMPTY;
3427     }
3428 
3429     if (!buffer && this.transferEncoding === "base64") {
3430       buffer = fromBase64Util(this[$content]);
3431     }
3432 
3433     if (!buffer) {
3434       return HTMLResult.EMPTY;
3435     }
3436 
3437     if (!this.contentType) {
3438       for (const [header, type] of IMAGES_HEADERS) {
3439         if (
3440           buffer.length > header.length &&
3441           header.every((x, i) => x === buffer[i])
3442         ) {
3443           this.contentType = type;
3444           break;
3445         }
3446       }
3447       if (!this.contentType) {
3448         return HTMLResult.EMPTY;
3449       }
3450     }
3451 
3452     // TODO: Firefox doesn't support natively tiff (and tif) format.
3453     const blob = new Blob([buffer], { type: this.contentType });
3454     let style;
3455     switch (this.aspect) {
3456       case "fit":
3457       case "actual":
3458         // TODO: check what to do with actual.
3459         // Normally we should return {auto, auto} for it but
3460         // it implies some wrong rendering (see xfa_bug1716816.pdf).
3461         break;
3462       case "height":
3463         style = {
3464           height: "100%",
3465           objectFit: "fill",
3466         };
3467         break;
3468       case "none":
3469         style = {
3470           width: "100%",
3471           height: "100%",
3472           objectFit: "fill",
3473         };
3474         break;
3475       case "width":
3476         style = {
3477           width: "100%",
3478           objectFit: "fill",
3479         };
3480         break;
3481     }
3482     const parent = this[$getParent]();
3483     return HTMLResult.success({
3484       name: "img",
3485       attributes: {
3486         class: ["xfaImage"],
3487         style,
3488         src: URL.createObjectURL(blob),
3489         alt: parent ? ariaLabel(parent[$getParent]()) : null,
3490       },
3491     });
3492   }
3493 }
3494 
3495 class ImageEdit extends XFAObject {
3496   constructor(attributes) {
3497     super(TEMPLATE_NS_ID, "imageEdit", /* hasChildren = */ true);
3498     this.data = getStringOption(attributes.data, ["link", "embed"]);
3499     this.id = attributes.id || "";
3500     this.use = attributes.use || "";
3501     this.usehref = attributes.usehref || "";
3502     this.border = null;
3503     this.extras = null;
3504     this.margin = null;
3505   }
3506 
3507   [$toHTML](availableSpace) {
3508     if (this.data === "embed") {
3509       return HTMLResult.success({
3510         name: "div",
3511         children: [],
3512         attributes: {},
3513       });
3514     }
3515 
3516     return HTMLResult.EMPTY;
3517   }
3518 }
3519 
3520 class Integer extends ContentObject {
3521   constructor(attributes) {
3522     super(TEMPLATE_NS_ID, "integer");
3523     this.id = attributes.id || "";
3524     this.name = attributes.name || "";
3525     this.use = attributes.use || "";
3526     this.usehref = attributes.usehref || "";
3527   }
3528 
3529   [$finalize]() {
3530     const number = parseInt(this[$content].trim(), 10);
3531     this[$content] = isNaN(number) ? null : number;
3532   }
3533 
3534   [$toHTML](availableSpace) {
3535     return valueToHtml(
3536       this[$content] !== null ? this[$content].toString() : ""
3537     );
3538   }
3539 }
3540 
3541 class Issuers extends XFAObject {
3542   constructor(attributes) {
3543     super(TEMPLATE_NS_ID, "issuers", /* hasChildren = */ true);
3544     this.id = attributes.id || "";
3545     this.type = getStringOption(attributes.type, ["optional", "required"]);
3546     this.use = attributes.use || "";
3547     this.usehref = attributes.usehref || "";
3548     this.certificate = new XFAObjectArray();
3549   }
3550 }
3551 
3552 class Items extends XFAObject {
3553   constructor(attributes) {
3554     super(TEMPLATE_NS_ID, "items", /* hasChildren = */ true);
3555     this.id = attributes.id || "";
3556     this.name = attributes.name || "";
3557     this.presence = getStringOption(attributes.presence, [
3558       "visible",
3559       "hidden",
3560       "inactive",
3561       "invisible",
3562     ]);
3563     this.ref = attributes.ref || "";
3564     this.save = getInteger({
3565       data: attributes.save,
3566       defaultValue: 0,
3567       validate: x => x === 1,
3568     });
3569     this.use = attributes.use || "";
3570     this.usehref = attributes.usehref || "";
3571     this.boolean = new XFAObjectArray();
3572     this.date = new XFAObjectArray();
3573     this.dateTime = new XFAObjectArray();
3574     this.decimal = new XFAObjectArray();
3575     this.exData = new XFAObjectArray();
3576     this.float = new XFAObjectArray();
3577     this.image = new XFAObjectArray();
3578     this.integer = new XFAObjectArray();
3579     this.text = new XFAObjectArray();
3580     this.time = new XFAObjectArray();
3581   }
3582 
3583   [$toHTML]() {
3584     const output = [];
3585     for (const child of this[$getChildren]()) {
3586       output.push(child[$text]());
3587     }
3588     return HTMLResult.success(output);
3589   }
3590 }
3591 
3592 class Keep extends XFAObject {
3593   constructor(attributes) {
3594     super(TEMPLATE_NS_ID, "keep", /* hasChildren = */ true);
3595     this.id = attributes.id || "";
3596     const options = ["none", "contentArea", "pageArea"];
3597     this.intact = getStringOption(attributes.intact, options);
3598     this.next = getStringOption(attributes.next, options);
3599     this.previous = getStringOption(attributes.previous, options);
3600     this.use = attributes.use || "";
3601     this.usehref = attributes.usehref || "";
3602     this.extras = null;
3603   }
3604 }
3605 
3606 class KeyUsage extends XFAObject {
3607   constructor(attributes) {
3608     super(TEMPLATE_NS_ID, "keyUsage");
3609     const options = ["", "yes", "no"];
3610     this.crlSign = getStringOption(attributes.crlSign, options);
3611     this.dataEncipherment = getStringOption(
3612       attributes.dataEncipherment,
3613       options
3614     );
3615     this.decipherOnly = getStringOption(attributes.decipherOnly, options);
3616     this.digitalSignature = getStringOption(
3617       attributes.digitalSignature,
3618       options
3619     );
3620     this.encipherOnly = getStringOption(attributes.encipherOnly, options);
3621     this.id = attributes.id || "";
3622     this.keyAgreement = getStringOption(attributes.keyAgreement, options);
3623     this.keyCertSign = getStringOption(attributes.keyCertSign, options);
3624     this.keyEncipherment = getStringOption(attributes.keyEncipherment, options);
3625     this.nonRepudiation = getStringOption(attributes.nonRepudiation, options);
3626     this.type = getStringOption(attributes.type, ["optional", "required"]);
3627     this.use = attributes.use || "";
3628     this.usehref = attributes.usehref || "";
3629   }
3630 }
3631 
3632 class Line extends XFAObject {
3633   constructor(attributes) {
3634     super(TEMPLATE_NS_ID, "line", /* hasChildren = */ true);
3635     this.hand = getStringOption(attributes.hand, ["even", "left", "right"]);
3636     this.id = attributes.id || "";
3637     this.slope = getStringOption(attributes.slope, ["\\", "/"]);
3638     this.use = attributes.use || "";
3639     this.usehref = attributes.usehref || "";
3640     this.edge = null;
3641   }
3642 
3643   [$toHTML]() {
3644     const parent = this[$getParent]()[$getParent]();
3645     const edge = this.edge || new Edge({});
3646     const edgeStyle = edge[$toStyle]();
3647     const style = Object.create(null);
3648     const thickness = edge.presence === "visible" ? edge.thickness : 0;
3649     style.strokeWidth = measureToString(thickness);
3650     style.stroke = edgeStyle.color;
3651     let x1, y1, x2, y2;
3652     let width = "100%";
3653     let height = "100%";
3654 
3655     if (parent.w <= thickness) {
3656       [x1, y1, x2, y2] = ["50%", 0, "50%", "100%"];
3657       width = style.strokeWidth;
3658     } else if (parent.h <= thickness) {
3659       [x1, y1, x2, y2] = [0, "50%", "100%", "50%"];
3660       height = style.strokeWidth;
3661     } else if (this.slope === "\\") {
3662       [x1, y1, x2, y2] = [0, 0, "100%", "100%"];
3663     } else {
3664       [x1, y1, x2, y2] = [0, "100%", "100%", 0];
3665     }
3666 
3667     const line = {
3668       name: "line",
3669       attributes: {
3670         xmlns: SVG_NS,
3671         x1,
3672         y1,
3673         x2,
3674         y2,
3675         style,
3676       },
3677     };
3678 
3679     const svg = {
3680       name: "svg",
3681       children: [line],
3682       attributes: {
3683         xmlns: SVG_NS,
3684         width,
3685         height,
3686         style: {
3687           overflow: "visible",
3688         },
3689       },
3690     };
3691 
3692     if (hasMargin(parent)) {
3693       return HTMLResult.success({
3694         name: "div",
3695         attributes: {
3696           style: {
3697             display: "inline",
3698             width: "100%",
3699             height: "100%",
3700           },
3701         },
3702         children: [svg],
3703       });
3704     }
3705 
3706     svg.attributes.style.position = "absolute";
3707     return HTMLResult.success(svg);
3708   }
3709 }
3710 
3711 class Linear extends XFAObject {
3712   constructor(attributes) {
3713     super(TEMPLATE_NS_ID, "linear", /* hasChildren = */ true);
3714     this.id = attributes.id || "";
3715     this.type = getStringOption(attributes.type, [
3716       "toRight",
3717       "toBottom",
3718       "toLeft",
3719       "toTop",
3720     ]);
3721     this.use = attributes.use || "";
3722     this.usehref = attributes.usehref || "";
3723     this.color = null;
3724     this.extras = null;
3725   }
3726 
3727   [$toStyle](startColor) {
3728     startColor = startColor ? startColor[$toStyle]() : "#FFFFFF";
3729     const transf = this.type.replace(/([RBLT])/, " $1").toLowerCase();
3730     const endColor = this.color ? this.color[$toStyle]() : "#000000";
3731     return `linear-gradient(${transf}, ${startColor}, ${endColor})`;
3732   }
3733 }
3734 
3735 class LockDocument extends ContentObject {
3736   constructor(attributes) {
3737     super(TEMPLATE_NS_ID, "lockDocument");
3738     this.id = attributes.id || "";
3739     this.type = getStringOption(attributes.type, ["optional", "required"]);
3740     this.use = attributes.use || "";
3741     this.usehref = attributes.usehref || "";
3742   }
3743 
3744   [$finalize]() {
3745     this[$content] = getStringOption(this[$content], ["auto", "0", "1"]);
3746   }
3747 }
3748 
3749 class Manifest extends XFAObject {
3750   constructor(attributes) {
3751     super(TEMPLATE_NS_ID, "manifest", /* hasChildren = */ true);
3752     this.action = getStringOption(attributes.action, [
3753       "include",
3754       "all",
3755       "exclude",
3756     ]);
3757     this.id = attributes.id || "";
3758     this.name = attributes.name || "";
3759     this.use = attributes.use || "";
3760     this.usehref = attributes.usehref || "";
3761     this.extras = null;
3762     this.ref = new XFAObjectArray();
3763   }
3764 }
3765 
3766 class Margin extends XFAObject {
3767   constructor(attributes) {
3768     super(TEMPLATE_NS_ID, "margin", /* hasChildren = */ true);
3769     this.bottomInset = getMeasurement(attributes.bottomInset, "0");
3770     this.id = attributes.id || "";
3771     this.leftInset = getMeasurement(attributes.leftInset, "0");
3772     this.rightInset = getMeasurement(attributes.rightInset, "0");
3773     this.topInset = getMeasurement(attributes.topInset, "0");
3774     this.use = attributes.use || "";
3775     this.usehref = attributes.usehref || "";
3776     this.extras = null;
3777   }
3778 
3779   [$toStyle]() {
3780     return {
3781       margin:
3782         measureToString(this.topInset) +
3783         " " +
3784         measureToString(this.rightInset) +
3785         " " +
3786         measureToString(this.bottomInset) +
3787         " " +
3788         measureToString(this.leftInset),
3789     };
3790   }
3791 }
3792 
3793 class Mdp extends XFAObject {
3794   constructor(attributes) {
3795     super(TEMPLATE_NS_ID, "mdp");
3796     this.id = attributes.id || "";
3797     this.permissions = getInteger({
3798       data: attributes.permissions,
3799       defaultValue: 2,
3800       validate: x => x === 1 || x === 3,
3801     });
3802     this.signatureType = getStringOption(attributes.signatureType, [
3803       "filler",
3804       "author",
3805     ]);
3806     this.use = attributes.use || "";
3807     this.usehref = attributes.usehref || "";
3808   }
3809 }
3810 
3811 class Medium extends XFAObject {
3812   constructor(attributes) {
3813     super(TEMPLATE_NS_ID, "medium");
3814     this.id = attributes.id || "";
3815     this.imagingBBox = getBBox(attributes.imagingBBox);
3816     this.long = getMeasurement(attributes.long);
3817     this.orientation = getStringOption(attributes.orientation, [
3818       "portrait",
3819       "landscape",
3820     ]);
3821     this.short = getMeasurement(attributes.short);
3822     this.stock = attributes.stock || "";
3823     this.trayIn = getStringOption(attributes.trayIn, [
3824       "auto",
3825       "delegate",
3826       "pageFront",
3827     ]);
3828     this.trayOut = getStringOption(attributes.trayOut, ["auto", "delegate"]);
3829     this.use = attributes.use || "";
3830     this.usehref = attributes.usehref || "";
3831   }
3832 }
3833 
3834 class Message extends XFAObject {
3835   constructor(attributes) {
3836     super(TEMPLATE_NS_ID, "message", /* hasChildren = */ true);
3837     this.id = attributes.id || "";
3838     this.use = attributes.use || "";
3839     this.usehref = attributes.usehref || "";
3840     this.text = new XFAObjectArray();
3841   }
3842 }
3843 
3844 class NumericEdit extends XFAObject {
3845   constructor(attributes) {
3846     super(TEMPLATE_NS_ID, "numericEdit", /* hasChildren = */ true);
3847     this.hScrollPolicy = getStringOption(attributes.hScrollPolicy, [
3848       "auto",
3849       "off",
3850       "on",
3851     ]);
3852     this.id = attributes.id || "";
3853     this.use = attributes.use || "";
3854     this.usehref = attributes.usehref || "";
3855     this.border = null;
3856     this.comb = null;
3857     this.extras = null;
3858     this.margin = null;
3859   }
3860 
3861   [$toHTML](availableSpace) {
3862     // TODO: incomplete.
3863     const style = toStyle(this, "border", "font", "margin");
3864     const field = this[$getParent]()[$getParent]();
3865     const html = {
3866       name: "input",
3867       attributes: {
3868         type: "text",
3869         fieldId: field[$uid],
3870         dataId: field[$data]?.[$uid] || field[$uid],
3871         class: ["xfaTextfield"],
3872         style,
3873         "aria-label": ariaLabel(field),
3874         "aria-required": false,
3875       },
3876     };
3877 
3878     if (isRequired(field)) {
3879       html.attributes["aria-required"] = true;
3880       html.attributes.required = true;
3881     }
3882 
3883     return HTMLResult.success({
3884       name: "label",
3885       attributes: {
3886         class: ["xfaLabel"],
3887       },
3888       children: [html],
3889     });
3890   }
3891 }
3892 
3893 class Occur extends XFAObject {
3894   constructor(attributes) {
3895     super(TEMPLATE_NS_ID, "occur", /* hasChildren = */ true);
3896     this.id = attributes.id || "";
3897     this.initial =
3898       attributes.initial !== ""
3899         ? getInteger({
3900             data: attributes.initial,
3901             defaultValue: "",
3902             validate: x => true,
3903           })
3904         : "";
3905     this.max =
3906       attributes.max !== ""
3907         ? getInteger({
3908             data: attributes.max,
3909             defaultValue: 1,
3910             validate: x => true,
3911           })
3912         : "";
3913     this.min =
3914       attributes.min !== ""
3915         ? getInteger({
3916             data: attributes.min,
3917             defaultValue: 1,
3918             validate: x => true,
3919           })
3920         : "";
3921     this.use = attributes.use || "";
3922     this.usehref = attributes.usehref || "";
3923     this.extras = null;
3924   }
3925 
3926   [$clean]() {
3927     const parent = this[$getParent]();
3928     const originalMin = this.min;
3929 
3930     if (this.min === "") {
3931       this.min =
3932         parent instanceof PageArea || parent instanceof PageSet ? 0 : 1;
3933     }
3934     if (this.max === "") {
3935       if (originalMin === "") {
3936         this.max =
3937           parent instanceof PageArea || parent instanceof PageSet ? -1 : 1;
3938       } else {
3939         this.max = this.min;
3940       }
3941     }
3942 
3943     if (this.max !== -1 && this.max < this.min) {
3944       this.max = this.min;
3945     }
3946 
3947     if (this.initial === "") {
3948       this.initial = parent instanceof Template ? 1 : this.min;
3949     }
3950   }
3951 }
3952 
3953 class Oid extends StringObject {
3954   constructor(attributes) {
3955     super(TEMPLATE_NS_ID, "oid");
3956     this.id = attributes.id || "";
3957     this.name = attributes.name || "";
3958     this.use = attributes.use || "";
3959     this.usehref = attributes.usehref || "";
3960   }
3961 }
3962 
3963 class Oids extends XFAObject {
3964   constructor(attributes) {
3965     super(TEMPLATE_NS_ID, "oids", /* hasChildren = */ true);
3966     this.id = attributes.id || "";
3967     this.type = getStringOption(attributes.type, ["optional", "required"]);
3968     this.use = attributes.use || "";
3969     this.usehref = attributes.usehref || "";
3970     this.oid = new XFAObjectArray();
3971   }
3972 }
3973 
3974 class Overflow extends XFAObject {
3975   constructor(attributes) {
3976     super(TEMPLATE_NS_ID, "overflow");
3977     this.id = attributes.id || "";
3978     this.leader = attributes.leader || "";
3979     this.target = attributes.target || "";
3980     this.trailer = attributes.trailer || "";
3981     this.use = attributes.use || "";
3982     this.usehref = attributes.usehref || "";
3983   }
3984 
3985   [$getExtra]() {
3986     if (!this[$extra]) {
3987       const parent = this[$getParent]();
3988       const root = this[$getTemplateRoot]();
3989       const target = root[$searchNode](this.target, parent);
3990       const leader = root[$searchNode](this.leader, parent);
3991       const trailer = root[$searchNode](this.trailer, parent);
3992       this[$extra] = {
3993         target: target?.[0] || null,
3994         leader: leader?.[0] || null,
3995         trailer: trailer?.[0] || null,
3996         addLeader: false,
3997         addTrailer: false,
3998       };
3999     }
4000     return this[$extra];
4001   }
4002 }
4003 
4004 class PageArea extends XFAObject {
4005   constructor(attributes) {
4006     super(TEMPLATE_NS_ID, "pageArea", /* hasChildren = */ true);
4007     this.blankOrNotBlank = getStringOption(attributes.blankOrNotBlank, [
4008       "any",
4009       "blank",
4010       "notBlank",
4011     ]);
4012     this.id = attributes.id || "";
4013     this.initialNumber = getInteger({
4014       data: attributes.initialNumber,
4015       defaultValue: 1,
4016       validate: x => true,
4017     });
4018     this.name = attributes.name || "";
4019     this.numbered = getInteger({
4020       data: attributes.numbered,
4021       defaultValue: 1,
4022       validate: x => true,
4023     });
4024     this.oddOrEven = getStringOption(attributes.oddOrEven, [
4025       "any",
4026       "even",
4027       "odd",
4028     ]);
4029     this.pagePosition = getStringOption(attributes.pagePosition, [
4030       "any",
4031       "first",
4032       "last",
4033       "only",
4034       "rest",
4035     ]);
4036     this.relevant = getRelevant(attributes.relevant);
4037     this.use = attributes.use || "";
4038     this.usehref = attributes.usehref || "";
4039     this.desc = null;
4040     this.extras = null;
4041     this.medium = null;
4042     this.occur = null;
4043     this.area = new XFAObjectArray();
4044     this.contentArea = new XFAObjectArray();
4045     this.draw = new XFAObjectArray();
4046     this.exclGroup = new XFAObjectArray();
4047     this.field = new XFAObjectArray();
4048     this.subform = new XFAObjectArray();
4049   }
4050 
4051   [$isUsable]() {
4052     if (!this[$extra]) {
4053       this[$extra] = {
4054         numberOfUse: 0,
4055       };
4056       return true;
4057     }
4058     return (
4059       !this.occur ||
4060       this.occur.max === -1 ||
4061       this[$extra].numberOfUse < this.occur.max
4062     );
4063   }
4064 
4065   [$cleanPage]() {
4066     delete this[$extra];
4067   }
4068 
4069   [$getNextPage]() {
4070     if (!this[$extra]) {
4071       this[$extra] = {
4072         numberOfUse: 0,
4073       };
4074     }
4075 
4076     const parent = this[$getParent]();
4077     if (parent.relation === "orderedOccurrence") {
4078       if (this[$isUsable]()) {
4079         this[$extra].numberOfUse += 1;
4080         return this;
4081       }
4082     }
4083 
4084     return parent[$getNextPage]();
4085   }
4086 
4087   [$getAvailableSpace]() {
4088     return this[$extra].space || { width: 0, height: 0 };
4089   }
4090 
4091   [$toHTML]() {
4092     // TODO: incomplete.
4093     if (!this[$extra]) {
4094       this[$extra] = {
4095         numberOfUse: 1,
4096       };
4097     }
4098 
4099     const children = [];
4100     this[$extra].children = children;
4101 
4102     const style = Object.create(null);
4103     if (this.medium && this.medium.short && this.medium.long) {
4104       style.width = measureToString(this.medium.short);
4105       style.height = measureToString(this.medium.long);
4106       this[$extra].space = {
4107         width: this.medium.short,
4108         height: this.medium.long,
4109       };
4110       if (this.medium.orientation === "landscape") {
4111         const x = style.width;
4112         style.width = style.height;
4113         style.height = x;
4114         this[$extra].space = {
4115           width: this.medium.long,
4116           height: this.medium.short,
4117         };
4118       }
4119     } else {
4120       warn("XFA - No medium specified in pageArea: please file a bug.");
4121     }
4122 
4123     this[$childrenToHTML]({
4124       filter: new Set(["area", "draw", "field", "subform"]),
4125       include: true,
4126     });
4127 
4128     // contentarea must be the last container to be sure it is
4129     // on top of the others.
4130     this[$childrenToHTML]({
4131       filter: new Set(["contentArea"]),
4132       include: true,
4133     });
4134 
4135     return HTMLResult.success({
4136       name: "div",
4137       children,
4138       attributes: {
4139         class: ["xfaPage"],
4140         id: this[$uid],
4141         style,
4142         xfaName: this.name,
4143       },
4144     });
4145   }
4146 }
4147 
4148 class PageSet extends XFAObject {
4149   constructor(attributes) {
4150     super(TEMPLATE_NS_ID, "pageSet", /* hasChildren = */ true);
4151     this.duplexImposition = getStringOption(attributes.duplexImposition, [
4152       "longEdge",
4153       "shortEdge",
4154     ]);
4155     this.id = attributes.id || "";
4156     this.name = attributes.name || "";
4157     this.relation = getStringOption(attributes.relation, [
4158       "orderedOccurrence",
4159       "duplexPaginated",
4160       "simplexPaginated",
4161     ]);
4162     this.relevant = getRelevant(attributes.relevant);
4163     this.use = attributes.use || "";
4164     this.usehref = attributes.usehref || "";
4165     this.extras = null;
4166     this.occur = null;
4167     this.pageArea = new XFAObjectArray();
4168     this.pageSet = new XFAObjectArray();
4169   }
4170 
4171   [$cleanPage]() {
4172     for (const page of this.pageArea.children) {
4173       page[$cleanPage]();
4174     }
4175     for (const page of this.pageSet.children) {
4176       page[$cleanPage]();
4177     }
4178   }
4179 
4180   [$isUsable]() {
4181     return (
4182       !this.occur ||
4183       this.occur.max === -1 ||
4184       this[$extra].numberOfUse < this.occur.max
4185     );
4186   }
4187 
4188   [$getNextPage]() {
4189     if (!this[$extra]) {
4190       this[$extra] = {
4191         numberOfUse: 1,
4192         pageIndex: -1,
4193         pageSetIndex: -1,
4194       };
4195     }
4196 
4197     if (this.relation === "orderedOccurrence") {
4198       if (this[$extra].pageIndex + 1 < this.pageArea.children.length) {
4199         this[$extra].pageIndex += 1;
4200         const pageArea = this.pageArea.children[this[$extra].pageIndex];
4201         return pageArea[$getNextPage]();
4202       }
4203 
4204       if (this[$extra].pageSetIndex + 1 < this.pageSet.children.length) {
4205         this[$extra].pageSetIndex += 1;
4206         return this.pageSet.children[this[$extra].pageSetIndex][$getNextPage]();
4207       }
4208 
4209       if (this[$isUsable]()) {
4210         this[$extra].numberOfUse += 1;
4211         this[$extra].pageIndex = -1;
4212         this[$extra].pageSetIndex = -1;
4213         return this[$getNextPage]();
4214       }
4215 
4216       const parent = this[$getParent]();
4217       if (parent instanceof PageSet) {
4218         return parent[$getNextPage]();
4219       }
4220 
4221       this[$cleanPage]();
4222       return this[$getNextPage]();
4223     }
4224     const pageNumber = this[$getTemplateRoot]()[$extra].pageNumber;
4225     const parity = pageNumber % 2 === 0 ? "even" : "odd";
4226     const position = pageNumber === 0 ? "first" : "rest";
4227 
4228     let page = this.pageArea.children.find(
4229       p => p.oddOrEven === parity && p.pagePosition === position
4230     );
4231     if (page) {
4232       return page;
4233     }
4234 
4235     page = this.pageArea.children.find(
4236       p => p.oddOrEven === "any" && p.pagePosition === position
4237     );
4238     if (page) {
4239       return page;
4240     }
4241 
4242     page = this.pageArea.children.find(
4243       p => p.oddOrEven === "any" && p.pagePosition === "any"
4244     );
4245     if (page) {
4246       return page;
4247     }
4248 
4249     return this.pageArea.children[0];
4250   }
4251 }
4252 
4253 class Para extends XFAObject {
4254   constructor(attributes) {
4255     super(TEMPLATE_NS_ID, "para", /* hasChildren = */ true);
4256     this.hAlign = getStringOption(attributes.hAlign, [
4257       "left",
4258       "center",
4259       "justify",
4260       "justifyAll",
4261       "radix",
4262       "right",
4263     ]);
4264     this.id = attributes.id || "";
4265     this.lineHeight = attributes.lineHeight
4266       ? getMeasurement(attributes.lineHeight, "0pt")
4267       : "";
4268     this.marginLeft = attributes.marginLeft
4269       ? getMeasurement(attributes.marginLeft, "0pt")
4270       : "";
4271     this.marginRight = attributes.marginRight
4272       ? getMeasurement(attributes.marginRight, "0pt")
4273       : "";
4274     this.orphans = getInteger({
4275       data: attributes.orphans,
4276       defaultValue: 0,
4277       validate: x => x >= 0,
4278     });
4279     this.preserve = attributes.preserve || "";
4280     this.radixOffset = attributes.radixOffset
4281       ? getMeasurement(attributes.radixOffset, "0pt")
4282       : "";
4283     this.spaceAbove = attributes.spaceAbove
4284       ? getMeasurement(attributes.spaceAbove, "0pt")
4285       : "";
4286     this.spaceBelow = attributes.spaceBelow
4287       ? getMeasurement(attributes.spaceBelow, "0pt")
4288       : "";
4289     this.tabDefault = attributes.tabDefault
4290       ? getMeasurement(this.tabDefault)
4291       : "";
4292     this.tabStops = (attributes.tabStops || "")
4293       .trim()
4294       .split(/\s+/)
4295       .map((x, i) => (i % 2 === 1 ? getMeasurement(x) : x));
4296     this.textIndent = attributes.textIndent
4297       ? getMeasurement(attributes.textIndent, "0pt")
4298       : "";
4299     this.use = attributes.use || "";
4300     this.usehref = attributes.usehref || "";
4301     this.vAlign = getStringOption(attributes.vAlign, [
4302       "top",
4303       "bottom",
4304       "middle",
4305     ]);
4306     this.widows = getInteger({
4307       data: attributes.widows,
4308       defaultValue: 0,
4309       validate: x => x >= 0,
4310     });
4311     this.hyphenation = null;
4312   }
4313 
4314   [$toStyle]() {
4315     const style = toStyle(this, "hAlign");
4316     if (this.marginLeft !== "") {
4317       style.paddingLeft = measureToString(this.marginLeft);
4318     }
4319     if (this.marginRight !== "") {
4320       style.paddingRight = measureToString(this.marginRight);
4321     }
4322     if (this.spaceAbove !== "") {
4323       style.paddingTop = measureToString(this.spaceAbove);
4324     }
4325     if (this.spaceBelow !== "") {
4326       style.paddingBottom = measureToString(this.spaceBelow);
4327     }
4328     if (this.textIndent !== "") {
4329       style.textIndent = measureToString(this.textIndent);
4330       fixTextIndent(style);
4331     }
4332 
4333     if (this.lineHeight > 0) {
4334       style.lineHeight = measureToString(this.lineHeight);
4335     }
4336 
4337     if (this.tabDefault !== "") {
4338       style.tabSize = measureToString(this.tabDefault);
4339     }
4340 
4341     if (this.tabStops.length > 0) {
4342       // TODO
4343     }
4344 
4345     if (this.hyphenatation) {
4346       Object.assign(style, this.hyphenatation[$toStyle]());
4347     }
4348 
4349     return style;
4350   }
4351 }
4352 
4353 class PasswordEdit extends XFAObject {
4354   constructor(attributes) {
4355     super(TEMPLATE_NS_ID, "passwordEdit", /* hasChildren = */ true);
4356     this.hScrollPolicy = getStringOption(attributes.hScrollPolicy, [
4357       "auto",
4358       "off",
4359       "on",
4360     ]);
4361     this.id = attributes.id || "";
4362     this.passwordChar = attributes.passwordChar || "*";
4363     this.use = attributes.use || "";
4364     this.usehref = attributes.usehref || "";
4365     this.border = null;
4366     this.extras = null;
4367     this.margin = null;
4368   }
4369 }
4370 
4371 class Pattern extends XFAObject {
4372   constructor(attributes) {
4373     super(TEMPLATE_NS_ID, "pattern", /* hasChildren = */ true);
4374     this.id = attributes.id || "";
4375     this.type = getStringOption(attributes.type, [
4376       "crossHatch",
4377       "crossDiagonal",
4378       "diagonalLeft",
4379       "diagonalRight",
4380       "horizontal",
4381       "vertical",
4382     ]);
4383     this.use = attributes.use || "";
4384     this.usehref = attributes.usehref || "";
4385     this.color = null;
4386     this.extras = null;
4387   }
4388 
4389   [$toStyle](startColor) {
4390     startColor = startColor ? startColor[$toStyle]() : "#FFFFFF";
4391     const endColor = this.color ? this.color[$toStyle]() : "#000000";
4392     const width = 5;
4393     const cmd = "repeating-linear-gradient";
4394     const colors = `${startColor},${startColor} ${width}px,${endColor} ${width}px,${endColor} ${
4395       2 * width
4396     }px`;
4397     switch (this.type) {
4398       case "crossHatch":
4399         return `${cmd}(to top,${colors}) ${cmd}(to right,${colors})`;
4400       case "crossDiagonal":
4401         return `${cmd}(45deg,${colors}) ${cmd}(-45deg,${colors})`;
4402       case "diagonalLeft":
4403         return `${cmd}(45deg,${colors})`;
4404       case "diagonalRight":
4405         return `${cmd}(-45deg,${colors})`;
4406       case "horizontal":
4407         return `${cmd}(to top,${colors})`;
4408       case "vertical":
4409         return `${cmd}(to right,${colors})`;
4410     }
4411 
4412     return "";
4413   }
4414 }
4415 
4416 class Picture extends StringObject {
4417   constructor(attributes) {
4418     super(TEMPLATE_NS_ID, "picture");
4419     this.id = attributes.id || "";
4420     this.use = attributes.use || "";
4421     this.usehref = attributes.usehref || "";
4422   }
4423 }
4424 
4425 class Proto extends XFAObject {
4426   constructor(attributes) {
4427     super(TEMPLATE_NS_ID, "proto", /* hasChildren = */ true);
4428     this.appearanceFilter = new XFAObjectArray();
4429     this.arc = new XFAObjectArray();
4430     this.area = new XFAObjectArray();
4431     this.assist = new XFAObjectArray();
4432     this.barcode = new XFAObjectArray();
4433     this.bindItems = new XFAObjectArray();
4434     this.bookend = new XFAObjectArray();
4435     this.boolean = new XFAObjectArray();
4436     this.border = new XFAObjectArray();
4437     this.break = new XFAObjectArray();
4438     this.breakAfter = new XFAObjectArray();
4439     this.breakBefore = new XFAObjectArray();
4440     this.button = new XFAObjectArray();
4441     this.calculate = new XFAObjectArray();
4442     this.caption = new XFAObjectArray();
4443     this.certificate = new XFAObjectArray();
4444     this.certificates = new XFAObjectArray();
4445     this.checkButton = new XFAObjectArray();
4446     this.choiceList = new XFAObjectArray();
4447     this.color = new XFAObjectArray();
4448     this.comb = new XFAObjectArray();
4449     this.connect = new XFAObjectArray();
4450     this.contentArea = new XFAObjectArray();
4451     this.corner = new XFAObjectArray();
4452     this.date = new XFAObjectArray();
4453     this.dateTime = new XFAObjectArray();
4454     this.dateTimeEdit = new XFAObjectArray();
4455     this.decimal = new XFAObjectArray();
4456     this.defaultUi = new XFAObjectArray();
4457     this.desc = new XFAObjectArray();
4458     this.digestMethod = new XFAObjectArray();
4459     this.digestMethods = new XFAObjectArray();
4460     this.draw = new XFAObjectArray();
4461     this.edge = new XFAObjectArray();
4462     this.encoding = new XFAObjectArray();
4463     this.encodings = new XFAObjectArray();
4464     this.encrypt = new XFAObjectArray();
4465     this.encryptData = new XFAObjectArray();
4466     this.encryption = new XFAObjectArray();
4467     this.encryptionMethod = new XFAObjectArray();
4468     this.encryptionMethods = new XFAObjectArray();
4469     this.event = new XFAObjectArray();
4470     this.exData = new XFAObjectArray();
4471     this.exObject = new XFAObjectArray();
4472     this.exclGroup = new XFAObjectArray();
4473     this.execute = new XFAObjectArray();
4474     this.extras = new XFAObjectArray();
4475     this.field = new XFAObjectArray();
4476     this.fill = new XFAObjectArray();
4477     this.filter = new XFAObjectArray();
4478     this.float = new XFAObjectArray();
4479     this.font = new XFAObjectArray();
4480     this.format = new XFAObjectArray();
4481     this.handler = new XFAObjectArray();
4482     this.hyphenation = new XFAObjectArray();
4483     this.image = new XFAObjectArray();
4484     this.imageEdit = new XFAObjectArray();
4485     this.integer = new XFAObjectArray();
4486     this.issuers = new XFAObjectArray();
4487     this.items = new XFAObjectArray();
4488     this.keep = new XFAObjectArray();
4489     this.keyUsage = new XFAObjectArray();
4490     this.line = new XFAObjectArray();
4491     this.linear = new XFAObjectArray();
4492     this.lockDocument = new XFAObjectArray();
4493     this.manifest = new XFAObjectArray();
4494     this.margin = new XFAObjectArray();
4495     this.mdp = new XFAObjectArray();
4496     this.medium = new XFAObjectArray();
4497     this.message = new XFAObjectArray();
4498     this.numericEdit = new XFAObjectArray();
4499     this.occur = new XFAObjectArray();
4500     this.oid = new XFAObjectArray();
4501     this.oids = new XFAObjectArray();
4502     this.overflow = new XFAObjectArray();
4503     this.pageArea = new XFAObjectArray();
4504     this.pageSet = new XFAObjectArray();
4505     this.para = new XFAObjectArray();
4506     this.passwordEdit = new XFAObjectArray();
4507     this.pattern = new XFAObjectArray();
4508     this.picture = new XFAObjectArray();
4509     this.radial = new XFAObjectArray();
4510     this.reason = new XFAObjectArray();
4511     this.reasons = new XFAObjectArray();
4512     this.rectangle = new XFAObjectArray();
4513     this.ref = new XFAObjectArray();
4514     this.script = new XFAObjectArray();
4515     this.setProperty = new XFAObjectArray();
4516     this.signData = new XFAObjectArray();
4517     this.signature = new XFAObjectArray();
4518     this.signing = new XFAObjectArray();
4519     this.solid = new XFAObjectArray();
4520     this.speak = new XFAObjectArray();
4521     this.stipple = new XFAObjectArray();
4522     this.subform = new XFAObjectArray();
4523     this.subformSet = new XFAObjectArray();
4524     this.subjectDN = new XFAObjectArray();
4525     this.subjectDNs = new XFAObjectArray();
4526     this.submit = new XFAObjectArray();
4527     this.text = new XFAObjectArray();
4528     this.textEdit = new XFAObjectArray();
4529     this.time = new XFAObjectArray();
4530     this.timeStamp = new XFAObjectArray();
4531     this.toolTip = new XFAObjectArray();
4532     this.traversal = new XFAObjectArray();
4533     this.traverse = new XFAObjectArray();
4534     this.ui = new XFAObjectArray();
4535     this.validate = new XFAObjectArray();
4536     this.value = new XFAObjectArray();
4537     this.variables = new XFAObjectArray();
4538   }
4539 }
4540 
4541 class Radial extends XFAObject {
4542   constructor(attributes) {
4543     super(TEMPLATE_NS_ID, "radial", /* hasChildren = */ true);
4544     this.id = attributes.id || "";
4545     this.type = getStringOption(attributes.type, ["toEdge", "toCenter"]);
4546     this.use = attributes.use || "";
4547     this.usehref = attributes.usehref || "";
4548     this.color = null;
4549     this.extras = null;
4550   }
4551 
4552   [$toStyle](startColor) {
4553     startColor = startColor ? startColor[$toStyle]() : "#FFFFFF";
4554     const endColor = this.color ? this.color[$toStyle]() : "#000000";
4555     const colors =
4556       this.type === "toEdge"
4557         ? `${startColor},${endColor}`
4558         : `${endColor},${startColor}`;
4559     return `radial-gradient(circle at center, ${colors})`;
4560   }
4561 }
4562 
4563 class Reason extends StringObject {
4564   constructor(attributes) {
4565     super(TEMPLATE_NS_ID, "reason");
4566     this.id = attributes.id || "";
4567     this.name = attributes.name || "";
4568     this.use = attributes.use || "";
4569     this.usehref = attributes.usehref || "";
4570   }
4571 }
4572 
4573 class Reasons extends XFAObject {
4574   constructor(attributes) {
4575     super(TEMPLATE_NS_ID, "reasons", /* hasChildren = */ true);
4576     this.id = attributes.id || "";
4577     this.type = getStringOption(attributes.type, ["optional", "required"]);
4578     this.use = attributes.use || "";
4579     this.usehref = attributes.usehref || "";
4580     this.reason = new XFAObjectArray();
4581   }
4582 }
4583 
4584 class Rectangle extends XFAObject {
4585   constructor(attributes) {
4586     super(TEMPLATE_NS_ID, "rectangle", /* hasChildren = */ true);
4587     this.hand = getStringOption(attributes.hand, ["even", "left", "right"]);
4588     this.id = attributes.id || "";
4589     this.use = attributes.use || "";
4590     this.usehref = attributes.usehref || "";
4591     this.corner = new XFAObjectArray(4);
4592     this.edge = new XFAObjectArray(4);
4593     this.fill = null;
4594   }
4595 
4596   [$toHTML]() {
4597     const edge = this.edge.children.length
4598       ? this.edge.children[0]
4599       : new Edge({});
4600     const edgeStyle = edge[$toStyle]();
4601     const style = Object.create(null);
4602     if (this.fill?.presence === "visible") {
4603       Object.assign(style, this.fill[$toStyle]());
4604     } else {
4605       style.fill = "transparent";
4606     }
4607     style.strokeWidth = measureToString(
4608       edge.presence === "visible" ? edge.thickness : 0
4609     );
4610     style.stroke = edgeStyle.color;
4611 
4612     const corner = this.corner.children.length
4613       ? this.corner.children[0]
4614       : new Corner({});
4615     const cornerStyle = corner[$toStyle]();
4616 
4617     const rect = {
4618       name: "rect",
4619       attributes: {
4620         xmlns: SVG_NS,
4621         width: "100%",
4622         height: "100%",
4623         x: 0,
4624         y: 0,
4625         rx: cornerStyle.radius,
4626         ry: cornerStyle.radius,
4627         style,
4628       },
4629     };
4630 
4631     const svg = {
4632       name: "svg",
4633       children: [rect],
4634       attributes: {
4635         xmlns: SVG_NS,
4636         style: {
4637           overflow: "visible",
4638         },
4639         width: "100%",
4640         height: "100%",
4641       },
4642     };
4643 
4644     const parent = this[$getParent]()[$getParent]();
4645     if (hasMargin(parent)) {
4646       return HTMLResult.success({
4647         name: "div",
4648         attributes: {
4649           style: {
4650             display: "inline",
4651             width: "100%",
4652             height: "100%",
4653           },
4654         },
4655         children: [svg],
4656       });
4657     }
4658 
4659     svg.attributes.style.position = "absolute";
4660     return HTMLResult.success(svg);
4661   }
4662 }
4663 
4664 class RefElement extends StringObject {
4665   constructor(attributes) {
4666     super(TEMPLATE_NS_ID, "ref");
4667     this.id = attributes.id || "";
4668     this.use = attributes.use || "";
4669     this.usehref = attributes.usehref || "";
4670   }
4671 }
4672 
4673 class Script extends StringObject {
4674   constructor(attributes) {
4675     super(TEMPLATE_NS_ID, "script");
4676     this.binding = attributes.binding || "";
4677     this.contentType = attributes.contentType || "";
4678     this.id = attributes.id || "";
4679     this.name = attributes.name || "";
4680     this.runAt = getStringOption(attributes.runAt, [
4681       "client",
4682       "both",
4683       "server",
4684     ]);
4685     this.use = attributes.use || "";
4686     this.usehref = attributes.usehref || "";
4687   }
4688 }
4689 
4690 class SetProperty extends XFAObject {
4691   constructor(attributes) {
4692     super(TEMPLATE_NS_ID, "setProperty");
4693     this.connection = attributes.connection || "";
4694     this.ref = attributes.ref || "";
4695     this.target = attributes.target || "";
4696   }
4697 }
4698 
4699 class SignData extends XFAObject {
4700   constructor(attributes) {
4701     super(TEMPLATE_NS_ID, "signData", /* hasChildren = */ true);
4702     this.id = attributes.id || "";
4703     this.operation = getStringOption(attributes.operation, [
4704       "sign",
4705       "clear",
4706       "verify",
4707     ]);
4708     this.ref = attributes.ref || "";
4709     this.target = attributes.target || "";
4710     this.use = attributes.use || "";
4711     this.usehref = attributes.usehref || "";
4712     this.filter = null;
4713     this.manifest = null;
4714   }
4715 }
4716 
4717 class Signature extends XFAObject {
4718   constructor(attributes) {
4719     super(TEMPLATE_NS_ID, "signature", /* hasChildren = */ true);
4720     this.id = attributes.id || "";
4721     this.type = getStringOption(attributes.type, ["PDF1.3", "PDF1.6"]);
4722     this.use = attributes.use || "";
4723     this.usehref = attributes.usehref || "";
4724     this.border = null;
4725     this.extras = null;
4726     this.filter = null;
4727     this.manifest = null;
4728     this.margin = null;
4729   }
4730 }
4731 
4732 class Signing extends XFAObject {
4733   constructor(attributes) {
4734     super(TEMPLATE_NS_ID, "signing", /* hasChildren = */ true);
4735     this.id = attributes.id || "";
4736     this.type = getStringOption(attributes.type, ["optional", "required"]);
4737     this.use = attributes.use || "";
4738     this.usehref = attributes.usehref || "";
4739     this.certificate = new XFAObjectArray();
4740   }
4741 }
4742 
4743 class Solid extends XFAObject {
4744   constructor(attributes) {
4745     super(TEMPLATE_NS_ID, "solid", /* hasChildren = */ true);
4746     this.id = attributes.id || "";
4747     this.use = attributes.use || "";
4748     this.usehref = attributes.usehref || "";
4749     this.extras = null;
4750   }
4751 
4752   [$toStyle](startColor) {
4753     return startColor ? startColor[$toStyle]() : "#FFFFFF";
4754   }
4755 }
4756 
4757 class Speak extends StringObject {
4758   constructor(attributes) {
4759     super(TEMPLATE_NS_ID, "speak");
4760     this.disable = getInteger({
4761       data: attributes.disable,
4762       defaultValue: 0,
4763       validate: x => x === 1,
4764     });
4765     this.id = attributes.id || "";
4766     this.priority = getStringOption(attributes.priority, [
4767       "custom",
4768       "caption",
4769       "name",
4770       "toolTip",
4771     ]);
4772     this.rid = attributes.rid || "";
4773     this.use = attributes.use || "";
4774     this.usehref = attributes.usehref || "";
4775   }
4776 }
4777 
4778 class Stipple extends XFAObject {
4779   constructor(attributes) {
4780     super(TEMPLATE_NS_ID, "stipple", /* hasChildren = */ true);
4781     this.id = attributes.id || "";
4782     this.rate = getInteger({
4783       data: attributes.rate,
4784       defaultValue: 50,
4785       validate: x => x >= 0 && x <= 100,
4786     });
4787     this.use = attributes.use || "";
4788     this.usehref = attributes.usehref || "";
4789     this.color = null;
4790     this.extras = null;
4791   }
4792 
4793   [$toStyle](bgColor) {
4794     const alpha = this.rate / 100;
4795     return Util.makeHexColor(
4796       Math.round(bgColor.value.r * (1 - alpha) + this.value.r * alpha),
4797       Math.round(bgColor.value.g * (1 - alpha) + this.value.g * alpha),
4798       Math.round(bgColor.value.b * (1 - alpha) + this.value.b * alpha)
4799     );
4800   }
4801 }
4802 
4803 class Subform extends XFAObject {
4804   constructor(attributes) {
4805     super(TEMPLATE_NS_ID, "subform", /* hasChildren = */ true);
4806     this.access = getStringOption(attributes.access, [
4807       "open",
4808       "nonInteractive",
4809       "protected",
4810       "readOnly",
4811     ]);
4812     this.allowMacro = getInteger({
4813       data: attributes.allowMacro,
4814       defaultValue: 0,
4815       validate: x => x === 1,
4816     });
4817     this.anchorType = getStringOption(attributes.anchorType, [
4818       "topLeft",
4819       "bottomCenter",
4820       "bottomLeft",
4821       "bottomRight",
4822       "middleCenter",
4823       "middleLeft",
4824       "middleRight",
4825       "topCenter",
4826       "topRight",
4827     ]);
4828     this.colSpan = getInteger({
4829       data: attributes.colSpan,
4830       defaultValue: 1,
4831       validate: n => n >= 1 || n === -1,
4832     });
4833     this.columnWidths = (attributes.columnWidths || "")
4834       .trim()
4835       .split(/\s+/)
4836       .map(x => (x === "-1" ? -1 : getMeasurement(x)));
4837     this.h = attributes.h ? getMeasurement(attributes.h) : "";
4838     this.hAlign = getStringOption(attributes.hAlign, [
4839       "left",
4840       "center",
4841       "justify",
4842       "justifyAll",
4843       "radix",
4844       "right",
4845     ]);
4846     this.id = attributes.id || "";
4847     this.layout = getStringOption(attributes.layout, [
4848       "position",
4849       "lr-tb",
4850       "rl-row",
4851       "rl-tb",
4852       "row",
4853       "table",
4854       "tb",
4855     ]);
4856     this.locale = attributes.locale || "";
4857     this.maxH = getMeasurement(attributes.maxH, "0pt");
4858     this.maxW = getMeasurement(attributes.maxW, "0pt");
4859     this.mergeMode = getStringOption(attributes.mergeMode, [
4860       "consumeData",
4861       "matchTemplate",
4862     ]);
4863     this.minH = getMeasurement(attributes.minH, "0pt");
4864     this.minW = getMeasurement(attributes.minW, "0pt");
4865     this.name = attributes.name || "";
4866     this.presence = getStringOption(attributes.presence, [
4867       "visible",
4868       "hidden",
4869       "inactive",
4870       "invisible",
4871     ]);
4872     this.relevant = getRelevant(attributes.relevant);
4873     this.restoreState = getStringOption(attributes.restoreState, [
4874       "manual",
4875       "auto",
4876     ]);
4877     this.scope = getStringOption(attributes.scope, ["name", "none"]);
4878     this.use = attributes.use || "";
4879     this.usehref = attributes.usehref || "";
4880     this.w = attributes.w ? getMeasurement(attributes.w) : "";
4881     this.x = getMeasurement(attributes.x, "0pt");
4882     this.y = getMeasurement(attributes.y, "0pt");
4883     this.assist = null;
4884     this.bind = null;
4885     this.bookend = null;
4886     this.border = null;
4887     this.break = null;
4888     this.calculate = null;
4889     this.desc = null;
4890     this.extras = null;
4891     this.keep = null;
4892     this.margin = null;
4893     this.occur = null;
4894     this.overflow = null;
4895     this.pageSet = null;
4896     this.para = null;
4897     this.traversal = null;
4898     this.validate = null;
4899     this.variables = null;
4900     this.area = new XFAObjectArray();
4901     this.breakAfter = new XFAObjectArray();
4902     this.breakBefore = new XFAObjectArray();
4903     this.connect = new XFAObjectArray();
4904     this.draw = new XFAObjectArray();
4905     this.event = new XFAObjectArray();
4906     this.exObject = new XFAObjectArray();
4907     this.exclGroup = new XFAObjectArray();
4908     this.field = new XFAObjectArray();
4909     this.proto = new XFAObjectArray();
4910     this.setProperty = new XFAObjectArray();
4911     this.subform = new XFAObjectArray();
4912     this.subformSet = new XFAObjectArray();
4913   }
4914 
4915   [$getSubformParent]() {
4916     const parent = this[$getParent]();
4917     if (parent instanceof SubformSet) {
4918       return parent[$getSubformParent]();
4919     }
4920     return parent;
4921   }
4922 
4923   [$isBindable]() {
4924     return true;
4925   }
4926 
4927   [$isThereMoreWidth]() {
4928     return (
4929       (this.layout.endsWith("-tb") &&
4930         this[$extra].attempt === 0 &&
4931         this[$extra].numberInLine > 0) ||
4932       this[$getParent]()[$isThereMoreWidth]()
4933     );
4934   }
4935 
4936   *[$getContainedChildren]() {
4937     // This function is overriden in order to fake that subforms under
4938     // this set are in fact under parent subform.
4939     yield* getContainedChildren(this);
4940   }
4941 
4942   [$flushHTML]() {
4943     return flushHTML(this);
4944   }
4945 
4946   [$addHTML](html, bbox) {
4947     addHTML(this, html, bbox);
4948   }
4949 
4950   [$getAvailableSpace]() {
4951     return getAvailableSpace(this);
4952   }
4953 
4954   [$isSplittable]() {
4955     // We cannot cache the result here because the contentArea
4956     // can change.
4957     const parent = this[$getSubformParent]();
4958     if (!parent[$isSplittable]()) {
4959       return false;
4960     }
4961 
4962     if (this[$extra]._isSplittable !== undefined) {
4963       return this[$extra]._isSplittable;
4964     }
4965 
4966     if (this.layout === "position" || this.layout.includes("row")) {
4967       this[$extra]._isSplittable = false;
4968       return false;
4969     }
4970 
4971     if (this.keep && this.keep.intact !== "none") {
4972       this[$extra]._isSplittable = false;
4973       return false;
4974     }
4975 
4976     if (parent.layout?.endsWith("-tb") && parent[$extra].numberInLine !== 0) {
4977       // If parent can fit in w=100 and there's already an element which takes
4978       // 90 then we've 10 for this element. Suppose this element has a tb layout
4979       // and 5 elements have a width of 7 and the 6th has a width of 20:
4980       // then this element (and all its content) must move on the next line.
4981       // If this element is splittable then the first 5 children will stay
4982       // at the end of the line: we don't want that.
4983       return false;
4984     }
4985 
4986     this[$extra]._isSplittable = true;
4987 
4988     return true;
4989   }
4990 
4991   [$toHTML](availableSpace) {
4992     setTabIndex(this);
4993 
4994     if (this.break) {
4995       // break element is deprecated so plug it on one of its replacement
4996       // breakBefore or breakAfter.
4997       if (this.break.after !== "auto" || this.break.afterTarget !== "") {
4998         const node = new BreakAfter({
4999           targetType: this.break.after,
5000           target: this.break.afterTarget,
5001           startNew: this.break.startNew.toString(),
5002         });
5003         node[$globalData] = this[$globalData];
5004         this[$appendChild](node);
5005         this.breakAfter.push(node);
5006       }
5007 
5008       if (this.break.before !== "auto" || this.break.beforeTarget !== "") {
5009         const node = new BreakBefore({
5010           targetType: this.break.before,
5011           target: this.break.beforeTarget,
5012           startNew: this.break.startNew.toString(),
5013         });
5014         node[$globalData] = this[$globalData];
5015         this[$appendChild](node);
5016         this.breakBefore.push(node);
5017       }
5018 
5019       if (this.break.overflowTarget !== "") {
5020         const node = new Overflow({
5021           target: this.break.overflowTarget,
5022           leader: this.break.overflowLeader,
5023           trailer: this.break.overflowTrailer,
5024         });
5025         node[$globalData] = this[$globalData];
5026         this[$appendChild](node);
5027         this.overflow.push(node);
5028       }
5029 
5030       this[$removeChild](this.break);
5031       this.break = null;
5032     }
5033 
5034     if (this.presence === "hidden" || this.presence === "inactive") {
5035       return HTMLResult.EMPTY;
5036     }
5037 
5038     if (
5039       this.breakBefore.children.length > 1 ||
5040       this.breakAfter.children.length > 1
5041     ) {
5042       // Specs are always talking about the breakBefore element
5043       // and it doesn't really make sense to have several ones.
5044       warn(
5045         "XFA - Several breakBefore or breakAfter in subforms: please file a bug."
5046       );
5047     }
5048 
5049     if (this.breakBefore.children.length >= 1) {
5050       const breakBefore = this.breakBefore.children[0];
5051       if (handleBreak(breakBefore)) {
5052         return HTMLResult.breakNode(breakBefore);
5053       }
5054     }
5055 
5056     if (this[$extra]?.afterBreakAfter) {
5057       return HTMLResult.EMPTY;
5058     }
5059 
5060     // TODO: incomplete.
5061     fixDimensions(this);
5062     const children = [];
5063     const attributes = {
5064       id: this[$uid],
5065       class: [],
5066     };
5067 
5068     setAccess(this, attributes.class);
5069 
5070     if (!this[$extra]) {
5071       this[$extra] = Object.create(null);
5072     }
5073 
5074     Object.assign(this[$extra], {
5075       children,
5076       line: null,
5077       attributes,
5078       attempt: 0,
5079       numberInLine: 0,
5080       availableSpace: {
5081         width: Math.min(this.w || Infinity, availableSpace.width),
5082         height: Math.min(this.h || Infinity, availableSpace.height),
5083       },
5084       width: 0,
5085       height: 0,
5086       prevHeight: 0,
5087       currentWidth: 0,
5088     });
5089 
5090     const root = this[$getTemplateRoot]();
5091     const savedNoLayoutFailure = root[$extra].noLayoutFailure;
5092 
5093     const isSplittable = this[$isSplittable]();
5094     if (!isSplittable) {
5095       setFirstUnsplittable(this);
5096     }
5097 
5098     if (!checkDimensions(this, availableSpace)) {
5099       return HTMLResult.FAILURE;
5100     }
5101 
5102     const filter = new Set([
5103       "area",
5104       "draw",
5105       "exclGroup",
5106       "field",
5107       "subform",
5108       "subformSet",
5109     ]);
5110 
5111     if (this.layout.includes("row")) {
5112       const columnWidths = this[$getSubformParent]().columnWidths;
5113       if (Array.isArray(columnWidths) && columnWidths.length > 0) {
5114         this[$extra].columnWidths = columnWidths;
5115         this[$extra].currentColumn = 0;
5116       }
5117     }
5118 
5119     const style = toStyle(
5120       this,
5121       "anchorType",
5122       "dimensions",
5123       "position",
5124       "presence",
5125       "border",
5126       "margin",
5127       "hAlign"
5128     );
5129     const classNames = ["xfaSubform"];
5130     const cl = layoutClass(this);
5131     if (cl) {
5132       classNames.push(cl);
5133     }
5134 
5135     attributes.style = style;
5136     attributes.class = classNames;
5137 
5138     if (this.name) {
5139       attributes.xfaName = this.name;
5140     }
5141 
5142     if (this.overflow) {
5143       const overflowExtra = this.overflow[$getExtra]();
5144       if (overflowExtra.addLeader) {
5145         overflowExtra.addLeader = false;
5146         handleOverflow(this, overflowExtra.leader, availableSpace);
5147       }
5148     }
5149 
5150     this[$pushPara]();
5151     const isLrTb = this.layout === "lr-tb" || this.layout === "rl-tb";
5152     const maxRun = isLrTb ? MAX_ATTEMPTS_FOR_LRTB_LAYOUT : 1;
5153     for (; this[$extra].attempt < maxRun; this[$extra].attempt++) {
5154       if (isLrTb && this[$extra].attempt === MAX_ATTEMPTS_FOR_LRTB_LAYOUT - 1) {
5155         // If the layout is lr-tb then having attempt equals to
5156         // MAX_ATTEMPTS_FOR_LRTB_LAYOUT-1 means that we're trying to layout
5157         // on the next line so this on is empty.
5158         this[$extra].numberInLine = 0;
5159       }
5160       const result = this[$childrenToHTML]({
5161         filter,
5162         include: true,
5163       });
5164       if (result.success) {
5165         break;
5166       }
5167       if (result.isBreak()) {
5168         this[$popPara]();
5169         return result;
5170       }
5171       if (
5172         isLrTb &&
5173         this[$extra].attempt === 0 &&
5174         this[$extra].numberInLine === 0 &&
5175         !root[$extra].noLayoutFailure
5176       ) {
5177         // We're failing to put the first element on the line so no
5178         // need to test on the next line.
5179         // The goal is not only to avoid some useless checks but to avoid
5180         // bugs too: if a descendant managed to put a node and failed
5181         // on the next one, going to the next step here will imply to
5182         // visit the descendant again, clear [$extra].children and restart
5183         // on the failing node, consequently the first node just disappears
5184         // because it has never been flushed.
5185         this[$extra].attempt = maxRun;
5186         break;
5187       }
5188     }
5189 
5190     this[$popPara]();
5191     if (!isSplittable) {
5192       unsetFirstUnsplittable(this);
5193     }
5194     root[$extra].noLayoutFailure = savedNoLayoutFailure;
5195 
5196     if (this[$extra].attempt === maxRun) {
5197       if (this.overflow) {
5198         this[$getTemplateRoot]()[$extra].overflowNode = this.overflow;
5199       }
5200 
5201       if (!isSplittable) {
5202         // Since a new try will happen in a new container with maybe
5203         // new dimensions, we invalidate already layed out components.
5204         delete this[$extra];
5205       }
5206       return HTMLResult.FAILURE;
5207     }
5208 
5209     if (this.overflow) {
5210       const overflowExtra = this.overflow[$getExtra]();
5211       if (overflowExtra.addTrailer) {
5212         overflowExtra.addTrailer = false;
5213         handleOverflow(this, overflowExtra.trailer, availableSpace);
5214       }
5215     }
5216 
5217     let marginH = 0;
5218     let marginV = 0;
5219     if (this.margin) {
5220       marginH = this.margin.leftInset + this.margin.rightInset;
5221       marginV = this.margin.topInset + this.margin.bottomInset;
5222     }
5223 
5224     const width = Math.max(this[$extra].width + marginH, this.w || 0);
5225     const height = Math.max(this[$extra].height + marginV, this.h || 0);
5226     const bbox = [this.x, this.y, width, height];
5227 
5228     if (this.w === "") {
5229       style.width = measureToString(width);
5230     }
5231     if (this.h === "") {
5232       style.height = measureToString(height);
5233     }
5234 
5235     if (
5236       (style.width === "0px" || style.height === "0px") &&
5237       children.length === 0
5238     ) {
5239       return HTMLResult.EMPTY;
5240     }
5241 
5242     const html = {
5243       name: "div",
5244       attributes,
5245       children,
5246     };
5247 
5248     applyAssist(this, attributes);
5249 
5250     const result = HTMLResult.success(createWrapper(this, html), bbox);
5251 
5252     if (this.breakAfter.children.length >= 1) {
5253       const breakAfter = this.breakAfter.children[0];
5254       if (handleBreak(breakAfter)) {
5255         this[$extra].afterBreakAfter = result;
5256         return HTMLResult.breakNode(breakAfter);
5257       }
5258     }
5259 
5260     delete this[$extra];
5261 
5262     return result;
5263   }
5264 }
5265 
5266 class SubformSet extends XFAObject {
5267   constructor(attributes) {
5268     super(TEMPLATE_NS_ID, "subformSet", /* hasChildren = */ true);
5269     this.id = attributes.id || "";
5270     this.name = attributes.name || "";
5271     this.relation = getStringOption(attributes.relation, [
5272       "ordered",
5273       "choice",
5274       "unordered",
5275     ]);
5276     this.relevant = getRelevant(attributes.relevant);
5277     this.use = attributes.use || "";
5278     this.usehref = attributes.usehref || "";
5279     this.bookend = null;
5280     this.break = null;
5281     this.desc = null;
5282     this.extras = null;
5283     this.occur = null;
5284     this.overflow = null;
5285     this.breakAfter = new XFAObjectArray();
5286     this.breakBefore = new XFAObjectArray();
5287     this.subform = new XFAObjectArray();
5288     this.subformSet = new XFAObjectArray();
5289 
5290     // TODO: need to handle break stuff and relation.
5291   }
5292 
5293   *[$getContainedChildren]() {
5294     // This function is overriden in order to fake that subforms under
5295     // this set are in fact under parent subform.
5296     yield* getContainedChildren(this);
5297   }
5298 
5299   [$getSubformParent]() {
5300     let parent = this[$getParent]();
5301     while (!(parent instanceof Subform)) {
5302       parent = parent[$getParent]();
5303     }
5304     return parent;
5305   }
5306 
5307   [$isBindable]() {
5308     return true;
5309   }
5310 }
5311 
5312 class SubjectDN extends ContentObject {
5313   constructor(attributes) {
5314     super(TEMPLATE_NS_ID, "subjectDN");
5315     this.delimiter = attributes.delimiter || ",";
5316     this.id = attributes.id || "";
5317     this.name = attributes.name || "";
5318     this.use = attributes.use || "";
5319     this.usehref = attributes.usehref || "";
5320   }
5321 
5322   [$finalize]() {
5323     this[$content] = new Map(
5324       this[$content].split(this.delimiter).map(kv => {
5325         kv = kv.split("=", 2);
5326         kv[0] = kv[0].trim();
5327         return kv;
5328       })
5329     );
5330   }
5331 }
5332 
5333 class SubjectDNs extends XFAObject {
5334   constructor(attributes) {
5335     super(TEMPLATE_NS_ID, "subjectDNs", /* hasChildren = */ true);
5336     this.id = attributes.id || "";
5337     this.type = getStringOption(attributes.type, ["optional", "required"]);
5338     this.use = attributes.use || "";
5339     this.usehref = attributes.usehref || "";
5340     this.subjectDN = new XFAObjectArray();
5341   }
5342 }
5343 
5344 class Submit extends XFAObject {
5345   constructor(attributes) {
5346     super(TEMPLATE_NS_ID, "submit", /* hasChildren = */ true);
5347     this.embedPDF = getInteger({
5348       data: attributes.embedPDF,
5349       defaultValue: 0,
5350       validate: x => x === 1,
5351     });
5352     this.format = getStringOption(attributes.format, [
5353       "xdp",
5354       "formdata",
5355       "pdf",
5356       "urlencoded",
5357       "xfd",
5358       "xml",
5359     ]);
5360     this.id = attributes.id || "";
5361     this.target = attributes.target || "";
5362     this.textEncoding = getKeyword({
5363       data: attributes.textEncoding
5364         ? attributes.textEncoding.toLowerCase()
5365         : "",
5366       defaultValue: "",
5367       validate: k =>
5368         [
5369           "utf-8",
5370           "big-five",
5371           "fontspecific",
5372           "gbk",
5373           "gb-18030",
5374           "gb-2312",
5375           "ksc-5601",
5376           "none",
5377           "shift-jis",
5378           "ucs-2",
5379           "utf-16",
5380         ].includes(k) || k.match(/iso-8859-\d{2}/),
5381     });
5382     this.use = attributes.use || "";
5383     this.usehref = attributes.usehref || "";
5384     this.xdpContent = attributes.xdpContent || "";
5385     this.encrypt = null;
5386     this.encryptData = new XFAObjectArray();
5387     this.signData = new XFAObjectArray();
5388   }
5389 }
5390 
5391 class Template extends XFAObject {
5392   constructor(attributes) {
5393     super(TEMPLATE_NS_ID, "template", /* hasChildren = */ true);
5394     this.baseProfile = getStringOption(attributes.baseProfile, [
5395       "full",
5396       "interactiveForms",
5397     ]);
5398     this.extras = null;
5399 
5400     // Spec is unclear:
5401     //  A container element that describes a single subform capable of
5402     //  enclosing other containers.
5403     // Can we have more than one subform ?
5404     this.subform = new XFAObjectArray();
5405   }
5406 
5407   [$finalize]() {
5408     if (this.subform.children.length === 0) {
5409       warn("XFA - No subforms in template node.");
5410     }
5411     if (this.subform.children.length >= 2) {
5412       warn("XFA - Several subforms in template node: please file a bug.");
5413     }
5414     this[$tabIndex] = DEFAULT_TAB_INDEX;
5415   }
5416 
5417   [$isSplittable]() {
5418     return true;
5419   }
5420 
5421   [$searchNode](expr, container) {
5422     if (expr.startsWith("#")) {
5423       // This is an id.
5424       return [this[$ids].get(expr.slice(1))];
5425     }
5426     return searchNode(this, container, expr, true, true);
5427   }
5428 
5429   /**
5430    * This function is a generator because the conversion into
5431    * pages is done asynchronously and we want to save the state
5432    * of the function where we were in the previous iteration.
5433    */
5434   *[$toPages]() {
5435     if (!this.subform.children.length) {
5436       return HTMLResult.success({
5437         name: "div",
5438         children: [],
5439       });
5440     }
5441     this[$extra] = {
5442       overflowNode: null,
5443       firstUnsplittable: null,
5444       currentContentArea: null,
5445       currentPageArea: null,
5446       noLayoutFailure: false,
5447       pageNumber: 1,
5448       pagePosition: "first",
5449       oddOrEven: "odd",
5450       blankOrNotBlank: "nonBlank",
5451       paraStack: [],
5452     };
5453 
5454     const root = this.subform.children[0];
5455     root.pageSet[$cleanPage]();
5456 
5457     const pageAreas = root.pageSet.pageArea.children;
5458     const mainHtml = {
5459       name: "div",
5460       children: [],
5461     };
5462 
5463     let pageArea = null;
5464     let breakBefore = null;
5465     let breakBeforeTarget = null;
5466     if (root.breakBefore.children.length >= 1) {
5467       breakBefore = root.breakBefore.children[0];
5468       breakBeforeTarget = breakBefore.target;
5469     } else if (
5470       root.subform.children.length >= 1 &&
5471       root.subform.children[0].breakBefore.children.length >= 1
5472     ) {
5473       breakBefore = root.subform.children[0].breakBefore.children[0];
5474       breakBeforeTarget = breakBefore.target;
5475     } else if (root.break?.beforeTarget) {
5476       breakBefore = root.break;
5477       breakBeforeTarget = breakBefore.beforeTarget;
5478     } else if (
5479       root.subform.children.length >= 1 &&
5480       root.subform.children[0].break?.beforeTarget
5481     ) {
5482       breakBefore = root.subform.children[0].break;
5483       breakBeforeTarget = breakBefore.beforeTarget;
5484     }
5485 
5486     if (breakBefore) {
5487       const target = this[$searchNode](
5488         breakBeforeTarget,
5489         breakBefore[$getParent]()
5490       );
5491       if (target instanceof PageArea) {
5492         pageArea = target;
5493         // Consume breakBefore.
5494         breakBefore[$extra] = {};
5495       }
5496     }
5497 
5498     if (!pageArea) {
5499       pageArea = pageAreas[0];
5500     }
5501 
5502     pageArea[$extra] = {
5503       numberOfUse: 1,
5504     };
5505 
5506     const pageAreaParent = pageArea[$getParent]();
5507     pageAreaParent[$extra] = {
5508       numberOfUse: 1,
5509       pageIndex: pageAreaParent.pageArea.children.indexOf(pageArea),
5510       pageSetIndex: 0,
5511     };
5512 
5513     let targetPageArea;
5514     let leader = null;
5515     let trailer = null;
5516     let hasSomething = true;
5517     let hasSomethingCounter = 0;
5518     let startIndex = 0;
5519 
5520     while (true) {
5521       if (!hasSomething) {
5522         mainHtml.children.pop();
5523         // Nothing has been added in the previous page
5524         if (++hasSomethingCounter === MAX_EMPTY_PAGES) {
5525           warn("XFA - Something goes wrong: please file a bug.");
5526           return mainHtml;
5527         }
5528       } else {
5529         hasSomethingCounter = 0;
5530       }
5531 
5532       targetPageArea = null;
5533       this[$extra].currentPageArea = pageArea;
5534       const page = pageArea[$toHTML]().html;
5535       mainHtml.children.push(page);
5536 
5537       if (leader) {
5538         this[$extra].noLayoutFailure = true;
5539         page.children.push(leader[$toHTML](pageArea[$extra].space).html);
5540         leader = null;
5541       }
5542 
5543       if (trailer) {
5544         this[$extra].noLayoutFailure = true;
5545         page.children.push(trailer[$toHTML](pageArea[$extra].space).html);
5546         trailer = null;
5547       }
5548 
5549       const contentAreas = pageArea.contentArea.children;
5550       const htmlContentAreas = page.children.filter(node =>
5551         node.attributes.class.includes("xfaContentarea")
5552       );
5553 
5554       hasSomething = false;
5555       this[$extra].firstUnsplittable = null;
5556       this[$extra].noLayoutFailure = false;
5557 
5558       const flush = index => {
5559         const html = root[$flushHTML]();
5560         if (html) {
5561           hasSomething ||= html.children?.length > 0;
5562           htmlContentAreas[index].children.push(html);
5563         }
5564       };
5565 
5566       for (let i = startIndex, ii = contentAreas.length; i < ii; i++) {
5567         const contentArea = (this[$extra].currentContentArea = contentAreas[i]);
5568         const space = { width: contentArea.w, height: contentArea.h };
5569         startIndex = 0;
5570 
5571         if (leader) {
5572           htmlContentAreas[i].children.push(leader[$toHTML](space).html);
5573           leader = null;
5574         }
5575 
5576         if (trailer) {
5577           htmlContentAreas[i].children.push(trailer[$toHTML](space).html);
5578           trailer = null;
5579         }
5580 
5581         const html = root[$toHTML](space);
5582         if (html.success) {
5583           if (html.html) {
5584             hasSomething ||= html.html.children?.length > 0;
5585             htmlContentAreas[i].children.push(html.html);
5586           } else if (!hasSomething && mainHtml.children.length > 1) {
5587             mainHtml.children.pop();
5588           }
5589           return mainHtml;
5590         }
5591 
5592         if (html.isBreak()) {
5593           const node = html.breakNode;
5594           flush(i);
5595 
5596           if (node.targetType === "auto") {
5597             continue;
5598           }
5599 
5600           if (node.leader) {
5601             leader = this[$searchNode](node.leader, node[$getParent]());
5602             leader = leader ? leader[0] : null;
5603           }
5604 
5605           if (node.trailer) {
5606             trailer = this[$searchNode](node.trailer, node[$getParent]());
5607             trailer = trailer ? trailer[0] : null;
5608           }
5609 
5610           if (node.targetType === "pageArea") {
5611             targetPageArea = node[$extra].target;
5612             i = Infinity;
5613           } else if (!node[$extra].target) {
5614             // We stay on the same page.
5615             i = node[$extra].index;
5616           } else {
5617             targetPageArea = node[$extra].target;
5618             startIndex = node[$extra].index + 1;
5619             i = Infinity;
5620           }
5621 
5622           continue;
5623         }
5624 
5625         if (this[$extra].overflowNode) {
5626           const node = this[$extra].overflowNode;
5627           this[$extra].overflowNode = null;
5628 
5629           const overflowExtra = node[$getExtra]();
5630           const target = overflowExtra.target;
5631           overflowExtra.addLeader = overflowExtra.leader !== null;
5632           overflowExtra.addTrailer = overflowExtra.trailer !== null;
5633 
5634           flush(i);
5635 
5636           const currentIndex = i;
5637 
5638           i = Infinity;
5639           if (target instanceof PageArea) {
5640             // We must stop the contentAreas filling and go to the next page.
5641             targetPageArea = target;
5642           } else if (target instanceof ContentArea) {
5643             const index = contentAreas.indexOf(target);
5644             if (index !== -1) {
5645               if (index > currentIndex) {
5646                 // In the next loop iteration `i` will be incremented, note the
5647                 // `continue` just below, hence we need to subtract one here.
5648                 i = index - 1;
5649               } else {
5650                 // The targetted contentArea has already been filled
5651                 // so create a new page.
5652                 startIndex = index;
5653               }
5654             } else {
5655               targetPageArea = target[$getParent]();
5656               startIndex = targetPageArea.contentArea.children.indexOf(target);
5657             }
5658           }
5659           continue;
5660         }
5661 
5662         flush(i);
5663       }
5664 
5665       this[$extra].pageNumber += 1;
5666       if (targetPageArea) {
5667         if (targetPageArea[$isUsable]()) {
5668           targetPageArea[$extra].numberOfUse += 1;
5669         } else {
5670           targetPageArea = null;
5671         }
5672       }
5673       pageArea = targetPageArea || pageArea[$getNextPage]();
5674       yield null;
5675     }
5676   }
5677 }
5678 
5679 class Text extends ContentObject {
5680   constructor(attributes) {
5681     super(TEMPLATE_NS_ID, "text");
5682     this.id = attributes.id || "";
5683     this.maxChars = getInteger({
5684       data: attributes.maxChars,
5685       defaultValue: 0,
5686       validate: x => x >= 0,
5687     });
5688     this.name = attributes.name || "";
5689     this.rid = attributes.rid || "";
5690     this.use = attributes.use || "";
5691     this.usehref = attributes.usehref || "";
5692   }
5693 
5694   [$acceptWhitespace]() {
5695     return true;
5696   }
5697 
5698   [$onChild](child) {
5699     if (child[$namespaceId] === NamespaceIds.xhtml.id) {
5700       this[$content] = child;
5701       return true;
5702     }
5703     warn(`XFA - Invalid content in Text: ${child[$nodeName]}.`);
5704     return false;
5705   }
5706 
5707   [$onText](str) {
5708     if (this[$content] instanceof XFAObject) {
5709       return;
5710     }
5711     super[$onText](str);
5712   }
5713 
5714   [$finalize]() {
5715     if (typeof this[$content] === "string") {
5716       this[$content] = this[$content].replaceAll("\r\n", "\n");
5717     }
5718   }
5719 
5720   [$getExtra]() {
5721     if (typeof this[$content] === "string") {
5722       return this[$content]
5723         .split(/[\u2029\u2028\n]/)
5724         .filter(line => !!line)
5725         .join("\n");
5726     }
5727     return this[$content][$text]();
5728   }
5729 
5730   [$toHTML](availableSpace) {
5731     if (typeof this[$content] === "string") {
5732       // \u2028 is a line separator.
5733       // \u2029 is a paragraph separator.
5734       const html = valueToHtml(this[$content]).html;
5735 
5736       if (this[$content].includes("\u2029")) {
5737         // We've plain text containing a paragraph separator
5738         // so convert it into a set of <p>.
5739         html.name = "div";
5740         html.children = [];
5741         this[$content]
5742           .split("\u2029")
5743           .map(para =>
5744             // Convert a paragraph into a set of <span> (for lines)
5745             // separated by <br>.
5746             para.split(/[\u2028\n]/).flatMap(line => [
5747               {
5748                 name: "span",
5749                 value: line,
5750               },
5751               {
5752                 name: "br",
5753               },
5754             ])
5755           )
5756           .forEach(lines => {
5757             html.children.push({
5758               name: "p",
5759               children: lines,
5760             });
5761           });
5762       } else if (/[\u2028\n]/.test(this[$content])) {
5763         html.name = "div";
5764         html.children = [];
5765         // Convert plain text into a set of <span> (for lines)
5766         // separated by <br>.
5767         this[$content].split(/[\u2028\n]/).forEach(line => {
5768           html.children.push(
5769             {
5770               name: "span",
5771               value: line,
5772             },
5773             {
5774               name: "br",
5775             }
5776           );
5777         });
5778       }
5779 
5780       return HTMLResult.success(html);
5781     }
5782 
5783     return this[$content][$toHTML](availableSpace);
5784   }
5785 }
5786 
5787 class TextEdit extends XFAObject {
5788   constructor(attributes) {
5789     super(TEMPLATE_NS_ID, "textEdit", /* hasChildren = */ true);
5790     this.allowRichText = getInteger({
5791       data: attributes.allowRichText,
5792       defaultValue: 0,
5793       validate: x => x === 1,
5794     });
5795     this.hScrollPolicy = getStringOption(attributes.hScrollPolicy, [
5796       "auto",
5797       "off",
5798       "on",
5799     ]);
5800     this.id = attributes.id || "";
5801     this.multiLine = getInteger({
5802       data: attributes.multiLine,
5803       defaultValue: "",
5804       validate: x => x === 0 || x === 1,
5805     });
5806     this.use = attributes.use || "";
5807     this.usehref = attributes.usehref || "";
5808     this.vScrollPolicy = getStringOption(attributes.vScrollPolicy, [
5809       "auto",
5810       "off",
5811       "on",
5812     ]);
5813     this.border = null;
5814     this.comb = null;
5815     this.extras = null;
5816     this.margin = null;
5817   }
5818 
5819   [$toHTML](availableSpace) {
5820     // TODO: incomplete.
5821     const style = toStyle(this, "border", "font", "margin");
5822     let html;
5823     const field = this[$getParent]()[$getParent]();
5824     if (this.multiLine === "") {
5825       this.multiLine = field instanceof Draw ? 1 : 0;
5826     }
5827     if (this.multiLine === 1) {
5828       html = {
5829         name: "textarea",
5830         attributes: {
5831           dataId: field[$data]?.[$uid] || field[$uid],
5832           fieldId: field[$uid],
5833           class: ["xfaTextfield"],
5834           style,
5835           "aria-label": ariaLabel(field),
5836           "aria-required": false,
5837         },
5838       };
5839     } else {
5840       html = {
5841         name: "input",
5842         attributes: {
5843           type: "text",
5844           dataId: field[$data]?.[$uid] || field[$uid],
5845           fieldId: field[$uid],
5846           class: ["xfaTextfield"],
5847           style,
5848           "aria-label": ariaLabel(field),
5849           "aria-required": false,
5850         },
5851       };
5852     }
5853 
5854     if (isRequired(field)) {
5855       html.attributes["aria-required"] = true;
5856       html.attributes.required = true;
5857     }
5858 
5859     return HTMLResult.success({
5860       name: "label",
5861       attributes: {
5862         class: ["xfaLabel"],
5863       },
5864       children: [html],
5865     });
5866   }
5867 }
5868 
5869 class Time extends StringObject {
5870   constructor(attributes) {
5871     super(TEMPLATE_NS_ID, "time");
5872     this.id = attributes.id || "";
5873     this.name = attributes.name || "";
5874     this.use = attributes.use || "";
5875     this.usehref = attributes.usehref || "";
5876   }
5877 
5878   [$finalize]() {
5879     // TODO: need to handle the string as a time and not as a date.
5880     const date = this[$content].trim();
5881     this[$content] = date ? new Date(date) : null;
5882   }
5883 
5884   [$toHTML](availableSpace) {
5885     return valueToHtml(this[$content] ? this[$content].toString() : "");
5886   }
5887 }
5888 
5889 class TimeStamp extends XFAObject {
5890   constructor(attributes) {
5891     super(TEMPLATE_NS_ID, "timeStamp");
5892     this.id = attributes.id || "";
5893     this.server = attributes.server || "";
5894     this.type = getStringOption(attributes.type, ["optional", "required"]);
5895     this.use = attributes.use || "";
5896     this.usehref = attributes.usehref || "";
5897   }
5898 }
5899 
5900 class ToolTip extends StringObject {
5901   constructor(attributes) {
5902     super(TEMPLATE_NS_ID, "toolTip");
5903     this.id = attributes.id || "";
5904     this.rid = attributes.rid || "";
5905     this.use = attributes.use || "";
5906     this.usehref = attributes.usehref || "";
5907   }
5908 }
5909 
5910 class Traversal extends XFAObject {
5911   constructor(attributes) {
5912     super(TEMPLATE_NS_ID, "traversal", /* hasChildren = */ true);
5913     this.id = attributes.id || "";
5914     this.use = attributes.use || "";
5915     this.usehref = attributes.usehref || "";
5916     this.extras = null;
5917     this.traverse = new XFAObjectArray();
5918   }
5919 }
5920 
5921 class Traverse extends XFAObject {
5922   constructor(attributes) {
5923     super(TEMPLATE_NS_ID, "traverse", /* hasChildren = */ true);
5924     this.id = attributes.id || "";
5925     this.operation = getStringOption(attributes.operation, [
5926       "next",
5927       "back",
5928       "down",
5929       "first",
5930       "left",
5931       "right",
5932       "up",
5933     ]);
5934     this.ref = attributes.ref || "";
5935     this.use = attributes.use || "";
5936     this.usehref = attributes.usehref || "";
5937     this.extras = null;
5938     this.script = null;
5939   }
5940 
5941   get name() {
5942     // SOM expression: see page 94
5943     return this.operation;
5944   }
5945 
5946   [$isTransparent]() {
5947     return false;
5948   }
5949 }
5950 
5951 class Ui extends XFAObject {
5952   constructor(attributes) {
5953     super(TEMPLATE_NS_ID, "ui", /* hasChildren = */ true);
5954     this.id = attributes.id || "";
5955     this.use = attributes.use || "";
5956     this.usehref = attributes.usehref || "";
5957     this.extras = null;
5958     this.picture = null;
5959 
5960     // One-of properties
5961     this.barcode = null;
5962     this.button = null;
5963     this.checkButton = null;
5964     this.choiceList = null;
5965     this.dateTimeEdit = null;
5966     this.defaultUi = null;
5967     this.imageEdit = null;
5968     this.numericEdit = null;
5969     this.passwordEdit = null;
5970     this.signature = null;
5971     this.textEdit = null;
5972   }
5973 
5974   [$getExtra]() {
5975     if (this[$extra] === undefined) {
5976       for (const name of Object.getOwnPropertyNames(this)) {
5977         if (name === "extras" || name === "picture") {
5978           continue;
5979         }
5980         const obj = this[name];
5981         if (!(obj instanceof XFAObject)) {
5982           continue;
5983         }
5984 
5985         this[$extra] = obj;
5986         return obj;
5987       }
5988       this[$extra] = null;
5989     }
5990     return this[$extra];
5991   }
5992 
5993   [$toHTML](availableSpace) {
5994     // TODO: picture.
5995     const obj = this[$getExtra]();
5996     if (obj) {
5997       return obj[$toHTML](availableSpace);
5998     }
5999     return HTMLResult.EMPTY;
6000   }
6001 }
6002 
6003 class Validate extends XFAObject {
6004   constructor(attributes) {
6005     super(TEMPLATE_NS_ID, "validate", /* hasChildren = */ true);
6006     this.formatTest = getStringOption(attributes.formatTest, [
6007       "warning",
6008       "disabled",
6009       "error",
6010     ]);
6011     this.id = attributes.id || "";
6012     this.nullTest = getStringOption(attributes.nullTest, [
6013       "disabled",
6014       "error",
6015       "warning",
6016     ]);
6017     this.scriptTest = getStringOption(attributes.scriptTest, [
6018       "error",
6019       "disabled",
6020       "warning",
6021     ]);
6022     this.use = attributes.use || "";
6023     this.usehref = attributes.usehref || "";
6024     this.extras = null;
6025     this.message = null;
6026     this.picture = null;
6027     this.script = null;
6028   }
6029 }
6030 
6031 class Value extends XFAObject {
6032   constructor(attributes) {
6033     super(TEMPLATE_NS_ID, "value", /* hasChildren = */ true);
6034     this.id = attributes.id || "";
6035     this.override = getInteger({
6036       data: attributes.override,
6037       defaultValue: 0,
6038       validate: x => x === 1,
6039     });
6040     this.relevant = getRelevant(attributes.relevant);
6041     this.use = attributes.use || "";
6042     this.usehref = attributes.usehref || "";
6043 
6044     // One-of properties
6045     this.arc = null;
6046     this.boolean = null;
6047     this.date = null;
6048     this.dateTime = null;
6049     this.decimal = null;
6050     this.exData = null;
6051     this.float = null;
6052     this.image = null;
6053     this.integer = null;
6054     this.line = null;
6055     this.rectangle = null;
6056     this.text = null;
6057     this.time = null;
6058   }
6059 
6060   [$setValue](value) {
6061     const parent = this[$getParent]();
6062     if (parent instanceof Field) {
6063       if (parent.ui?.imageEdit) {
6064         if (!this.image) {
6065           this.image = new Image({});
6066           this[$appendChild](this.image);
6067         }
6068         this.image[$content] = value[$content];
6069         return;
6070       }
6071     }
6072 
6073     const valueName = value[$nodeName];
6074     if (this[valueName] !== null) {
6075       this[valueName][$content] = value[$content];
6076       return;
6077     }
6078 
6079     // Reset all the properties.
6080     for (const name of Object.getOwnPropertyNames(this)) {
6081       const obj = this[name];
6082       if (obj instanceof XFAObject) {
6083         this[name] = null;
6084         this[$removeChild](obj);
6085       }
6086     }
6087 
6088     this[value[$nodeName]] = value;
6089     this[$appendChild](value);
6090   }
6091 
6092   [$text]() {
6093     if (this.exData) {
6094       if (typeof this.exData[$content] === "string") {
6095         return this.exData[$content].trim();
6096       }
6097       return this.exData[$content][$text]().trim();
6098     }
6099     for (const name of Object.getOwnPropertyNames(this)) {
6100       if (name === "image") {
6101         continue;
6102       }
6103       const obj = this[name];
6104       if (obj instanceof XFAObject) {
6105         return (obj[$content] || "").toString().trim();
6106       }
6107     }
6108     return null;
6109   }
6110 
6111   [$toHTML](availableSpace) {
6112     for (const name of Object.getOwnPropertyNames(this)) {
6113       const obj = this[name];
6114       if (!(obj instanceof XFAObject)) {
6115         continue;
6116       }
6117 
6118       return obj[$toHTML](availableSpace);
6119     }
6120 
6121     return HTMLResult.EMPTY;
6122   }
6123 }
6124 
6125 class Variables extends XFAObject {
6126   constructor(attributes) {
6127     super(TEMPLATE_NS_ID, "variables", /* hasChildren = */ true);
6128     this.id = attributes.id || "";
6129     this.use = attributes.use || "";
6130     this.usehref = attributes.usehref || "";
6131     this.boolean = new XFAObjectArray();
6132     this.date = new XFAObjectArray();
6133     this.dateTime = new XFAObjectArray();
6134     this.decimal = new XFAObjectArray();
6135     this.exData = new XFAObjectArray();
6136     this.float = new XFAObjectArray();
6137     this.image = new XFAObjectArray();
6138     this.integer = new XFAObjectArray();
6139     this.manifest = new XFAObjectArray();
6140     this.script = new XFAObjectArray();
6141     this.text = new XFAObjectArray();
6142     this.time = new XFAObjectArray();
6143   }
6144 
6145   [$isTransparent]() {
6146     return true;
6147   }
6148 }
6149 
6150 class TemplateNamespace {
6151   static [$buildXFAObject](name, attributes) {
6152     if (TemplateNamespace.hasOwnProperty(name)) {
6153       const node = TemplateNamespace[name](attributes);
6154       node[$setSetAttributes](attributes);
6155       return node;
6156     }
6157     return undefined;
6158   }
6159 
6160   static appearanceFilter(attrs) {
6161     return new AppearanceFilter(attrs);
6162   }
6163 
6164   static arc(attrs) {
6165     return new Arc(attrs);
6166   }
6167 
6168   static area(attrs) {
6169     return new Area(attrs);
6170   }
6171 
6172   static assist(attrs) {
6173     return new Assist(attrs);
6174   }
6175 
6176   static barcode(attrs) {
6177     return new Barcode(attrs);
6178   }
6179 
6180   static bind(attrs) {
6181     return new Bind(attrs);
6182   }
6183 
6184   static bindItems(attrs) {
6185     return new BindItems(attrs);
6186   }
6187 
6188   static bookend(attrs) {
6189     return new Bookend(attrs);
6190   }
6191 
6192   static boolean(attrs) {
6193     return new BooleanElement(attrs);
6194   }
6195 
6196   static border(attrs) {
6197     return new Border(attrs);
6198   }
6199 
6200   static break(attrs) {
6201     return new Break(attrs);
6202   }
6203 
6204   static breakAfter(attrs) {
6205     return new BreakAfter(attrs);
6206   }
6207 
6208   static breakBefore(attrs) {
6209     return new BreakBefore(attrs);
6210   }
6211 
6212   static button(attrs) {
6213     return new Button(attrs);
6214   }
6215 
6216   static calculate(attrs) {
6217     return new Calculate(attrs);
6218   }
6219 
6220   static caption(attrs) {
6221     return new Caption(attrs);
6222   }
6223 
6224   static certificate(attrs) {
6225     return new Certificate(attrs);
6226   }
6227 
6228   static certificates(attrs) {
6229     return new Certificates(attrs);
6230   }
6231 
6232   static checkButton(attrs) {
6233     return new CheckButton(attrs);
6234   }
6235 
6236   static choiceList(attrs) {
6237     return new ChoiceList(attrs);
6238   }
6239 
6240   static color(attrs) {
6241     return new Color(attrs);
6242   }
6243 
6244   static comb(attrs) {
6245     return new Comb(attrs);
6246   }
6247 
6248   static connect(attrs) {
6249     return new Connect(attrs);
6250   }
6251 
6252   static contentArea(attrs) {
6253     return new ContentArea(attrs);
6254   }
6255 
6256   static corner(attrs) {
6257     return new Corner(attrs);
6258   }
6259 
6260   static date(attrs) {
6261     return new DateElement(attrs);
6262   }
6263 
6264   static dateTime(attrs) {
6265     return new DateTime(attrs);
6266   }
6267 
6268   static dateTimeEdit(attrs) {
6269     return new DateTimeEdit(attrs);
6270   }
6271 
6272   static decimal(attrs) {
6273     return new Decimal(attrs);
6274   }
6275 
6276   static defaultUi(attrs) {
6277     return new DefaultUi(attrs);
6278   }
6279 
6280   static desc(attrs) {
6281     return new Desc(attrs);
6282   }
6283 
6284   static digestMethod(attrs) {
6285     return new DigestMethod(attrs);
6286   }
6287 
6288   static digestMethods(attrs) {
6289     return new DigestMethods(attrs);
6290   }
6291 
6292   static draw(attrs) {
6293     return new Draw(attrs);
6294   }
6295 
6296   static edge(attrs) {
6297     return new Edge(attrs);
6298   }
6299 
6300   static encoding(attrs) {
6301     return new Encoding(attrs);
6302   }
6303 
6304   static encodings(attrs) {
6305     return new Encodings(attrs);
6306   }
6307 
6308   static encrypt(attrs) {
6309     return new Encrypt(attrs);
6310   }
6311 
6312   static encryptData(attrs) {
6313     return new EncryptData(attrs);
6314   }
6315 
6316   static encryption(attrs) {
6317     return new Encryption(attrs);
6318   }
6319 
6320   static encryptionMethod(attrs) {
6321     return new EncryptionMethod(attrs);
6322   }
6323 
6324   static encryptionMethods(attrs) {
6325     return new EncryptionMethods(attrs);
6326   }
6327 
6328   static event(attrs) {
6329     return new Event(attrs);
6330   }
6331 
6332   static exData(attrs) {
6333     return new ExData(attrs);
6334   }
6335 
6336   static exObject(attrs) {
6337     return new ExObject(attrs);
6338   }
6339 
6340   static exclGroup(attrs) {
6341     return new ExclGroup(attrs);
6342   }
6343 
6344   static execute(attrs) {
6345     return new Execute(attrs);
6346   }
6347 
6348   static extras(attrs) {
6349     return new Extras(attrs);
6350   }
6351 
6352   static field(attrs) {
6353     return new Field(attrs);
6354   }
6355 
6356   static fill(attrs) {
6357     return new Fill(attrs);
6358   }
6359 
6360   static filter(attrs) {
6361     return new Filter(attrs);
6362   }
6363 
6364   static float(attrs) {
6365     return new Float(attrs);
6366   }
6367 
6368   static font(attrs) {
6369     return new Font(attrs);
6370   }
6371 
6372   static format(attrs) {
6373     return new Format(attrs);
6374   }
6375 
6376   static handler(attrs) {
6377     return new Handler(attrs);
6378   }
6379 
6380   static hyphenation(attrs) {
6381     return new Hyphenation(attrs);
6382   }
6383 
6384   static image(attrs) {
6385     return new Image(attrs);
6386   }
6387 
6388   static imageEdit(attrs) {
6389     return new ImageEdit(attrs);
6390   }
6391 
6392   static integer(attrs) {
6393     return new Integer(attrs);
6394   }
6395 
6396   static issuers(attrs) {
6397     return new Issuers(attrs);
6398   }
6399 
6400   static items(attrs) {
6401     return new Items(attrs);
6402   }
6403 
6404   static keep(attrs) {
6405     return new Keep(attrs);
6406   }
6407 
6408   static keyUsage(attrs) {
6409     return new KeyUsage(attrs);
6410   }
6411 
6412   static line(attrs) {
6413     return new Line(attrs);
6414   }
6415 
6416   static linear(attrs) {
6417     return new Linear(attrs);
6418   }
6419 
6420   static lockDocument(attrs) {
6421     return new LockDocument(attrs);
6422   }
6423 
6424   static manifest(attrs) {
6425     return new Manifest(attrs);
6426   }
6427 
6428   static margin(attrs) {
6429     return new Margin(attrs);
6430   }
6431 
6432   static mdp(attrs) {
6433     return new Mdp(attrs);
6434   }
6435 
6436   static medium(attrs) {
6437     return new Medium(attrs);
6438   }
6439 
6440   static message(attrs) {
6441     return new Message(attrs);
6442   }
6443 
6444   static numericEdit(attrs) {
6445     return new NumericEdit(attrs);
6446   }
6447 
6448   static occur(attrs) {
6449     return new Occur(attrs);
6450   }
6451 
6452   static oid(attrs) {
6453     return new Oid(attrs);
6454   }
6455 
6456   static oids(attrs) {
6457     return new Oids(attrs);
6458   }
6459 
6460   static overflow(attrs) {
6461     return new Overflow(attrs);
6462   }
6463 
6464   static pageArea(attrs) {
6465     return new PageArea(attrs);
6466   }
6467 
6468   static pageSet(attrs) {
6469     return new PageSet(attrs);
6470   }
6471 
6472   static para(attrs) {
6473     return new Para(attrs);
6474   }
6475 
6476   static passwordEdit(attrs) {
6477     return new PasswordEdit(attrs);
6478   }
6479 
6480   static pattern(attrs) {
6481     return new Pattern(attrs);
6482   }
6483 
6484   static picture(attrs) {
6485     return new Picture(attrs);
6486   }
6487 
6488   static proto(attrs) {
6489     return new Proto(attrs);
6490   }
6491 
6492   static radial(attrs) {
6493     return new Radial(attrs);
6494   }
6495 
6496   static reason(attrs) {
6497     return new Reason(attrs);
6498   }
6499 
6500   static reasons(attrs) {
6501     return new Reasons(attrs);
6502   }
6503 
6504   static rectangle(attrs) {
6505     return new Rectangle(attrs);
6506   }
6507 
6508   static ref(attrs) {
6509     return new RefElement(attrs);
6510   }
6511 
6512   static script(attrs) {
6513     return new Script(attrs);
6514   }
6515 
6516   static setProperty(attrs) {
6517     return new SetProperty(attrs);
6518   }
6519 
6520   static signData(attrs) {
6521     return new SignData(attrs);
6522   }
6523 
6524   static signature(attrs) {
6525     return new Signature(attrs);
6526   }
6527 
6528   static signing(attrs) {
6529     return new Signing(attrs);
6530   }
6531 
6532   static solid(attrs) {
6533     return new Solid(attrs);
6534   }
6535 
6536   static speak(attrs) {
6537     return new Speak(attrs);
6538   }
6539 
6540   static stipple(attrs) {
6541     return new Stipple(attrs);
6542   }
6543 
6544   static subform(attrs) {
6545     return new Subform(attrs);
6546   }
6547 
6548   static subformSet(attrs) {
6549     return new SubformSet(attrs);
6550   }
6551 
6552   static subjectDN(attrs) {
6553     return new SubjectDN(attrs);
6554   }
6555 
6556   static subjectDNs(attrs) {
6557     return new SubjectDNs(attrs);
6558   }
6559 
6560   static submit(attrs) {
6561     return new Submit(attrs);
6562   }
6563 
6564   static template(attrs) {
6565     return new Template(attrs);
6566   }
6567 
6568   static text(attrs) {
6569     return new Text(attrs);
6570   }
6571 
6572   static textEdit(attrs) {
6573     return new TextEdit(attrs);
6574   }
6575 
6576   static time(attrs) {
6577     return new Time(attrs);
6578   }
6579 
6580   static timeStamp(attrs) {
6581     return new TimeStamp(attrs);
6582   }
6583 
6584   static toolTip(attrs) {
6585     return new ToolTip(attrs);
6586   }
6587 
6588   static traversal(attrs) {
6589     return new Traversal(attrs);
6590   }
6591 
6592   static traverse(attrs) {
6593     return new Traverse(attrs);
6594   }
6595 
6596   static ui(attrs) {
6597     return new Ui(attrs);
6598   }
6599 
6600   static validate(attrs) {
6601     return new Validate(attrs);
6602   }
6603 
6604   static value(attrs) {
6605     return new Value(attrs);
6606   }
6607 
6608   static variables(attrs) {
6609     return new Variables(attrs);
6610   }
6611 }
6612 
6613 export {
6614   BindItems,
6615   Field,
6616   Items,
6617   SetProperty,
6618   Template,
6619   TemplateNamespace,
6620   Text,
6621   Value,
6622 };
</code>

Test file:
<test_file>
File:
test/unit/xfa_parser_spec.js
/* Copyright 2020 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  $dump,
  $getChildren,
  $getChildrenByClass,
  $getChildrenByName,
  $text,
} from "../../src/core/xfa/symbol_utils.js";
import { Binder } from "../../src/core/xfa/bind.js";
import { searchNode } from "../../src/core/xfa/som.js";
import { XFAParser } from "../../src/core/xfa/parser.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

