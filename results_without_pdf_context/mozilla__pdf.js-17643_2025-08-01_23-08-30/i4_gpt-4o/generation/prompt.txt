Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Free Highlight element has its tooltip incorrectly displayed in rotated PDF
</issue>

Patch:
<patch>
diff --git a/src/display/editor/highlight.js b/src/display/editor/highlight.js
--- a/src/display/editor/highlight.js
+++ b/src/display/editor/highlight.js
@@ -169,11 +169,9 @@ class HighlightEditor extends AnnotationEditor {
         break;
       }
     }
+
     const { lastPoint } = this.#focusOutlines.box;
-    this.#lastPoint = [
-      (lastPoint[0] - this.x) / this.width,
-      (lastPoint[1] - this.y) / this.height,
-    ];
+    this.#lastPoint = [(lastPoint[0] - x) / width, (lastPoint[1] - y) / height];
   }
 
   /** @inheritdoc */


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.23.9
- @babel/preset-env: ^7.23.9
- @babel/runtime: ^7.23.9
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.9.0
- @jazzer.js/core: ^2.1.0
- autoprefixer: ^10.4.17
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001580
- canvas: ^2.11.2
- core-js: ^3.35.1
- cross-env: ^7.0.3
- eslint: ^8.56.0
- eslint-config-prettier: ^8.10.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.29.1
- eslint-plugin-jasmine: ^4.1.3
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.3.2
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.1.3
- eslint-plugin-sort-exports: ^0.9.1
- eslint-plugin-unicorn: ^50.0.1
- globals: ^13.24.0
- gulp: ^4.0.2
- gulp-cli: ^2.3.0
- gulp-postcss: ^9.1.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.3.1
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.33
- postcss-dark-theme-class: ^1.1.0
- postcss-dir-pseudo-class: ^8.0.1
- postcss-discard-comments: ^6.0.1
- postcss-nesting: ^12.0.2
- prettier: ^3.2.4
- puppeteer: ^21.9.0
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^16.2.0
- stylelint-prettier: ^5.0.0
- terser: ^5.27.0
- through2: ^4.0.2
- tsc-alias: ^1.8.8
- ttest: ^4.0.0
- typescript: ^5.3.3
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.90.0
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/outliner.js`: Outliner
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/display/editor/highlight.js
1 /* Copyright 2022 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AnnotationEditorParamsType,
18   AnnotationEditorType,
19   Util,
20 } from "../../shared/util.js";
21 import { FreeOutliner, Outliner } from "./outliner.js";
22 import { AnnotationEditor } from "./editor.js";
23 import { bindEvents } from "./tools.js";
24 import { ColorPicker } from "./color_picker.js";
25 import { noContextMenu } from "../display_utils.js";
26 
27 /**
28  * Basic draw editor in order to generate an Highlight annotation.
29  */
30 class HighlightEditor extends AnnotationEditor {
31   #boxes;
32 
33   #clipPathId = null;
34 
35   #colorPicker = null;
36 
37   #focusOutlines = null;
38 
39   #highlightDiv = null;
40 
41   #highlightOutlines = null;
42 
43   #id = null;
44 
45   #isFreeHighlight = false;
46 
47   #lastPoint = null;
48 
49   #opacity;
50 
51   #outlineId = null;
52 
53   #thickness;
54 
55   static _defaultColor = null;
56 
57   static _defaultOpacity = 1;
58 
59   static _defaultThickness = 12;
60 
61   static _l10nPromise;
62 
63   static _type = "highlight";
64 
65   static _editorType = AnnotationEditorType.HIGHLIGHT;
66 
67   static _freeHighlightId = -1;
68 
69   static _freeHighlight = null;
70 
71   static _freeHighlightClipId = "";
72 
73   constructor(params) {
74     super({ ...params, name: "highlightEditor" });
75     this.color = params.color || HighlightEditor._defaultColor;
76     this.#thickness = params.thickness || HighlightEditor._defaultThickness;
77     this.#opacity = params.opacity || HighlightEditor._defaultOpacity;
78     this.#boxes = params.boxes || null;
79     this._isDraggable = false;
80 
81     if (params.highlightId > -1) {
82       this.#isFreeHighlight = true;
83       this.#createFreeOutlines(params);
84       this.#addToDrawLayer();
85     } else {
86       this.#createOutlines();
87       this.#addToDrawLayer();
88       this.rotate(this.rotation);
89     }
90   }
91 
92   #createOutlines() {
93     const outliner = new Outliner(this.#boxes, /* borderWidth = */ 0.001);
94     this.#highlightOutlines = outliner.getOutlines();
95     ({
96       x: this.x,
97       y: this.y,
98       width: this.width,
99       height: this.height,
100     } = this.#highlightOutlines.box);
101 
102     const outlinerForOutline = new Outliner(
103       this.#boxes,
104       /* borderWidth = */ 0.0025,
105       /* innerMargin = */ 0.001,
106       this._uiManager.direction === "ltr"
107     );
108     this.#focusOutlines = outlinerForOutline.getOutlines();
109 
110     // The last point is in the pages coordinate system.
111     const { lastPoint } = this.#focusOutlines.box;
112     this.#lastPoint = [
113       (lastPoint[0] - this.x) / this.width,
114       (lastPoint[1] - this.y) / this.height,
115     ];
116   }
117 
118   #createFreeOutlines({ highlightOutlines, highlightId, clipPathId }) {
119     this.#highlightOutlines = highlightOutlines;
120     const extraThickness = 1.5;
121     this.#focusOutlines = highlightOutlines.getNewOutline(
122       /* Slightly bigger than the highlight in order to have a little
123          space between the highlight and the outline. */
124       this.#thickness / 2 + extraThickness,
125       /* innerMargin = */ 0.0025
126     );
127 
128     if (highlightId >= 0) {
129       this.#id = highlightId;
130       this.#clipPathId = clipPathId;
131       // We need to redraw the highlight because we change the coordinates to be
132       // in the box coordinate system.
133       this.parent.drawLayer.finalizeLine(highlightId, highlightOutlines);
134       this.#outlineId = this.parent.drawLayer.highlightOutline(
135         this.#focusOutlines
136       );
137     } else if (this.parent) {
138       this.parent.drawLayer.updateLine(this.#id, highlightOutlines);
139       this.parent.drawLayer.updateLine(this.#outlineId, this.#focusOutlines);
140     }
141     const { x, y, width, height } = highlightOutlines.box;
142     switch (this.rotation) {
143       case 0:
144         this.x = x;
145         this.y = y;
146         this.width = width;
147         this.height = height;
148         break;
149       case 90: {
150         const [pageWidth, pageHeight] = this.parentDimensions;
151         this.x = y;
152         this.y = 1 - x;
153         this.width = (width * pageHeight) / pageWidth;
154         this.height = (height * pageWidth) / pageHeight;
155         break;
156       }
157       case 180:
158         this.x = 1 - x;
159         this.y = 1 - y;
160         this.width = width;
161         this.height = height;
162         break;
163       case 270: {
164         const [pageWidth, pageHeight] = this.parentDimensions;
165         this.x = 1 - y;
166         this.y = x;
167         this.width = (width * pageHeight) / pageWidth;
168         this.height = (height * pageWidth) / pageHeight;
169         break;
170       }
171     }
172     const { lastPoint } = this.#focusOutlines.box;
173     this.#lastPoint = [
174       (lastPoint[0] - this.x) / this.width,
175       (lastPoint[1] - this.y) / this.height,
176     ];
177   }
178 
179   /** @inheritdoc */
180   static initialize(l10n, uiManager) {
181     AnnotationEditor.initialize(l10n, uiManager);
182     HighlightEditor._defaultColor ||=
183       uiManager.highlightColors?.values().next().value || "#fff066";
184   }
185 
186   /** @inheritdoc */
187   static updateDefaultParams(type, value) {
188     switch (type) {
189       case AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:
190         HighlightEditor._defaultColor = value;
191         break;
192       case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
193         HighlightEditor._defaultThickness = value;
194         break;
195     }
196   }
197 
198   /** @inheritdoc */
199   translateInPage(x, y) {}
200 
201   /** @inheritdoc */
202   get toolbarPosition() {
203     return this.#lastPoint;
204   }
205 
206   /** @inheritdoc */
207   updateParams(type, value) {
208     switch (type) {
209       case AnnotationEditorParamsType.HIGHLIGHT_COLOR:
210         this.#updateColor(value);
211         break;
212       case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
213         this.#updateThickness(value);
214         break;
215     }
216   }
217 
218   static get defaultPropertiesToUpdate() {
219     return [
220       [
221         AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR,
222         HighlightEditor._defaultColor,
223       ],
224       [
225         AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,
226         HighlightEditor._defaultThickness,
227       ],
228     ];
229   }
230 
231   /** @inheritdoc */
232   get propertiesToUpdate() {
233     return [
234       [
235         AnnotationEditorParamsType.HIGHLIGHT_COLOR,
236         this.color || HighlightEditor._defaultColor,
237       ],
238       [
239         AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,
240         this.#thickness || HighlightEditor._defaultThickness,
241       ],
242     ];
243   }
244 
245   /**
246    * Update the color and make this action undoable.
247    * @param {string} color
248    */
249   #updateColor(color) {
250     const setColor = col => {
251       this.color = col;
252       this.parent?.drawLayer.changeColor(this.#id, col);
253       this.#colorPicker?.updateColor(col);
254     };
255     const savedColor = this.color;
256     this.addCommands({
257       cmd: setColor.bind(this, color),
258       undo: setColor.bind(this, savedColor),
259       post: this._uiManager.updateUI.bind(this._uiManager, this),
260       mustExec: true,
261       type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,
262       overwriteIfSameType: true,
263       keepUndo: true,
264     });
265   }
266 
267   /**
268    * Update the thickness and make this action undoable.
269    * @param {number} thickness
270    */
271   #updateThickness(thickness) {
272     const savedThickness = this.#thickness;
273     const setThickness = th => {
274       this.#thickness = th;
275       this.#changeThickness(th);
276     };
277     this.addCommands({
278       cmd: setThickness.bind(this, thickness),
279       undo: setThickness.bind(this, savedThickness),
280       post: this._uiManager.updateUI.bind(this._uiManager, this),
281       mustExec: true,
282       type: AnnotationEditorParamsType.INK_THICKNESS,
283       overwriteIfSameType: true,
284       keepUndo: true,
285     });
286   }
287 
288   /** @inheritdoc */
289   async addEditToolbar() {
290     const toolbar = await super.addEditToolbar();
291     if (!toolbar) {
292       return null;
293     }
294     if (this._uiManager.highlightColors) {
295       this.#colorPicker = new ColorPicker({ editor: this });
296       toolbar.addColorPicker(this.#colorPicker);
297     }
298     return toolbar;
299   }
300 
301   /** @inheritdoc */
302   disableEditing() {
303     super.disableEditing();
304     this.div.classList.toggle("disabled", true);
305   }
306 
307   /** @inheritdoc */
308   enableEditing() {
309     super.enableEditing();
310     this.div.classList.toggle("disabled", false);
311   }
312 
313   /** @inheritdoc */
314   fixAndSetPosition() {
315     return super.fixAndSetPosition(this.#getRotation());
316   }
317 
318   /** @inheritdoc */
319   getBaseTranslation() {
320     // The editor itself doesn't have any CSS border (we're drawing one
321     // ourselves in using SVG).
322     return [0, 0];
323   }
324 
325   /** @inheritdoc */
326   getRect(tx, ty) {
327     return super.getRect(tx, ty, this.#getRotation());
328   }
329 
330   /** @inheritdoc */
331   onceAdded() {
332     this.parent.addUndoableEditor(this);
333     this.div.focus();
334   }
335 
336   /** @inheritdoc */
337   remove() {
338     super.remove();
339     this.#cleanDrawLayer();
340   }
341 
342   /** @inheritdoc */
343   rebuild() {
344     if (!this.parent) {
345       return;
346     }
347     super.rebuild();
348     if (this.div === null) {
349       return;
350     }
351 
352     this.#addToDrawLayer();
353 
354     if (!this.isAttachedToDOM) {
355       // At some point this editor was removed and we're rebuilding it,
356       // hence we must add it to its parent.
357       this.parent.add(this);
358     }
359   }
360 
361   setParent(parent) {
362     let mustBeSelected = false;
363     if (this.parent && !parent) {
364       this.#cleanDrawLayer();
365     } else if (parent) {
366       this.#addToDrawLayer(parent);
367       // If mustBeSelected is true it means that this editor was selected
368       // when its parent has been destroyed, hence we must select it again.
369       mustBeSelected =
370         !this.parent && this.div?.classList.contains("selectedEditor");
371     }
372     super.setParent(parent);
373     if (mustBeSelected) {
374       // We select it after the parent has been set.
375       this.select();
376     }
377   }
378 
379   #changeThickness(thickness) {
380     if (!this.#isFreeHighlight) {
381       return;
382     }
383     this.#createFreeOutlines({
384       highlightOutlines: this.#highlightOutlines.getNewOutline(thickness / 2),
385     });
386     this.fixAndSetPosition();
387     const [parentWidth, parentHeight] = this.parentDimensions;
388     this.setDims(this.width * parentWidth, this.height * parentHeight);
389   }
390 
391   #cleanDrawLayer() {
392     if (this.#id === null || !this.parent) {
393       return;
394     }
395     this.parent.drawLayer.remove(this.#id);
396     this.#id = null;
397     this.parent.drawLayer.remove(this.#outlineId);
398     this.#outlineId = null;
399   }
400 
401   #addToDrawLayer(parent = this.parent) {
402     if (this.#id !== null) {
403       return;
404     }
405     ({ id: this.#id, clipPathId: this.#clipPathId } =
406       parent.drawLayer.highlight(
407         this.#highlightOutlines,
408         this.color,
409         this.#opacity
410       ));
411     this.#outlineId = parent.drawLayer.highlightOutline(this.#focusOutlines);
412     if (this.#highlightDiv) {
413       this.#highlightDiv.style.clipPath = this.#clipPathId;
414     }
415   }
416 
417   static #rotateBbox({ x, y, width, height }, angle) {
418     switch (angle) {
419       case 90:
420         return {
421           x: 1 - y - height,
422           y: x,
423           width: height,
424           height: width,
425         };
426       case 180:
427         return {
428           x: 1 - x - width,
429           y: 1 - y - height,
430           width,
431           height,
432         };
433       case 270:
434         return {
435           x: y,
436           y: 1 - x - width,
437           width: height,
438           height: width,
439         };
440     }
441     return {
442       x,
443       y,
444       width,
445       height,
446     };
447   }
448 
449   /** @inheritdoc */
450   rotate(angle) {
451     // We need to rotate the svgs because of the coordinates system.
452     const { drawLayer } = this.parent;
453     let box;
454     if (this.#isFreeHighlight) {
455       angle = (angle - this.rotation + 360) % 360;
456       box = HighlightEditor.#rotateBbox(this.#highlightOutlines.box, angle);
457     } else {
458       // An highlight annotation is always drawn horizontally.
459       box = HighlightEditor.#rotateBbox(this, angle);
460     }
461     drawLayer.rotate(this.#id, angle);
462     drawLayer.rotate(this.#outlineId, angle);
463     drawLayer.updateBox(this.#id, box);
464     drawLayer.updateBox(
465       this.#outlineId,
466       HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle)
467     );
468   }
469 
470   /** @inheritdoc */
471   render() {
472     if (this.div) {
473       return this.div;
474     }
475 
476     const div = super.render();
477     if (this.#isFreeHighlight) {
478       div.classList.add("free");
479     }
480     const highlightDiv = (this.#highlightDiv = document.createElement("div"));
481     div.append(highlightDiv);
482     highlightDiv.className = "internal";
483     highlightDiv.style.clipPath = this.#clipPathId;
484     const [parentWidth, parentHeight] = this.parentDimensions;
485     this.setDims(this.width * parentWidth, this.height * parentHeight);
486 
487     bindEvents(this, this.#highlightDiv, ["pointerover", "pointerleave"]);
488     this.enableEditing();
489 
490     return div;
491   }
492 
493   pointerover() {
494     this.parent.drawLayer.addClass(this.#outlineId, "hovered");
495   }
496 
497   pointerleave() {
498     this.parent.drawLayer.removeClass(this.#outlineId, "hovered");
499   }
500 
501   /** @inheritdoc */
502   select() {
503     super.select();
504     this.parent?.drawLayer.removeClass(this.#outlineId, "hovered");
505     this.parent?.drawLayer.addClass(this.#outlineId, "selected");
506   }
507 
508   /** @inheritdoc */
509   unselect() {
510     super.unselect();
511     this.parent?.drawLayer.removeClass(this.#outlineId, "selected");
512   }
513 
514   #getRotation() {
515     // Highlight annotations are always drawn horizontally but if
516     // a free highlight annotation can be rotated.
517     return this.#isFreeHighlight ? this.rotation : 0;
518   }
519 
520   #serializeBoxes(rect) {
521     if (this.#isFreeHighlight) {
522       return null;
523     }
524     const [pageWidth, pageHeight] = this.pageDimensions;
525     const boxes = this.#boxes;
526     const quadPoints = new Array(boxes.length * 8);
527     const [tx, ty] = rect;
528     let i = 0;
529     for (const { x, y, width, height } of boxes) {
530       const sx = tx + x * pageWidth;
531       const sy = ty + (1 - y - height) * pageHeight;
532       // The specifications say that the rectangle should start from the bottom
533       // left corner and go counter-clockwise.
534       // But when opening the file in Adobe Acrobat it appears that this isn't
535       // correct hence the 4th and 6th numbers are just swapped.
536       quadPoints[i] = quadPoints[i + 4] = sx;
537       quadPoints[i + 1] = quadPoints[i + 3] = sy;
538       quadPoints[i + 2] = quadPoints[i + 6] = sx + width * pageWidth;
539       quadPoints[i + 5] = quadPoints[i + 7] = sy + height * pageHeight;
540       i += 8;
541     }
542     return quadPoints;
543   }
544 
545   #serializeOutlines(rect) {
546     return this.#highlightOutlines.serialize(rect, this.#getRotation());
547   }
548 
549   static startHighlighting(parent, isLTR, { target: textLayer, x, y }) {
550     const {
551       x: layerX,
552       y: layerY,
553       width: parentWidth,
554       height: parentHeight,
555     } = textLayer.getBoundingClientRect();
556     const pointerMove = e => {
557       this.#highlightMove(parent, e);
558     };
559     const pointerDownOptions = { capture: true, passive: false };
560     const pointerDown = e => {
561       // Avoid to have undesired clicks during the drawing.
562       e.preventDefault();
563       e.stopPropagation();
564     };
565     const pointerUpCallback = e => {
566       textLayer.removeEventListener("pointermove", pointerMove);
567       window.removeEventListener("blur", pointerUpCallback);
568       window.removeEventListener("pointerup", pointerUpCallback);
569       window.removeEventListener(
570         "pointerdown",
571         pointerDown,
572         pointerDownOptions
573       );
574       window.removeEventListener("contextmenu", noContextMenu);
575       this.#endHighlight(parent, e);
576     };
577     window.addEventListener("blur", pointerUpCallback);
578     window.addEventListener("pointerup", pointerUpCallback);
579     window.addEventListener("pointerdown", pointerDown, pointerDownOptions);
580     window.addEventListener("contextmenu", noContextMenu);
581 
582     textLayer.addEventListener("pointermove", pointerMove);
583     this._freeHighlight = new FreeOutliner(
584       { x, y },
585       [layerX, layerY, parentWidth, parentHeight],
586       parent.scale,
587       this._defaultThickness / 2,
588       isLTR,
589       /* innerMargin = */ 0.001
590     );
591     ({ id: this._freeHighlightId, clipPathId: this._freeHighlightClipId } =
592       parent.drawLayer.highlight(
593         this._freeHighlight,
594         this._defaultColor,
595         this._defaultOpacity,
596         /* isPathUpdatable = */ true
597       ));
598   }
599 
600   static #highlightMove(parent, event) {
601     if (this._freeHighlight.add(event)) {
602       // Redraw only if the point has been added.
603       parent.drawLayer.updatePath(this._freeHighlightId, this._freeHighlight);
604     }
605   }
606 
607   static #endHighlight(parent, event) {
608     if (!this._freeHighlight.isEmpty()) {
609       parent.createAndAddNewEditor(event, false, {
610         highlightId: this._freeHighlightId,
611         highlightOutlines: this._freeHighlight.getOutlines(),
612         clipPathId: this._freeHighlightClipId,
613       });
614     } else {
615       parent.drawLayer.removeFreeHighlight(this._freeHighlightId);
616     }
617     this._freeHighlightId = -1;
618     this._freeHighlight = null;
619     this._freeHighlightClipId = "";
620   }
621 
622   /** @inheritdoc */
623   static deserialize(data, parent, uiManager) {
624     const editor = super.deserialize(data, parent, uiManager);
625 
626     const {
627       rect: [blX, blY, trX, trY],
628       color,
629       quadPoints,
630     } = data;
631     editor.color = Util.makeHexColor(...color);
632     editor.#opacity = data.opacity;
633 
634     const [pageWidth, pageHeight] = editor.pageDimensions;
635     editor.width = (trX - blX) / pageWidth;
636     editor.height = (trY - blY) / pageHeight;
637     const boxes = (editor.#boxes = []);
638     for (let i = 0; i < quadPoints.length; i += 8) {
639       boxes.push({
640         x: (quadPoints[4] - trX) / pageWidth,
641         y: (trY - (1 - quadPoints[i + 5])) / pageHeight,
642         width: (quadPoints[i + 2] - quadPoints[i]) / pageWidth,
643         height: (quadPoints[i + 5] - quadPoints[i + 1]) / pageHeight,
644       });
645     }
646     editor.#createOutlines();
647 
648     return editor;
649   }
650 
651   /** @inheritdoc */
652   serialize(isForCopying = false) {
653     // It doesn't make sense to copy/paste a highlight annotation.
654     if (this.isEmpty() || isForCopying) {
655       return null;
656     }
657 
658     const rect = this.getRect(0, 0);
659     const color = AnnotationEditor._colorManager.convert(this.color);
660 
661     return {
662       annotationType: AnnotationEditorType.HIGHLIGHT,
663       color,
664       opacity: this.#opacity,
665       thickness: this.#thickness,
666       quadPoints: this.#serializeBoxes(rect),
667       outlines: this.#serializeOutlines(rect),
668       pageIndex: this.pageIndex,
669       rect,
670       rotation: this.#getRotation(),
671       structTreeParentId: this._structTreeParentId,
672     };
673   }
674 
675   static canCreateNewEmptyEditor() {
676     return false;
677   }
678 }
679 
680 export { HighlightEditor };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

