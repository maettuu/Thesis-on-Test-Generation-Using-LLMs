Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Fix new code scanning alerts
The following new code scanning alerts showed up recently:

- https://github.com/mozilla/pdf.js/security/code-scanning/402
- https://github.com/mozilla/pdf.js/security/code-scanning/401
- https://github.com/mozilla/pdf.js/security/code-scanning/400
- https://github.com/mozilla/pdf.js/security/code-scanning/399
- https://github.com/mozilla/pdf.js/security/code-scanning/398

There is a note in there that this is debugging code code, and it's indeed not called from anywhere. It has also mostly been changed 12 years ago.

@Snuffleupagus What do you think? Should we get rid of it, or is this something you have used or think is useful to keep? In the latter case we can just silence the alert.
</issue>

Patch:
<patch>
diff --git a/src/shared/cffStandardStrings.js b/src/shared/cffStandardStrings.js
--- a/src/shared/cffStandardStrings.js
+++ b/src/shared/cffStandardStrings.js
@@ -1,311 +0,0 @@
-/* Copyright 2012 Mozilla Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-'use strict';
-
-var CFFEncodingMap = {
-  '0': '-reserved-',
-  '1': 'hstem',
-  '2': '-reserved-',
-  '3': 'vstem',
-  '4': 'vmoveto',
-  '5': 'rlineto',
-  '6': 'hlineto',
-  '7': 'vlineto',
-  '8': 'rrcurveto',
-  '9': '-reserved-',
-  '10': 'callsubr',
-  '11': 'return',
-  '12': {
-    '3': 'and',
-    '4': 'or',
-    '5': 'not',
-    '9': 'abs',
-    '10': 'add',
-    '11': 'div',
-    '12': 'sub',
-    '14': 'neg',
-    '15': 'eq',
-    '18': 'drop',
-    '20': 'put',
-    '21': 'get',
-    '22': 'ifelse',
-    '23': 'random',
-    '24': 'mul',
-    '26': 'sqrt',
-    '27': 'dup',
-    '28': 'exch',
-    '29': 'index',
-    '30': 'roll',
-    '34': 'hflex',
-    '35': 'flex',
-    '36': 'hflex1',
-    '37': 'flex1'
-  },
-  '13': '-reserved-',
-  '14': 'endchar',
-  '15': '-reserved-',
-  '16': '-reserved-',
-  '17': '-reserved-',
-  '18': 'hstemhm',
-  '19': 'hintmask',
-  '20': 'cntrmask',
-  '21': 'rmoveto',
-  '22': 'hmoveto',
-  '23': 'vstemhm',
-  '24': 'rcurveline',
-  '25': 'rlivecurve',
-  '26': 'vvcurveto',
-  '27': 'hhcurveto',
-  '29': 'callgsubr',
-  '30': 'vhcurveto',
-  '31': 'hvcurveto'
-};
-
-var CFFDictDataMap = {
-  '0': {
-    name: 'version',
-    operand: 'SID'
-  },
-  '1': {
-    name: 'Notice',
-    operand: 'SID'
-  },
-  '2': {
-    name: 'FullName',
-    operand: 'SID'
-  },
-  '3': {
-    name: 'FamilyName',
-    operand: 'SID'
-  },
-  '4': {
-    name: 'Weight',
-    operand: 'SID'
-  },
-  '5': {
-    name: 'FontBBox',
-    operand: [0, 0, 0, 0]
-  },
-  '6': {
-    name: 'BlueValues'
-  },
-  '7': {
-    name: 'OtherBlues'
-  },
-  '8': {
-    name: 'FamilyBlues'
-  },
-  '9': {
-    name: 'FamilyOtherBlues'
-  },
-  '10': {
-    name: 'StdHW'
-  },
-  '11': {
-    name: 'StdVW'
-  },
-  '12': {
-    '0': {
-      name: 'Copyright',
-      operand: 'SID'
-    },
-    '1': {
-      name: 'IsFixedPitch',
-      operand: false
-    },
-    '2': {
-      name: 'ItalicAngle',
-      operand: 0
-    },
-    '3': {
-      name: 'UnderlinePosition',
-      operand: -100
-    },
-    '4': {
-      name: 'UnderlineThickness',
-      operand: 50
-    },
-    '5': {
-      name: 'PaintType',
-      operand: 0
-    },
-    '6': {
-      name: 'CharstringType',
-      operand: 2
-    },
-    '7': {
-      name: 'FontMatrix',
-      operand: [0.001, 0, 0, 0.001, 0, 0]
-    },
-    '8': {
-      name: 'StrokeWidth',
-      operand: 0
-    },
-    '9': {
-      name: 'BlueScale'
-    },
-    '10': {
-      name: 'BlueShift'
-    },
-    '11': {
-      name: 'BlueFuzz'
-    },
-    '12': {
-      name: 'StemSnapH'
-    },
-    '13': {
-      name: 'StemSnapV'
-    },
-    '14': {
-      name: 'ForceBold'
-    },
-    '17': {
-      name: 'LanguageGroup'
-    },
-    '18': {
-      name: 'ExpansionFactor'
-    },
-    '19': {
-      name: 'initialRandomSeed'
-    },
-    '20': {
-      name: 'SyntheticBase',
-      operand: null
-    },
-    '21': {
-      name: 'PostScript',
-      operand: 'SID'
-    },
-    '22': {
-      name: 'BaseFontName',
-      operand: 'SID'
-    },
-    '23': {
-      name: 'BaseFontBlend',
-      operand: 'delta'
-    }
-  },
-  '13': {
-    name: 'UniqueID',
-    operand: null
-  },
-  '14': {
-    name: 'XUID',
-    operand: []
-  },
-  '15': {
-    name: 'charset',
-    operand: 0
-  },
-  '16': {
-    name: 'Encoding',
-    operand: 0
-  },
-  '17': {
-    name: 'CharStrings',
-    operand: null
-  },
-  '18': {
-    name: 'Private',
-    operand: 'number number'
-  },
-  '19': {
-    name: 'Subrs'
-  },
-  '20': {
-    name: 'defaultWidthX'
-  },
-  '21': {
-    name: 'nominalWidthX'
-  }
-};
-
-var CFFDictPrivateDataMap = {
-  '6': {
-    name: 'BluesValues',
-    operand: 'delta'
-  },
-  '7': {
-    name: 'OtherBlues',
-    operand: 'delta'
-  },
-  '8': {
-    name: 'FamilyBlues',
-    operand: 'delta'
-  },
-  '9': {
-    name: 'FamilyOtherBlues',
-    operand: 'delta'
-  },
-  '10': {
-    name: 'StdHW',
-    operand: null
-  },
-  '11': {
-    name: 'StdVW',
-    operand: null
-  },
-  '12': {
-    '9': {
-      name: 'BlueScale',
-      operand: 0.039625
-    },
-    '10': {
-      name: 'BlueShift',
-      operand: 7
-    },
-    '11': {
-      name: 'BlueFuzz',
-      operand: 1
-    },
-    '12': {
-      name: 'StemSnapH',
-      operand: 'delta'
-    },
-    '13': {
-      name: 'StemSnapV',
-      operand: 'delta'
-    },
-    '14': {
-      name: 'ForceBold',
-      operand: 'boolean'
-    },
-    '17': {
-      name: 'LanguageGroup',
-      operand: 0
-    },
-    '18': {
-      name: 'ExpansionFactor',
-      operand: 0.06
-    },
-    '19': {
-      name: 'initialRandomSeed',
-      operand: 0
-    }
-  },
-  '19': {
-    name: 'Subrs',
-    operand: null
-  },
-  '20': {
-    name: 'defaultWidthX',
-    operand: 0
-  },
-  '21': {
-    name: 'nominalWidthX',
-    operand: 0
-  }
-};

diff --git a/src/shared/fonts_utils.js b/src/shared/fonts_utils.js
--- a/src/shared/fonts_utils.js
+++ b/src/shared/fonts_utils.js
@@ -1,429 +0,0 @@
-/* Copyright 2012 Mozilla Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/* globals CFFDictDataMap, CFFDictPrivateDataMap, CFFEncodingMap, CFFStrings,
-           Components, Dict, dump, FormatError, netscape, Stream */
-
-'use strict';
-
-/*
- * The Type2 reader code below is only used for debugging purpose since Type2
- * is only a CharString format and is never used directly as a Font file.
- *
- * So the code here is useful for dumping the data content of a .cff file in
- * order to investigate the similarity between a Type1 CharString and a Type2
- * CharString or to understand the structure of the CFF format.
- */
-
-/*
- * Build a charset by assigning the glyph name and the human readable form
- * of the glyph data.
- */
-function readCharset(aStream, aCharstrings) {
-  var charset = {};
-
-  var format = aStream.getByte();
-  var count = aCharstrings.length - 1;
-  var i, sid;
-  if (format === 0) {
-    charset['.notdef'] = readCharstringEncoding(aCharstrings[0]);
-
-    for (i = 1; i < count + 1; i++) {
-      sid = aStream.getByte() << 8 | aStream.getByte();
-      charset[CFFStrings[sid]] = readCharstringEncoding(aCharstrings[i]);
-    }
-  } else if (format === 1) {
-    for (i = 1; i < count + 1; i++) {
-      var first = aStream.getByte();
-      first = (first << 8) | aStream.getByte();
-      var numLeft = aStream.getByte();
-      for (var j = 0; j <= numLeft; j++) {
-        sid = first++;
-        charset[CFFStrings[sid]] = readCharstringEncoding(aCharstrings[j]);
-      }
-    }
-  } else {
-    throw new FormatError('Invalid charset format');
-  }
-
-  return charset;
-}
-
-/*
- * Take a Type2 binary charstring as input and transform it to a human
- * readable representation as specified by the 'The Type 2 Charstring Format',
- * chapter 3.1.
- */
-function readCharstringEncoding(aString) {
-  if (!aString) {
-    return '';
-  }
-
-  var charstringTokens = [];
-
-  var count = aString.length;
-  for (var i = 0; i < count; ) {
-    var value = aString[i++] | 0;
-    var token = null;
-
-    if (value < 0) {
-      continue;
-    } else if (value <= 11) {
-      token = CFFEncodingMap[value];
-    } else if (value === 12) {
-      token = CFFEncodingMap[value][aString[i++]];
-    } else if (value <= 18) {
-      token = CFFEncodingMap[value];
-    } else if (value <= 20) {
-      ++i; // var mask = aString[i++];
-      token = CFFEncodingMap[value];
-    } else if (value <= 27) {
-      token = CFFEncodingMap[value];
-    } else if (value === 28) {
-      token = aString[i++] << 8 | aString[i++];
-    } else if (value <= 31) {
-      token = CFFEncodingMap[value];
-    } else if (value < 247) {
-      token = parseInt(value, 10) - 139;
-    } else if (value < 251) {
-      token = (value - 247) * 256 + aString[i++] + 108;
-    } else if (value < 255) {
-      token = -(value - 251) * 256 - aString[i++] - 108;
-    } else { // value === 255
-      token = aString[i++] << 24 | aString[i++] << 16 |
-              aString[i++] << 8 | aString[i];
-    }
-
-    charstringTokens.push(token);
-  }
-
-  return charstringTokens;
-}
-
-
-/*
- * Take a binary DICT Data as input and transform it into a human readable
- * form as specified by 'The Compact Font Format Specification', chapter 5.
- */
-function readFontDictData(aString, aMap) {
-  var fontDictDataTokens = [];
-
-  var count = aString.length;
-  for (var i = 0; i < count; ) {
-    var value = aString[i++] | 0;
-    var token = null;
-
-    if (value === 12) {
-      token = aMap[value][aString[i++]];
-    } else if (value === 28) {
-      token = aString[i++] << 8 | aString[i++];
-    } else if (value === 29) {
-      token = aString[i++] << 24 |
-              aString[i++] << 16 |
-              aString[i++] << 8 |
-              aString[i++];
-    } else if (value === 30) {
-      token = '';
-      var parsed = false;
-      while (!parsed) {
-        var octet = aString[i++];
-
-        var nibbles = [parseInt(octet / 16, 10), parseInt(octet % 16, 10)];
-        for (var j = 0; j < nibbles.length; j++) {
-          var nibble = nibbles[j];
-          switch (nibble) {
-            case 0xA:
-              token += '.';
-              break;
-            case 0xB:
-              token += 'E';
-              break;
-            case 0xC:
-              token += 'E-';
-              break;
-            case 0xD:
-              break;
-            case 0xE:
-              token += '-';
-              break;
-            case 0xF:
-              parsed = true;
-              break;
-            default:
-              token += nibble;
-              break;
-          }
-        }
-      }
-      token = parseFloat(token);
-    } else if (value <= 31) {
-      token = aMap[value];
-    } else if (value <= 246) {
-      token = parseInt(value, 10) - 139;
-    } else if (value <= 250) {
-      token = (value - 247) * 256 + aString[i++] + 108;
-    } else if (value <= 254) {
-      token = -(value - 251) * 256 - aString[i++] - 108;
-    } else if (value === 255) {
-      throw new FormatError('255 is not a valid DICT command');
-    }
-
-    fontDictDataTokens.push(token);
-  }
-
-  return fontDictDataTokens;
-}
-
-/*
- * Take a stream as input and return an array of objects.
- * In CFF an INDEX is a structure with the following format:
- *  {
- *    count: 2 bytes (Number of objects stored in INDEX),
- *    offsize: 1 byte (Offset array element size),
- *    offset: [count + 1] bytes (Offsets array),
- *    data: - (Objects data)
- *  }
- *
- *  More explanation are given in the 'CFF Font Format Specification',
- *  chapter 5.
- */
-function readFontIndexData(aStream, aIsByte) {
-  var count = aStream.getByte() << 8 | aStream.getByte();
-  var offsize = aStream.getByte();
-
-  function getNextOffset() {
-    switch (offsize) {
-      case 0:
-        return 0;
-      case 1:
-        return aStream.getByte();
-      case 2:
-        return aStream.getByte() << 8 | aStream.getByte();
-      case 3:
-        return aStream.getByte() << 16 | aStream.getByte() << 8 |
-               aStream.getByte();
-      case 4:
-      return aStream.getByte() << 24 | aStream.getByte() << 16 |
-             aStream.getByte() << 8 | aStream.getByte();
-    }
-    throw new FormatError(offsize + ' is not a valid offset size');
-  }
-
-  var offsets = [];
-  var i;
-  for (i = 0; i < count + 1; i++) {
-    offsets.push(getNextOffset());
-  }
-
-  dump('Found ' + count + ' objects at offsets :' +
-       offsets + ' (offsize: ' + offsize + ')');
-
-  // Now extract the objects
-  var relativeOffset = aStream.pos;
-  var objects = [];
-  for (i = 0; i < count; i++) {
-    var offset = offsets[i];
-    aStream.pos = relativeOffset + offset - 1;
-
-    var data = [];
-    var length = offsets[i + 1] - 1;
-    for (var j = offset - 1; j < length; j++) {
-      data.push(aIsByte ? aStream.getByte() : aStream.getChar());
-    }
-    objects.push(data);
-  }
-
-  return objects;
-}
-
-var Type2Parser = function type2Parser(aFilePath) {
-  var font = new Dict(null);
-
-  var xhr = new XMLHttpRequest();
-  xhr.open('GET', aFilePath, false);
-  xhr.responseType = 'arraybuffer';
-  xhr.expected = document.URL.startsWith('file:') ? 0 : 200;
-  xhr.send(null);
-  this.data = new Stream(xhr.response);
-
-  // Turn on this flag for additional debugging logs
-  var debug = false;
-
-  function dump(aStr) {
-    if (debug) {
-      console.log(aStr);
-    }
-  }
-
-  function parseAsToken(aString, aMap) {
-    var decoded = readFontDictData(aString, aMap);
-
-    var stack = [];
-    var count = decoded.length;
-    for (var i = 0; i < count; i++) {
-      var token = decoded[i];
-      if (typeof token === "number") {
-        stack.push(token);
-      } else {
-        switch (token.operand) {
-          case 'SID':
-            font.set(token.name, CFFStrings[stack.pop()]);
-            break;
-          case 'number number':
-            font.set(token.name, {
-              offset: stack.pop(),
-              size: stack.pop()
-            });
-            break;
-          case 'boolean':
-            font.set(token.name, stack.pop());
-            break;
-          case 'delta':
-            font.set(token.name, stack.pop());
-            break;
-          default:
-            if (token.operand?.length) {
-              var array = [];
-              for (var j = 0; j < token.operand.length; j++) {
-                array.push(stack.pop());
-              }
-              font.set(token.name, array);
-            } else {
-              font.set(token.name, stack.pop());
-            }
-            break;
-        }
-      }
-    }
-  }
-
-  this.parse = function type2ParserParse(aStream) {
-    font.set('major', aStream.getByte());
-    font.set('minor', aStream.getByte());
-    font.set('hdrSize', aStream.getByte());
-    font.set('offsize', aStream.getByte());
-
-    // Read the NAME Index
-    dump('Reading Index: Names');
-    font.set('Names', readFontIndexData(aStream));
-    dump('Names: ' + font.get('Names'));
-
-    // Read the Top Dict Index
-    dump('Reading Index: TopDict');
-    var topDict = readFontIndexData(aStream, true);
-    dump('TopDict: ' + topDict);
-
-    // Read the String Index
-    dump('Reading Index: Strings');
-    var strings = readFontIndexData(aStream);
-    dump('strings: ' + strings);
-
-    // Fill up the Strings dictionary with the new unique strings
-    var i;
-    for (i = 0; i < strings.length; i++) {
-      CFFStrings.push(strings[i].join(''));
-    }
-
-    // Parse the TopDict operator
-    var count = topDict.length;
-    for (i = 0; i < count; i++) {
-      parseAsToken(topDict[i], CFFDictDataMap);
-    }
-
-    // Read the Global Subr Index that comes just after the Strings Index
-    // (cf. "The Compact Font Format Specification" Chapter 16)
-    dump('Reading Global Subr Index');
-    var subrs = readFontIndexData(aStream, true);
-    dump(subrs);
-
-    // Reading Private Dict
-    var priv = font.get('Private');
-    dump('Reading Private Dict (offset: ' + priv.offset +
-        ' size: ' + priv.size + ')');
-    aStream.pos = priv.offset;
-
-    var privateDict = [];
-    for (i = 0; i < priv.size; i++) {
-      privateDict.push(aStream.getByte());
-    }
-    dump('privateData:' + privateDict);
-    parseAsToken(privateDict, CFFDictPrivateDataMap);
-
-    font.forEach(function(key, value) {
-      dump(key + '::' + value);
-    });
-
-    // Read CharStrings Index
-    var charStringsOffset = font.get('CharStrings');
-    dump('Read CharStrings Index (offset: ' + charStringsOffset + ')');
-    aStream.pos = charStringsOffset;
-    var charStrings = readFontIndexData(aStream, true);
-
-    // Read Charset
-    dump('Read Charset for ' + charStrings.length + ' glyphs');
-    var charsetEntry = font.get('charset');
-    if (charsetEntry === 0) {
-      throw new FormatError('Need to support CFFISOAdobeCharset');
-    } else if (charsetEntry === 1) {
-      throw new FormatError('Need to support CFFExpert');
-    } else if (charsetEntry === 2) {
-      throw new FormatError('Need to support CFFExpertSubsetCharset');
-    } else {
-      aStream.pos = charsetEntry;
-      readCharset(aStream, charStrings);
-    }
-  };
-};
-
-/*
- * To try the Type2 decoder on a local file in the current directory:
- *
- *  var cff = new Type2Parser("file.cff");
- *  cff.parse(this.data);
- *
- * To try the Type2 decoder on a custom built CFF array:
- *
- *  var file = new Uint8Array(cffFileArray, 0, cffFileSize);
- *  var parser = new Type2Parser();
- *  parser.parse(new Stream(file));
- */
-
-/*
- * Write to a file to the disk (works only on Firefox in privilege mode)
- * but this is useful for dumping a font file to the disk and check with
- * fontforge or the ots program what's wrong with the file.
- *
- * writeToFile(fontData, "/tmp/pdf.js." + fontCount + ".cff");
- */
-function writeToFile(aBytes, aFilePath) {
-  if (!('netscape' in window)) {
-    return;
-  }
-
-  netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
-  var Cc = Components.classes,
-      Ci = Components.interfaces;
-  var file = Cc['@mozilla.org/file/local;1'].createInstance(Ci.nsILocalFile);
-  file.initWithPath(aFilePath);
-
-  var stream = Cc['@mozilla.org/network/file-output-stream;1']
-                 .createInstance(Ci.nsIFileOutputStream);
-  stream.init(file, 0x04 | 0x08 | 0x20, 0x180, 0);
-
-  var bos = Cc['@mozilla.org/binaryoutputstream;1']
-              .createInstance(Ci.nsIBinaryOutputStream);
-  bos.setOutputStream(stream);
-  bos.writeByteArray(aBytes, aBytes.length);
-  stream.close();
-}


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.22.20
- @babel/preset-env: ^7.22.20
- @babel/runtime: ^7.22.15
- @javascript-obfuscator/escodegen: 2.3.0
- acorn: ^8.10.0
- autoprefixer: ^10.4.16
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001538
- canvas: ^2.11.2
- core-js: ^3.32.2
- cross-env: ^7.0.3
- eslint: ^8.50.0
- eslint-config-prettier: ^8.10.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.28.1
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.2.0
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.0.0
- eslint-plugin-sort-exports: ^0.8.0
- eslint-plugin-unicorn: ^48.0.1
- globals: ^13.22.0
- gulp: ^4.0.2
- gulp-postcss: ^9.0.1
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^5.1.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.2.0
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.31
- postcss-dir-pseudo-class: ^8.0.0
- postcss-discard-comments: ^6.0.0
- postcss-nesting: ^12.0.1
- prettier: ^3.0.3
- puppeteer: ^21.3.4
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^15.10.3
- stylelint-prettier: ^4.0.2
- terser: ^5.20.0
- through2: ^4.0.2
- tsc-alias: ^1.8.8
- ttest: ^4.0.0
- typescript: ^5.2.2
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.88.2
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isArrayBuffer, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/l10n_utils.js`: NullL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

