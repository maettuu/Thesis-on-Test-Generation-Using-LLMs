Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Regression between Firefox 109.0.1 and 115.0.2 - document used to render, now does not
Link to PDF file here: [issue16759.pdf](https://github.com/mozilla/pdf.js/files/12185373/issue16759.pdf) (from [https://lab6.com/1](https://lab6.com/1))

Configuration:
- Web browser and its version: Firefox 115.0.2 (64-bit)
- Operating system and its version: Ubuntu 22.04
- PDF.js version: Version built into Firefox 115.0.2


Steps to reproduce the problem:
1. Try to load the above URL
2. Document does not render. The following error message can be found in the console:

```
Invalid or corrupted PDF file.

PDF.js v3.7.96 (build: 23958ffc5)
Message: Invalid PDF structure.
```

This document used to render in Firefox 109.0.1 (possibly later versions too, but that's the old version I have to hand). It renders in Chrome and Okular, and also passes PDF validators (https://www.pdfen.com/pdf-a-validator and VeraPDF).

N.B. This is a polyglot PDF/MP3 file that does not rely on parser bugs. I believe it to be fully conformant to the PDF spec, but it may push the boundaries of what a PDF processor expects, or I may be wrong about it being fully conformant.

</issue>

Patch:
<patch>
diff --git a/src/core/xref.js b/src/core/xref.js
--- a/src/core/xref.js
+++ b/src/core/xref.js
@@ -431,7 +431,7 @@ class XRef {
       }
       return skipped;
     }
-    const gEndobjRegExp = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer)\b/g;
+    const gEndobjRegExp = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer\s*<<)\b/g;
     const gStartxrefRegExp = /\b(startxref|\d+\s+\d+\s+obj)\b/g;
     const objRegExp = /^(\d+)\s+(\d+)\s+obj\b/;


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.22.9
- @babel/plugin-transform-modules-commonjs: ^7.22.5
- @babel/preset-env: ^7.22.9
- @babel/runtime: ^7.22.6
- @javascript-obfuscator/escodegen: 2.3.0
- acorn: ^8.10.0
- autoprefixer: ^10.4.14
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001517
- canvas: ^2.11.2
- core-js: ^3.31.1
- cross-env: ^7.0.3
- es-module-shims: 1.4.7
- eslint: ^8.45.0
- eslint-config-prettier: ^8.8.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.27.5
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.1.0
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.0.0
- eslint-plugin-sort-exports: ^0.8.0
- eslint-plugin-unicorn: ^48.0.0
- globals: ^13.20.0
- gulp: ^4.0.2
- gulp-postcss: ^9.0.1
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^5.1.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.2.0
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.27
- postcss-dir-pseudo-class: ^8.0.0
- prettier: ^3.0.0
- puppeteer: ^20.9.0
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^15.10.2
- stylelint-prettier: ^4.0.0
- terser: ^5.19.2
- through2: ^4.0.2
- ttest: ^4.0.0
- typescript: ^5.1.6
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.88.2
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, SVGGraphics, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, loadScript, setLayerDimensions
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/svg.js`: SVGGraphics
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isArrayBuffer, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/l10n_utils.js`: NullL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/xref.js
1 /* Copyright 2021 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   assert,
18   bytesToString,
19   FormatError,
20   info,
21   InvalidPDFException,
22   warn,
23 } from "../shared/util.js";
24 import { CIRCULAR_REF, Cmd, Dict, isCmd, Ref, RefSet } from "./primitives.js";
25 import { Lexer, Parser } from "./parser.js";
26 import {
27   MissingDataException,
28   ParserEOFException,
29   XRefEntryException,
30   XRefParseException,
31 } from "./core_utils.js";
32 import { BaseStream } from "./base_stream.js";
33 import { CipherTransformFactory } from "./crypto.js";
34 
35 class XRef {
36   #firstXRefStmPos = null;
37 
38   constructor(stream, pdfManager) {
39     this.stream = stream;
40     this.pdfManager = pdfManager;
41     this.entries = [];
42     this._xrefStms = new Set();
43     this._cacheMap = new Map(); // Prepare the XRef cache.
44     this._pendingRefs = new RefSet();
45     this._newPersistentRefNum = null;
46     this._newTemporaryRefNum = null;
47   }
48 
49   getNewPersistentRef(obj) {
50     // When printing we don't care that much about the ref number by itself, it
51     // can increase for ever and it allows to keep some re-usable refs.
52     if (this._newPersistentRefNum === null) {
53       this._newPersistentRefNum = this.entries.length || 1;
54     }
55     const num = this._newPersistentRefNum++;
56     this._cacheMap.set(num, obj);
57     return Ref.get(num, 0);
58   }
59 
60   getNewTemporaryRef() {
61     // When saving we want to have some minimal numbers.
62     // Those refs are only created in order to be written in the final pdf
63     // stream.
64     if (this._newTemporaryRefNum === null) {
65       this._newTemporaryRefNum = this.entries.length || 1;
66     }
67     return Ref.get(this._newTemporaryRefNum++, 0);
68   }
69 
70   resetNewTemporaryRef() {
71     // Called once saving is finished.
72     this._newTemporaryRefNum = null;
73   }
74 
75   setStartXRef(startXRef) {
76     // Store the starting positions of xref tables as we process them
77     // so we can recover from missing data errors
78     this.startXRefQueue = [startXRef];
79   }
80 
81   parse(recoveryMode = false) {
82     let trailerDict;
83     if (!recoveryMode) {
84       trailerDict = this.readXRef();
85     } else {
86       warn("Indexing all PDF objects");
87       trailerDict = this.indexObjects();
88     }
89     trailerDict.assignXref(this);
90     this.trailer = trailerDict;
91 
92     let encrypt;
93     try {
94       encrypt = trailerDict.get("Encrypt");
95     } catch (ex) {
96       if (ex instanceof MissingDataException) {
97         throw ex;
98       }
99       warn(`XRef.parse - Invalid "Encrypt" reference: "${ex}".`);
100     }
101     if (encrypt instanceof Dict) {
102       const ids = trailerDict.get("ID");
103       const fileId = ids?.length ? ids[0] : "";
104       // The 'Encrypt' dictionary itself should not be encrypted, and by
105       // setting `suppressEncryption` we can prevent an infinite loop inside
106       // of `XRef_fetchUncompressed` if the dictionary contains indirect
107       // objects (fixes issue7665.pdf).
108       encrypt.suppressEncryption = true;
109       this.encrypt = new CipherTransformFactory(
110         encrypt,
111         fileId,
112         this.pdfManager.password
113       );
114     }
115 
116     // Get the root dictionary (catalog) object, and do some basic validation.
117     let root;
118     try {
119       root = trailerDict.get("Root");
120     } catch (ex) {
121       if (ex instanceof MissingDataException) {
122         throw ex;
123       }
124       warn(`XRef.parse - Invalid "Root" reference: "${ex}".`);
125     }
126     if (root instanceof Dict) {
127       try {
128         const pages = root.get("Pages");
129         if (pages instanceof Dict) {
130           this.root = root;
131           return;
132         }
133       } catch (ex) {
134         if (ex instanceof MissingDataException) {
135           throw ex;
136         }
137         warn(`XRef.parse - Invalid "Pages" reference: "${ex}".`);
138       }
139     }
140 
141     if (!recoveryMode) {
142       throw new XRefParseException();
143     }
144     // Even recovery failed, there's nothing more we can do here.
145     throw new InvalidPDFException("Invalid Root reference.");
146   }
147 
148   processXRefTable(parser) {
149     if (!("tableState" in this)) {
150       // Stores state of the table as we process it so we can resume
151       // from middle of table in case of missing data error
152       this.tableState = {
153         entryNum: 0,
154         streamPos: parser.lexer.stream.pos,
155         parserBuf1: parser.buf1,
156         parserBuf2: parser.buf2,
157       };
158     }
159 
160     const obj = this.readXRefTable(parser);
161 
162     // Sanity check
163     if (!isCmd(obj, "trailer")) {
164       throw new FormatError(
165         "Invalid XRef table: could not find trailer dictionary"
166       );
167     }
168     // Read trailer dictionary, e.g.
169     // trailer
170     //    << /Size 22
171     //      /Root 20R
172     //      /Info 10R
173     //      /ID [ <81b14aafa313db63dbd6f981e49f94f4> ]
174     //    >>
175     // The parser goes through the entire stream << ... >> and provides
176     // a getter interface for the key-value table
177     let dict = parser.getObj();
178 
179     // The pdflib PDF generator can generate a nested trailer dictionary
180     if (!(dict instanceof Dict) && dict.dict) {
181       dict = dict.dict;
182     }
183     if (!(dict instanceof Dict)) {
184       throw new FormatError(
185         "Invalid XRef table: could not parse trailer dictionary"
186       );
187     }
188     delete this.tableState;
189 
190     return dict;
191   }
192 
193   readXRefTable(parser) {
194     // Example of cross-reference table:
195     // xref
196     // 0 1                    <-- subsection header (first obj #, obj count)
197     // 0000000000 65535 f     <-- actual object (offset, generation #, f/n)
198     // 23 2                   <-- subsection header ... and so on ...
199     // 0000025518 00002 n
200     // 0000025635 00000 n
201     // trailer
202     // ...
203 
204     const stream = parser.lexer.stream;
205     const tableState = this.tableState;
206     stream.pos = tableState.streamPos;
207     parser.buf1 = tableState.parserBuf1;
208     parser.buf2 = tableState.parserBuf2;
209 
210     // Outer loop is over subsection headers
211     let obj;
212 
213     while (true) {
214       if (!("firstEntryNum" in tableState) || !("entryCount" in tableState)) {
215         if (isCmd((obj = parser.getObj()), "trailer")) {
216           break;
217         }
218         tableState.firstEntryNum = obj;
219         tableState.entryCount = parser.getObj();
220       }
221 
222       let first = tableState.firstEntryNum;
223       const count = tableState.entryCount;
224       if (!Number.isInteger(first) || !Number.isInteger(count)) {
225         throw new FormatError(
226           "Invalid XRef table: wrong types in subsection header"
227         );
228       }
229       // Inner loop is over objects themselves
230       for (let i = tableState.entryNum; i < count; i++) {
231         tableState.streamPos = stream.pos;
232         tableState.entryNum = i;
233         tableState.parserBuf1 = parser.buf1;
234         tableState.parserBuf2 = parser.buf2;
235 
236         const entry = {};
237         entry.offset = parser.getObj();
238         entry.gen = parser.getObj();
239         const type = parser.getObj();
240 
241         if (type instanceof Cmd) {
242           switch (type.cmd) {
243             case "f":
244               entry.free = true;
245               break;
246             case "n":
247               entry.uncompressed = true;
248               break;
249           }
250         }
251 
252         // Validate entry obj
253         if (
254           !Number.isInteger(entry.offset) ||
255           !Number.isInteger(entry.gen) ||
256           !(entry.free || entry.uncompressed)
257         ) {
258           throw new FormatError(
259             `Invalid entry in XRef subsection: ${first}, ${count}`
260           );
261         }
262 
263         // The first xref table entry, i.e. obj 0, should be free. Attempting
264         // to adjust an incorrect first obj # (fixes issue 3248 and 7229).
265         if (i === 0 && entry.free && first === 1) {
266           first = 0;
267         }
268 
269         if (!this.entries[i + first]) {
270           this.entries[i + first] = entry;
271         }
272       }
273 
274       tableState.entryNum = 0;
275       tableState.streamPos = stream.pos;
276       tableState.parserBuf1 = parser.buf1;
277       tableState.parserBuf2 = parser.buf2;
278       delete tableState.firstEntryNum;
279       delete tableState.entryCount;
280     }
281 
282     // Sanity check: as per spec, first object must be free
283     if (this.entries[0] && !this.entries[0].free) {
284       throw new FormatError("Invalid XRef table: unexpected first object");
285     }
286     return obj;
287   }
288 
289   processXRefStream(stream) {
290     if (!("streamState" in this)) {
291       // Stores state of the stream as we process it so we can resume
292       // from middle of stream in case of missing data error
293       const streamParameters = stream.dict;
294       const byteWidths = streamParameters.get("W");
295       let range = streamParameters.get("Index");
296       if (!range) {
297         range = [0, streamParameters.get("Size")];
298       }
299 
300       this.streamState = {
301         entryRanges: range,
302         byteWidths,
303         entryNum: 0,
304         streamPos: stream.pos,
305       };
306     }
307     this.readXRefStream(stream);
308     delete this.streamState;
309 
310     return stream.dict;
311   }
312 
313   readXRefStream(stream) {
314     const streamState = this.streamState;
315     stream.pos = streamState.streamPos;
316 
317     const [typeFieldWidth, offsetFieldWidth, generationFieldWidth] =
318       streamState.byteWidths;
319 
320     const entryRanges = streamState.entryRanges;
321     while (entryRanges.length > 0) {
322       const [first, n] = entryRanges;
323 
324       if (!Number.isInteger(first) || !Number.isInteger(n)) {
325         throw new FormatError(`Invalid XRef range fields: ${first}, ${n}`);
326       }
327       if (
328         !Number.isInteger(typeFieldWidth) ||
329         !Number.isInteger(offsetFieldWidth) ||
330         !Number.isInteger(generationFieldWidth)
331       ) {
332         throw new FormatError(
333           `Invalid XRef entry fields length: ${first}, ${n}`
334         );
335       }
336       for (let i = streamState.entryNum; i < n; ++i) {
337         streamState.entryNum = i;
338         streamState.streamPos = stream.pos;
339 
340         let type = 0,
341           offset = 0,
342           generation = 0;
343         for (let j = 0; j < typeFieldWidth; ++j) {
344           const typeByte = stream.getByte();
345           if (typeByte === -1) {
346             throw new FormatError("Invalid XRef byteWidths 'type'.");
347           }
348           type = (type << 8) | typeByte;
349         }
350         // if type field is absent, its default value is 1
351         if (typeFieldWidth === 0) {
352           type = 1;
353         }
354         for (let j = 0; j < offsetFieldWidth; ++j) {
355           const offsetByte = stream.getByte();
356           if (offsetByte === -1) {
357             throw new FormatError("Invalid XRef byteWidths 'offset'.");
358           }
359           offset = (offset << 8) | offsetByte;
360         }
361         for (let j = 0; j < generationFieldWidth; ++j) {
362           const generationByte = stream.getByte();
363           if (generationByte === -1) {
364             throw new FormatError("Invalid XRef byteWidths 'generation'.");
365           }
366           generation = (generation << 8) | generationByte;
367         }
368         const entry = {};
369         entry.offset = offset;
370         entry.gen = generation;
371         switch (type) {
372           case 0:
373             entry.free = true;
374             break;
375           case 1:
376             entry.uncompressed = true;
377             break;
378           case 2:
379             break;
380           default:
381             throw new FormatError(`Invalid XRef entry type: ${type}`);
382         }
383         if (!this.entries[first + i]) {
384           this.entries[first + i] = entry;
385         }
386       }
387 
388       streamState.entryNum = 0;
389       streamState.streamPos = stream.pos;
390       entryRanges.splice(0, 2);
391     }
392   }
393 
394   indexObjects() {
395     // Simple scan through the PDF content to find objects,
396     // trailers and XRef streams.
397     const TAB = 0x9,
398       LF = 0xa,
399       CR = 0xd,
400       SPACE = 0x20;
401     const PERCENT = 0x25,
402       LT = 0x3c;
403 
404     function readToken(data, offset) {
405       let token = "",
406         ch = data[offset];
407       while (ch !== LF && ch !== CR && ch !== LT) {
408         if (++offset >= data.length) {
409           break;
410         }
411         token += String.fromCharCode(ch);
412         ch = data[offset];
413       }
414       return token;
415     }
416     function skipUntil(data, offset, what) {
417       const length = what.length,
418         dataLength = data.length;
419       let skipped = 0;
420       // finding byte sequence
421       while (offset < dataLength) {
422         let i = 0;
423         while (i < length && data[offset + i] === what[i]) {
424           ++i;
425         }
426         if (i >= length) {
427           break; // sequence found
428         }
429         offset++;
430         skipped++;
431       }
432       return skipped;
433     }
434     const gEndobjRegExp = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer)\b/g;
435     const gStartxrefRegExp = /\b(startxref|\d+\s+\d+\s+obj)\b/g;
436     const objRegExp = /^(\d+)\s+(\d+)\s+obj\b/;
437 
438     const trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]);
439     const startxrefBytes = new Uint8Array([
440       115, 116, 97, 114, 116, 120, 114, 101, 102,
441     ]);
442     const xrefBytes = new Uint8Array([47, 88, 82, 101, 102]);
443 
444     // Clear out any existing entries, since they may be bogus.
445     this.entries.length = 0;
446     this._cacheMap.clear();
447 
448     const stream = this.stream;
449     stream.pos = 0;
450     const buffer = stream.getBytes(),
451       bufferStr = bytesToString(buffer),
452       length = buffer.length;
453     let position = stream.start;
454     const trailers = [],
455       xrefStms = [];
456     while (position < length) {
457       let ch = buffer[position];
458       if (ch === TAB || ch === LF || ch === CR || ch === SPACE) {
459         ++position;
460         continue;
461       }
462       if (ch === PERCENT) {
463         // %-comment
464         do {
465           ++position;
466           if (position >= length) {
467             break;
468           }
469           ch = buffer[position];
470         } while (ch !== LF && ch !== CR);
471         continue;
472       }
473       const token = readToken(buffer, position);
474       let m;
475       if (
476         token.startsWith("xref") &&
477         (token.length === 4 || /\s/.test(token[4]))
478       ) {
479         position += skipUntil(buffer, position, trailerBytes);
480         trailers.push(position);
481         position += skipUntil(buffer, position, startxrefBytes);
482       } else if ((m = objRegExp.exec(token))) {
483         const num = m[1] | 0,
484           gen = m[2] | 0;
485 
486         const startPos = position + token.length;
487         let contentLength,
488           updateEntries = false;
489         if (!this.entries[num]) {
490           updateEntries = true;
491         } else if (this.entries[num].gen === gen) {
492           // Before overwriting an existing entry, ensure that the new one won't
493           // cause *immediate* errors when it's accessed (fixes issue13783.pdf).
494           try {
495             const parser = new Parser({
496               lexer: new Lexer(stream.makeSubStream(startPos)),
497             });
498             parser.getObj();
499             updateEntries = true;
500           } catch (ex) {
501             if (ex instanceof ParserEOFException) {
502               warn(`indexObjects -- checking object (${token}): "${ex}".`);
503             } else {
504               // The error may come from the `Parser`-instance being initialized
505               // without an `XRef`-instance (we don't have a usable one yet).
506               updateEntries = true;
507             }
508           }
509         }
510         if (updateEntries) {
511           this.entries[num] = {
512             offset: position - stream.start,
513             gen,
514             uncompressed: true,
515           };
516         }
517 
518         // Find the next "obj" string, rather than "endobj", to ensure that
519         // we won't skip over a new 'obj' operator in corrupt files where
520         // 'endobj' operators are missing (fixes issue9105_reduced.pdf).
521         gEndobjRegExp.lastIndex = startPos;
522         const match = gEndobjRegExp.exec(bufferStr);
523 
524         if (match) {
525           const endPos = gEndobjRegExp.lastIndex + 1;
526           contentLength = endPos - position;
527 
528           if (match[1] !== "endobj") {
529             warn(
530               `indexObjects: Found "${match[1]}" inside of another "obj", ` +
531                 'caused by missing "endobj" -- trying to recover.'
532             );
533             contentLength -= match[1].length + 1;
534           }
535         } else {
536           contentLength = length - position;
537         }
538         const content = buffer.subarray(position, position + contentLength);
539 
540         // checking XRef stream suspect
541         // (it shall have '/XRef' and next char is not a letter)
542         const xrefTagOffset = skipUntil(content, 0, xrefBytes);
543         if (xrefTagOffset < contentLength && content[xrefTagOffset + 5] < 64) {
544           xrefStms.push(position - stream.start);
545           this._xrefStms.add(position - stream.start); // Avoid recursion
546         }
547 
548         position += contentLength;
549       } else if (
550         token.startsWith("trailer") &&
551         (token.length === 7 || /\s/.test(token[7]))
552       ) {
553         trailers.push(position);
554 
555         const startPos = position + token.length;
556         let contentLength;
557         // Attempt to handle (some) corrupt documents, where no 'startxref'
558         // operators are present (fixes issue15590.pdf).
559         gStartxrefRegExp.lastIndex = startPos;
560         const match = gStartxrefRegExp.exec(bufferStr);
561 
562         if (match) {
563           const endPos = gStartxrefRegExp.lastIndex + 1;
564           contentLength = endPos - position;
565 
566           if (match[1] !== "startxref") {
567             warn(
568               `indexObjects: Found "${match[1]}" after "trailer", ` +
569                 'caused by missing "startxref" -- trying to recover.'
570             );
571             contentLength -= match[1].length + 1;
572           }
573         } else {
574           contentLength = length - position;
575         }
576         position += contentLength;
577       } else {
578         position += token.length + 1;
579       }
580     }
581     // reading XRef streams
582     for (const xrefStm of xrefStms) {
583       this.startXRefQueue.push(xrefStm);
584       this.readXRef(/* recoveryMode */ true);
585     }
586 
587     const trailerDicts = [];
588     // Pre-parsing the trailers to check if the document is possibly encrypted.
589     let isEncrypted = false;
590     for (const trailer of trailers) {
591       stream.pos = trailer;
592       const parser = new Parser({
593         lexer: new Lexer(stream),
594         xref: this,
595         allowStreams: true,
596         recoveryMode: true,
597       });
598       const obj = parser.getObj();
599       if (!isCmd(obj, "trailer")) {
600         continue;
601       }
602       // read the trailer dictionary
603       const dict = parser.getObj();
604       if (!(dict instanceof Dict)) {
605         continue;
606       }
607       trailerDicts.push(dict);
608 
609       if (dict.has("Encrypt")) {
610         isEncrypted = true;
611       }
612     }
613 
614     // finding main trailer
615     let trailerDict, trailerError;
616     for (const dict of [...trailerDicts, "genFallback", ...trailerDicts]) {
617       if (dict === "genFallback") {
618         if (!trailerError) {
619           break; // No need to fallback if there were no validation errors.
620         }
621         this._generationFallback = true;
622         continue;
623       }
624       // Do some basic validation of the trailer/root dictionary candidate.
625       let validPagesDict = false;
626       try {
627         const rootDict = dict.get("Root");
628         if (!(rootDict instanceof Dict)) {
629           continue;
630         }
631         const pagesDict = rootDict.get("Pages");
632         if (!(pagesDict instanceof Dict)) {
633           continue;
634         }
635         const pagesCount = pagesDict.get("Count");
636         if (Number.isInteger(pagesCount)) {
637           validPagesDict = true;
638         }
639         // The top-level /Pages dictionary isn't obviously corrupt.
640       } catch (ex) {
641         trailerError = ex;
642         continue;
643       }
644       // taking the first one with 'ID'
645       if (
646         validPagesDict &&
647         (!isEncrypted || dict.has("Encrypt")) &&
648         dict.has("ID")
649       ) {
650         return dict;
651       }
652       // The current dictionary is a candidate, but continue searching.
653       trailerDict = dict;
654     }
655     // No trailer with 'ID', taking last one (if exists).
656     if (trailerDict) {
657       return trailerDict;
658     }
659     // No trailer dictionary found, taking the "top"-dictionary (if exists).
660     if (this.topDict) {
661       return this.topDict;
662     }
663     // nothing helps
664     throw new InvalidPDFException("Invalid PDF structure.");
665   }
666 
667   readXRef(recoveryMode = false) {
668     const stream = this.stream;
669     // Keep track of already parsed XRef tables, to prevent an infinite loop
670     // when parsing corrupt PDF files where e.g. the /Prev entries create a
671     // circular dependency between tables (fixes bug1393476.pdf).
672     const startXRefParsedCache = new Set();
673 
674     while (this.startXRefQueue.length) {
675       try {
676         const startXRef = this.startXRefQueue[0];
677 
678         if (startXRefParsedCache.has(startXRef)) {
679           warn("readXRef - skipping XRef table since it was already parsed.");
680           this.startXRefQueue.shift();
681           continue;
682         }
683         startXRefParsedCache.add(startXRef);
684 
685         stream.pos = startXRef + stream.start;
686 
687         const parser = new Parser({
688           lexer: new Lexer(stream),
689           xref: this,
690           allowStreams: true,
691         });
692         let obj = parser.getObj();
693         let dict;
694 
695         // Get dictionary
696         if (isCmd(obj, "xref")) {
697           // Parse end-of-file XRef
698           dict = this.processXRefTable(parser);
699           if (!this.topDict) {
700             this.topDict = dict;
701           }
702 
703           // Recursively get other XRefs 'XRefStm', if any
704           obj = dict.get("XRefStm");
705           if (Number.isInteger(obj) && !this._xrefStms.has(obj)) {
706             // ignore previously loaded xref streams
707             // (possible infinite recursion)
708             this._xrefStms.add(obj);
709             this.startXRefQueue.push(obj);
710             this.#firstXRefStmPos ??= obj;
711           }
712         } else if (Number.isInteger(obj)) {
713           // Parse in-stream XRef
714           if (
715             !Number.isInteger(parser.getObj()) ||
716             !isCmd(parser.getObj(), "obj") ||
717             !((obj = parser.getObj()) instanceof BaseStream)
718           ) {
719             throw new FormatError("Invalid XRef stream");
720           }
721           dict = this.processXRefStream(obj);
722           if (!this.topDict) {
723             this.topDict = dict;
724           }
725           if (!dict) {
726             throw new FormatError("Failed to read XRef stream");
727           }
728         } else {
729           throw new FormatError("Invalid XRef stream header");
730         }
731 
732         // Recursively get previous dictionary, if any
733         obj = dict.get("Prev");
734         if (Number.isInteger(obj)) {
735           this.startXRefQueue.push(obj);
736         } else if (obj instanceof Ref) {
737           // The spec says Prev must not be a reference, i.e. "/Prev NNN"
738           // This is a fallback for non-compliant PDFs, i.e. "/Prev NNN 0 R"
739           this.startXRefQueue.push(obj.num);
740         }
741       } catch (e) {
742         if (e instanceof MissingDataException) {
743           throw e;
744         }
745         info("(while reading XRef): " + e);
746       }
747       this.startXRefQueue.shift();
748     }
749 
750     if (this.topDict) {
751       return this.topDict;
752     }
753     if (recoveryMode) {
754       return undefined;
755     }
756     throw new XRefParseException();
757   }
758 
759   get lastXRefStreamPos() {
760     return (
761       this.#firstXRefStmPos ??
762       (this._xrefStms.size > 0 ? Math.max(...this._xrefStms) : null)
763     );
764   }
765 
766   getEntry(i) {
767     const xrefEntry = this.entries[i];
768     if (xrefEntry && !xrefEntry.free && xrefEntry.offset) {
769       return xrefEntry;
770     }
771     return null;
772   }
773 
774   fetchIfRef(obj, suppressEncryption = false) {
775     if (obj instanceof Ref) {
776       return this.fetch(obj, suppressEncryption);
777     }
778     return obj;
779   }
780 
781   fetch(ref, suppressEncryption = false) {
782     if (!(ref instanceof Ref)) {
783       throw new Error("ref object is not a reference");
784     }
785     const num = ref.num;
786 
787     // The XRef cache is populated with objects which are obtained through
788     // `Parser.getObj`, and indirectly via `Lexer.getObj`. Neither of these
789     // methods should ever return `undefined` (note the `assert` calls below).
790     const cacheEntry = this._cacheMap.get(num);
791     if (cacheEntry !== undefined) {
792       // In documents with Object Streams, it's possible that cached `Dict`s
793       // have not been assigned an `objId` yet (see e.g. issue3115r.pdf).
794       if (cacheEntry instanceof Dict && !cacheEntry.objId) {
795         cacheEntry.objId = ref.toString();
796       }
797       return cacheEntry;
798     }
799     let xrefEntry = this.getEntry(num);
800 
801     if (xrefEntry === null) {
802       // The referenced entry can be free.
803       this._cacheMap.set(num, xrefEntry);
804       return xrefEntry;
805     }
806     // Prevent circular references, in corrupt PDF documents, from hanging the
807     // worker-thread. This relies, implicitly, on the parsing being synchronous.
808     if (this._pendingRefs.has(ref)) {
809       this._pendingRefs.remove(ref);
810 
811       warn(`Ignoring circular reference: ${ref}.`);
812       return CIRCULAR_REF;
813     }
814     this._pendingRefs.put(ref);
815 
816     try {
817       xrefEntry = xrefEntry.uncompressed
818         ? this.fetchUncompressed(ref, xrefEntry, suppressEncryption)
819         : this.fetchCompressed(ref, xrefEntry, suppressEncryption);
820       this._pendingRefs.remove(ref);
821     } catch (ex) {
822       this._pendingRefs.remove(ref);
823       throw ex;
824     }
825     if (xrefEntry instanceof Dict) {
826       xrefEntry.objId = ref.toString();
827     } else if (xrefEntry instanceof BaseStream) {
828       xrefEntry.dict.objId = ref.toString();
829     }
830     return xrefEntry;
831   }
832 
833   fetchUncompressed(ref, xrefEntry, suppressEncryption = false) {
834     const gen = ref.gen;
835     let num = ref.num;
836     if (xrefEntry.gen !== gen) {
837       const msg = `Inconsistent generation in XRef: ${ref}`;
838       // Try falling back to a *previous* generation (fixes issue15577.pdf).
839       if (this._generationFallback && xrefEntry.gen < gen) {
840         warn(msg);
841         return this.fetchUncompressed(
842           Ref.get(num, xrefEntry.gen),
843           xrefEntry,
844           suppressEncryption
845         );
846       }
847       throw new XRefEntryException(msg);
848     }
849     const stream = this.stream.makeSubStream(
850       xrefEntry.offset + this.stream.start
851     );
852     const parser = new Parser({
853       lexer: new Lexer(stream),
854       xref: this,
855       allowStreams: true,
856     });
857     const obj1 = parser.getObj();
858     const obj2 = parser.getObj();
859     const obj3 = parser.getObj();
860 
861     if (obj1 !== num || obj2 !== gen || !(obj3 instanceof Cmd)) {
862       throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`);
863     }
864     if (obj3.cmd !== "obj") {
865       // some bad PDFs use "obj1234" and really mean 1234
866       if (obj3.cmd.startsWith("obj")) {
867         num = parseInt(obj3.cmd.substring(3), 10);
868         if (!Number.isNaN(num)) {
869           return num;
870         }
871       }
872       throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`);
873     }
874     xrefEntry =
875       this.encrypt && !suppressEncryption
876         ? parser.getObj(this.encrypt.createCipherTransform(num, gen))
877         : parser.getObj();
878     if (!(xrefEntry instanceof BaseStream)) {
879       if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
880         assert(
881           xrefEntry !== undefined,
882           'fetchUncompressed: The "xrefEntry" cannot be undefined.'
883         );
884       }
885       this._cacheMap.set(num, xrefEntry);
886     }
887     return xrefEntry;
888   }
889 
890   fetchCompressed(ref, xrefEntry, suppressEncryption = false) {
891     const tableOffset = xrefEntry.offset;
892     const stream = this.fetch(Ref.get(tableOffset, 0));
893     if (!(stream instanceof BaseStream)) {
894       throw new FormatError("bad ObjStm stream");
895     }
896     const first = stream.dict.get("First");
897     const n = stream.dict.get("N");
898     if (!Number.isInteger(first) || !Number.isInteger(n)) {
899       throw new FormatError("invalid first and n parameters for ObjStm stream");
900     }
901     let parser = new Parser({
902       lexer: new Lexer(stream),
903       xref: this,
904       allowStreams: true,
905     });
906     const nums = new Array(n);
907     const offsets = new Array(n);
908     // read the object numbers to populate cache
909     for (let i = 0; i < n; ++i) {
910       const num = parser.getObj();
911       if (!Number.isInteger(num)) {
912         throw new FormatError(
913           `invalid object number in the ObjStm stream: ${num}`
914         );
915       }
916       const offset = parser.getObj();
917       if (!Number.isInteger(offset)) {
918         throw new FormatError(
919           `invalid object offset in the ObjStm stream: ${offset}`
920         );
921       }
922       nums[i] = num;
923       offsets[i] = offset;
924     }
925 
926     const start = (stream.start || 0) + first;
927     const entries = new Array(n);
928     // read stream objects for cache
929     for (let i = 0; i < n; ++i) {
930       const length = i < n - 1 ? offsets[i + 1] - offsets[i] : undefined;
931       if (length < 0) {
932         throw new FormatError("Invalid offset in the ObjStm stream.");
933       }
934       parser = new Parser({
935         lexer: new Lexer(
936           stream.makeSubStream(start + offsets[i], length, stream.dict)
937         ),
938         xref: this,
939         allowStreams: true,
940       });
941 
942       const obj = parser.getObj();
943       entries[i] = obj;
944       if (obj instanceof BaseStream) {
945         continue;
946       }
947       const num = nums[i],
948         entry = this.entries[num];
949       if (entry && entry.offset === tableOffset && entry.gen === i) {
950         if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
951           assert(
952             obj !== undefined,
953             'fetchCompressed: The "obj" cannot be undefined.'
954           );
955         }
956         this._cacheMap.set(num, obj);
957       }
958     }
959     xrefEntry = entries[xrefEntry.gen];
960     if (xrefEntry === undefined) {
961       throw new XRefEntryException(`Bad (compressed) XRef entry: ${ref}`);
962     }
963     return xrefEntry;
964   }
965 
966   async fetchIfRefAsync(obj, suppressEncryption) {
967     if (obj instanceof Ref) {
968       return this.fetchAsync(obj, suppressEncryption);
969     }
970     return obj;
971   }
972 
973   async fetchAsync(ref, suppressEncryption) {
974     try {
975       return this.fetch(ref, suppressEncryption);
976     } catch (ex) {
977       if (!(ex instanceof MissingDataException)) {
978         throw ex;
979       }
980       await this.pdfManager.requestRange(ex.begin, ex.end);
981       return this.fetchAsync(ref, suppressEncryption);
982     }
983   }
984 
985   getCatalogObj() {
986     return this.root;
987   }
988 }
989 
990 export { XRef };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

