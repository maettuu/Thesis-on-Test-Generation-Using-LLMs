Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: content is not visible in some fields.
### Attach (recommended) or Link to PDF file

[TEST_TM DATA ENTRY.pdf](https://github.com/user-attachments/files/17843174/TEST_TM.DATA.ENTRY.pdf)


### Web browser and its version

chrome, 131.0.6778.71

### Operating system and its version

MAC OS, 14.7.1

### PDF.js version

4.8.69

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

1. Open the above attached PDF, in page 6, the account number is not visible if the PDF is opened using PDF. But PDF is opened in any other viewer like adobe or chrome, the account name is visible.

### What is the expected behavior?

![in adobe](https://github.com/user-attachments/assets/7584880a-a43d-4536-9d4e-9d2ffec379f9)
The content should be visible in these fields where marked with red box in the screenshot.

### What went wrong?

![In PDF JS](https://github.com/user-attachments/assets/7ca62bb0-cb04-48a9-9629-dbbe19d71346)
The content is not visible in these fields where marked with red box in the screenshot.

### Link to a viewer

_No response_

### Additional context

_No response_
</issue>

Patch:
<patch>
diff --git a/src/core/annotation.js b/src/core/annotation.js
--- a/src/core/annotation.js
+++ b/src/core/annotation.js
@@ -3511,6 +3511,18 @@ class ChoiceWidgetAnnotation extends WidgetAnnotation {
       }
     }
 
+    // It's a workaround for the issue #19083.
+    // Normally a choice widget is a mix of a text field and a listbox,
+    // So in the case where the V entry isn't an option we should just set it
+    // as the text field value.
+    if (this.data.options.length === 0 && this.data.fieldValue.length > 0) {
+      // If there are no options, then the field value is the only option.
+      this.data.options = this.data.fieldValue.map(value => ({
+        exportValue: value,
+        displayValue: value,
+      }));
+    }
+
     // Process field flags for the display layer.
     this.data.combo = this.hasFieldFlag(AnnotationFieldFlag.COMBO);
     this.data.multiSelect = this.hasFieldFlag(AnnotationFieldFlag.MULTISELECT);


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.0
- @babel/preset-env: ^7.26.0
- @babel/runtime: ^7.26.0
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @jazzer.js/core: ^2.1.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.62
- @types/node: ^22.9.0
- autoprefixer: ^10.4.20
- babel-loader: ^9.2.1
- caniuse-lite: ^1.0.30001680
- core-js: ^3.39.0
- eslint: ^9.15.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^3.9.1
- eslint-plugin-prettier: ^5.2.1
- eslint-plugin-unicorn: ^56.0.0
- globals: ^15.12.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- highlight.js: ^11.10.0
- jasmine: ^5.4.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.4.49
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.3.3
- puppeteer: 23.3.1
- stylelint: ^16.10.0
- stylelint-prettier: ^5.0.2
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.10
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.6.3
- vinyl: ^3.0.0
- webpack: ^5.96.1
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: fetchData
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory, createTemporaryNodeServer
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/annotation.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AnnotationActionEventType,
18   AnnotationBorderStyleType,
19   AnnotationEditorType,
20   AnnotationFieldFlag,
21   AnnotationFlag,
22   AnnotationReplyType,
23   AnnotationType,
24   assert,
25   BASELINE_FACTOR,
26   FeatureTest,
27   getModificationDate,
28   IDENTITY_MATRIX,
29   info,
30   isArrayEqual,
31   LINE_DESCENT_FACTOR,
32   LINE_FACTOR,
33   OPS,
34   RenderingIntentFlag,
35   shadow,
36   stringToPDFString,
37   unreachable,
38   Util,
39   warn,
40 } from "../shared/util.js";
41 import {
42   collectActions,
43   escapeString,
44   getInheritableProperty,
45   getParentToUpdate,
46   getRotationMatrix,
47   isNumberArray,
48   lookupMatrix,
49   lookupNormalRect,
50   lookupRect,
51   numberToString,
52   stringToAsciiOrUTF16BE,
53   stringToUTF16String,
54 } from "./core_utils.js";
55 import {
56   createDefaultAppearance,
57   FakeUnicodeFont,
58   getPdfColor,
59   parseAppearanceStream,
60   parseDefaultAppearance,
61 } from "./default_appearance.js";
62 import { Dict, isName, isRefsEqual, Name, Ref, RefSet } from "./primitives.js";
63 import { Stream, StringStream } from "./stream.js";
64 import { BaseStream } from "./base_stream.js";
65 import { bidi } from "./bidi.js";
66 import { Catalog } from "./catalog.js";
67 import { ColorSpace } from "./colorspace.js";
68 import { FileSpec } from "./file_spec.js";
69 import { JpegStream } from "./jpeg_stream.js";
70 import { ObjectLoader } from "./object_loader.js";
71 import { OperatorList } from "./operator_list.js";
72 import { XFAFactory } from "./xfa/factory.js";
73 
74 class AnnotationFactory {
75   static createGlobals(pdfManager) {
76     return Promise.all([
77       pdfManager.ensureCatalog("acroForm"),
78       pdfManager.ensureDoc("xfaDatasets"),
79       pdfManager.ensureCatalog("structTreeRoot"),
80       // Only necessary to prevent the `Catalog.baseUrl`-getter, used
81       // with some Annotations, from throwing and thus breaking parsing:
82       pdfManager.ensureCatalog("baseUrl"),
83       // Only necessary to prevent the `Catalog.attachments`-getter, used
84       // with "GoToE" actions, from throwing and thus breaking parsing:
85       pdfManager.ensureCatalog("attachments"),
86     ]).then(
87       // eslint-disable-next-line arrow-body-style
88       ([acroForm, xfaDatasets, structTreeRoot, baseUrl, attachments]) => {
89         return {
90           pdfManager,
91           acroForm: acroForm instanceof Dict ? acroForm : Dict.empty,
92           xfaDatasets,
93           structTreeRoot,
94           baseUrl,
95           attachments,
96         };
97       },
98       reason => {
99         warn(`createGlobals: "${reason}".`);
100         return null;
101       }
102     );
103   }
104 
105   /**
106    * Create an `Annotation` object of the correct type for the given reference
107    * to an annotation dictionary. This yields a promise that is resolved when
108    * the `Annotation` object is constructed.
109    *
110    * @param {XRef} xref
111    * @param {Object} ref
112    * @params {Object} annotationGlobals
113    * @param {Object} idFactory
114    * @param {boolean} [collectFields]
115    * @param {Object} [orphanFields]
116    * @param {Object} [pageRef]
117    * @returns {Promise} A promise that is resolved with an {Annotation}
118    *   instance.
119    */
120   static async create(
121     xref,
122     ref,
123     annotationGlobals,
124     idFactory,
125     collectFields,
126     orphanFields,
127     pageRef
128   ) {
129     const pageIndex = collectFields
130       ? await this._getPageIndex(xref, ref, annotationGlobals.pdfManager)
131       : null;
132 
133     return annotationGlobals.pdfManager.ensure(this, "_create", [
134       xref,
135       ref,
136       annotationGlobals,
137       idFactory,
138       collectFields,
139       orphanFields,
140       pageIndex,
141       pageRef,
142     ]);
143   }
144 
145   /**
146    * @private
147    */
148   static _create(
149     xref,
150     ref,
151     annotationGlobals,
152     idFactory,
153     collectFields = false,
154     orphanFields = null,
155     pageIndex = null,
156     pageRef = null
157   ) {
158     const dict = xref.fetchIfRef(ref);
159     if (!(dict instanceof Dict)) {
160       return undefined;
161     }
162 
163     const { acroForm, pdfManager } = annotationGlobals;
164     const id =
165       ref instanceof Ref ? ref.toString() : `annot_${idFactory.createObjId()}`;
166 
167     // Determine the annotation's subtype.
168     let subtype = dict.get("Subtype");
169     subtype = subtype instanceof Name ? subtype.name : null;
170 
171     // Return the right annotation object based on the subtype and field type.
172     const parameters = {
173       xref,
174       ref,
175       dict,
176       subtype,
177       id,
178       annotationGlobals,
179       collectFields,
180       orphanFields,
181       needAppearances:
182         !collectFields && acroForm.get("NeedAppearances") === true,
183       pageIndex,
184       evaluatorOptions: pdfManager.evaluatorOptions,
185       pageRef,
186     };
187 
188     switch (subtype) {
189       case "Link":
190         return new LinkAnnotation(parameters);
191 
192       case "Text":
193         return new TextAnnotation(parameters);
194 
195       case "Widget":
196         let fieldType = getInheritableProperty({ dict, key: "FT" });
197         fieldType = fieldType instanceof Name ? fieldType.name : null;
198 
199         switch (fieldType) {
200           case "Tx":
201             return new TextWidgetAnnotation(parameters);
202           case "Btn":
203             return new ButtonWidgetAnnotation(parameters);
204           case "Ch":
205             return new ChoiceWidgetAnnotation(parameters);
206           case "Sig":
207             return new SignatureWidgetAnnotation(parameters);
208         }
209         warn(
210           `Unimplemented widget field type "${fieldType}", ` +
211             "falling back to base field type."
212         );
213         return new WidgetAnnotation(parameters);
214 
215       case "Popup":
216         return new PopupAnnotation(parameters);
217 
218       case "FreeText":
219         return new FreeTextAnnotation(parameters);
220 
221       case "Line":
222         return new LineAnnotation(parameters);
223 
224       case "Square":
225         return new SquareAnnotation(parameters);
226 
227       case "Circle":
228         return new CircleAnnotation(parameters);
229 
230       case "PolyLine":
231         return new PolylineAnnotation(parameters);
232 
233       case "Polygon":
234         return new PolygonAnnotation(parameters);
235 
236       case "Caret":
237         return new CaretAnnotation(parameters);
238 
239       case "Ink":
240         return new InkAnnotation(parameters);
241 
242       case "Highlight":
243         return new HighlightAnnotation(parameters);
244 
245       case "Underline":
246         return new UnderlineAnnotation(parameters);
247 
248       case "Squiggly":
249         return new SquigglyAnnotation(parameters);
250 
251       case "StrikeOut":
252         return new StrikeOutAnnotation(parameters);
253 
254       case "Stamp":
255         return new StampAnnotation(parameters);
256 
257       case "FileAttachment":
258         return new FileAttachmentAnnotation(parameters);
259 
260       default:
261         if (!collectFields) {
262           if (!subtype) {
263             warn("Annotation is missing the required /Subtype.");
264           } else {
265             warn(
266               `Unimplemented annotation type "${subtype}", ` +
267                 "falling back to base annotation."
268             );
269           }
270         }
271         return new Annotation(parameters);
272     }
273   }
274 
275   static async _getPageIndex(xref, ref, pdfManager) {
276     try {
277       const annotDict = await xref.fetchIfRefAsync(ref);
278       if (!(annotDict instanceof Dict)) {
279         return -1;
280       }
281       const pageRef = annotDict.getRaw("P");
282       if (pageRef instanceof Ref) {
283         try {
284           const pageIndex = await pdfManager.ensureCatalog("getPageIndex", [
285             pageRef,
286           ]);
287           return pageIndex;
288         } catch (ex) {
289           info(`_getPageIndex -- not a valid page reference: "${ex}".`);
290         }
291       }
292       if (annotDict.has("Kids")) {
293         return -1; // Not an annotation reference.
294       }
295       // Fallback to, potentially, checking the annotations of all pages.
296       // PLEASE NOTE: This could force the *entire* PDF document to load,
297       //              hence it absolutely cannot be done unconditionally.
298       const numPages = await pdfManager.ensureDoc("numPages");
299 
300       for (let pageIndex = 0; pageIndex < numPages; pageIndex++) {
301         const page = await pdfManager.getPage(pageIndex);
302         const annotations = await pdfManager.ensure(page, "annotations");
303 
304         for (const annotRef of annotations) {
305           if (annotRef instanceof Ref && isRefsEqual(annotRef, ref)) {
306             return pageIndex;
307           }
308         }
309       }
310     } catch (ex) {
311       warn(`_getPageIndex: "${ex}".`);
312     }
313     return -1;
314   }
315 
316   static generateImages(annotations, xref, isOffscreenCanvasSupported) {
317     if (!isOffscreenCanvasSupported) {
318       warn(
319         "generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images."
320       );
321       return null;
322     }
323     let imagePromises;
324     for (const { bitmapId, bitmap } of annotations) {
325       if (!bitmap) {
326         continue;
327       }
328       imagePromises ||= new Map();
329       imagePromises.set(bitmapId, StampAnnotation.createImage(bitmap, xref));
330     }
331 
332     return imagePromises;
333   }
334 
335   static async saveNewAnnotations(
336     evaluator,
337     task,
338     annotations,
339     imagePromises,
340     changes
341   ) {
342     const xref = evaluator.xref;
343     let baseFontRef;
344     const promises = [];
345     const { isOffscreenCanvasSupported } = evaluator.options;
346 
347     for (const annotation of annotations) {
348       if (annotation.deleted) {
349         continue;
350       }
351       switch (annotation.annotationType) {
352         case AnnotationEditorType.FREETEXT:
353           if (!baseFontRef) {
354             const baseFont = new Dict(xref);
355             baseFont.set("BaseFont", Name.get("Helvetica"));
356             baseFont.set("Type", Name.get("Font"));
357             baseFont.set("Subtype", Name.get("Type1"));
358             baseFont.set("Encoding", Name.get("WinAnsiEncoding"));
359             baseFontRef = xref.getNewTemporaryRef();
360             changes.put(baseFontRef, {
361               data: baseFont,
362             });
363           }
364           promises.push(
365             FreeTextAnnotation.createNewAnnotation(xref, annotation, changes, {
366               evaluator,
367               task,
368               baseFontRef,
369             })
370           );
371           break;
372         case AnnotationEditorType.HIGHLIGHT:
373           if (annotation.quadPoints) {
374             promises.push(
375               HighlightAnnotation.createNewAnnotation(xref, annotation, changes)
376             );
377           } else {
378             promises.push(
379               InkAnnotation.createNewAnnotation(xref, annotation, changes)
380             );
381           }
382           break;
383         case AnnotationEditorType.INK:
384           promises.push(
385             InkAnnotation.createNewAnnotation(xref, annotation, changes)
386           );
387           break;
388         case AnnotationEditorType.STAMP:
389           const image = isOffscreenCanvasSupported
390             ? await imagePromises?.get(annotation.bitmapId)
391             : null;
392           if (image?.imageStream) {
393             const { imageStream, smaskStream } = image;
394             if (smaskStream) {
395               const smaskRef = xref.getNewTemporaryRef();
396               changes.put(smaskRef, {
397                 data: smaskStream,
398               });
399               imageStream.dict.set("SMask", smaskRef);
400             }
401             const imageRef = (image.imageRef = xref.getNewTemporaryRef());
402             changes.put(imageRef, {
403               data: imageStream,
404             });
405             image.imageStream = image.smaskStream = null;
406           }
407           promises.push(
408             StampAnnotation.createNewAnnotation(xref, annotation, changes, {
409               image,
410             })
411           );
412           break;
413       }
414     }
415 
416     return {
417       annotations: await Promise.all(promises),
418     };
419   }
420 
421   static async printNewAnnotations(
422     annotationGlobals,
423     evaluator,
424     task,
425     annotations,
426     imagePromises
427   ) {
428     if (!annotations) {
429       return null;
430     }
431 
432     const { options, xref } = evaluator;
433     const promises = [];
434     for (const annotation of annotations) {
435       if (annotation.deleted) {
436         continue;
437       }
438       switch (annotation.annotationType) {
439         case AnnotationEditorType.FREETEXT:
440           promises.push(
441             FreeTextAnnotation.createNewPrintAnnotation(
442               annotationGlobals,
443               xref,
444               annotation,
445               {
446                 evaluator,
447                 task,
448                 evaluatorOptions: options,
449               }
450             )
451           );
452           break;
453         case AnnotationEditorType.HIGHLIGHT:
454           if (annotation.quadPoints) {
455             promises.push(
456               HighlightAnnotation.createNewPrintAnnotation(
457                 annotationGlobals,
458                 xref,
459                 annotation,
460                 {
461                   evaluatorOptions: options,
462                 }
463               )
464             );
465           } else {
466             promises.push(
467               InkAnnotation.createNewPrintAnnotation(
468                 annotationGlobals,
469                 xref,
470                 annotation,
471                 {
472                   evaluatorOptions: options,
473                 }
474               )
475             );
476           }
477           break;
478         case AnnotationEditorType.INK:
479           promises.push(
480             InkAnnotation.createNewPrintAnnotation(
481               annotationGlobals,
482               xref,
483               annotation,
484               {
485                 evaluatorOptions: options,
486               }
487             )
488           );
489           break;
490         case AnnotationEditorType.STAMP:
491           const image = options.isOffscreenCanvasSupported
492             ? await imagePromises?.get(annotation.bitmapId)
493             : null;
494           if (image?.imageStream) {
495             const { imageStream, smaskStream } = image;
496             if (smaskStream) {
497               imageStream.dict.set("SMask", smaskStream);
498             }
499             image.imageRef = new JpegStream(imageStream, imageStream.length);
500             image.imageStream = image.smaskStream = null;
501           }
502           promises.push(
503             StampAnnotation.createNewPrintAnnotation(
504               annotationGlobals,
505               xref,
506               annotation,
507               {
508                 image,
509                 evaluatorOptions: options,
510               }
511             )
512           );
513           break;
514       }
515     }
516 
517     return Promise.all(promises);
518   }
519 }
520 
521 function getRgbColor(color, defaultColor = new Uint8ClampedArray(3)) {
522   if (!Array.isArray(color)) {
523     return defaultColor;
524   }
525 
526   const rgbColor = defaultColor || new Uint8ClampedArray(3);
527   switch (color.length) {
528     case 0: // Transparent, which we indicate with a null value
529       return null;
530 
531     case 1: // Convert grayscale to RGB
532       ColorSpace.singletons.gray.getRgbItem(color, 0, rgbColor, 0);
533       return rgbColor;
534 
535     case 3: // Convert RGB percentages to RGB
536       ColorSpace.singletons.rgb.getRgbItem(color, 0, rgbColor, 0);
537       return rgbColor;
538 
539     case 4: // Convert CMYK to RGB
540       ColorSpace.singletons.cmyk.getRgbItem(color, 0, rgbColor, 0);
541       return rgbColor;
542 
543     default:
544       return defaultColor;
545   }
546 }
547 
548 function getPdfColorArray(color) {
549   return Array.from(color, c => c / 255);
550 }
551 
552 function getQuadPoints(dict, rect) {
553   // The region is described as a number of quadrilaterals.
554   // Each quadrilateral must consist of eight coordinates.
555   const quadPoints = dict.getArray("QuadPoints");
556   if (
557     !isNumberArray(quadPoints, null) ||
558     quadPoints.length === 0 ||
559     quadPoints.length % 8 > 0
560   ) {
561     return null;
562   }
563 
564   const newQuadPoints = new Float32Array(quadPoints.length);
565   for (let i = 0, ii = quadPoints.length; i < ii; i += 8) {
566     // Each series of eight numbers represents the coordinates for one
567     // quadrilateral in the order [x1, y1, x2, y2, x3, y3, x4, y4].
568     // Convert this to an array of objects with x and y coordinates.
569     const [x1, y1, x2, y2, x3, y3, x4, y4] = quadPoints.slice(i, i + 8);
570     const minX = Math.min(x1, x2, x3, x4);
571     const maxX = Math.max(x1, x2, x3, x4);
572     const minY = Math.min(y1, y2, y3, y4);
573     const maxY = Math.max(y1, y2, y3, y4);
574     // The quadpoints should be ignored if any coordinate in the array
575     // lies outside the region specified by the rectangle. The rectangle
576     // can be `null` for markup annotations since their rectangle may be
577     // incorrect (fixes bug 1538111).
578     if (
579       rect !== null &&
580       (minX < rect[0] || maxX > rect[2] || minY < rect[1] || maxY > rect[3])
581     ) {
582       return null;
583     }
584     // The PDF specification states in section 12.5.6.10 (figure 64) that the
585     // order of the quadpoints should be bottom left, bottom right, top right
586     // and top left. However, in practice PDF files use a different order,
587     // namely bottom left, bottom right, top left and top right (this is also
588     // mentioned on https://github.com/highkite/pdfAnnotate#QuadPoints), so
589     // this is the actual order we should work with. However, the situation is
590     // even worse since Adobe's own applications and other applications violate
591     // the specification and create annotations with other orders, namely top
592     // left, top right, bottom left and bottom right or even top left,
593     // top right, bottom right and bottom left. To avoid inconsistency and
594     // broken rendering, we normalize all lists to put the quadpoints in the
595     // same standard order (see https://stackoverflow.com/a/10729881).
596     newQuadPoints.set([minX, maxY, maxX, maxY, minX, minY, maxX, minY], i);
597   }
598   return newQuadPoints;
599 }
600 
601 function getTransformMatrix(rect, bbox, matrix) {
602   // 12.5.5: Algorithm: Appearance streams
603   const [minX, minY, maxX, maxY] = Util.getAxialAlignedBoundingBox(
604     bbox,
605     matrix
606   );
607   if (minX === maxX || minY === maxY) {
608     // From real-life file, bbox was [0, 0, 0, 0]. In this case,
609     // just apply the transform for rect
610     return [1, 0, 0, 1, rect[0], rect[1]];
611   }
612 
613   const xRatio = (rect[2] - rect[0]) / (maxX - minX);
614   const yRatio = (rect[3] - rect[1]) / (maxY - minY);
615   return [
616     xRatio,
617     0,
618     0,
619     yRatio,
620     rect[0] - minX * xRatio,
621     rect[1] - minY * yRatio,
622   ];
623 }
624 
625 class Annotation {
626   constructor(params) {
627     const { dict, xref, annotationGlobals, ref, orphanFields } = params;
628     const parentRef = orphanFields?.get(ref);
629     if (parentRef) {
630       dict.set("Parent", parentRef);
631     }
632 
633     this.setTitle(dict.get("T"));
634     this.setContents(dict.get("Contents"));
635     this.setModificationDate(dict.get("M"));
636     this.setFlags(dict.get("F"));
637     this.setRectangle(dict.getArray("Rect"));
638     this.setColor(dict.getArray("C"));
639     this.setBorderStyle(dict);
640     this.setAppearance(dict);
641     this.setOptionalContent(dict);
642 
643     const MK = dict.get("MK");
644     this.setBorderAndBackgroundColors(MK);
645     this.setRotation(MK, dict);
646     this.ref = params.ref instanceof Ref ? params.ref : null;
647 
648     this._streams = [];
649     if (this.appearance) {
650       this._streams.push(this.appearance);
651     }
652 
653     // The annotation cannot be changed (neither its position/visibility nor its
654     // contents), hence we can just display its appearance and don't generate
655     // a HTML element for it.
656     const isLocked = !!(this.flags & AnnotationFlag.LOCKED);
657     const isContentLocked = !!(this.flags & AnnotationFlag.LOCKEDCONTENTS);
658 
659     // Expose public properties using a data object.
660     this.data = {
661       annotationFlags: this.flags,
662       borderStyle: this.borderStyle,
663       color: this.color,
664       backgroundColor: this.backgroundColor,
665       borderColor: this.borderColor,
666       rotation: this.rotation,
667       contentsObj: this._contents,
668       hasAppearance: !!this.appearance,
669       id: params.id,
670       modificationDate: this.modificationDate,
671       rect: this.rectangle,
672       subtype: params.subtype,
673       hasOwnCanvas: false,
674       noRotate: !!(this.flags & AnnotationFlag.NOROTATE),
675       noHTML: isLocked && isContentLocked,
676       isEditable: false,
677       structParent: -1,
678     };
679 
680     if (annotationGlobals.structTreeRoot) {
681       let structParent = dict.get("StructParent");
682       this.data.structParent = structParent =
683         Number.isInteger(structParent) && structParent >= 0 ? structParent : -1;
684 
685       annotationGlobals.structTreeRoot.addAnnotationIdToPage(
686         params.pageRef,
687         structParent
688       );
689     }
690 
691     if (params.collectFields) {
692       // Fields can act as container for other fields and have
693       // some actions even if no Annotation inherit from them.
694       // Those fields can be referenced by CO (calculation order).
695       const kids = dict.get("Kids");
696       if (Array.isArray(kids)) {
697         const kidIds = [];
698         for (const kid of kids) {
699           if (kid instanceof Ref) {
700             kidIds.push(kid.toString());
701           }
702         }
703         if (kidIds.length !== 0) {
704           this.data.kidIds = kidIds;
705         }
706       }
707 
708       this.data.actions = collectActions(xref, dict, AnnotationActionEventType);
709       this.data.fieldName = this._constructFieldName(dict);
710       this.data.pageIndex = params.pageIndex;
711     }
712 
713     const it = dict.get("IT");
714     if (it instanceof Name) {
715       this.data.it = it.name;
716     }
717 
718     this._isOffscreenCanvasSupported =
719       params.evaluatorOptions.isOffscreenCanvasSupported;
720     this._fallbackFontDict = null;
721     this._needAppearances = false;
722   }
723 
724   /**
725    * @private
726    */
727   _hasFlag(flags, flag) {
728     return !!(flags & flag);
729   }
730 
731   _buildFlags(noView, noPrint) {
732     let { flags } = this;
733     if (noView === undefined) {
734       if (noPrint === undefined) {
735         return undefined;
736       }
737       if (noPrint) {
738         return flags & ~AnnotationFlag.PRINT;
739       }
740       return (flags & ~AnnotationFlag.HIDDEN) | AnnotationFlag.PRINT;
741     }
742 
743     if (noView) {
744       flags |= AnnotationFlag.PRINT;
745       if (noPrint) {
746         // display === 1.
747         return (flags & ~AnnotationFlag.NOVIEW) | AnnotationFlag.HIDDEN;
748       }
749       // display === 3.
750       return (flags & ~AnnotationFlag.HIDDEN) | AnnotationFlag.NOVIEW;
751     }
752 
753     flags &= ~(AnnotationFlag.HIDDEN | AnnotationFlag.NOVIEW);
754     if (noPrint) {
755       // display === 2.
756       return flags & ~AnnotationFlag.PRINT;
757     }
758 
759     // display === 0.
760     return flags | AnnotationFlag.PRINT;
761   }
762 
763   /**
764    * @private
765    */
766   _isViewable(flags) {
767     return (
768       !this._hasFlag(flags, AnnotationFlag.INVISIBLE) &&
769       !this._hasFlag(flags, AnnotationFlag.NOVIEW)
770     );
771   }
772 
773   /**
774    * @private
775    */
776   _isPrintable(flags) {
777     // In Acrobat, hidden flag cancels the print one
778     // (see annotation_hidden_print.pdf).
779     return (
780       this._hasFlag(flags, AnnotationFlag.PRINT) &&
781       !this._hasFlag(flags, AnnotationFlag.HIDDEN) &&
782       !this._hasFlag(flags, AnnotationFlag.INVISIBLE)
783     );
784   }
785 
786   /**
787    * Check if the annotation must be displayed by taking into account
788    * the value found in the annotationStorage which may have been set
789    * through JS.
790    *
791    * @public
792    * @memberof Annotation
793    * @param {AnnotationStorage} [annotationStorage] - Storage for annotation
794    * @param {boolean} [_renderForms] - if true widgets are rendered thanks to
795    *                                   the annotation layer.
796    */
797   mustBeViewed(annotationStorage, _renderForms) {
798     const noView = annotationStorage?.get(this.data.id)?.noView;
799     if (noView !== undefined) {
800       return !noView;
801     }
802     return this.viewable && !this._hasFlag(this.flags, AnnotationFlag.HIDDEN);
803   }
804 
805   /**
806    * Check if the annotation must be printed by taking into account
807    * the value found in the annotationStorage which may have been set
808    * through JS.
809    *
810    * @public
811    * @memberof Annotation
812    * @param {AnnotationStorage} [annotationStorage] - Storage for annotation
813    */
814   mustBePrinted(annotationStorage) {
815     const noPrint = annotationStorage?.get(this.data.id)?.noPrint;
816     if (noPrint !== undefined) {
817       return !noPrint;
818     }
819     return this.printable;
820   }
821 
822   mustBeViewedWhenEditing(isEditing, modifiedIds = null) {
823     return isEditing ? !this.data.isEditable : !modifiedIds?.has(this.data.id);
824   }
825 
826   /**
827    * @type {boolean}
828    */
829   get viewable() {
830     if (this.data.quadPoints === null) {
831       return false;
832     }
833     if (this.flags === 0) {
834       return true;
835     }
836     return this._isViewable(this.flags);
837   }
838 
839   /**
840    * @type {boolean}
841    */
842   get printable() {
843     if (this.data.quadPoints === null) {
844       return false;
845     }
846     if (this.flags === 0) {
847       return false;
848     }
849     return this._isPrintable(this.flags);
850   }
851 
852   /**
853    * @private
854    */
855   _parseStringHelper(data) {
856     const str = typeof data === "string" ? stringToPDFString(data) : "";
857     const dir = str && bidi(str).dir === "rtl" ? "rtl" : "ltr";
858 
859     return { str, dir };
860   }
861 
862   setDefaultAppearance(params) {
863     const { dict, annotationGlobals } = params;
864 
865     const defaultAppearance =
866       getInheritableProperty({ dict, key: "DA" }) ||
867       annotationGlobals.acroForm.get("DA");
868     this._defaultAppearance =
869       typeof defaultAppearance === "string" ? defaultAppearance : "";
870     this.data.defaultAppearanceData = parseDefaultAppearance(
871       this._defaultAppearance
872     );
873   }
874 
875   /**
876    * Set the title.
877    *
878    * @param {string} title - The title of the annotation, used e.g. with
879    *   PopupAnnotations.
880    */
881   setTitle(title) {
882     this._title = this._parseStringHelper(title);
883   }
884 
885   /**
886    * Set the contents.
887    *
888    * @param {string} contents - Text to display for the annotation or, if the
889    *                            type of annotation does not display text, a
890    *                            description of the annotation's contents
891    */
892   setContents(contents) {
893     this._contents = this._parseStringHelper(contents);
894   }
895 
896   /**
897    * Set the modification date.
898    *
899    * @public
900    * @memberof Annotation
901    * @param {string} modificationDate - PDF date string that indicates when the
902    *                                    annotation was last modified
903    */
904   setModificationDate(modificationDate) {
905     this.modificationDate =
906       typeof modificationDate === "string" ? modificationDate : null;
907   }
908 
909   /**
910    * Set the flags.
911    *
912    * @public
913    * @memberof Annotation
914    * @param {number} flags - Unsigned 32-bit integer specifying annotation
915    *                         characteristics
916    * @see {@link shared/util.js}
917    */
918   setFlags(flags) {
919     this.flags = Number.isInteger(flags) && flags > 0 ? flags : 0;
920     if (
921       this.flags & AnnotationFlag.INVISIBLE &&
922       this.constructor.name !== "Annotation"
923     ) {
924       // From the pdf spec v1.7, section 12.5.3 (Annotation Flags):
925       //   If set, do not display the annotation if it does not belong to one of
926       //   the standard annotation types and no annotation handler is available.
927       //
928       // So we can remove the flag in case we have a known annotation type.
929       this.flags ^= AnnotationFlag.INVISIBLE;
930     }
931   }
932 
933   /**
934    * Check if a provided flag is set.
935    *
936    * @public
937    * @memberof Annotation
938    * @param {number} flag - Hexadecimal representation for an annotation
939    *                        characteristic
940    * @returns {boolean}
941    * @see {@link shared/util.js}
942    */
943   hasFlag(flag) {
944     return this._hasFlag(this.flags, flag);
945   }
946 
947   /**
948    * Set the rectangle.
949    *
950    * @public
951    * @memberof Annotation
952    * @param {Array} rectangle - The rectangle array with exactly four entries
953    */
954   setRectangle(rectangle) {
955     this.rectangle = lookupNormalRect(rectangle, [0, 0, 0, 0]);
956   }
957 
958   /**
959    * Set the color and take care of color space conversion.
960    * The default value is black, in RGB color space.
961    *
962    * @public
963    * @memberof Annotation
964    * @param {Array} color - The color array containing either 0
965    *                        (transparent), 1 (grayscale), 3 (RGB) or
966    *                        4 (CMYK) elements
967    */
968   setColor(color) {
969     this.color = getRgbColor(color);
970   }
971 
972   /**
973    * Set the line endings; should only be used with specific annotation types.
974    * @param {Array} lineEndings - The line endings array.
975    */
976   setLineEndings(lineEndings) {
977     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) {
978       throw new Error("Not implemented: setLineEndings");
979     }
980     this.lineEndings = ["None", "None"]; // The default values.
981 
982     if (Array.isArray(lineEndings) && lineEndings.length === 2) {
983       for (let i = 0; i < 2; i++) {
984         const obj = lineEndings[i];
985 
986         if (obj instanceof Name) {
987           switch (obj.name) {
988             case "None":
989               continue;
990             case "Square":
991             case "Circle":
992             case "Diamond":
993             case "OpenArrow":
994             case "ClosedArrow":
995             case "Butt":
996             case "ROpenArrow":
997             case "RClosedArrow":
998             case "Slash":
999               this.lineEndings[i] = obj.name;
1000               continue;
1001           }
1002         }
1003         warn(`Ignoring invalid lineEnding: ${obj}`);
1004       }
1005     }
1006   }
1007 
1008   setRotation(mk, dict) {
1009     this.rotation = 0;
1010     let angle = mk instanceof Dict ? mk.get("R") || 0 : dict.get("Rotate") || 0;
1011     if (Number.isInteger(angle) && angle !== 0) {
1012       angle %= 360;
1013       if (angle < 0) {
1014         angle += 360;
1015       }
1016       if (angle % 90 === 0) {
1017         this.rotation = angle;
1018       }
1019     }
1020   }
1021 
1022   /**
1023    * Set the color for background and border if any.
1024    * The default values are transparent.
1025    *
1026    * @public
1027    * @memberof Annotation
1028    * @param {Dict} mk - The MK dictionary
1029    */
1030   setBorderAndBackgroundColors(mk) {
1031     if (mk instanceof Dict) {
1032       this.borderColor = getRgbColor(mk.getArray("BC"), null);
1033       this.backgroundColor = getRgbColor(mk.getArray("BG"), null);
1034     } else {
1035       this.borderColor = this.backgroundColor = null;
1036     }
1037   }
1038 
1039   /**
1040    * Set the border style (as AnnotationBorderStyle object).
1041    *
1042    * @public
1043    * @memberof Annotation
1044    * @param {Dict} borderStyle - The border style dictionary
1045    */
1046   setBorderStyle(borderStyle) {
1047     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1048       assert(this.rectangle, "setRectangle must have been called previously.");
1049     }
1050 
1051     this.borderStyle = new AnnotationBorderStyle();
1052     if (!(borderStyle instanceof Dict)) {
1053       return;
1054     }
1055     if (borderStyle.has("BS")) {
1056       const dict = borderStyle.get("BS");
1057 
1058       if (dict instanceof Dict) {
1059         const dictType = dict.get("Type");
1060 
1061         if (!dictType || isName(dictType, "Border")) {
1062           this.borderStyle.setWidth(dict.get("W"), this.rectangle);
1063           this.borderStyle.setStyle(dict.get("S"));
1064           this.borderStyle.setDashArray(dict.getArray("D"));
1065         }
1066       }
1067     } else if (borderStyle.has("Border")) {
1068       const array = borderStyle.getArray("Border");
1069       if (Array.isArray(array) && array.length >= 3) {
1070         this.borderStyle.setHorizontalCornerRadius(array[0]);
1071         this.borderStyle.setVerticalCornerRadius(array[1]);
1072         this.borderStyle.setWidth(array[2], this.rectangle);
1073 
1074         if (array.length === 4) {
1075           // Dash array available
1076           this.borderStyle.setDashArray(array[3], /* forceStyle = */ true);
1077         }
1078       }
1079     } else {
1080       // There are no border entries in the dictionary. According to the
1081       // specification, we should draw a solid border of width 1 in that
1082       // case, but Adobe Reader did not implement that part of the
1083       // specification and instead draws no border at all, so we do the same.
1084       // See also https://github.com/mozilla/pdf.js/issues/6179.
1085       this.borderStyle.setWidth(0);
1086     }
1087   }
1088 
1089   /**
1090    * Set the (normal) appearance.
1091    *
1092    * @public
1093    * @memberof Annotation
1094    * @param {Dict} dict - The annotation's data dictionary
1095    */
1096   setAppearance(dict) {
1097     this.appearance = null;
1098 
1099     const appearanceStates = dict.get("AP");
1100     if (!(appearanceStates instanceof Dict)) {
1101       return;
1102     }
1103 
1104     // In case the normal appearance is a stream, then it is used directly.
1105     const normalAppearanceState = appearanceStates.get("N");
1106     if (normalAppearanceState instanceof BaseStream) {
1107       this.appearance = normalAppearanceState;
1108       return;
1109     }
1110     if (!(normalAppearanceState instanceof Dict)) {
1111       return;
1112     }
1113 
1114     // In case the normal appearance is a dictionary, the `AS` entry provides
1115     // the key of the stream in this dictionary.
1116     const as = dict.get("AS");
1117     if (!(as instanceof Name) || !normalAppearanceState.has(as.name)) {
1118       return;
1119     }
1120     const appearance = normalAppearanceState.get(as.name);
1121     if (appearance instanceof BaseStream) {
1122       this.appearance = appearance;
1123     }
1124   }
1125 
1126   setOptionalContent(dict) {
1127     this.oc = null;
1128 
1129     const oc = dict.get("OC");
1130     if (oc instanceof Name) {
1131       warn("setOptionalContent: Support for /Name-entry is not implemented.");
1132     } else if (oc instanceof Dict) {
1133       this.oc = oc;
1134     }
1135   }
1136 
1137   loadResources(keys, appearance) {
1138     return appearance.dict.getAsync("Resources").then(resources => {
1139       if (!resources) {
1140         return undefined;
1141       }
1142 
1143       const objectLoader = new ObjectLoader(resources, keys, resources.xref);
1144       return objectLoader.load().then(function () {
1145         return resources;
1146       });
1147     });
1148   }
1149 
1150   async getOperatorList(evaluator, task, intent, annotationStorage) {
1151     const { hasOwnCanvas, id, rect } = this.data;
1152     let appearance = this.appearance;
1153     const isUsingOwnCanvas = !!(
1154       hasOwnCanvas && intent & RenderingIntentFlag.DISPLAY
1155     );
1156     if (isUsingOwnCanvas && (rect[0] === rect[2] || rect[1] === rect[3])) {
1157       // Empty annotation, don't draw anything.
1158       this.data.hasOwnCanvas = false;
1159       return {
1160         opList: new OperatorList(),
1161         separateForm: false,
1162         separateCanvas: false,
1163       };
1164     }
1165     if (!appearance) {
1166       if (!isUsingOwnCanvas) {
1167         return {
1168           opList: new OperatorList(),
1169           separateForm: false,
1170           separateCanvas: false,
1171         };
1172       }
1173       appearance = new StringStream("");
1174       appearance.dict = new Dict();
1175     }
1176 
1177     const appearanceDict = appearance.dict;
1178     const resources = await this.loadResources(
1179       ["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"],
1180       appearance
1181     );
1182     const bbox = lookupRect(appearanceDict.getArray("BBox"), [0, 0, 1, 1]);
1183     const matrix = lookupMatrix(
1184       appearanceDict.getArray("Matrix"),
1185       IDENTITY_MATRIX
1186     );
1187     const transform = getTransformMatrix(rect, bbox, matrix);
1188 
1189     const opList = new OperatorList();
1190 
1191     let optionalContent;
1192     if (this.oc) {
1193       optionalContent = await evaluator.parseMarkedContentProps(
1194         this.oc,
1195         /* resources = */ null
1196       );
1197     }
1198     if (optionalContent !== undefined) {
1199       opList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
1200     }
1201 
1202     opList.addOp(OPS.beginAnnotation, [
1203       id,
1204       rect,
1205       transform,
1206       matrix,
1207       isUsingOwnCanvas,
1208     ]);
1209 
1210     await evaluator.getOperatorList({
1211       stream: appearance,
1212       task,
1213       resources,
1214       operatorList: opList,
1215       fallbackFontDict: this._fallbackFontDict,
1216     });
1217     opList.addOp(OPS.endAnnotation, []);
1218 
1219     if (optionalContent !== undefined) {
1220       opList.addOp(OPS.endMarkedContent, []);
1221     }
1222     this.reset();
1223     return { opList, separateForm: false, separateCanvas: isUsingOwnCanvas };
1224   }
1225 
1226   async save(evaluator, task, annotationStorage, changes) {
1227     return null;
1228   }
1229 
1230   get hasTextContent() {
1231     return false;
1232   }
1233 
1234   async extractTextContent(evaluator, task, viewBox) {
1235     if (!this.appearance) {
1236       return;
1237     }
1238 
1239     const resources = await this.loadResources(
1240       ["ExtGState", "Font", "Properties", "XObject"],
1241       this.appearance
1242     );
1243 
1244     const text = [];
1245     const buffer = [];
1246     let firstPosition = null;
1247     const sink = {
1248       desiredSize: Math.Infinity,
1249       ready: true,
1250 
1251       enqueue(chunk, size) {
1252         for (const item of chunk.items) {
1253           if (item.str === undefined) {
1254             continue;
1255           }
1256           firstPosition ||= item.transform.slice(-2);
1257           buffer.push(item.str);
1258           if (item.hasEOL) {
1259             text.push(buffer.join("").trimEnd());
1260             buffer.length = 0;
1261           }
1262         }
1263       },
1264     };
1265 
1266     await evaluator.getTextContent({
1267       stream: this.appearance,
1268       task,
1269       resources,
1270       includeMarkedContent: true,
1271       keepWhiteSpace: true,
1272       sink,
1273       viewBox,
1274     });
1275     this.reset();
1276 
1277     if (buffer.length) {
1278       text.push(buffer.join("").trimEnd());
1279     }
1280 
1281     if (text.length > 1 || text[0]) {
1282       const appearanceDict = this.appearance.dict;
1283       const bbox = lookupRect(appearanceDict.getArray("BBox"), null);
1284       const matrix = lookupMatrix(appearanceDict.getArray("Matrix"), null);
1285 
1286       this.data.textPosition = this._transformPoint(
1287         firstPosition,
1288         bbox,
1289         matrix
1290       );
1291       this.data.textContent = text;
1292     }
1293   }
1294 
1295   _transformPoint(coords, bbox, matrix) {
1296     const { rect } = this.data;
1297     bbox ||= [0, 0, 1, 1];
1298     matrix ||= [1, 0, 0, 1, 0, 0];
1299     const transform = getTransformMatrix(rect, bbox, matrix);
1300     transform[4] -= rect[0];
1301     transform[5] -= rect[1];
1302     coords = Util.applyTransform(coords, transform);
1303     return Util.applyTransform(coords, matrix);
1304   }
1305 
1306   /**
1307    * Get field data for usage in JS sandbox.
1308    *
1309    * Field object is defined here:
1310    * https://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/js_api_reference.pdf#page=16
1311    *
1312    * @public
1313    * @memberof Annotation
1314    * @returns {Object | null}
1315    */
1316   getFieldObject() {
1317     if (this.data.kidIds) {
1318       return {
1319         id: this.data.id,
1320         actions: this.data.actions,
1321         name: this.data.fieldName,
1322         strokeColor: this.data.borderColor,
1323         fillColor: this.data.backgroundColor,
1324         type: "",
1325         kidIds: this.data.kidIds,
1326         page: this.data.pageIndex,
1327         rotation: this.rotation,
1328       };
1329     }
1330     return null;
1331   }
1332 
1333   /**
1334    * Reset the annotation.
1335    *
1336    * This involves resetting the various streams that are either cached on the
1337    * annotation instance or created during its construction.
1338    *
1339    * @public
1340    * @memberof Annotation
1341    */
1342   reset() {
1343     if (
1344       (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) &&
1345       this.appearance &&
1346       !this._streams.includes(this.appearance)
1347     ) {
1348       unreachable("The appearance stream should always be reset.");
1349     }
1350 
1351     for (const stream of this._streams) {
1352       stream.reset();
1353     }
1354   }
1355 
1356   /**
1357    * Construct the (fully qualified) field name from the (partial) field
1358    * names of the field and its ancestors.
1359    *
1360    * @private
1361    * @memberof Annotation
1362    * @param {Dict} dict - Complete widget annotation dictionary
1363    * @returns {string}
1364    */
1365   _constructFieldName(dict) {
1366     // Both the `Parent` and `T` fields are optional. While at least one of
1367     // them should be provided, bad PDF generators may fail to do so.
1368     if (!dict.has("T") && !dict.has("Parent")) {
1369       warn("Unknown field name, falling back to empty field name.");
1370       return "";
1371     }
1372 
1373     // If no parent exists, the partial and fully qualified names are equal.
1374     if (!dict.has("Parent")) {
1375       return stringToPDFString(dict.get("T"));
1376     }
1377 
1378     // Form the fully qualified field name by appending the partial name to
1379     // the parent's fully qualified name, separated by a period.
1380     const fieldName = [];
1381     if (dict.has("T")) {
1382       fieldName.unshift(stringToPDFString(dict.get("T")));
1383     }
1384 
1385     let loopDict = dict;
1386     const visited = new RefSet();
1387     if (dict.objId) {
1388       visited.put(dict.objId);
1389     }
1390     while (loopDict.has("Parent")) {
1391       loopDict = loopDict.get("Parent");
1392       if (
1393         !(loopDict instanceof Dict) ||
1394         (loopDict.objId && visited.has(loopDict.objId))
1395       ) {
1396         // Even though it is not allowed according to the PDF specification,
1397         // bad PDF generators may provide a `Parent` entry that is not a
1398         // dictionary, but `null` for example (issue 8143).
1399         //
1400         // If parent has been already visited, it means that we're
1401         // in an infinite loop.
1402         break;
1403       }
1404       if (loopDict.objId) {
1405         visited.put(loopDict.objId);
1406       }
1407 
1408       if (loopDict.has("T")) {
1409         fieldName.unshift(stringToPDFString(loopDict.get("T")));
1410       }
1411     }
1412     return fieldName.join(".");
1413   }
1414 }
1415 
1416 /**
1417  * Contains all data regarding an annotation's border style.
1418  */
1419 class AnnotationBorderStyle {
1420   constructor() {
1421     this.width = 1;
1422     this.rawWidth = 1;
1423     this.style = AnnotationBorderStyleType.SOLID;
1424     this.dashArray = [3];
1425     this.horizontalCornerRadius = 0;
1426     this.verticalCornerRadius = 0;
1427   }
1428 
1429   /**
1430    * Set the width.
1431    *
1432    * @public
1433    * @memberof AnnotationBorderStyle
1434    * @param {number} width - The width.
1435    * @param {Array} rect - The annotation `Rect` entry.
1436    */
1437   setWidth(width, rect = [0, 0, 0, 0]) {
1438     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1439       assert(
1440         isNumberArray(rect, 4),
1441         "A valid `rect` parameter must be provided."
1442       );
1443     }
1444 
1445     // Some corrupt PDF generators may provide the width as a `Name`,
1446     // rather than as a number (fixes issue 10385).
1447     if (width instanceof Name) {
1448       this.width = 0; // This is consistent with the behaviour in Adobe Reader.
1449       return;
1450     }
1451     if (typeof width === "number") {
1452       if (width > 0) {
1453         this.rawWidth = width;
1454         const maxWidth = (rect[2] - rect[0]) / 2;
1455         const maxHeight = (rect[3] - rect[1]) / 2;
1456 
1457         // Ignore large `width`s, since they lead to the Annotation overflowing
1458         // the size set by the `Rect` entry thus causing the `annotationLayer`
1459         // to render it over the surrounding document (fixes bug1552113.pdf).
1460         if (
1461           maxWidth > 0 &&
1462           maxHeight > 0 &&
1463           (width > maxWidth || width > maxHeight)
1464         ) {
1465           warn(`AnnotationBorderStyle.setWidth - ignoring width: ${width}`);
1466           width = 1;
1467         }
1468       }
1469       this.width = width;
1470     }
1471   }
1472 
1473   /**
1474    * Set the style.
1475    *
1476    * @public
1477    * @memberof AnnotationBorderStyle
1478    * @param {Name} style - The annotation style.
1479    * @see {@link shared/util.js}
1480    */
1481   setStyle(style) {
1482     if (!(style instanceof Name)) {
1483       return;
1484     }
1485     switch (style.name) {
1486       case "S":
1487         this.style = AnnotationBorderStyleType.SOLID;
1488         break;
1489 
1490       case "D":
1491         this.style = AnnotationBorderStyleType.DASHED;
1492         break;
1493 
1494       case "B":
1495         this.style = AnnotationBorderStyleType.BEVELED;
1496         break;
1497 
1498       case "I":
1499         this.style = AnnotationBorderStyleType.INSET;
1500         break;
1501 
1502       case "U":
1503         this.style = AnnotationBorderStyleType.UNDERLINE;
1504         break;
1505 
1506       default:
1507         break;
1508     }
1509   }
1510 
1511   /**
1512    * Set the dash array.
1513    *
1514    * @public
1515    * @memberof AnnotationBorderStyle
1516    * @param {Array} dashArray - The dash array with at least one element
1517    * @param {boolean} [forceStyle]
1518    */
1519   setDashArray(dashArray, forceStyle = false) {
1520     // We validate the dash array, but we do not use it because CSS does not
1521     // allow us to change spacing of dashes. For more information, visit
1522     // http://www.w3.org/TR/css3-background/#the-border-style.
1523     if (Array.isArray(dashArray)) {
1524       // The PDF specification states that elements in the dash array, if
1525       // present, must be non-negative numbers and must not all equal zero.
1526       let isValid = true;
1527       let allZeros = true;
1528       for (const element of dashArray) {
1529         const validNumber = +element >= 0;
1530         if (!validNumber) {
1531           isValid = false;
1532           break;
1533         } else if (element > 0) {
1534           allZeros = false;
1535         }
1536       }
1537       if (dashArray.length === 0 || (isValid && !allZeros)) {
1538         this.dashArray = dashArray;
1539 
1540         if (forceStyle) {
1541           // Even though we cannot use the dash array in the display layer,
1542           // at least ensure that we use the correct border-style.
1543           this.setStyle(Name.get("D"));
1544         }
1545       } else {
1546         this.width = 0; // Adobe behavior when the array is invalid.
1547       }
1548     } else if (dashArray) {
1549       this.width = 0; // Adobe behavior when the array is invalid.
1550     }
1551   }
1552 
1553   /**
1554    * Set the horizontal corner radius (from a Border dictionary).
1555    *
1556    * @public
1557    * @memberof AnnotationBorderStyle
1558    * @param {number} radius - The horizontal corner radius.
1559    */
1560   setHorizontalCornerRadius(radius) {
1561     if (Number.isInteger(radius)) {
1562       this.horizontalCornerRadius = radius;
1563     }
1564   }
1565 
1566   /**
1567    * Set the vertical corner radius (from a Border dictionary).
1568    *
1569    * @public
1570    * @memberof AnnotationBorderStyle
1571    * @param {number} radius - The vertical corner radius.
1572    */
1573   setVerticalCornerRadius(radius) {
1574     if (Number.isInteger(radius)) {
1575       this.verticalCornerRadius = radius;
1576     }
1577   }
1578 }
1579 
1580 class MarkupAnnotation extends Annotation {
1581   constructor(params) {
1582     super(params);
1583 
1584     const { dict } = params;
1585 
1586     if (dict.has("IRT")) {
1587       const rawIRT = dict.getRaw("IRT");
1588       this.data.inReplyTo = rawIRT instanceof Ref ? rawIRT.toString() : null;
1589 
1590       const rt = dict.get("RT");
1591       this.data.replyType =
1592         rt instanceof Name ? rt.name : AnnotationReplyType.REPLY;
1593     }
1594     let popupRef = null;
1595 
1596     if (this.data.replyType === AnnotationReplyType.GROUP) {
1597       // Subordinate annotations in a group should inherit
1598       // the group attributes from the primary annotation.
1599       const parent = dict.get("IRT");
1600 
1601       this.setTitle(parent.get("T"));
1602       this.data.titleObj = this._title;
1603 
1604       this.setContents(parent.get("Contents"));
1605       this.data.contentsObj = this._contents;
1606 
1607       if (!parent.has("CreationDate")) {
1608         this.data.creationDate = null;
1609       } else {
1610         this.setCreationDate(parent.get("CreationDate"));
1611         this.data.creationDate = this.creationDate;
1612       }
1613 
1614       if (!parent.has("M")) {
1615         this.data.modificationDate = null;
1616       } else {
1617         this.setModificationDate(parent.get("M"));
1618         this.data.modificationDate = this.modificationDate;
1619       }
1620 
1621       popupRef = parent.getRaw("Popup");
1622 
1623       if (!parent.has("C")) {
1624         // Fall back to the default background color.
1625         this.data.color = null;
1626       } else {
1627         this.setColor(parent.getArray("C"));
1628         this.data.color = this.color;
1629       }
1630     } else {
1631       this.data.titleObj = this._title;
1632 
1633       this.setCreationDate(dict.get("CreationDate"));
1634       this.data.creationDate = this.creationDate;
1635 
1636       popupRef = dict.getRaw("Popup");
1637 
1638       if (!dict.has("C")) {
1639         // Fall back to the default background color.
1640         this.data.color = null;
1641       }
1642     }
1643 
1644     this.data.popupRef = popupRef instanceof Ref ? popupRef.toString() : null;
1645 
1646     if (dict.has("RC")) {
1647       this.data.richText = XFAFactory.getRichTextAsHtml(dict.get("RC"));
1648     }
1649   }
1650 
1651   /**
1652    * Set the creation date.
1653    *
1654    * @public
1655    * @memberof MarkupAnnotation
1656    * @param {string} creationDate - PDF date string that indicates when the
1657    *                                annotation was originally created
1658    */
1659   setCreationDate(creationDate) {
1660     this.creationDate = typeof creationDate === "string" ? creationDate : null;
1661   }
1662 
1663   _setDefaultAppearance({
1664     xref,
1665     extra,
1666     strokeColor,
1667     fillColor,
1668     blendMode,
1669     strokeAlpha,
1670     fillAlpha,
1671     pointsCallback,
1672   }) {
1673     let minX = Number.MAX_VALUE;
1674     let minY = Number.MAX_VALUE;
1675     let maxX = Number.MIN_VALUE;
1676     let maxY = Number.MIN_VALUE;
1677 
1678     const buffer = ["q"];
1679     if (extra) {
1680       buffer.push(extra);
1681     }
1682     if (strokeColor) {
1683       buffer.push(`${strokeColor[0]} ${strokeColor[1]} ${strokeColor[2]} RG`);
1684     }
1685     if (fillColor) {
1686       buffer.push(`${fillColor[0]} ${fillColor[1]} ${fillColor[2]} rg`);
1687     }
1688 
1689     let pointsArray = this.data.quadPoints;
1690     if (!pointsArray) {
1691       // If there are no quadpoints, the rectangle should be used instead.
1692       // Convert the rectangle definition to a points array similar to how the
1693       // quadpoints are defined.
1694       pointsArray = Float32Array.from([
1695         this.rectangle[0],
1696         this.rectangle[3],
1697         this.rectangle[2],
1698         this.rectangle[3],
1699         this.rectangle[0],
1700         this.rectangle[1],
1701         this.rectangle[2],
1702         this.rectangle[1],
1703       ]);
1704     }
1705 
1706     for (let i = 0, ii = pointsArray.length; i < ii; i += 8) {
1707       const [mX, MX, mY, MY] = pointsCallback(
1708         buffer,
1709         pointsArray.subarray(i, i + 8)
1710       );
1711       minX = Math.min(minX, mX);
1712       maxX = Math.max(maxX, MX);
1713       minY = Math.min(minY, mY);
1714       maxY = Math.max(maxY, MY);
1715     }
1716     buffer.push("Q");
1717 
1718     const formDict = new Dict(xref);
1719     const appearanceStreamDict = new Dict(xref);
1720     appearanceStreamDict.set("Subtype", Name.get("Form"));
1721 
1722     const appearanceStream = new StringStream(buffer.join(" "));
1723     appearanceStream.dict = appearanceStreamDict;
1724     formDict.set("Fm0", appearanceStream);
1725 
1726     const gsDict = new Dict(xref);
1727     if (blendMode) {
1728       gsDict.set("BM", Name.get(blendMode));
1729     }
1730     if (typeof strokeAlpha === "number") {
1731       gsDict.set("CA", strokeAlpha);
1732     }
1733     if (typeof fillAlpha === "number") {
1734       gsDict.set("ca", fillAlpha);
1735     }
1736 
1737     const stateDict = new Dict(xref);
1738     stateDict.set("GS0", gsDict);
1739 
1740     const resources = new Dict(xref);
1741     resources.set("ExtGState", stateDict);
1742     resources.set("XObject", formDict);
1743 
1744     const appearanceDict = new Dict(xref);
1745     appearanceDict.set("Resources", resources);
1746     const bbox = (this.data.rect = [minX, minY, maxX, maxY]);
1747     appearanceDict.set("BBox", bbox);
1748 
1749     this.appearance = new StringStream("/GS0 gs /Fm0 Do");
1750     this.appearance.dict = appearanceDict;
1751 
1752     // This method is only called if there is no appearance for the annotation,
1753     // so `this.appearance` is not pushed yet in the `Annotation` constructor.
1754     this._streams.push(this.appearance, appearanceStream);
1755   }
1756 
1757   static async createNewAnnotation(xref, annotation, changes, params) {
1758     if (!annotation.ref) {
1759       annotation.ref = xref.getNewTemporaryRef();
1760     }
1761 
1762     const annotationRef = annotation.ref;
1763     const ap = await this.createNewAppearanceStream(annotation, xref, params);
1764     let annotationDict;
1765 
1766     if (ap) {
1767       const apRef = xref.getNewTemporaryRef();
1768       annotationDict = this.createNewDict(annotation, xref, {
1769         apRef,
1770       });
1771       changes.put(apRef, {
1772         data: ap,
1773       });
1774     } else {
1775       annotationDict = this.createNewDict(annotation, xref, {});
1776     }
1777     if (Number.isInteger(annotation.parentTreeId)) {
1778       annotationDict.set("StructParent", annotation.parentTreeId);
1779     }
1780 
1781     changes.put(annotationRef, {
1782       data: annotationDict,
1783     });
1784 
1785     return { ref: annotationRef };
1786   }
1787 
1788   static async createNewPrintAnnotation(
1789     annotationGlobals,
1790     xref,
1791     annotation,
1792     params
1793   ) {
1794     const ap = await this.createNewAppearanceStream(annotation, xref, params);
1795     const annotationDict = this.createNewDict(
1796       annotation,
1797       xref,
1798       ap ? { ap } : {}
1799     );
1800 
1801     const newAnnotation = new this.prototype.constructor({
1802       dict: annotationDict,
1803       xref,
1804       annotationGlobals,
1805       evaluatorOptions: params.evaluatorOptions,
1806     });
1807 
1808     if (annotation.ref) {
1809       newAnnotation.ref = newAnnotation.refToReplace = annotation.ref;
1810     }
1811 
1812     return newAnnotation;
1813   }
1814 }
1815 
1816 class WidgetAnnotation extends Annotation {
1817   constructor(params) {
1818     super(params);
1819 
1820     const { dict, xref, annotationGlobals } = params;
1821     const data = this.data;
1822     this._needAppearances = params.needAppearances;
1823 
1824     data.annotationType = AnnotationType.WIDGET;
1825     if (data.fieldName === undefined) {
1826       data.fieldName = this._constructFieldName(dict);
1827     }
1828 
1829     if (data.actions === undefined) {
1830       data.actions = collectActions(xref, dict, AnnotationActionEventType);
1831     }
1832 
1833     let fieldValue = getInheritableProperty({
1834       dict,
1835       key: "V",
1836       getArray: true,
1837     });
1838     data.fieldValue = this._decodeFormValue(fieldValue);
1839 
1840     const defaultFieldValue = getInheritableProperty({
1841       dict,
1842       key: "DV",
1843       getArray: true,
1844     });
1845     data.defaultFieldValue = this._decodeFormValue(defaultFieldValue);
1846 
1847     if (fieldValue === undefined && annotationGlobals.xfaDatasets) {
1848       // Try to figure out if we have something in the xfa dataset.
1849       const path = this._title.str;
1850       if (path) {
1851         this._hasValueFromXFA = true;
1852         data.fieldValue = fieldValue =
1853           annotationGlobals.xfaDatasets.getValue(path);
1854       }
1855     }
1856 
1857     // When no "V" entry exists, let the fieldValue fallback to the "DV" entry
1858     // (fixes issue13823.pdf).
1859     if (fieldValue === undefined && data.defaultFieldValue !== null) {
1860       data.fieldValue = data.defaultFieldValue;
1861     }
1862 
1863     data.alternativeText = stringToPDFString(dict.get("TU") || "");
1864 
1865     this.setDefaultAppearance(params);
1866 
1867     data.hasAppearance ||=
1868       this._needAppearances &&
1869       data.fieldValue !== undefined &&
1870       data.fieldValue !== null;
1871 
1872     const fieldType = getInheritableProperty({ dict, key: "FT" });
1873     data.fieldType = fieldType instanceof Name ? fieldType.name : null;
1874 
1875     const localResources = getInheritableProperty({ dict, key: "DR" });
1876     const acroFormResources = annotationGlobals.acroForm.get("DR");
1877     const appearanceResources = this.appearance?.dict.get("Resources");
1878 
1879     this._fieldResources = {
1880       localResources,
1881       acroFormResources,
1882       appearanceResources,
1883       mergedResources: Dict.merge({
1884         xref,
1885         dictArray: [localResources, appearanceResources, acroFormResources],
1886         mergeSubDicts: true,
1887       }),
1888     };
1889 
1890     data.fieldFlags = getInheritableProperty({ dict, key: "Ff" });
1891     if (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) {
1892       data.fieldFlags = 0;
1893     }
1894 
1895     data.readOnly = this.hasFieldFlag(AnnotationFieldFlag.READONLY);
1896     data.required = this.hasFieldFlag(AnnotationFieldFlag.REQUIRED);
1897     data.hidden =
1898       this._hasFlag(data.annotationFlags, AnnotationFlag.HIDDEN) ||
1899       this._hasFlag(data.annotationFlags, AnnotationFlag.NOVIEW);
1900   }
1901 
1902   /**
1903    * Decode the given form value.
1904    *
1905    * @private
1906    * @memberof WidgetAnnotation
1907    * @param {Array<string>|Name|string} formValue - The (possibly encoded)
1908    *   form value.
1909    * @returns {Array<string>|string|null}
1910    */
1911   _decodeFormValue(formValue) {
1912     if (Array.isArray(formValue)) {
1913       return formValue
1914         .filter(item => typeof item === "string")
1915         .map(item => stringToPDFString(item));
1916     } else if (formValue instanceof Name) {
1917       return stringToPDFString(formValue.name);
1918     } else if (typeof formValue === "string") {
1919       return stringToPDFString(formValue);
1920     }
1921     return null;
1922   }
1923 
1924   /**
1925    * Check if a provided field flag is set.
1926    *
1927    * @public
1928    * @memberof WidgetAnnotation
1929    * @param {number} flag - Hexadecimal representation for an annotation
1930    *                        field characteristic
1931    * @returns {boolean}
1932    * @see {@link shared/util.js}
1933    */
1934   hasFieldFlag(flag) {
1935     return !!(this.data.fieldFlags & flag);
1936   }
1937 
1938   /** @inheritdoc */
1939   _isViewable(flags) {
1940     // We don't take into account the `NOVIEW` or `HIDDEN` flags here,
1941     // since the visibility can be changed by js code, hence in case
1942     // it's made viewable, we should render it (with visibility set to
1943     // hidden).
1944     // We don't take into account the `INVISIBLE` flag here, since we've a known
1945     // annotation type.
1946     return true;
1947   }
1948 
1949   /** @inheritdoc */
1950   mustBeViewed(annotationStorage, renderForms) {
1951     if (renderForms) {
1952       return this.viewable;
1953     }
1954     return (
1955       super.mustBeViewed(annotationStorage, renderForms) &&
1956       !this._hasFlag(this.flags, AnnotationFlag.NOVIEW)
1957     );
1958   }
1959 
1960   getRotationMatrix(annotationStorage) {
1961     let rotation = annotationStorage?.get(this.data.id)?.rotation;
1962     if (rotation === undefined) {
1963       rotation = this.rotation;
1964     }
1965 
1966     if (rotation === 0) {
1967       return IDENTITY_MATRIX;
1968     }
1969 
1970     const width = this.data.rect[2] - this.data.rect[0];
1971     const height = this.data.rect[3] - this.data.rect[1];
1972 
1973     return getRotationMatrix(rotation, width, height);
1974   }
1975 
1976   getBorderAndBackgroundAppearances(annotationStorage) {
1977     let rotation = annotationStorage?.get(this.data.id)?.rotation;
1978     if (rotation === undefined) {
1979       rotation = this.rotation;
1980     }
1981 
1982     if (!this.backgroundColor && !this.borderColor) {
1983       return "";
1984     }
1985     const width = this.data.rect[2] - this.data.rect[0];
1986     const height = this.data.rect[3] - this.data.rect[1];
1987     const rect =
1988       rotation === 0 || rotation === 180
1989         ? `0 0 ${width} ${height} re`
1990         : `0 0 ${height} ${width} re`;
1991 
1992     let str = "";
1993     if (this.backgroundColor) {
1994       str = `${getPdfColor(
1995         this.backgroundColor,
1996         /* isFill */ true
1997       )} ${rect} f `;
1998     }
1999 
2000     if (this.borderColor) {
2001       const borderWidth = this.borderStyle.width || 1;
2002       str += `${borderWidth} w ${getPdfColor(
2003         this.borderColor,
2004         /* isFill */ false
2005       )} ${rect} S `;
2006     }
2007 
2008     return str;
2009   }
2010 
2011   async getOperatorList(evaluator, task, intent, annotationStorage) {
2012     // Do not render form elements on the canvas when interactive forms are
2013     // enabled. The display layer is responsible for rendering them instead.
2014     if (
2015       intent & RenderingIntentFlag.ANNOTATIONS_FORMS &&
2016       !(this instanceof SignatureWidgetAnnotation) &&
2017       !this.data.noHTML &&
2018       !this.data.hasOwnCanvas
2019     ) {
2020       return {
2021         opList: new OperatorList(),
2022         separateForm: true,
2023         separateCanvas: false,
2024       };
2025     }
2026 
2027     if (!this._hasText) {
2028       return super.getOperatorList(evaluator, task, intent, annotationStorage);
2029     }
2030 
2031     const content = await this._getAppearance(
2032       evaluator,
2033       task,
2034       intent,
2035       annotationStorage
2036     );
2037     if (this.appearance && content === null) {
2038       return super.getOperatorList(evaluator, task, intent, annotationStorage);
2039     }
2040 
2041     const opList = new OperatorList();
2042 
2043     // Even if there is an appearance stream, ignore it. This is the
2044     // behaviour used by Adobe Reader.
2045     if (!this._defaultAppearance || content === null) {
2046       return { opList, separateForm: false, separateCanvas: false };
2047     }
2048 
2049     const isUsingOwnCanvas = !!(
2050       this.data.hasOwnCanvas && intent & RenderingIntentFlag.DISPLAY
2051     );
2052 
2053     const matrix = [1, 0, 0, 1, 0, 0];
2054     const bbox = [
2055       0,
2056       0,
2057       this.data.rect[2] - this.data.rect[0],
2058       this.data.rect[3] - this.data.rect[1],
2059     ];
2060     const transform = getTransformMatrix(this.data.rect, bbox, matrix);
2061 
2062     let optionalContent;
2063     if (this.oc) {
2064       optionalContent = await evaluator.parseMarkedContentProps(
2065         this.oc,
2066         /* resources = */ null
2067       );
2068     }
2069     if (optionalContent !== undefined) {
2070       opList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
2071     }
2072 
2073     opList.addOp(OPS.beginAnnotation, [
2074       this.data.id,
2075       this.data.rect,
2076       transform,
2077       this.getRotationMatrix(annotationStorage),
2078       isUsingOwnCanvas,
2079     ]);
2080 
2081     const stream = new StringStream(content);
2082     await evaluator.getOperatorList({
2083       stream,
2084       task,
2085       resources: this._fieldResources.mergedResources,
2086       operatorList: opList,
2087     });
2088     opList.addOp(OPS.endAnnotation, []);
2089 
2090     if (optionalContent !== undefined) {
2091       opList.addOp(OPS.endMarkedContent, []);
2092     }
2093     return { opList, separateForm: false, separateCanvas: isUsingOwnCanvas };
2094   }
2095 
2096   _getMKDict(rotation) {
2097     const mk = new Dict(null);
2098     if (rotation) {
2099       mk.set("R", rotation);
2100     }
2101     if (this.borderColor) {
2102       mk.set("BC", getPdfColorArray(this.borderColor));
2103     }
2104     if (this.backgroundColor) {
2105       mk.set("BG", getPdfColorArray(this.backgroundColor));
2106     }
2107     return mk.size > 0 ? mk : null;
2108   }
2109 
2110   amendSavedDict(annotationStorage, dict) {}
2111 
2112   setValue(dict, value, xref, changes) {
2113     const { dict: parentDict, ref: parentRef } = getParentToUpdate(
2114       dict,
2115       this.ref,
2116       xref
2117     );
2118     if (!parentDict) {
2119       dict.set("V", value);
2120     } else if (!changes.has(parentRef)) {
2121       const newParentDict = parentDict.clone();
2122       newParentDict.set("V", value);
2123       changes.put(parentRef, { data: newParentDict });
2124       return newParentDict;
2125     }
2126 
2127     return null;
2128   }
2129 
2130   async save(evaluator, task, annotationStorage, changes) {
2131     const storageEntry = annotationStorage?.get(this.data.id);
2132     const flags = this._buildFlags(storageEntry?.noView, storageEntry?.noPrint);
2133     let value = storageEntry?.value,
2134       rotation = storageEntry?.rotation;
2135     if (value === this.data.fieldValue || value === undefined) {
2136       if (
2137         !this._hasValueFromXFA &&
2138         rotation === undefined &&
2139         flags === undefined
2140       ) {
2141         return;
2142       }
2143       value ||= this.data.fieldValue;
2144     }
2145 
2146     // Value can be an array (with choice list and multiple selections)
2147     if (
2148       rotation === undefined &&
2149       !this._hasValueFromXFA &&
2150       Array.isArray(value) &&
2151       Array.isArray(this.data.fieldValue) &&
2152       isArrayEqual(value, this.data.fieldValue) &&
2153       flags === undefined
2154     ) {
2155       return;
2156     }
2157 
2158     if (rotation === undefined) {
2159       rotation = this.rotation;
2160     }
2161 
2162     let appearance = null;
2163     if (!this._needAppearances) {
2164       appearance = await this._getAppearance(
2165         evaluator,
2166         task,
2167         RenderingIntentFlag.SAVE,
2168         annotationStorage
2169       );
2170       if (appearance === null && flags === undefined) {
2171         // Appearance didn't change.
2172         return;
2173       }
2174     } else {
2175       // No need to create an appearance: the pdf has the flag /NeedAppearances
2176       // which means that it's up to the reader to produce an appearance.
2177     }
2178 
2179     let needAppearances = false;
2180     if (appearance?.needAppearances) {
2181       needAppearances = true;
2182       appearance = null;
2183     }
2184 
2185     const { xref } = evaluator;
2186 
2187     const originalDict = xref.fetchIfRef(this.ref);
2188     if (!(originalDict instanceof Dict)) {
2189       return;
2190     }
2191 
2192     const dict = new Dict(xref);
2193     for (const key of originalDict.getKeys()) {
2194       if (key !== "AP") {
2195         dict.set(key, originalDict.getRaw(key));
2196       }
2197     }
2198     if (flags !== undefined) {
2199       dict.set("F", flags);
2200       if (appearance === null && !needAppearances) {
2201         const ap = originalDict.getRaw("AP");
2202         if (ap) {
2203           dict.set("AP", ap);
2204         }
2205       }
2206     }
2207 
2208     const xfa = {
2209       path: this.data.fieldName,
2210       value,
2211     };
2212 
2213     const newParentDict = this.setValue(
2214       dict,
2215       Array.isArray(value)
2216         ? value.map(stringToAsciiOrUTF16BE)
2217         : stringToAsciiOrUTF16BE(value),
2218       xref,
2219       changes
2220     );
2221     this.amendSavedDict(annotationStorage, newParentDict || dict);
2222 
2223     const maybeMK = this._getMKDict(rotation);
2224     if (maybeMK) {
2225       dict.set("MK", maybeMK);
2226     }
2227 
2228     changes.put(this.ref, {
2229       data: dict,
2230       xfa,
2231       needAppearances,
2232     });
2233     if (appearance !== null) {
2234       const newRef = xref.getNewTemporaryRef();
2235       const AP = new Dict(xref);
2236       dict.set("AP", AP);
2237       AP.set("N", newRef);
2238 
2239       const resources = this._getSaveFieldResources(xref);
2240       const appearanceStream = new StringStream(appearance);
2241       const appearanceDict = (appearanceStream.dict = new Dict(xref));
2242       appearanceDict.set("Subtype", Name.get("Form"));
2243       appearanceDict.set("Resources", resources);
2244       appearanceDict.set("BBox", [
2245         0,
2246         0,
2247         this.data.rect[2] - this.data.rect[0],
2248         this.data.rect[3] - this.data.rect[1],
2249       ]);
2250 
2251       const rotationMatrix = this.getRotationMatrix(annotationStorage);
2252       if (rotationMatrix !== IDENTITY_MATRIX) {
2253         // The matrix isn't the identity one.
2254         appearanceDict.set("Matrix", rotationMatrix);
2255       }
2256 
2257       changes.put(newRef, {
2258         data: appearanceStream,
2259         xfa: null,
2260         needAppearances: false,
2261       });
2262     }
2263 
2264     dict.set("M", `D:${getModificationDate()}`);
2265   }
2266 
2267   async _getAppearance(evaluator, task, intent, annotationStorage) {
2268     const isPassword = this.hasFieldFlag(AnnotationFieldFlag.PASSWORD);
2269     if (isPassword) {
2270       return null;
2271     }
2272     const storageEntry = annotationStorage?.get(this.data.id);
2273     let value, rotation;
2274     if (storageEntry) {
2275       value = storageEntry.formattedValue || storageEntry.value;
2276       rotation = storageEntry.rotation;
2277     }
2278 
2279     if (
2280       rotation === undefined &&
2281       value === undefined &&
2282       !this._needAppearances
2283     ) {
2284       if (!this._hasValueFromXFA || this.appearance) {
2285         // The annotation hasn't been rendered so use the appearance.
2286         return null;
2287       }
2288     }
2289 
2290     // Empty or it has a trailing whitespace.
2291     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2292 
2293     if (value === undefined) {
2294       // The annotation has its value in XFA datasets but not in the V field.
2295       value = this.data.fieldValue;
2296       if (!value) {
2297         return `/Tx BMC q ${colors}Q EMC`;
2298       }
2299     }
2300 
2301     if (Array.isArray(value) && value.length === 1) {
2302       value = value[0];
2303     }
2304 
2305     assert(typeof value === "string", "Expected `value` to be a string.");
2306     value = value.trimEnd();
2307 
2308     if (this.data.combo) {
2309       // The value can be one of the exportValue or any other values.
2310       const option = this.data.options.find(
2311         ({ exportValue }) => value === exportValue
2312       );
2313       value = option?.displayValue || value;
2314     }
2315 
2316     if (value === "") {
2317       // the field is empty: nothing to render
2318       return `/Tx BMC q ${colors}Q EMC`;
2319     }
2320 
2321     if (rotation === undefined) {
2322       rotation = this.rotation;
2323     }
2324 
2325     let lineCount = -1;
2326     let lines;
2327 
2328     // We could have a text containing for example some sequences of chars and
2329     // their diacritics (e.g. "é".normalize("NFKD") shows 1 char when it's 2).
2330     // Positioning diacritics is really something we don't want to do here.
2331     // So if a font has a glyph for a acute accent and one for "e" then we won't
2332     // get any encoding issues but we'll render "e" and then "´".
2333     // It's why we normalize the string. We use NFC to preserve the initial
2334     // string, (e.g. "²".normalize("NFC") === "²"
2335     // but "²".normalize("NFKC") === "2").
2336     //
2337     // TODO: it isn't a perfect solution, some chars like "ẹ́" will be
2338     // decomposed into two chars ("ẹ" and "´"), so we should detect such
2339     // situations and then use either FakeUnicodeFont or set the
2340     // /NeedAppearances flag.
2341     if (this.data.multiLine) {
2342       lines = value.split(/\r\n?|\n/).map(line => line.normalize("NFC"));
2343       lineCount = lines.length;
2344     } else {
2345       lines = [value.replace(/\r\n?|\n/, "").normalize("NFC")];
2346     }
2347 
2348     const defaultPadding = 1;
2349     const defaultHPadding = 2;
2350     let totalHeight = this.data.rect[3] - this.data.rect[1];
2351     let totalWidth = this.data.rect[2] - this.data.rect[0];
2352 
2353     if (rotation === 90 || rotation === 270) {
2354       [totalWidth, totalHeight] = [totalHeight, totalWidth];
2355     }
2356 
2357     if (!this._defaultAppearance) {
2358       // The DA is required and must be a string.
2359       // If there is no font named Helvetica in the resource dictionary,
2360       // the evaluator will fall back to a default font.
2361       // Doing so prevents exceptions and allows saving/printing
2362       // the file as expected.
2363       this.data.defaultAppearanceData = parseDefaultAppearance(
2364         (this._defaultAppearance = "/Helvetica 0 Tf 0 g")
2365       );
2366     }
2367 
2368     let font = await WidgetAnnotation._getFontData(
2369       evaluator,
2370       task,
2371       this.data.defaultAppearanceData,
2372       this._fieldResources.mergedResources
2373     );
2374 
2375     let defaultAppearance, fontSize, lineHeight;
2376     const encodedLines = [];
2377     let encodingError = false;
2378     for (const line of lines) {
2379       const encodedString = font.encodeString(line);
2380       if (encodedString.length > 1) {
2381         encodingError = true;
2382       }
2383       encodedLines.push(encodedString.join(""));
2384     }
2385 
2386     if (encodingError && intent & RenderingIntentFlag.SAVE) {
2387       // We don't have a way to render the field, so we just rely on the
2388       // /NeedAppearances trick to let the different sofware correctly render
2389       // this pdf.
2390       return { needAppearances: true };
2391     }
2392 
2393     // We check that the font is able to encode the string.
2394     if (encodingError && this._isOffscreenCanvasSupported) {
2395       // If it can't then we fallback on fake unicode font (mapped to sans-serif
2396       // for the rendering).
2397       // It means that a printed form can be rendered differently (it depends on
2398       // the sans-serif font) but at least we've something to render.
2399       // In an ideal world the associated font should correctly handle the
2400       // possible chars but a user can add a smiley or whatever.
2401       // We could try to embed a font but it means that we must have access
2402       // to the raw font file.
2403       const fontFamily = this.data.comb ? "monospace" : "sans-serif";
2404       const fakeUnicodeFont = new FakeUnicodeFont(evaluator.xref, fontFamily);
2405       const resources = fakeUnicodeFont.createFontResources(lines.join(""));
2406       const newFont = resources.getRaw("Font");
2407 
2408       if (this._fieldResources.mergedResources.has("Font")) {
2409         const oldFont = this._fieldResources.mergedResources.get("Font");
2410         for (const key of newFont.getKeys()) {
2411           oldFont.set(key, newFont.getRaw(key));
2412         }
2413       } else {
2414         this._fieldResources.mergedResources.set("Font", newFont);
2415       }
2416 
2417       const fontName = fakeUnicodeFont.fontName.name;
2418       font = await WidgetAnnotation._getFontData(
2419         evaluator,
2420         task,
2421         { fontName, fontSize: 0 },
2422         resources
2423       );
2424 
2425       for (let i = 0, ii = encodedLines.length; i < ii; i++) {
2426         encodedLines[i] = stringToUTF16String(lines[i]);
2427       }
2428 
2429       const savedDefaultAppearance = Object.assign(
2430         Object.create(null),
2431         this.data.defaultAppearanceData
2432       );
2433       this.data.defaultAppearanceData.fontSize = 0;
2434       this.data.defaultAppearanceData.fontName = fontName;
2435 
2436       [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(
2437         totalHeight - 2 * defaultPadding,
2438         totalWidth - 2 * defaultHPadding,
2439         value,
2440         font,
2441         lineCount
2442       );
2443 
2444       this.data.defaultAppearanceData = savedDefaultAppearance;
2445     } else {
2446       if (!this._isOffscreenCanvasSupported) {
2447         warn(
2448           "_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly."
2449         );
2450       }
2451 
2452       [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(
2453         totalHeight - 2 * defaultPadding,
2454         totalWidth - 2 * defaultHPadding,
2455         value,
2456         font,
2457         lineCount
2458       );
2459     }
2460 
2461     let descent = font.descent;
2462     if (isNaN(descent)) {
2463       descent = BASELINE_FACTOR * lineHeight;
2464     } else {
2465       descent = Math.max(
2466         BASELINE_FACTOR * lineHeight,
2467         Math.abs(descent) * fontSize
2468       );
2469     }
2470 
2471     // Take into account the space we have to compute the default vertical
2472     // padding.
2473     const defaultVPadding = Math.min(
2474       Math.floor((totalHeight - fontSize) / 2),
2475       defaultPadding
2476     );
2477     const alignment = this.data.textAlignment;
2478 
2479     if (this.data.multiLine) {
2480       return this._getMultilineAppearance(
2481         defaultAppearance,
2482         encodedLines,
2483         font,
2484         fontSize,
2485         totalWidth,
2486         totalHeight,
2487         alignment,
2488         defaultHPadding,
2489         defaultVPadding,
2490         descent,
2491         lineHeight,
2492         annotationStorage
2493       );
2494     }
2495 
2496     if (this.data.comb) {
2497       return this._getCombAppearance(
2498         defaultAppearance,
2499         font,
2500         encodedLines[0],
2501         fontSize,
2502         totalWidth,
2503         totalHeight,
2504         defaultHPadding,
2505         defaultVPadding,
2506         descent,
2507         lineHeight,
2508         annotationStorage
2509       );
2510     }
2511 
2512     const bottomPadding = defaultVPadding + descent;
2513     if (alignment === 0 || alignment > 2) {
2514       // Left alignment: nothing to do
2515       return (
2516         `/Tx BMC q ${colors}BT ` +
2517         defaultAppearance +
2518         ` 1 0 0 1 ${numberToString(defaultHPadding)} ${numberToString(
2519           bottomPadding
2520         )} Tm (${escapeString(encodedLines[0])}) Tj` +
2521         " ET Q EMC"
2522       );
2523     }
2524 
2525     const prevInfo = { shift: 0 };
2526     const renderedText = this._renderText(
2527       encodedLines[0],
2528       font,
2529       fontSize,
2530       totalWidth,
2531       alignment,
2532       prevInfo,
2533       defaultHPadding,
2534       bottomPadding
2535     );
2536     return (
2537       `/Tx BMC q ${colors}BT ` +
2538       defaultAppearance +
2539       ` 1 0 0 1 0 0 Tm ${renderedText}` +
2540       " ET Q EMC"
2541     );
2542   }
2543 
2544   static async _getFontData(evaluator, task, appearanceData, resources) {
2545     const operatorList = new OperatorList();
2546     const initialState = {
2547       font: null,
2548       clone() {
2549         return this;
2550       },
2551     };
2552 
2553     const { fontName, fontSize } = appearanceData;
2554     await evaluator.handleSetFont(
2555       resources,
2556       [fontName && Name.get(fontName), fontSize],
2557       /* fontRef = */ null,
2558       operatorList,
2559       task,
2560       initialState,
2561       /* fallbackFontDict = */ null
2562     );
2563 
2564     return initialState.font;
2565   }
2566 
2567   _getTextWidth(text, font) {
2568     return (
2569       font
2570         .charsToGlyphs(text)
2571         .reduce((width, glyph) => width + glyph.width, 0) / 1000
2572     );
2573   }
2574 
2575   _computeFontSize(height, width, text, font, lineCount) {
2576     let { fontSize } = this.data.defaultAppearanceData;
2577     let lineHeight = (fontSize || 12) * LINE_FACTOR,
2578       numberOfLines = Math.round(height / lineHeight);
2579 
2580     if (!fontSize) {
2581       // A zero value for size means that the font shall be auto-sized:
2582       // its size shall be computed as a function of the height of the
2583       // annotation rectangle (see 12.7.3.3).
2584 
2585       const roundWithTwoDigits = x => Math.floor(x * 100) / 100;
2586 
2587       if (lineCount === -1) {
2588         // Get the text width for a font size of 1.
2589         const textWidth = this._getTextWidth(text, font);
2590 
2591         // width / textWidth is the max font size to fit the width.
2592         // height / LINE_FACTOR is the max font size to fit the height.
2593         fontSize = roundWithTwoDigits(
2594           Math.min(height / LINE_FACTOR, width / textWidth)
2595         );
2596         numberOfLines = 1;
2597       } else {
2598         const lines = text.split(/\r\n?|\n/);
2599         const cachedLines = [];
2600         for (const line of lines) {
2601           const encoded = font.encodeString(line).join("");
2602           const glyphs = font.charsToGlyphs(encoded);
2603           const positions = font.getCharPositions(encoded);
2604           cachedLines.push({
2605             line: encoded,
2606             glyphs,
2607             positions,
2608           });
2609         }
2610 
2611         const isTooBig = fsize => {
2612           // Return true when the text doesn't fit the given height.
2613           let totalHeight = 0;
2614           for (const cache of cachedLines) {
2615             const chunks = this._splitLine(null, font, fsize, width, cache);
2616             totalHeight += chunks.length * fsize;
2617             if (totalHeight > height) {
2618               return true;
2619             }
2620           }
2621           return false;
2622         };
2623 
2624         // Hard to guess how many lines there are.
2625         // The field may have been sized to have 10 lines
2626         // and the user entered only 1 so if we get font size from
2627         // height and number of lines then we'll get something too big.
2628         // So we compute a fake number of lines based on height and
2629         // a font size equal to 12 (this is the default font size in
2630         // Acrobat).
2631         // Then we'll adjust font size to what we have really.
2632         numberOfLines = Math.max(numberOfLines, lineCount);
2633 
2634         while (true) {
2635           lineHeight = height / numberOfLines;
2636           fontSize = roundWithTwoDigits(lineHeight / LINE_FACTOR);
2637 
2638           if (isTooBig(fontSize)) {
2639             numberOfLines++;
2640             continue;
2641           }
2642 
2643           break;
2644         }
2645       }
2646 
2647       const { fontName, fontColor } = this.data.defaultAppearanceData;
2648       this._defaultAppearance = createDefaultAppearance({
2649         fontSize,
2650         fontName,
2651         fontColor,
2652       });
2653     }
2654 
2655     return [this._defaultAppearance, fontSize, height / numberOfLines];
2656   }
2657 
2658   _renderText(
2659     text,
2660     font,
2661     fontSize,
2662     totalWidth,
2663     alignment,
2664     prevInfo,
2665     hPadding,
2666     vPadding
2667   ) {
2668     // TODO: we need to take into account (if possible) how the text
2669     // is rendered. For example in arabic, the cumulated width of some
2670     // glyphs isn't equal to the width of the rendered glyphs because
2671     // of ligatures.
2672     let shift;
2673     if (alignment === 1) {
2674       // Center
2675       const width = this._getTextWidth(text, font) * fontSize;
2676       shift = (totalWidth - width) / 2;
2677     } else if (alignment === 2) {
2678       // Right
2679       const width = this._getTextWidth(text, font) * fontSize;
2680       shift = totalWidth - width - hPadding;
2681     } else {
2682       shift = hPadding;
2683     }
2684     const shiftStr = numberToString(shift - prevInfo.shift);
2685     prevInfo.shift = shift;
2686     vPadding = numberToString(vPadding);
2687 
2688     return `${shiftStr} ${vPadding} Td (${escapeString(text)}) Tj`;
2689   }
2690 
2691   /**
2692    * @private
2693    */
2694   _getSaveFieldResources(xref) {
2695     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
2696       assert(
2697         this.data.defaultAppearanceData,
2698         "Expected `_defaultAppearanceData` to have been set."
2699       );
2700     }
2701     const { localResources, appearanceResources, acroFormResources } =
2702       this._fieldResources;
2703 
2704     const fontName = this.data.defaultAppearanceData?.fontName;
2705     if (!fontName) {
2706       return localResources || Dict.empty;
2707     }
2708 
2709     for (const resources of [localResources, appearanceResources]) {
2710       if (resources instanceof Dict) {
2711         const localFont = resources.get("Font");
2712         if (localFont instanceof Dict && localFont.has(fontName)) {
2713           return resources;
2714         }
2715       }
2716     }
2717     if (acroFormResources instanceof Dict) {
2718       const acroFormFont = acroFormResources.get("Font");
2719       if (acroFormFont instanceof Dict && acroFormFont.has(fontName)) {
2720         const subFontDict = new Dict(xref);
2721         subFontDict.set(fontName, acroFormFont.getRaw(fontName));
2722 
2723         const subResourcesDict = new Dict(xref);
2724         subResourcesDict.set("Font", subFontDict);
2725 
2726         return Dict.merge({
2727           xref,
2728           dictArray: [subResourcesDict, localResources],
2729           mergeSubDicts: true,
2730         });
2731       }
2732     }
2733     return localResources || Dict.empty;
2734   }
2735 
2736   getFieldObject() {
2737     return null;
2738   }
2739 }
2740 
2741 class TextWidgetAnnotation extends WidgetAnnotation {
2742   constructor(params) {
2743     super(params);
2744 
2745     const { dict } = params;
2746 
2747     if (dict.has("PMD")) {
2748       // It's used to display a barcode but it isn't specified so we just hide
2749       // it to avoid any confusion.
2750       this.flags |= AnnotationFlag.HIDDEN;
2751       this.data.hidden = true;
2752       warn("Barcodes are not supported");
2753     }
2754 
2755     this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML;
2756     this._hasText = true;
2757 
2758     // The field value is always a string.
2759     if (typeof this.data.fieldValue !== "string") {
2760       this.data.fieldValue = "";
2761     }
2762 
2763     // Determine the alignment of text in the field.
2764     let alignment = getInheritableProperty({ dict, key: "Q" });
2765     if (!Number.isInteger(alignment) || alignment < 0 || alignment > 2) {
2766       alignment = null;
2767     }
2768     this.data.textAlignment = alignment;
2769 
2770     // Determine the maximum length of text in the field.
2771     let maximumLength = getInheritableProperty({ dict, key: "MaxLen" });
2772     if (!Number.isInteger(maximumLength) || maximumLength < 0) {
2773       maximumLength = 0;
2774     }
2775     this.data.maxLen = maximumLength;
2776 
2777     // Process field flags for the display layer.
2778     this.data.multiLine = this.hasFieldFlag(AnnotationFieldFlag.MULTILINE);
2779     this.data.comb =
2780       this.hasFieldFlag(AnnotationFieldFlag.COMB) &&
2781       !this.hasFieldFlag(AnnotationFieldFlag.MULTILINE) &&
2782       !this.hasFieldFlag(AnnotationFieldFlag.PASSWORD) &&
2783       !this.hasFieldFlag(AnnotationFieldFlag.FILESELECT) &&
2784       this.data.maxLen !== 0;
2785     this.data.doNotScroll = this.hasFieldFlag(AnnotationFieldFlag.DONOTSCROLL);
2786   }
2787 
2788   get hasTextContent() {
2789     return !!this.appearance && !this._needAppearances;
2790   }
2791 
2792   _getCombAppearance(
2793     defaultAppearance,
2794     font,
2795     text,
2796     fontSize,
2797     width,
2798     height,
2799     hPadding,
2800     vPadding,
2801     descent,
2802     lineHeight,
2803     annotationStorage
2804   ) {
2805     const combWidth = width / this.data.maxLen;
2806     // Empty or it has a trailing whitespace.
2807     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2808 
2809     const buf = [];
2810     const positions = font.getCharPositions(text);
2811     for (const [start, end] of positions) {
2812       buf.push(`(${escapeString(text.substring(start, end))}) Tj`);
2813     }
2814 
2815     const renderedComb = buf.join(` ${numberToString(combWidth)} 0 Td `);
2816     return (
2817       `/Tx BMC q ${colors}BT ` +
2818       defaultAppearance +
2819       ` 1 0 0 1 ${numberToString(hPadding)} ${numberToString(
2820         vPadding + descent
2821       )} Tm ${renderedComb}` +
2822       " ET Q EMC"
2823     );
2824   }
2825 
2826   _getMultilineAppearance(
2827     defaultAppearance,
2828     lines,
2829     font,
2830     fontSize,
2831     width,
2832     height,
2833     alignment,
2834     hPadding,
2835     vPadding,
2836     descent,
2837     lineHeight,
2838     annotationStorage
2839   ) {
2840     const buf = [];
2841     const totalWidth = width - 2 * hPadding;
2842     const prevInfo = { shift: 0 };
2843     for (let i = 0, ii = lines.length; i < ii; i++) {
2844       const line = lines[i];
2845       const chunks = this._splitLine(line, font, fontSize, totalWidth);
2846       for (let j = 0, jj = chunks.length; j < jj; j++) {
2847         const chunk = chunks[j];
2848         const vShift =
2849           i === 0 && j === 0 ? -vPadding - (lineHeight - descent) : -lineHeight;
2850         buf.push(
2851           this._renderText(
2852             chunk,
2853             font,
2854             fontSize,
2855             width,
2856             alignment,
2857             prevInfo,
2858             hPadding,
2859             vShift
2860           )
2861         );
2862       }
2863     }
2864 
2865     // Empty or it has a trailing whitespace.
2866     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2867     const renderedText = buf.join("\n");
2868 
2869     return (
2870       `/Tx BMC q ${colors}BT ` +
2871       defaultAppearance +
2872       ` 1 0 0 1 0 ${numberToString(height)} Tm ${renderedText}` +
2873       " ET Q EMC"
2874     );
2875   }
2876 
2877   _splitLine(line, font, fontSize, width, cache = {}) {
2878     line = cache.line || line;
2879 
2880     const glyphs = cache.glyphs || font.charsToGlyphs(line);
2881 
2882     if (glyphs.length <= 1) {
2883       // Nothing to split
2884       return [line];
2885     }
2886 
2887     const positions = cache.positions || font.getCharPositions(line);
2888     const scale = fontSize / 1000;
2889     const chunks = [];
2890 
2891     let lastSpacePosInStringStart = -1,
2892       lastSpacePosInStringEnd = -1,
2893       lastSpacePos = -1,
2894       startChunk = 0,
2895       currentWidth = 0;
2896 
2897     for (let i = 0, ii = glyphs.length; i < ii; i++) {
2898       const [start, end] = positions[i];
2899       const glyph = glyphs[i];
2900       const glyphWidth = glyph.width * scale;
2901       if (glyph.unicode === " ") {
2902         if (currentWidth + glyphWidth > width) {
2903           // We can break here
2904           chunks.push(line.substring(startChunk, start));
2905           startChunk = start;
2906           currentWidth = glyphWidth;
2907           lastSpacePosInStringStart = -1;
2908           lastSpacePos = -1;
2909         } else {
2910           currentWidth += glyphWidth;
2911           lastSpacePosInStringStart = start;
2912           lastSpacePosInStringEnd = end;
2913           lastSpacePos = i;
2914         }
2915       } else if (currentWidth + glyphWidth > width) {
2916         // We must break to the last white position (if available)
2917         if (lastSpacePosInStringStart !== -1) {
2918           chunks.push(line.substring(startChunk, lastSpacePosInStringEnd));
2919           startChunk = lastSpacePosInStringEnd;
2920           i = lastSpacePos + 1;
2921           lastSpacePosInStringStart = -1;
2922           currentWidth = 0;
2923         } else {
2924           // Just break in the middle of the word
2925           chunks.push(line.substring(startChunk, start));
2926           startChunk = start;
2927           currentWidth = glyphWidth;
2928         }
2929       } else {
2930         currentWidth += glyphWidth;
2931       }
2932     }
2933 
2934     if (startChunk < line.length) {
2935       chunks.push(line.substring(startChunk, line.length));
2936     }
2937 
2938     return chunks;
2939   }
2940 
2941   async extractTextContent(evaluator, task, viewBox) {
2942     await super.extractTextContent(evaluator, task, viewBox);
2943     const text = this.data.textContent;
2944     if (!text) {
2945       return;
2946     }
2947 
2948     // The text extractor doesn't handle empty lines correctly, so if the
2949     // content we get is more or less (modulo whitespaces) the same as the
2950     // field value we just ignore it.
2951     const allText = text.join("\n");
2952     if (allText === this.data.fieldValue) {
2953       return;
2954     }
2955     const regex = allText.replaceAll(/([.*+?^${}()|[\]\\])|(\s+)/g, (_m, p1) =>
2956       p1 ? `\\${p1}` : "\\s+"
2957     );
2958     if (new RegExp(`^\\s*${regex}\\s*$`).test(this.data.fieldValue)) {
2959       this.data.textContent = this.data.fieldValue.split("\n");
2960     }
2961   }
2962 
2963   getFieldObject() {
2964     return {
2965       id: this.data.id,
2966       value: this.data.fieldValue,
2967       defaultValue: this.data.defaultFieldValue || "",
2968       multiline: this.data.multiLine,
2969       password: this.hasFieldFlag(AnnotationFieldFlag.PASSWORD),
2970       charLimit: this.data.maxLen,
2971       comb: this.data.comb,
2972       editable: !this.data.readOnly,
2973       hidden: this.data.hidden,
2974       name: this.data.fieldName,
2975       rect: this.data.rect,
2976       actions: this.data.actions,
2977       page: this.data.pageIndex,
2978       strokeColor: this.data.borderColor,
2979       fillColor: this.data.backgroundColor,
2980       rotation: this.rotation,
2981       type: "text",
2982     };
2983   }
2984 }
2985 
2986 class ButtonWidgetAnnotation extends WidgetAnnotation {
2987   constructor(params) {
2988     super(params);
2989 
2990     this.checkedAppearance = null;
2991     this.uncheckedAppearance = null;
2992 
2993     this.data.checkBox =
2994       !this.hasFieldFlag(AnnotationFieldFlag.RADIO) &&
2995       !this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2996     this.data.radioButton =
2997       this.hasFieldFlag(AnnotationFieldFlag.RADIO) &&
2998       !this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2999     this.data.pushButton = this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
3000     this.data.isTooltipOnly = false;
3001 
3002     if (this.data.checkBox) {
3003       this._processCheckBox(params);
3004     } else if (this.data.radioButton) {
3005       this._processRadioButton(params);
3006     } else if (this.data.pushButton) {
3007       this.data.hasOwnCanvas = true;
3008       this.data.noHTML = false;
3009       this._processPushButton(params);
3010     } else {
3011       warn("Invalid field flags for button widget annotation");
3012     }
3013   }
3014 
3015   async getOperatorList(evaluator, task, intent, annotationStorage) {
3016     if (this.data.pushButton) {
3017       return super.getOperatorList(
3018         evaluator,
3019         task,
3020         intent,
3021         false, // we use normalAppearance to render the button
3022         annotationStorage
3023       );
3024     }
3025 
3026     let value = null;
3027     let rotation = null;
3028     if (annotationStorage) {
3029       const storageEntry = annotationStorage.get(this.data.id);
3030       value = storageEntry ? storageEntry.value : null;
3031       rotation = storageEntry ? storageEntry.rotation : null;
3032     }
3033 
3034     if (value === null && this.appearance) {
3035       // Nothing in the annotationStorage.
3036       // But we've a default appearance so use it.
3037       return super.getOperatorList(evaluator, task, intent, annotationStorage);
3038     }
3039 
3040     if (value === null || value === undefined) {
3041       // There is no default appearance so use the one derived
3042       // from the field value.
3043       value = this.data.checkBox
3044         ? this.data.fieldValue === this.data.exportValue
3045         : this.data.fieldValue === this.data.buttonValue;
3046     }
3047 
3048     const appearance = value
3049       ? this.checkedAppearance
3050       : this.uncheckedAppearance;
3051     if (appearance) {
3052       const savedAppearance = this.appearance;
3053       const savedMatrix = lookupMatrix(
3054         appearance.dict.getArray("Matrix"),
3055         IDENTITY_MATRIX
3056       );
3057 
3058       if (rotation) {
3059         appearance.dict.set(
3060           "Matrix",
3061           this.getRotationMatrix(annotationStorage)
3062         );
3063       }
3064 
3065       this.appearance = appearance;
3066       const operatorList = super.getOperatorList(
3067         evaluator,
3068         task,
3069         intent,
3070         annotationStorage
3071       );
3072       this.appearance = savedAppearance;
3073       appearance.dict.set("Matrix", savedMatrix);
3074       return operatorList;
3075     }
3076 
3077     // No appearance
3078     return {
3079       opList: new OperatorList(),
3080       separateForm: false,
3081       separateCanvas: false,
3082     };
3083   }
3084 
3085   async save(evaluator, task, annotationStorage, changes) {
3086     if (this.data.checkBox) {
3087       this._saveCheckbox(evaluator, task, annotationStorage, changes);
3088       return;
3089     }
3090 
3091     if (this.data.radioButton) {
3092       this._saveRadioButton(evaluator, task, annotationStorage, changes);
3093     }
3094   }
3095 
3096   async _saveCheckbox(evaluator, task, annotationStorage, changes) {
3097     if (!annotationStorage) {
3098       return;
3099     }
3100     const storageEntry = annotationStorage.get(this.data.id);
3101     const flags = this._buildFlags(storageEntry?.noView, storageEntry?.noPrint);
3102     let rotation = storageEntry?.rotation,
3103       value = storageEntry?.value;
3104 
3105     if (rotation === undefined && flags === undefined) {
3106       if (value === undefined) {
3107         return;
3108       }
3109 
3110       const defaultValue = this.data.fieldValue === this.data.exportValue;
3111       if (defaultValue === value) {
3112         return;
3113       }
3114     }
3115 
3116     let dict = evaluator.xref.fetchIfRef(this.ref);
3117     if (!(dict instanceof Dict)) {
3118       return;
3119     }
3120     dict = dict.clone();
3121 
3122     if (rotation === undefined) {
3123       rotation = this.rotation;
3124     }
3125     if (value === undefined) {
3126       value = this.data.fieldValue === this.data.exportValue;
3127     }
3128 
3129     const xfa = {
3130       path: this.data.fieldName,
3131       value: value ? this.data.exportValue : "",
3132     };
3133 
3134     const name = Name.get(value ? this.data.exportValue : "Off");
3135     this.setValue(dict, name, evaluator.xref, changes);
3136 
3137     dict.set("AS", name);
3138     dict.set("M", `D:${getModificationDate()}`);
3139     if (flags !== undefined) {
3140       dict.set("F", flags);
3141     }
3142 
3143     const maybeMK = this._getMKDict(rotation);
3144     if (maybeMK) {
3145       dict.set("MK", maybeMK);
3146     }
3147 
3148     changes.put(this.ref, {
3149       data: dict,
3150       xfa,
3151       needAppearances: false,
3152     });
3153   }
3154 
3155   async _saveRadioButton(evaluator, task, annotationStorage, changes) {
3156     if (!annotationStorage) {
3157       return;
3158     }
3159     const storageEntry = annotationStorage.get(this.data.id);
3160     const flags = this._buildFlags(storageEntry?.noView, storageEntry?.noPrint);
3161     let rotation = storageEntry?.rotation,
3162       value = storageEntry?.value;
3163 
3164     if (rotation === undefined && flags === undefined) {
3165       if (value === undefined) {
3166         return;
3167       }
3168 
3169       const defaultValue = this.data.fieldValue === this.data.buttonValue;
3170       if (defaultValue === value) {
3171         return;
3172       }
3173     }
3174 
3175     let dict = evaluator.xref.fetchIfRef(this.ref);
3176     if (!(dict instanceof Dict)) {
3177       return;
3178     }
3179     dict = dict.clone();
3180 
3181     if (value === undefined) {
3182       value = this.data.fieldValue === this.data.buttonValue;
3183     }
3184 
3185     if (rotation === undefined) {
3186       rotation = this.rotation;
3187     }
3188 
3189     const xfa = {
3190       path: this.data.fieldName,
3191       value: value ? this.data.buttonValue : "",
3192     };
3193 
3194     const name = Name.get(value ? this.data.buttonValue : "Off");
3195     if (value) {
3196       this.setValue(dict, name, evaluator.xref, changes);
3197     }
3198 
3199     dict.set("AS", name);
3200     dict.set("M", `D:${getModificationDate()}`);
3201     if (flags !== undefined) {
3202       dict.set("F", flags);
3203     }
3204 
3205     const maybeMK = this._getMKDict(rotation);
3206     if (maybeMK) {
3207       dict.set("MK", maybeMK);
3208     }
3209 
3210     changes.put(this.ref, {
3211       data: dict,
3212       xfa,
3213       needAppearances: false,
3214     });
3215   }
3216 
3217   _getDefaultCheckedAppearance(params, type) {
3218     const width = this.data.rect[2] - this.data.rect[0];
3219     const height = this.data.rect[3] - this.data.rect[1];
3220     const bbox = [0, 0, width, height];
3221 
3222     // Ratio used to have a mark slightly smaller than the bbox.
3223     const FONT_RATIO = 0.8;
3224     const fontSize = Math.min(width, height) * FONT_RATIO;
3225 
3226     // Char Metrics
3227     // Widths came from widths for ZapfDingbats.
3228     // Heights are guessed with Fontforge and FoxitDingbats.pfb.
3229     let metrics, char;
3230     if (type === "check") {
3231       // Char 33 (2713 in unicode)
3232       metrics = {
3233         width: 0.755 * fontSize,
3234         height: 0.705 * fontSize,
3235       };
3236       char = "\x33";
3237     } else if (type === "disc") {
3238       // Char 6C (25CF in unicode)
3239       metrics = {
3240         width: 0.791 * fontSize,
3241         height: 0.705 * fontSize,
3242       };
3243       char = "\x6C";
3244     } else {
3245       unreachable(`_getDefaultCheckedAppearance - unsupported type: ${type}`);
3246     }
3247 
3248     // Values to center the glyph in the bbox.
3249     const xShift = numberToString((width - metrics.width) / 2);
3250     const yShift = numberToString((height - metrics.height) / 2);
3251 
3252     const appearance = `q BT /PdfJsZaDb ${fontSize} Tf 0 g ${xShift} ${yShift} Td (${char}) Tj ET Q`;
3253 
3254     const appearanceStreamDict = new Dict(params.xref);
3255     appearanceStreamDict.set("FormType", 1);
3256     appearanceStreamDict.set("Subtype", Name.get("Form"));
3257     appearanceStreamDict.set("Type", Name.get("XObject"));
3258     appearanceStreamDict.set("BBox", bbox);
3259     appearanceStreamDict.set("Matrix", [1, 0, 0, 1, 0, 0]);
3260     appearanceStreamDict.set("Length", appearance.length);
3261 
3262     const resources = new Dict(params.xref);
3263     const font = new Dict(params.xref);
3264     font.set("PdfJsZaDb", this.fallbackFontDict);
3265     resources.set("Font", font);
3266 
3267     appearanceStreamDict.set("Resources", resources);
3268 
3269     this.checkedAppearance = new StringStream(appearance);
3270     this.checkedAppearance.dict = appearanceStreamDict;
3271 
3272     this._streams.push(this.checkedAppearance);
3273   }
3274 
3275   _processCheckBox(params) {
3276     const customAppearance = params.dict.get("AP");
3277     if (!(customAppearance instanceof Dict)) {
3278       return;
3279     }
3280 
3281     const normalAppearance = customAppearance.get("N");
3282     if (!(normalAppearance instanceof Dict)) {
3283       return;
3284     }
3285 
3286     // See https://bugzilla.mozilla.org/show_bug.cgi?id=1722036.
3287     // If we've an AS and a V then take AS.
3288     const asValue = this._decodeFormValue(params.dict.get("AS"));
3289     if (typeof asValue === "string") {
3290       this.data.fieldValue = asValue;
3291     }
3292 
3293     const yes =
3294       this.data.fieldValue !== null && this.data.fieldValue !== "Off"
3295         ? this.data.fieldValue
3296         : "Yes";
3297 
3298     const exportValues = normalAppearance.getKeys();
3299     if (exportValues.length === 0) {
3300       exportValues.push("Off", yes);
3301     } else if (exportValues.length === 1) {
3302       if (exportValues[0] === "Off") {
3303         exportValues.push(yes);
3304       } else {
3305         exportValues.unshift("Off");
3306       }
3307     } else if (exportValues.includes(yes)) {
3308       exportValues.length = 0;
3309       exportValues.push("Off", yes);
3310     } else {
3311       const otherYes = exportValues.find(v => v !== "Off");
3312       exportValues.length = 0;
3313       exportValues.push("Off", otherYes);
3314     }
3315 
3316     // Don't use a "V" entry pointing to a non-existent appearance state,
3317     // see e.g. bug1720411.pdf where it's an *empty* Name-instance.
3318     if (!exportValues.includes(this.data.fieldValue)) {
3319       this.data.fieldValue = "Off";
3320     }
3321 
3322     this.data.exportValue = exportValues[1];
3323 
3324     const checkedAppearance = normalAppearance.get(this.data.exportValue);
3325     this.checkedAppearance =
3326       checkedAppearance instanceof BaseStream ? checkedAppearance : null;
3327     const uncheckedAppearance = normalAppearance.get("Off");
3328     this.uncheckedAppearance =
3329       uncheckedAppearance instanceof BaseStream ? uncheckedAppearance : null;
3330 
3331     if (this.checkedAppearance) {
3332       this._streams.push(this.checkedAppearance);
3333     } else {
3334       this._getDefaultCheckedAppearance(params, "check");
3335     }
3336     if (this.uncheckedAppearance) {
3337       this._streams.push(this.uncheckedAppearance);
3338     }
3339     this._fallbackFontDict = this.fallbackFontDict;
3340     if (this.data.defaultFieldValue === null) {
3341       this.data.defaultFieldValue = "Off";
3342     }
3343   }
3344 
3345   _processRadioButton(params) {
3346     this.data.buttonValue = null;
3347 
3348     // The parent field's `V` entry holds a `Name` object with the appearance
3349     // state of whichever child field is currently in the "on" state.
3350     const fieldParent = params.dict.get("Parent");
3351     if (fieldParent instanceof Dict) {
3352       this.parent = params.dict.getRaw("Parent");
3353       const fieldParentValue = fieldParent.get("V");
3354       if (fieldParentValue instanceof Name) {
3355         this.data.fieldValue = this._decodeFormValue(fieldParentValue);
3356       }
3357     }
3358 
3359     // The button's value corresponds to its appearance state.
3360     const appearanceStates = params.dict.get("AP");
3361     if (!(appearanceStates instanceof Dict)) {
3362       return;
3363     }
3364     const normalAppearance = appearanceStates.get("N");
3365     if (!(normalAppearance instanceof Dict)) {
3366       return;
3367     }
3368     for (const key of normalAppearance.getKeys()) {
3369       if (key !== "Off") {
3370         this.data.buttonValue = this._decodeFormValue(key);
3371         break;
3372       }
3373     }
3374 
3375     const checkedAppearance = normalAppearance.get(this.data.buttonValue);
3376     this.checkedAppearance =
3377       checkedAppearance instanceof BaseStream ? checkedAppearance : null;
3378     const uncheckedAppearance = normalAppearance.get("Off");
3379     this.uncheckedAppearance =
3380       uncheckedAppearance instanceof BaseStream ? uncheckedAppearance : null;
3381 
3382     if (this.checkedAppearance) {
3383       this._streams.push(this.checkedAppearance);
3384     } else {
3385       this._getDefaultCheckedAppearance(params, "disc");
3386     }
3387     if (this.uncheckedAppearance) {
3388       this._streams.push(this.uncheckedAppearance);
3389     }
3390     this._fallbackFontDict = this.fallbackFontDict;
3391     if (this.data.defaultFieldValue === null) {
3392       this.data.defaultFieldValue = "Off";
3393     }
3394   }
3395 
3396   _processPushButton(params) {
3397     const { dict, annotationGlobals } = params;
3398 
3399     if (!dict.has("A") && !dict.has("AA") && !this.data.alternativeText) {
3400       warn("Push buttons without action dictionaries are not supported");
3401       return;
3402     }
3403 
3404     this.data.isTooltipOnly = !dict.has("A") && !dict.has("AA");
3405 
3406     Catalog.parseDestDictionary({
3407       destDict: dict,
3408       resultObj: this.data,
3409       docBaseUrl: annotationGlobals.baseUrl,
3410       docAttachments: annotationGlobals.attachments,
3411     });
3412   }
3413 
3414   getFieldObject() {
3415     let type = "button";
3416     let exportValues;
3417     if (this.data.checkBox) {
3418       type = "checkbox";
3419       exportValues = this.data.exportValue;
3420     } else if (this.data.radioButton) {
3421       type = "radiobutton";
3422       exportValues = this.data.buttonValue;
3423     }
3424     return {
3425       id: this.data.id,
3426       value: this.data.fieldValue || "Off",
3427       defaultValue: this.data.defaultFieldValue,
3428       exportValues,
3429       editable: !this.data.readOnly,
3430       name: this.data.fieldName,
3431       rect: this.data.rect,
3432       hidden: this.data.hidden,
3433       actions: this.data.actions,
3434       page: this.data.pageIndex,
3435       strokeColor: this.data.borderColor,
3436       fillColor: this.data.backgroundColor,
3437       rotation: this.rotation,
3438       type,
3439     };
3440   }
3441 
3442   get fallbackFontDict() {
3443     const dict = new Dict();
3444     dict.set("BaseFont", Name.get("ZapfDingbats"));
3445     dict.set("Type", Name.get("FallbackType"));
3446     dict.set("Subtype", Name.get("FallbackType"));
3447     dict.set("Encoding", Name.get("ZapfDingbatsEncoding"));
3448 
3449     return shadow(this, "fallbackFontDict", dict);
3450   }
3451 }
3452 
3453 class ChoiceWidgetAnnotation extends WidgetAnnotation {
3454   constructor(params) {
3455     super(params);
3456 
3457     const { dict, xref } = params;
3458 
3459     this.indices = dict.getArray("I");
3460     this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0;
3461 
3462     // Determine the options. The options array may consist of strings or
3463     // arrays. If the array consists of arrays, then the first element of
3464     // each array is the export value and the second element of each array is
3465     // the display value. If the array consists of strings, then these
3466     // represent both the export and display value. In this case, we convert
3467     // it to an array of arrays as well for convenience in the display layer.
3468     // Note that the specification does not state that the `Opt` field is
3469     // inheritable, but in practice PDF generators do make annotations
3470     // inherit the options from a parent annotation (issue 8094).
3471     this.data.options = [];
3472 
3473     const options = getInheritableProperty({ dict, key: "Opt" });
3474     if (Array.isArray(options)) {
3475       for (let i = 0, ii = options.length; i < ii; i++) {
3476         const option = xref.fetchIfRef(options[i]);
3477         const isOptionArray = Array.isArray(option);
3478 
3479         this.data.options[i] = {
3480           exportValue: this._decodeFormValue(
3481             isOptionArray ? xref.fetchIfRef(option[0]) : option
3482           ),
3483           displayValue: this._decodeFormValue(
3484             isOptionArray ? xref.fetchIfRef(option[1]) : option
3485           ),
3486         };
3487       }
3488     }
3489 
3490     if (!this.hasIndices) {
3491       // The field value can be `null` if no item is selected, a string if one
3492       // item is selected or an array of strings if multiple items are selected.
3493       // For consistency in the API and convenience in the display layer, we
3494       // always make the field value an array with zero, one or multiple items.
3495       if (typeof this.data.fieldValue === "string") {
3496         this.data.fieldValue = [this.data.fieldValue];
3497       } else if (!this.data.fieldValue) {
3498         this.data.fieldValue = [];
3499       }
3500     } else {
3501       // The specs say that we should have an indices array only with
3502       // multiselectable Choice and the "V" entry should have the
3503       // precedence, but Acrobat itself is using it whatever the
3504       // the "V" entry is (see bug 1770750).
3505       this.data.fieldValue = [];
3506       const ii = this.data.options.length;
3507       for (const i of this.indices) {
3508         if (Number.isInteger(i) && i >= 0 && i < ii) {
3509           this.data.fieldValue.push(this.data.options[i].exportValue);
3510         }
3511       }
3512     }
3513 
3514     // Process field flags for the display layer.
3515     this.data.combo = this.hasFieldFlag(AnnotationFieldFlag.COMBO);
3516     this.data.multiSelect = this.hasFieldFlag(AnnotationFieldFlag.MULTISELECT);
3517     this._hasText = true;
3518   }
3519 
3520   getFieldObject() {
3521     const type = this.data.combo ? "combobox" : "listbox";
3522     const value =
3523       this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
3524     return {
3525       id: this.data.id,
3526       value,
3527       defaultValue: this.data.defaultFieldValue,
3528       editable: !this.data.readOnly,
3529       name: this.data.fieldName,
3530       rect: this.data.rect,
3531       numItems: this.data.fieldValue.length,
3532       multipleSelection: this.data.multiSelect,
3533       hidden: this.data.hidden,
3534       actions: this.data.actions,
3535       items: this.data.options,
3536       page: this.data.pageIndex,
3537       strokeColor: this.data.borderColor,
3538       fillColor: this.data.backgroundColor,
3539       rotation: this.rotation,
3540       type,
3541     };
3542   }
3543 
3544   amendSavedDict(annotationStorage, dict) {
3545     if (!this.hasIndices) {
3546       return;
3547     }
3548     let values = annotationStorage?.get(this.data.id)?.value;
3549     if (!Array.isArray(values)) {
3550       values = [values];
3551     }
3552     const indices = [];
3553     const { options } = this.data;
3554     for (let i = 0, j = 0, ii = options.length; i < ii; i++) {
3555       if (options[i].exportValue === values[j]) {
3556         indices.push(i);
3557         j += 1;
3558       }
3559     }
3560     dict.set("I", indices);
3561   }
3562 
3563   async _getAppearance(evaluator, task, intent, annotationStorage) {
3564     if (this.data.combo) {
3565       return super._getAppearance(evaluator, task, intent, annotationStorage);
3566     }
3567 
3568     let exportedValue, rotation;
3569     const storageEntry = annotationStorage?.get(this.data.id);
3570     if (storageEntry) {
3571       rotation = storageEntry.rotation;
3572       exportedValue = storageEntry.value;
3573     }
3574 
3575     if (
3576       rotation === undefined &&
3577       exportedValue === undefined &&
3578       !this._needAppearances
3579     ) {
3580       // The annotation hasn't been rendered so use the appearance
3581       return null;
3582     }
3583 
3584     if (exportedValue === undefined) {
3585       exportedValue = this.data.fieldValue;
3586     } else if (!Array.isArray(exportedValue)) {
3587       exportedValue = [exportedValue];
3588     }
3589 
3590     const defaultPadding = 1;
3591     const defaultHPadding = 2;
3592     let totalHeight = this.data.rect[3] - this.data.rect[1];
3593     let totalWidth = this.data.rect[2] - this.data.rect[0];
3594 
3595     if (rotation === 90 || rotation === 270) {
3596       [totalWidth, totalHeight] = [totalHeight, totalWidth];
3597     }
3598 
3599     const lineCount = this.data.options.length;
3600     const valueIndices = [];
3601     for (let i = 0; i < lineCount; i++) {
3602       const { exportValue } = this.data.options[i];
3603       if (exportedValue.includes(exportValue)) {
3604         valueIndices.push(i);
3605       }
3606     }
3607 
3608     if (!this._defaultAppearance) {
3609       // The DA is required and must be a string.
3610       // If there is no font named Helvetica in the resource dictionary,
3611       // the evaluator will fall back to a default font.
3612       // Doing so prevents exceptions and allows saving/printing
3613       // the file as expected.
3614       this.data.defaultAppearanceData = parseDefaultAppearance(
3615         (this._defaultAppearance = "/Helvetica 0 Tf 0 g")
3616       );
3617     }
3618 
3619     const font = await WidgetAnnotation._getFontData(
3620       evaluator,
3621       task,
3622       this.data.defaultAppearanceData,
3623       this._fieldResources.mergedResources
3624     );
3625 
3626     let defaultAppearance;
3627     let { fontSize } = this.data.defaultAppearanceData;
3628     if (!fontSize) {
3629       const lineHeight = (totalHeight - defaultPadding) / lineCount;
3630       let lineWidth = -1;
3631       let value;
3632       for (const { displayValue } of this.data.options) {
3633         const width = this._getTextWidth(displayValue, font);
3634         if (width > lineWidth) {
3635           lineWidth = width;
3636           value = displayValue;
3637         }
3638       }
3639 
3640       [defaultAppearance, fontSize] = this._computeFontSize(
3641         lineHeight,
3642         totalWidth - 2 * defaultHPadding,
3643         value,
3644         font,
3645         -1
3646       );
3647     } else {
3648       defaultAppearance = this._defaultAppearance;
3649     }
3650 
3651     const lineHeight = fontSize * LINE_FACTOR;
3652     const vPadding = (lineHeight - fontSize) / 2;
3653     const numberOfVisibleLines = Math.floor(totalHeight / lineHeight);
3654 
3655     let firstIndex = 0;
3656     if (valueIndices.length > 0) {
3657       const minIndex = Math.min(...valueIndices);
3658       const maxIndex = Math.max(...valueIndices);
3659 
3660       firstIndex = Math.max(0, maxIndex - numberOfVisibleLines + 1);
3661       if (firstIndex > minIndex) {
3662         firstIndex = minIndex;
3663       }
3664     }
3665     const end = Math.min(firstIndex + numberOfVisibleLines + 1, lineCount);
3666 
3667     const buf = ["/Tx BMC q", `1 1 ${totalWidth} ${totalHeight} re W n`];
3668 
3669     if (valueIndices.length) {
3670       // This value has been copied/pasted from annotation-choice-widget.pdf.
3671       // It corresponds to rgb(153, 193, 218).
3672       buf.push("0.600006 0.756866 0.854904 rg");
3673 
3674       // Highlight the lines in filling a blue rectangle at the selected
3675       // positions.
3676       for (const index of valueIndices) {
3677         if (firstIndex <= index && index < end) {
3678           buf.push(
3679             `1 ${
3680               totalHeight - (index - firstIndex + 1) * lineHeight
3681             } ${totalWidth} ${lineHeight} re f`
3682           );
3683         }
3684       }
3685     }
3686     buf.push("BT", defaultAppearance, `1 0 0 1 0 ${totalHeight} Tm`);
3687 
3688     const prevInfo = { shift: 0 };
3689     for (let i = firstIndex; i < end; i++) {
3690       const { displayValue } = this.data.options[i];
3691       const vpadding = i === firstIndex ? vPadding : 0;
3692       buf.push(
3693         this._renderText(
3694           displayValue,
3695           font,
3696           fontSize,
3697           totalWidth,
3698           0,
3699           prevInfo,
3700           defaultHPadding,
3701           -lineHeight + vpadding
3702         )
3703       );
3704     }
3705 
3706     buf.push("ET Q EMC");
3707 
3708     return buf.join("\n");
3709   }
3710 }
3711 
3712 class SignatureWidgetAnnotation extends WidgetAnnotation {
3713   constructor(params) {
3714     super(params);
3715 
3716     // Unset the fieldValue since it's (most likely) a `Dict` which is
3717     // non-serializable and will thus cause errors when sending annotations
3718     // to the main-thread (issue 10347).
3719     this.data.fieldValue = null;
3720     this.data.hasOwnCanvas = this.data.noRotate;
3721     this.data.noHTML = !this.data.hasOwnCanvas;
3722   }
3723 
3724   getFieldObject() {
3725     return {
3726       id: this.data.id,
3727       value: null,
3728       page: this.data.pageIndex,
3729       type: "signature",
3730     };
3731   }
3732 }
3733 
3734 class TextAnnotation extends MarkupAnnotation {
3735   constructor(params) {
3736     const DEFAULT_ICON_SIZE = 22; // px
3737 
3738     super(params);
3739 
3740     // No rotation for Text (see 12.5.6.4).
3741     this.data.noRotate = true;
3742     this.data.hasOwnCanvas = this.data.noRotate;
3743     this.data.noHTML = false;
3744 
3745     const { dict } = params;
3746     this.data.annotationType = AnnotationType.TEXT;
3747 
3748     if (this.data.hasAppearance) {
3749       this.data.name = "NoIcon";
3750     } else {
3751       this.data.rect[1] = this.data.rect[3] - DEFAULT_ICON_SIZE;
3752       this.data.rect[2] = this.data.rect[0] + DEFAULT_ICON_SIZE;
3753       this.data.name = dict.has("Name") ? dict.get("Name").name : "Note";
3754     }
3755 
3756     if (dict.has("State")) {
3757       this.data.state = dict.get("State") || null;
3758       this.data.stateModel = dict.get("StateModel") || null;
3759     } else {
3760       this.data.state = null;
3761       this.data.stateModel = null;
3762     }
3763   }
3764 }
3765 
3766 class LinkAnnotation extends Annotation {
3767   constructor(params) {
3768     super(params);
3769 
3770     const { dict, annotationGlobals } = params;
3771     this.data.annotationType = AnnotationType.LINK;
3772 
3773     // A link is never rendered on the main canvas so we must render its HTML
3774     // version.
3775     this.data.noHTML = false;
3776 
3777     const quadPoints = getQuadPoints(dict, this.rectangle);
3778     if (quadPoints) {
3779       this.data.quadPoints = quadPoints;
3780     }
3781 
3782     // The color entry for a link annotation is the color of the border.
3783     this.data.borderColor ||= this.data.color;
3784 
3785     Catalog.parseDestDictionary({
3786       destDict: dict,
3787       resultObj: this.data,
3788       docBaseUrl: annotationGlobals.baseUrl,
3789       docAttachments: annotationGlobals.attachments,
3790     });
3791   }
3792 }
3793 
3794 class PopupAnnotation extends Annotation {
3795   constructor(params) {
3796     super(params);
3797 
3798     const { dict } = params;
3799     this.data.annotationType = AnnotationType.POPUP;
3800 
3801     // A pop-up is never rendered on the main canvas so we must render its HTML
3802     // version.
3803     this.data.noHTML = false;
3804 
3805     if (
3806       this.data.rect[0] === this.data.rect[2] ||
3807       this.data.rect[1] === this.data.rect[3]
3808     ) {
3809       this.data.rect = null;
3810     }
3811 
3812     let parentItem = dict.get("Parent");
3813     if (!parentItem) {
3814       warn("Popup annotation has a missing or invalid parent annotation.");
3815       return;
3816     }
3817     this.data.parentRect = lookupNormalRect(parentItem.getArray("Rect"), null);
3818 
3819     const rt = parentItem.get("RT");
3820     if (isName(rt, AnnotationReplyType.GROUP)) {
3821       // Subordinate annotations in a group should inherit
3822       // the group attributes from the primary annotation.
3823       parentItem = parentItem.get("IRT");
3824     }
3825 
3826     if (!parentItem.has("M")) {
3827       this.data.modificationDate = null;
3828     } else {
3829       this.setModificationDate(parentItem.get("M"));
3830       this.data.modificationDate = this.modificationDate;
3831     }
3832 
3833     if (!parentItem.has("C")) {
3834       // Fall back to the default background color.
3835       this.data.color = null;
3836     } else {
3837       this.setColor(parentItem.getArray("C"));
3838       this.data.color = this.color;
3839     }
3840 
3841     // If the Popup annotation is not viewable, but the parent annotation is,
3842     // that is most likely a bug. Fallback to inherit the flags from the parent
3843     // annotation (this is consistent with the behaviour in Adobe Reader).
3844     if (!this.viewable) {
3845       const parentFlags = parentItem.get("F");
3846       if (this._isViewable(parentFlags)) {
3847         this.setFlags(parentFlags);
3848       }
3849     }
3850 
3851     this.setTitle(parentItem.get("T"));
3852     this.data.titleObj = this._title;
3853 
3854     this.setContents(parentItem.get("Contents"));
3855     this.data.contentsObj = this._contents;
3856 
3857     if (parentItem.has("RC")) {
3858       this.data.richText = XFAFactory.getRichTextAsHtml(parentItem.get("RC"));
3859     }
3860 
3861     this.data.open = !!dict.get("Open");
3862   }
3863 }
3864 
3865 class FreeTextAnnotation extends MarkupAnnotation {
3866   constructor(params) {
3867     super(params);
3868 
3869     // It uses its own canvas in order to be hidden if edited.
3870     // But if it has the noHTML flag, it means that we don't want to be able
3871     // to modify it so we can just draw it on the main canvas.
3872     this.data.hasOwnCanvas = this.data.noRotate;
3873     this.data.isEditable = !this.data.noHTML;
3874     // We want to be able to add mouse listeners to the annotation.
3875     this.data.noHTML = false;
3876 
3877     const { evaluatorOptions, xref } = params;
3878     this.data.annotationType = AnnotationType.FREETEXT;
3879     this.setDefaultAppearance(params);
3880     this._hasAppearance = !!this.appearance;
3881 
3882     if (this._hasAppearance) {
3883       const { fontColor, fontSize } = parseAppearanceStream(
3884         this.appearance,
3885         evaluatorOptions,
3886         xref
3887       );
3888       this.data.defaultAppearanceData.fontColor = fontColor;
3889       this.data.defaultAppearanceData.fontSize = fontSize || 10;
3890     } else {
3891       this.data.defaultAppearanceData.fontSize ||= 10;
3892       const { fontColor, fontSize } = this.data.defaultAppearanceData;
3893       if (this._contents.str) {
3894         this.data.textContent = this._contents.str
3895           .split(/\r\n?|\n/)
3896           .map(line => line.trimEnd());
3897         const { coords, bbox, matrix } = FakeUnicodeFont.getFirstPositionInfo(
3898           this.rectangle,
3899           this.rotation,
3900           fontSize
3901         );
3902         this.data.textPosition = this._transformPoint(coords, bbox, matrix);
3903       }
3904       if (this._isOffscreenCanvasSupported) {
3905         const strokeAlpha = params.dict.get("CA");
3906         const fakeUnicodeFont = new FakeUnicodeFont(xref, "sans-serif");
3907         this.appearance = fakeUnicodeFont.createAppearance(
3908           this._contents.str,
3909           this.rectangle,
3910           this.rotation,
3911           fontSize,
3912           fontColor,
3913           strokeAlpha
3914         );
3915         this._streams.push(this.appearance);
3916       } else {
3917         warn(
3918           "FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly."
3919         );
3920       }
3921     }
3922   }
3923 
3924   get hasTextContent() {
3925     return this._hasAppearance;
3926   }
3927 
3928   static createNewDict(annotation, xref, { apRef, ap }) {
3929     const { color, fontSize, oldAnnotation, rect, rotation, user, value } =
3930       annotation;
3931     const freetext = oldAnnotation || new Dict(xref);
3932     freetext.set("Type", Name.get("Annot"));
3933     freetext.set("Subtype", Name.get("FreeText"));
3934     if (oldAnnotation) {
3935       freetext.set("M", `D:${getModificationDate()}`);
3936       // TODO: We should try to generate a new RC from the content we've.
3937       // For now we can just remove it to avoid any issues.
3938       freetext.delete("RC");
3939     } else {
3940       freetext.set("CreationDate", `D:${getModificationDate()}`);
3941     }
3942     freetext.set("Rect", rect);
3943     const da = `/Helv ${fontSize} Tf ${getPdfColor(color, /* isFill */ true)}`;
3944     freetext.set("DA", da);
3945     freetext.set("Contents", stringToAsciiOrUTF16BE(value));
3946     freetext.set("F", 4);
3947     freetext.set("Border", [0, 0, 0]);
3948     freetext.set("Rotate", rotation);
3949 
3950     if (user) {
3951       freetext.set("T", stringToAsciiOrUTF16BE(user));
3952     }
3953 
3954     if (apRef || ap) {
3955       const n = new Dict(xref);
3956       freetext.set("AP", n);
3957 
3958       if (apRef) {
3959         n.set("N", apRef);
3960       } else {
3961         n.set("N", ap);
3962       }
3963     }
3964 
3965     return freetext;
3966   }
3967 
3968   static async createNewAppearanceStream(annotation, xref, params) {
3969     const { baseFontRef, evaluator, task } = params;
3970     const { color, fontSize, rect, rotation, value } = annotation;
3971 
3972     const resources = new Dict(xref);
3973     const font = new Dict(xref);
3974 
3975     if (baseFontRef) {
3976       font.set("Helv", baseFontRef);
3977     } else {
3978       const baseFont = new Dict(xref);
3979       baseFont.set("BaseFont", Name.get("Helvetica"));
3980       baseFont.set("Type", Name.get("Font"));
3981       baseFont.set("Subtype", Name.get("Type1"));
3982       baseFont.set("Encoding", Name.get("WinAnsiEncoding"));
3983       font.set("Helv", baseFont);
3984     }
3985     resources.set("Font", font);
3986 
3987     const helv = await WidgetAnnotation._getFontData(
3988       evaluator,
3989       task,
3990       {
3991         fontName: "Helv",
3992         fontSize,
3993       },
3994       resources
3995     );
3996 
3997     const [x1, y1, x2, y2] = rect;
3998     let w = x2 - x1;
3999     let h = y2 - y1;
4000 
4001     if (rotation % 180 !== 0) {
4002       [w, h] = [h, w];
4003     }
4004 
4005     const lines = value.split("\n");
4006     const scale = fontSize / 1000;
4007     let totalWidth = -Infinity;
4008     const encodedLines = [];
4009     for (let line of lines) {
4010       const encoded = helv.encodeString(line);
4011       if (encoded.length > 1) {
4012         // The font doesn't contain all the chars.
4013         return null;
4014       }
4015       line = encoded.join("");
4016       encodedLines.push(line);
4017       let lineWidth = 0;
4018       const glyphs = helv.charsToGlyphs(line);
4019       for (const glyph of glyphs) {
4020         lineWidth += glyph.width * scale;
4021       }
4022       totalWidth = Math.max(totalWidth, lineWidth);
4023     }
4024 
4025     let hscale = 1;
4026     if (totalWidth > w) {
4027       hscale = w / totalWidth;
4028     }
4029     let vscale = 1;
4030     const lineHeight = LINE_FACTOR * fontSize;
4031     const lineAscent = (LINE_FACTOR - LINE_DESCENT_FACTOR) * fontSize;
4032     const totalHeight = lineHeight * lines.length;
4033     if (totalHeight > h) {
4034       vscale = h / totalHeight;
4035     }
4036     const fscale = Math.min(hscale, vscale);
4037     const newFontSize = fontSize * fscale;
4038     let firstPoint, clipBox, matrix;
4039     switch (rotation) {
4040       case 0:
4041         matrix = [1, 0, 0, 1];
4042         clipBox = [rect[0], rect[1], w, h];
4043         firstPoint = [rect[0], rect[3] - lineAscent];
4044         break;
4045       case 90:
4046         matrix = [0, 1, -1, 0];
4047         clipBox = [rect[1], -rect[2], w, h];
4048         firstPoint = [rect[1], -rect[0] - lineAscent];
4049         break;
4050       case 180:
4051         matrix = [-1, 0, 0, -1];
4052         clipBox = [-rect[2], -rect[3], w, h];
4053         firstPoint = [-rect[2], -rect[1] - lineAscent];
4054         break;
4055       case 270:
4056         matrix = [0, -1, 1, 0];
4057         clipBox = [-rect[3], rect[0], w, h];
4058         firstPoint = [-rect[3], rect[2] - lineAscent];
4059         break;
4060     }
4061 
4062     const buffer = [
4063       "q",
4064       `${matrix.join(" ")} 0 0 cm`,
4065       `${clipBox.join(" ")} re W n`,
4066       `BT`,
4067       `${getPdfColor(color, /* isFill */ true)}`,
4068       `0 Tc /Helv ${numberToString(newFontSize)} Tf`,
4069     ];
4070 
4071     buffer.push(
4072       `${firstPoint.join(" ")} Td (${escapeString(encodedLines[0])}) Tj`
4073     );
4074     const vShift = numberToString(lineHeight);
4075     for (let i = 1, ii = encodedLines.length; i < ii; i++) {
4076       const line = encodedLines[i];
4077       buffer.push(`0 -${vShift} Td (${escapeString(line)}) Tj`);
4078     }
4079     buffer.push("ET", "Q");
4080     const appearance = buffer.join("\n");
4081 
4082     const appearanceStreamDict = new Dict(xref);
4083     appearanceStreamDict.set("FormType", 1);
4084     appearanceStreamDict.set("Subtype", Name.get("Form"));
4085     appearanceStreamDict.set("Type", Name.get("XObject"));
4086     appearanceStreamDict.set("BBox", rect);
4087     appearanceStreamDict.set("Resources", resources);
4088     appearanceStreamDict.set("Matrix", [1, 0, 0, 1, -rect[0], -rect[1]]);
4089 
4090     const ap = new StringStream(appearance);
4091     ap.dict = appearanceStreamDict;
4092 
4093     return ap;
4094   }
4095 }
4096 
4097 class LineAnnotation extends MarkupAnnotation {
4098   constructor(params) {
4099     super(params);
4100 
4101     const { dict, xref } = params;
4102     this.data.annotationType = AnnotationType.LINE;
4103     this.data.hasOwnCanvas = this.data.noRotate;
4104     this.data.noHTML = false;
4105 
4106     const lineCoordinates = lookupRect(dict.getArray("L"), [0, 0, 0, 0]);
4107     this.data.lineCoordinates = Util.normalizeRect(lineCoordinates);
4108 
4109     if (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) {
4110       this.setLineEndings(dict.getArray("LE"));
4111       this.data.lineEndings = this.lineEndings;
4112     }
4113 
4114     if (!this.appearance) {
4115       // The default stroke color is black.
4116       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4117       const strokeAlpha = dict.get("CA");
4118 
4119       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4120       // The default fill color is transparent. Setting the fill colour is
4121       // necessary if/when we want to add support for non-default line endings.
4122       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4123       const fillAlpha = fillColor ? strokeAlpha : null;
4124 
4125       const borderWidth = this.borderStyle.width || 1,
4126         borderAdjust = 2 * borderWidth;
4127 
4128       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4129       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4130       const bbox = [
4131         this.data.lineCoordinates[0] - borderAdjust,
4132         this.data.lineCoordinates[1] - borderAdjust,
4133         this.data.lineCoordinates[2] + borderAdjust,
4134         this.data.lineCoordinates[3] + borderAdjust,
4135       ];
4136       if (!Util.intersect(this.rectangle, bbox)) {
4137         this.rectangle = bbox;
4138       }
4139 
4140       this._setDefaultAppearance({
4141         xref,
4142         extra: `${borderWidth} w`,
4143         strokeColor,
4144         fillColor,
4145         strokeAlpha,
4146         fillAlpha,
4147         pointsCallback: (buffer, points) => {
4148           buffer.push(
4149             `${lineCoordinates[0]} ${lineCoordinates[1]} m`,
4150             `${lineCoordinates[2]} ${lineCoordinates[3]} l`,
4151             "S"
4152           );
4153           return [
4154             points[0] - borderWidth,
4155             points[2] + borderWidth,
4156             points[7] - borderWidth,
4157             points[3] + borderWidth,
4158           ];
4159         },
4160       });
4161     }
4162   }
4163 }
4164 
4165 class SquareAnnotation extends MarkupAnnotation {
4166   constructor(params) {
4167     super(params);
4168 
4169     const { dict, xref } = params;
4170     this.data.annotationType = AnnotationType.SQUARE;
4171     this.data.hasOwnCanvas = this.data.noRotate;
4172     this.data.noHTML = false;
4173 
4174     if (!this.appearance) {
4175       // The default stroke color is black.
4176       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4177       const strokeAlpha = dict.get("CA");
4178 
4179       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4180       // The default fill color is transparent.
4181       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4182       const fillAlpha = fillColor ? strokeAlpha : null;
4183 
4184       if (this.borderStyle.width === 0 && !fillColor) {
4185         // Prevent rendering a "hairline" border (fixes issue14164.pdf).
4186         return;
4187       }
4188 
4189       this._setDefaultAppearance({
4190         xref,
4191         extra: `${this.borderStyle.width} w`,
4192         strokeColor,
4193         fillColor,
4194         strokeAlpha,
4195         fillAlpha,
4196         pointsCallback: (buffer, points) => {
4197           const x = points[4] + this.borderStyle.width / 2;
4198           const y = points[5] + this.borderStyle.width / 2;
4199           const width = points[6] - points[4] - this.borderStyle.width;
4200           const height = points[3] - points[7] - this.borderStyle.width;
4201           buffer.push(`${x} ${y} ${width} ${height} re`);
4202           if (fillColor) {
4203             buffer.push("B");
4204           } else {
4205             buffer.push("S");
4206           }
4207           return [points[0], points[2], points[7], points[3]];
4208         },
4209       });
4210     }
4211   }
4212 }
4213 
4214 class CircleAnnotation extends MarkupAnnotation {
4215   constructor(params) {
4216     super(params);
4217 
4218     const { dict, xref } = params;
4219     this.data.annotationType = AnnotationType.CIRCLE;
4220 
4221     if (!this.appearance) {
4222       // The default stroke color is black.
4223       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4224       const strokeAlpha = dict.get("CA");
4225 
4226       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4227       // The default fill color is transparent.
4228       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4229       const fillAlpha = fillColor ? strokeAlpha : null;
4230 
4231       if (this.borderStyle.width === 0 && !fillColor) {
4232         // Prevent rendering a "hairline" border (fixes issue14164.pdf).
4233         return;
4234       }
4235 
4236       // Circles are approximated by Bézier curves with four segments since
4237       // there is no circle primitive in the PDF specification. For the control
4238       // points distance, see https://stackoverflow.com/a/27863181.
4239       const controlPointsDistance = (4 / 3) * Math.tan(Math.PI / (2 * 4));
4240 
4241       this._setDefaultAppearance({
4242         xref,
4243         extra: `${this.borderStyle.width} w`,
4244         strokeColor,
4245         fillColor,
4246         strokeAlpha,
4247         fillAlpha,
4248         pointsCallback: (buffer, points) => {
4249           const x0 = points[0] + this.borderStyle.width / 2;
4250           const y0 = points[1] - this.borderStyle.width / 2;
4251           const x1 = points[6] - this.borderStyle.width / 2;
4252           const y1 = points[7] + this.borderStyle.width / 2;
4253           const xMid = x0 + (x1 - x0) / 2;
4254           const yMid = y0 + (y1 - y0) / 2;
4255           const xOffset = ((x1 - x0) / 2) * controlPointsDistance;
4256           const yOffset = ((y1 - y0) / 2) * controlPointsDistance;
4257 
4258           buffer.push(
4259             `${xMid} ${y1} m`,
4260             `${xMid + xOffset} ${y1} ${x1} ${yMid + yOffset} ${x1} ${yMid} c`,
4261             `${x1} ${yMid - yOffset} ${xMid + xOffset} ${y0} ${xMid} ${y0} c`,
4262             `${xMid - xOffset} ${y0} ${x0} ${yMid - yOffset} ${x0} ${yMid} c`,
4263             `${x0} ${yMid + yOffset} ${xMid - xOffset} ${y1} ${xMid} ${y1} c`,
4264             "h"
4265           );
4266           if (fillColor) {
4267             buffer.push("B");
4268           } else {
4269             buffer.push("S");
4270           }
4271           return [points[0], points[2], points[7], points[3]];
4272         },
4273       });
4274     }
4275   }
4276 }
4277 
4278 class PolylineAnnotation extends MarkupAnnotation {
4279   constructor(params) {
4280     super(params);
4281 
4282     const { dict, xref } = params;
4283     this.data.annotationType = AnnotationType.POLYLINE;
4284     this.data.hasOwnCanvas = this.data.noRotate;
4285     this.data.noHTML = false;
4286     this.data.vertices = null;
4287 
4288     if (
4289       (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) &&
4290       !(this instanceof PolygonAnnotation)
4291     ) {
4292       // Only meaningful for polyline annotations.
4293       this.setLineEndings(dict.getArray("LE"));
4294       this.data.lineEndings = this.lineEndings;
4295     }
4296 
4297     // The vertices array is an array of numbers representing the alternating
4298     // horizontal and vertical coordinates, respectively, of each vertex.
4299     // Convert this to an array of objects with x and y coordinates.
4300     const rawVertices = dict.getArray("Vertices");
4301     if (!isNumberArray(rawVertices, null)) {
4302       return;
4303     }
4304     const vertices = (this.data.vertices = Float32Array.from(rawVertices));
4305 
4306     if (!this.appearance) {
4307       // The default stroke color is black.
4308       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4309       const strokeAlpha = dict.get("CA");
4310 
4311       const borderWidth = this.borderStyle.width || 1,
4312         borderAdjust = 2 * borderWidth;
4313 
4314       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4315       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4316       const bbox = [Infinity, Infinity, -Infinity, -Infinity];
4317       for (let i = 0, ii = vertices.length; i < ii; i += 2) {
4318         bbox[0] = Math.min(bbox[0], vertices[i] - borderAdjust);
4319         bbox[1] = Math.min(bbox[1], vertices[i + 1] - borderAdjust);
4320         bbox[2] = Math.max(bbox[2], vertices[i] + borderAdjust);
4321         bbox[3] = Math.max(bbox[3], vertices[i + 1] + borderAdjust);
4322       }
4323       if (!Util.intersect(this.rectangle, bbox)) {
4324         this.rectangle = bbox;
4325       }
4326 
4327       this._setDefaultAppearance({
4328         xref,
4329         extra: `${borderWidth} w`,
4330         strokeColor,
4331         strokeAlpha,
4332         pointsCallback: (buffer, points) => {
4333           for (let i = 0, ii = vertices.length; i < ii; i += 2) {
4334             buffer.push(
4335               `${vertices[i]} ${vertices[i + 1]} ${i === 0 ? "m" : "l"}`
4336             );
4337           }
4338           buffer.push("S");
4339           return [points[0], points[2], points[7], points[3]];
4340         },
4341       });
4342     }
4343   }
4344 }
4345 
4346 class PolygonAnnotation extends PolylineAnnotation {
4347   constructor(params) {
4348     // Polygons are specific forms of polylines, so reuse their logic.
4349     super(params);
4350 
4351     this.data.annotationType = AnnotationType.POLYGON;
4352   }
4353 }
4354 
4355 class CaretAnnotation extends MarkupAnnotation {
4356   constructor(params) {
4357     super(params);
4358 
4359     this.data.annotationType = AnnotationType.CARET;
4360   }
4361 }
4362 
4363 class InkAnnotation extends MarkupAnnotation {
4364   constructor(params) {
4365     super(params);
4366 
4367     this.data.hasOwnCanvas = this.data.noRotate;
4368     this.data.noHTML = false;
4369 
4370     const { dict, xref } = params;
4371     this.data.annotationType = AnnotationType.INK;
4372     this.data.inkLists = [];
4373     this.data.isEditable = !this.data.noHTML && this.data.it === "InkHighlight";
4374     // We want to be able to add mouse listeners to the annotation.
4375     this.data.noHTML = false;
4376     this.data.opacity = dict.get("CA") || 1;
4377 
4378     const rawInkLists = dict.getArray("InkList");
4379     if (!Array.isArray(rawInkLists)) {
4380       return;
4381     }
4382     for (let i = 0, ii = rawInkLists.length; i < ii; ++i) {
4383       // The raw ink lists array contains arrays of numbers representing
4384       // the alternating horizontal and vertical coordinates, respectively,
4385       // of each vertex. Convert this to an array of objects with x and y
4386       // coordinates.
4387       if (!Array.isArray(rawInkLists[i])) {
4388         continue;
4389       }
4390       const inkList = new Float32Array(rawInkLists[i].length);
4391       this.data.inkLists.push(inkList);
4392       for (let j = 0, jj = rawInkLists[i].length; j < jj; j += 2) {
4393         const x = xref.fetchIfRef(rawInkLists[i][j]),
4394           y = xref.fetchIfRef(rawInkLists[i][j + 1]);
4395         if (typeof x === "number" && typeof y === "number") {
4396           inkList[j] = x;
4397           inkList[j + 1] = y;
4398         }
4399       }
4400     }
4401 
4402     if (!this.appearance) {
4403       // The default stroke color is black.
4404       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4405       const strokeAlpha = dict.get("CA");
4406 
4407       const borderWidth = this.borderStyle.width || 1,
4408         borderAdjust = 2 * borderWidth;
4409 
4410       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4411       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4412       const bbox = [Infinity, Infinity, -Infinity, -Infinity];
4413       for (const inkList of this.data.inkLists) {
4414         for (let i = 0, ii = inkList.length; i < ii; i += 2) {
4415           bbox[0] = Math.min(bbox[0], inkList[i] - borderAdjust);
4416           bbox[1] = Math.min(bbox[1], inkList[i + 1] - borderAdjust);
4417           bbox[2] = Math.max(bbox[2], inkList[i] + borderAdjust);
4418           bbox[3] = Math.max(bbox[3], inkList[i + 1] + borderAdjust);
4419         }
4420       }
4421       if (!Util.intersect(this.rectangle, bbox)) {
4422         this.rectangle = bbox;
4423       }
4424 
4425       this._setDefaultAppearance({
4426         xref,
4427         extra: `${borderWidth} w`,
4428         strokeColor,
4429         strokeAlpha,
4430         pointsCallback: (buffer, points) => {
4431           // According to the specification, see "12.5.6.13 Ink Annotations":
4432           //   When drawn, the points shall be connected by straight lines or
4433           //   curves in an implementation-dependent way.
4434           // In order to simplify things, we utilize straight lines for now.
4435           for (const inkList of this.data.inkLists) {
4436             for (let i = 0, ii = inkList.length; i < ii; i += 2) {
4437               buffer.push(
4438                 `${inkList[i]} ${inkList[i + 1]} ${i === 0 ? "m" : "l"}`
4439               );
4440             }
4441             buffer.push("S");
4442           }
4443           return [points[0], points[2], points[7], points[3]];
4444         },
4445       });
4446     }
4447   }
4448 
4449   static createNewDict(annotation, xref, { apRef, ap }) {
4450     const { color, opacity, paths, outlines, rect, rotation, thickness } =
4451       annotation;
4452     const ink = new Dict(xref);
4453     ink.set("Type", Name.get("Annot"));
4454     ink.set("Subtype", Name.get("Ink"));
4455     ink.set("CreationDate", `D:${getModificationDate()}`);
4456     ink.set("Rect", rect);
4457     ink.set("InkList", outlines?.points || paths.map(p => p.points));
4458     ink.set("F", 4);
4459     ink.set("Rotate", rotation);
4460 
4461     if (outlines) {
4462       // Free highlight.
4463       // There's nothing about this in the spec, but it's used when highlighting
4464       // in Edge's viewer. Acrobat takes into account this parameter to indicate
4465       // that the Ink is used for highlighting.
4466       ink.set("IT", Name.get("InkHighlight"));
4467     }
4468 
4469     // Line thickness.
4470     const bs = new Dict(xref);
4471     ink.set("BS", bs);
4472     bs.set("W", thickness);
4473 
4474     // Color.
4475     ink.set(
4476       "C",
4477       Array.from(color, c => c / 255)
4478     );
4479 
4480     // Opacity.
4481     ink.set("CA", opacity);
4482 
4483     const n = new Dict(xref);
4484     ink.set("AP", n);
4485 
4486     if (apRef) {
4487       n.set("N", apRef);
4488     } else {
4489       n.set("N", ap);
4490     }
4491 
4492     return ink;
4493   }
4494 
4495   static async createNewAppearanceStream(annotation, xref, params) {
4496     if (annotation.outlines) {
4497       return this.createNewAppearanceStreamForHighlight(
4498         annotation,
4499         xref,
4500         params
4501       );
4502     }
4503     const { color, rect, paths, thickness, opacity } = annotation;
4504 
4505     const appearanceBuffer = [
4506       `${thickness} w 1 J 1 j`,
4507       `${getPdfColor(color, /* isFill */ false)}`,
4508     ];
4509 
4510     if (opacity !== 1) {
4511       appearanceBuffer.push("/R0 gs");
4512     }
4513 
4514     const buffer = [];
4515     for (const { bezier } of paths) {
4516       buffer.length = 0;
4517       buffer.push(
4518         `${numberToString(bezier[0])} ${numberToString(bezier[1])} m`
4519       );
4520       if (bezier.length === 2) {
4521         buffer.push(
4522           `${numberToString(bezier[0])} ${numberToString(bezier[1])} l S`
4523         );
4524       } else {
4525         for (let i = 2, ii = bezier.length; i < ii; i += 6) {
4526           const curve = bezier
4527             .slice(i, i + 6)
4528             .map(numberToString)
4529             .join(" ");
4530           buffer.push(`${curve} c`);
4531         }
4532         buffer.push("S");
4533       }
4534       appearanceBuffer.push(buffer.join("\n"));
4535     }
4536     const appearance = appearanceBuffer.join("\n");
4537 
4538     const appearanceStreamDict = new Dict(xref);
4539     appearanceStreamDict.set("FormType", 1);
4540     appearanceStreamDict.set("Subtype", Name.get("Form"));
4541     appearanceStreamDict.set("Type", Name.get("XObject"));
4542     appearanceStreamDict.set("BBox", rect);
4543     appearanceStreamDict.set("Length", appearance.length);
4544 
4545     if (opacity !== 1) {
4546       const resources = new Dict(xref);
4547       const extGState = new Dict(xref);
4548       const r0 = new Dict(xref);
4549       r0.set("CA", opacity);
4550       r0.set("Type", Name.get("ExtGState"));
4551       extGState.set("R0", r0);
4552       resources.set("ExtGState", extGState);
4553       appearanceStreamDict.set("Resources", resources);
4554     }
4555 
4556     const ap = new StringStream(appearance);
4557     ap.dict = appearanceStreamDict;
4558 
4559     return ap;
4560   }
4561 
4562   static async createNewAppearanceStreamForHighlight(annotation, xref, params) {
4563     const {
4564       color,
4565       rect,
4566       outlines: { outline },
4567       opacity,
4568     } = annotation;
4569     const appearanceBuffer = [
4570       `${getPdfColor(color, /* isFill */ true)}`,
4571       "/R0 gs",
4572     ];
4573 
4574     appearanceBuffer.push(
4575       `${numberToString(outline[4])} ${numberToString(outline[5])} m`
4576     );
4577     for (let i = 6, ii = outline.length; i < ii; i += 6) {
4578       if (isNaN(outline[i]) || outline[i] === null) {
4579         appearanceBuffer.push(
4580           `${numberToString(outline[i + 4])} ${numberToString(
4581             outline[i + 5]
4582           )} l`
4583         );
4584       } else {
4585         const curve = outline
4586           .slice(i, i + 6)
4587           .map(numberToString)
4588           .join(" ");
4589         appearanceBuffer.push(`${curve} c`);
4590       }
4591     }
4592     appearanceBuffer.push("h f");
4593     const appearance = appearanceBuffer.join("\n");
4594 
4595     const appearanceStreamDict = new Dict(xref);
4596     appearanceStreamDict.set("FormType", 1);
4597     appearanceStreamDict.set("Subtype", Name.get("Form"));
4598     appearanceStreamDict.set("Type", Name.get("XObject"));
4599     appearanceStreamDict.set("BBox", rect);
4600     appearanceStreamDict.set("Length", appearance.length);
4601 
4602     const resources = new Dict(xref);
4603     const extGState = new Dict(xref);
4604     resources.set("ExtGState", extGState);
4605     appearanceStreamDict.set("Resources", resources);
4606     const r0 = new Dict(xref);
4607     extGState.set("R0", r0);
4608     r0.set("BM", Name.get("Multiply"));
4609 
4610     if (opacity !== 1) {
4611       r0.set("ca", opacity);
4612       r0.set("Type", Name.get("ExtGState"));
4613     }
4614 
4615     const ap = new StringStream(appearance);
4616     ap.dict = appearanceStreamDict;
4617 
4618     return ap;
4619   }
4620 }
4621 
4622 class HighlightAnnotation extends MarkupAnnotation {
4623   constructor(params) {
4624     super(params);
4625 
4626     const { dict, xref } = params;
4627     this.data.annotationType = AnnotationType.HIGHLIGHT;
4628     this.data.isEditable = !this.data.noHTML;
4629     // We want to be able to add mouse listeners to the annotation.
4630     this.data.noHTML = false;
4631     this.data.opacity = dict.get("CA") || 1;
4632 
4633     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4634     if (quadPoints) {
4635       const resources = this.appearance?.dict.get("Resources");
4636 
4637       if (!this.appearance || !resources?.has("ExtGState")) {
4638         if (this.appearance) {
4639           // Workaround for cases where there's no /ExtGState-entry directly
4640           // available, e.g. when the appearance stream contains a /XObject of
4641           // the /Form-type, since that causes the highlighting to completely
4642           // obscure the PDF content below it (fixes issue13242.pdf).
4643           warn("HighlightAnnotation - ignoring built-in appearance stream.");
4644         }
4645         // Default color is yellow in Acrobat Reader
4646         const fillColor = this.color ? getPdfColorArray(this.color) : [1, 1, 0];
4647         const fillAlpha = dict.get("CA");
4648 
4649         this._setDefaultAppearance({
4650           xref,
4651           fillColor,
4652           blendMode: "Multiply",
4653           fillAlpha,
4654           pointsCallback: (buffer, points) => {
4655             buffer.push(
4656               `${points[0]} ${points[1]} m`,
4657               `${points[2]} ${points[3]} l`,
4658               `${points[6]} ${points[7]} l`,
4659               `${points[4]} ${points[5]} l`,
4660               "f"
4661             );
4662             return [points[0], points[2], points[7], points[3]];
4663           },
4664         });
4665       }
4666     } else {
4667       this.data.popupRef = null;
4668     }
4669   }
4670 
4671   static createNewDict(annotation, xref, { apRef, ap }) {
4672     const { color, oldAnnotation, opacity, rect, rotation, user, quadPoints } =
4673       annotation;
4674     const highlight = oldAnnotation || new Dict(xref);
4675     highlight.set("Type", Name.get("Annot"));
4676     highlight.set("Subtype", Name.get("Highlight"));
4677     highlight.set(
4678       oldAnnotation ? "M" : "CreationDate",
4679       `D:${getModificationDate()}`
4680     );
4681     highlight.set("CreationDate", `D:${getModificationDate()}`);
4682     highlight.set("Rect", rect);
4683     highlight.set("F", 4);
4684     highlight.set("Border", [0, 0, 0]);
4685     highlight.set("Rotate", rotation);
4686     highlight.set("QuadPoints", quadPoints);
4687 
4688     // Color.
4689     highlight.set(
4690       "C",
4691       Array.from(color, c => c / 255)
4692     );
4693 
4694     // Opacity.
4695     highlight.set("CA", opacity);
4696 
4697     if (user) {
4698       highlight.set("T", stringToAsciiOrUTF16BE(user));
4699     }
4700 
4701     if (apRef || ap) {
4702       const n = new Dict(xref);
4703       highlight.set("AP", n);
4704       n.set("N", apRef || ap);
4705     }
4706 
4707     return highlight;
4708   }
4709 
4710   static async createNewAppearanceStream(annotation, xref, params) {
4711     const { color, rect, outlines, opacity } = annotation;
4712 
4713     const appearanceBuffer = [
4714       `${getPdfColor(color, /* isFill */ true)}`,
4715       "/R0 gs",
4716     ];
4717 
4718     const buffer = [];
4719     for (const outline of outlines) {
4720       buffer.length = 0;
4721       buffer.push(
4722         `${numberToString(outline[0])} ${numberToString(outline[1])} m`
4723       );
4724       for (let i = 2, ii = outline.length; i < ii; i += 2) {
4725         buffer.push(
4726           `${numberToString(outline[i])} ${numberToString(outline[i + 1])} l`
4727         );
4728       }
4729       buffer.push("h");
4730       appearanceBuffer.push(buffer.join("\n"));
4731     }
4732     appearanceBuffer.push("f*");
4733     const appearance = appearanceBuffer.join("\n");
4734 
4735     const appearanceStreamDict = new Dict(xref);
4736     appearanceStreamDict.set("FormType", 1);
4737     appearanceStreamDict.set("Subtype", Name.get("Form"));
4738     appearanceStreamDict.set("Type", Name.get("XObject"));
4739     appearanceStreamDict.set("BBox", rect);
4740     appearanceStreamDict.set("Length", appearance.length);
4741 
4742     const resources = new Dict(xref);
4743     const extGState = new Dict(xref);
4744     resources.set("ExtGState", extGState);
4745     appearanceStreamDict.set("Resources", resources);
4746     const r0 = new Dict(xref);
4747     extGState.set("R0", r0);
4748     r0.set("BM", Name.get("Multiply"));
4749 
4750     if (opacity !== 1) {
4751       r0.set("ca", opacity);
4752       r0.set("Type", Name.get("ExtGState"));
4753     }
4754 
4755     const ap = new StringStream(appearance);
4756     ap.dict = appearanceStreamDict;
4757 
4758     return ap;
4759   }
4760 }
4761 
4762 class UnderlineAnnotation extends MarkupAnnotation {
4763   constructor(params) {
4764     super(params);
4765 
4766     const { dict, xref } = params;
4767     this.data.annotationType = AnnotationType.UNDERLINE;
4768 
4769     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4770     if (quadPoints) {
4771       if (!this.appearance) {
4772         // Default color is black
4773         const strokeColor = this.color
4774           ? getPdfColorArray(this.color)
4775           : [0, 0, 0];
4776         const strokeAlpha = dict.get("CA");
4777 
4778         // The values 0.571 and 1.3 below corresponds to what Acrobat is doing.
4779         this._setDefaultAppearance({
4780           xref,
4781           extra: "[] 0 d 0.571 w",
4782           strokeColor,
4783           strokeAlpha,
4784           pointsCallback: (buffer, points) => {
4785             buffer.push(
4786               `${points[4]} ${points[5] + 1.3} m`,
4787               `${points[6]} ${points[7] + 1.3} l`,
4788               "S"
4789             );
4790             return [points[0], points[2], points[7], points[3]];
4791           },
4792         });
4793       }
4794     } else {
4795       this.data.popupRef = null;
4796     }
4797   }
4798 }
4799 
4800 class SquigglyAnnotation extends MarkupAnnotation {
4801   constructor(params) {
4802     super(params);
4803 
4804     const { dict, xref } = params;
4805     this.data.annotationType = AnnotationType.SQUIGGLY;
4806 
4807     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4808     if (quadPoints) {
4809       if (!this.appearance) {
4810         // Default color is black
4811         const strokeColor = this.color
4812           ? getPdfColorArray(this.color)
4813           : [0, 0, 0];
4814         const strokeAlpha = dict.get("CA");
4815 
4816         this._setDefaultAppearance({
4817           xref,
4818           extra: "[] 0 d 1 w",
4819           strokeColor,
4820           strokeAlpha,
4821           pointsCallback: (buffer, points) => {
4822             const dy = (points[1] - points[5]) / 6;
4823             let shift = dy;
4824             let x = points[4];
4825             const y = points[5];
4826             const xEnd = points[6];
4827             buffer.push(`${x} ${y + shift} m`);
4828             do {
4829               x += 2;
4830               shift = shift === 0 ? dy : 0;
4831               buffer.push(`${x} ${y + shift} l`);
4832             } while (x < xEnd);
4833             buffer.push("S");
4834             return [points[4], xEnd, y - 2 * dy, y + 2 * dy];
4835           },
4836         });
4837       }
4838     } else {
4839       this.data.popupRef = null;
4840     }
4841   }
4842 }
4843 
4844 class StrikeOutAnnotation extends MarkupAnnotation {
4845   constructor(params) {
4846     super(params);
4847 
4848     const { dict, xref } = params;
4849     this.data.annotationType = AnnotationType.STRIKEOUT;
4850 
4851     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4852     if (quadPoints) {
4853       if (!this.appearance) {
4854         // Default color is black
4855         const strokeColor = this.color
4856           ? getPdfColorArray(this.color)
4857           : [0, 0, 0];
4858         const strokeAlpha = dict.get("CA");
4859 
4860         this._setDefaultAppearance({
4861           xref,
4862           extra: "[] 0 d 1 w",
4863           strokeColor,
4864           strokeAlpha,
4865           pointsCallback: (buffer, points) => {
4866             buffer.push(
4867               `${(points[0] + points[4]) / 2} ` +
4868                 `${(points[1] + points[5]) / 2} m`,
4869               `${(points[2] + points[6]) / 2} ` +
4870                 `${(points[3] + points[7]) / 2} l`,
4871               "S"
4872             );
4873             return [points[0], points[2], points[7], points[3]];
4874           },
4875         });
4876       }
4877     } else {
4878       this.data.popupRef = null;
4879     }
4880   }
4881 }
4882 
4883 class StampAnnotation extends MarkupAnnotation {
4884   #savedHasOwnCanvas;
4885 
4886   constructor(params) {
4887     super(params);
4888 
4889     this.data.annotationType = AnnotationType.STAMP;
4890     this.#savedHasOwnCanvas = this.data.hasOwnCanvas = this.data.noRotate;
4891     this.data.isEditable = !this.data.noHTML;
4892     // We want to be able to add mouse listeners to the annotation.
4893     this.data.noHTML = false;
4894   }
4895 
4896   mustBeViewedWhenEditing(isEditing, modifiedIds = null) {
4897     if (isEditing) {
4898       if (!this.data.isEditable) {
4899         return false;
4900       }
4901       // When we're editing, we want to ensure that the stamp annotation is
4902       // drawn on a canvas in order to use it in the annotation editor layer.
4903       this.#savedHasOwnCanvas = this.data.hasOwnCanvas;
4904       this.data.hasOwnCanvas = true;
4905       return true;
4906     }
4907     this.data.hasOwnCanvas = this.#savedHasOwnCanvas;
4908 
4909     return !modifiedIds?.has(this.data.id);
4910   }
4911 
4912   static async createImage(bitmap, xref) {
4913     // TODO: when printing, we could have a specific internal colorspace
4914     // (e.g. something like DeviceRGBA) in order avoid any conversion (i.e. no
4915     // jpeg, no rgba to rgb conversion, etc...)
4916 
4917     const { width, height } = bitmap;
4918     const canvas = new OffscreenCanvas(width, height);
4919     const ctx = canvas.getContext("2d", { alpha: true });
4920 
4921     // Draw the image and get the data in order to extract the transparency.
4922     ctx.drawImage(bitmap, 0, 0);
4923     const data = ctx.getImageData(0, 0, width, height).data;
4924     const buf32 = new Uint32Array(data.buffer);
4925     const hasAlpha = buf32.some(
4926       FeatureTest.isLittleEndian
4927         ? x => x >>> 24 !== 0xff
4928         : x => (x & 0xff) !== 0xff
4929     );
4930 
4931     if (hasAlpha) {
4932       // Redraw the image on a white background in order to remove the thin gray
4933       // line which can appear when exporting to jpeg.
4934       ctx.fillStyle = "white";
4935       ctx.fillRect(0, 0, width, height);
4936       ctx.drawImage(bitmap, 0, 0);
4937     }
4938 
4939     const jpegBufferPromise = canvas
4940       .convertToBlob({ type: "image/jpeg", quality: 1 })
4941       .then(blob => blob.arrayBuffer());
4942 
4943     const xobjectName = Name.get("XObject");
4944     const imageName = Name.get("Image");
4945     const image = new Dict(xref);
4946     image.set("Type", xobjectName);
4947     image.set("Subtype", imageName);
4948     image.set("BitsPerComponent", 8);
4949     image.set("ColorSpace", Name.get("DeviceRGB"));
4950     image.set("Filter", Name.get("DCTDecode"));
4951     image.set("BBox", [0, 0, width, height]);
4952     image.set("Width", width);
4953     image.set("Height", height);
4954 
4955     let smaskStream = null;
4956     if (hasAlpha) {
4957       const alphaBuffer = new Uint8Array(buf32.length);
4958       if (FeatureTest.isLittleEndian) {
4959         for (let i = 0, ii = buf32.length; i < ii; i++) {
4960           alphaBuffer[i] = buf32[i] >>> 24;
4961         }
4962       } else {
4963         for (let i = 0, ii = buf32.length; i < ii; i++) {
4964           alphaBuffer[i] = buf32[i] & 0xff;
4965         }
4966       }
4967 
4968       const smask = new Dict(xref);
4969       smask.set("Type", xobjectName);
4970       smask.set("Subtype", imageName);
4971       smask.set("BitsPerComponent", 8);
4972       smask.set("ColorSpace", Name.get("DeviceGray"));
4973       smask.set("Width", width);
4974       smask.set("Height", height);
4975 
4976       smaskStream = new Stream(alphaBuffer, 0, 0, smask);
4977     }
4978     const imageStream = new Stream(await jpegBufferPromise, 0, 0, image);
4979 
4980     return {
4981       imageStream,
4982       smaskStream,
4983       width,
4984       height,
4985     };
4986   }
4987 
4988   static createNewDict(annotation, xref, { apRef, ap }) {
4989     const { oldAnnotation, rect, rotation, user } = annotation;
4990     const stamp = oldAnnotation || new Dict(xref);
4991     stamp.set("Type", Name.get("Annot"));
4992     stamp.set("Subtype", Name.get("Stamp"));
4993     stamp.set(
4994       oldAnnotation ? "M" : "CreationDate",
4995       `D:${getModificationDate()}`
4996     );
4997     stamp.set("CreationDate", `D:${getModificationDate()}`);
4998     stamp.set("Rect", rect);
4999     stamp.set("F", 4);
5000     stamp.set("Border", [0, 0, 0]);
5001     stamp.set("Rotate", rotation);
5002 
5003     if (user) {
5004       stamp.set("T", stringToAsciiOrUTF16BE(user));
5005     }
5006 
5007     if (apRef || ap) {
5008       const n = new Dict(xref);
5009       stamp.set("AP", n);
5010 
5011       if (apRef) {
5012         n.set("N", apRef);
5013       } else {
5014         n.set("N", ap);
5015       }
5016     }
5017 
5018     return stamp;
5019   }
5020 
5021   static async createNewAppearanceStream(annotation, xref, params) {
5022     if (annotation.oldAnnotation) {
5023       // We'll use the AP we already have.
5024       return null;
5025     }
5026 
5027     const { rotation } = annotation;
5028     const { imageRef, width, height } = params.image;
5029     const resources = new Dict(xref);
5030     const xobject = new Dict(xref);
5031     resources.set("XObject", xobject);
5032     xobject.set("Im0", imageRef);
5033     const appearance = `q ${width} 0 0 ${height} 0 0 cm /Im0 Do Q`;
5034 
5035     const appearanceStreamDict = new Dict(xref);
5036     appearanceStreamDict.set("FormType", 1);
5037     appearanceStreamDict.set("Subtype", Name.get("Form"));
5038     appearanceStreamDict.set("Type", Name.get("XObject"));
5039     appearanceStreamDict.set("BBox", [0, 0, width, height]);
5040     appearanceStreamDict.set("Resources", resources);
5041 
5042     if (rotation) {
5043       const matrix = getRotationMatrix(rotation, width, height);
5044       appearanceStreamDict.set("Matrix", matrix);
5045     }
5046 
5047     const ap = new StringStream(appearance);
5048     ap.dict = appearanceStreamDict;
5049 
5050     return ap;
5051   }
5052 }
5053 
5054 class FileAttachmentAnnotation extends MarkupAnnotation {
5055   constructor(params) {
5056     super(params);
5057 
5058     const { dict, xref } = params;
5059     const file = new FileSpec(dict.get("FS"), xref);
5060 
5061     this.data.annotationType = AnnotationType.FILEATTACHMENT;
5062     this.data.hasOwnCanvas = this.data.noRotate;
5063     this.data.noHTML = false;
5064     this.data.file = file.serializable;
5065 
5066     const name = dict.get("Name");
5067     this.data.name =
5068       name instanceof Name ? stringToPDFString(name.name) : "PushPin";
5069 
5070     const fillAlpha = dict.get("ca");
5071     this.data.fillAlpha =
5072       typeof fillAlpha === "number" && fillAlpha >= 0 && fillAlpha <= 1
5073         ? fillAlpha
5074         : null;
5075   }
5076 }
5077 
5078 export {
5079   Annotation,
5080   AnnotationBorderStyle,
5081   AnnotationFactory,
5082   getQuadPoints,
5083   MarkupAnnotation,
5084   PopupAnnotation,
5085   WidgetAnnotation,
5086 };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

