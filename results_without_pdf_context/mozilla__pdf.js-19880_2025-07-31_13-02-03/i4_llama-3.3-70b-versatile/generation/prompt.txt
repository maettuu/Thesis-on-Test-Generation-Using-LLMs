Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: numberToString function doesn't properly handle null values in pdf.js/src/core/core_utils.js
### Attach (recommended) or Link to PDF file

The bug is about node.js logic.

### Web browser and its version

node.js

### Operating system and its version

ubuntu 22.04

### PDF.js version

v5.2.133

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

```
// Implementation of numberToString function 
// Source: /pdf.js/src/core/core_utils.js
function numberToString(value) {
    if (Number.isInteger(value)) {
      return value.toString();
    }
  
    const roundedValue = Math.round(value * 100);
    if (roundedValue % 100 === 0) {
      return (roundedValue / 100).toString();
    }
  
    if (roundedValue % 10 === 0) {
      return value.toFixed(1);
    }
  
    return value.toFixed(2);
  }
  
  // Test and output results
  console.log('=== numberToString Function Test ===');
  console.log(`numberToString(42.345) = "${numberToString(42.345)}"`);
  console.log(`numberToString(-42.345) = "${numberToString(-42.345)}"`);
  console.log(`numberToString(0) = "${numberToString(0)}"`);
  console.log(`numberToString(null) = "${numberToString(null)}"`); // This will output "0", demonstrating the bug
  
  try {
    console.log(`numberToString("42.345") = "${numberToString("42.345")}"`);
  } catch (error) {
    console.log(`String input error: ${error.message}`); // Will throw an error because strings don't have a toFixed method
  }
```

The implement is copy from the source code, and we focus on when the input is "null".

### What is the expected behavior?

The out put of "null" should consider different situations.

### What went wrong?

The out put of "null" is always "0" since node.js implement.

### Link to a viewer

_No response_

### Additional context

During PDF processing, directly converting null values to 0 might not always be appropriate. In some cases, a null can represent missing or undefined data rather than an actual numeric value. Automatically treating it as 0 could unintentionally alter the meaning of the data, potentially leading to incorrect interpretations or downstream issues.

It might be safer to preserve null as-is, or to handle it explicitly based on context — for example, distinguishing between truly "zero" values and "unknown/missing" values. This would help maintain data integrity and avoid masking important information.

Just a suggestion to consider: handling null values more carefully depending on the specific use case could make the system more robust.
</issue>

Patch:
<patch>
diff --git a/src/core/core_utils.js b/src/core/core_utils.js
--- a/src/core/core_utils.js
+++ b/src/core/core_utils.js
@@ -632,6 +632,13 @@ function recoverJsURL(str) {
 }
 
 function numberToString(value) {
+  if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
+    assert(
+      typeof value === "number",
+      `numberToString - the value (${value}) should be a number.`
+    );
+  }
+
   if (Number.isInteger(value)) {
     return value.toString();
   }


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.10
- @babel/preset-env: ^7.26.9
- @babel/runtime: ^7.27.0
- @csstools/postcss-light-dark-function: ^2.0.8
- @fluent/bundle: ^0.19.1
- @fluent/dom: ^0.10.1
- @metalsmith/layouts: ^3.0.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.69
- @types/node: ^22.15.2
- autoprefixer: ^10.4.21
- babel-loader: ^10.0.0
- caniuse-lite: ^1.0.30001715
- core-js: ^3.41.0
- eslint: ^9.25.1
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.12.3
- eslint-plugin-prettier: ^5.2.6
- eslint-plugin-unicorn: ^58.0.0
- globals: ^16.0.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.6.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.5.3
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.5.3
- puppeteer: ^24.7.2
- stylelint: ^16.19.1
- stylelint-prettier: ^5.0.3
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.14
- tsc-alias: ^1.8.15
- ttest: ^4.0.0
- typescript: ^5.8.3
- vinyl: ^3.0.0
- webpack: ^5.99.7
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20.16.0 || >=22.3.0

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/calculate_md5.js`: calculateMD5
- `../../src/core/calculate_sha256.js`: calculateSHA256
- `../../src/core/calculate_sha_other.js`: calculateSHA384, calculateSHA512
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/colorspace_utils.js`: ColorSpaceUtils
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalColorSpaceCache, GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, isValidExplicitDest, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/cmap_reader_factory.js`: DOMCMapReaderFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, SupportedImageMimeTypes, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/drawers/signaturedraw.js`: SignatureExtractor
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodeCMapReaderFactory, NodeStandardFontDataFactory, fetchData
- `../../src/display/standard_fontdata_factory.js`: DOMStandardFontDataFactory
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, DrawOPS, FeatureTest, FormatError, ImageKind, InvalidPDFException, MathClamp, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, ResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util, updateUrlHash
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/autolinker.js`: Autolinker
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultCMapReaderFactory, DefaultFileReaderFactory, DefaultStandardFontDataFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/core/core_utils.js
1 /* Copyright 2019 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AnnotationEditorPrefix,
18   assert,
19   BaseException,
20   hexNumbers,
21   objectSize,
22   stringToPDFString,
23   Util,
24   warn,
25 } from "../shared/util.js";
26 import { Dict, isName, Ref, RefSet } from "./primitives.js";
27 import { BaseStream } from "./base_stream.js";
28 
29 const PDF_VERSION_REGEXP = /^[1-9]\.\d$/;
30 const MAX_INT_32 = 2 ** 31 - 1;
31 const MIN_INT_32 = -(2 ** 31);
32 
33 const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
34 
35 const RESOURCES_KEYS_OPERATOR_LIST = [
36   "ColorSpace",
37   "ExtGState",
38   "Font",
39   "Pattern",
40   "Properties",
41   "Shading",
42   "XObject",
43 ];
44 
45 const RESOURCES_KEYS_TEXT_CONTENT = [
46   "ExtGState",
47   "Font",
48   "Properties",
49   "XObject",
50 ];
51 
52 function getLookupTableFactory(initializer) {
53   let lookup;
54   return function () {
55     if (initializer) {
56       lookup = Object.create(null);
57       initializer(lookup);
58       initializer = null;
59     }
60     return lookup;
61   };
62 }
63 
64 class MissingDataException extends BaseException {
65   constructor(begin, end) {
66     super(`Missing data [${begin}, ${end})`, "MissingDataException");
67     this.begin = begin;
68     this.end = end;
69   }
70 }
71 
72 class ParserEOFException extends BaseException {
73   constructor(msg) {
74     super(msg, "ParserEOFException");
75   }
76 }
77 
78 class XRefEntryException extends BaseException {
79   constructor(msg) {
80     super(msg, "XRefEntryException");
81   }
82 }
83 
84 class XRefParseException extends BaseException {
85   constructor(msg) {
86     super(msg, "XRefParseException");
87   }
88 }
89 
90 /**
91  * Combines multiple ArrayBuffers into a single Uint8Array.
92  * @param {Array<ArrayBuffer>} arr - An array of ArrayBuffers.
93  * @returns {Uint8Array}
94  */
95 function arrayBuffersToBytes(arr) {
96   if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
97     for (const item of arr) {
98       assert(
99         item instanceof ArrayBuffer,
100         "arrayBuffersToBytes - expected an ArrayBuffer."
101       );
102     }
103   }
104   const length = arr.length;
105   if (length === 0) {
106     return new Uint8Array(0);
107   }
108   if (length === 1) {
109     return new Uint8Array(arr[0]);
110   }
111   let dataLength = 0;
112   for (let i = 0; i < length; i++) {
113     dataLength += arr[i].byteLength;
114   }
115   const data = new Uint8Array(dataLength);
116   let pos = 0;
117   for (let i = 0; i < length; i++) {
118     const item = new Uint8Array(arr[i]);
119     data.set(item, pos);
120     pos += item.byteLength;
121   }
122   return data;
123 }
124 
125 async function fetchBinaryData(url) {
126   const response = await fetch(url);
127   if (!response.ok) {
128     throw new Error(
129       `Failed to fetch file "${url}" with "${response.statusText}".`
130     );
131   }
132   return new Uint8Array(await response.arrayBuffer());
133 }
134 
135 /**
136  * Get the value of an inheritable property.
137  *
138  * If the PDF specification explicitly lists a property in a dictionary as
139  * inheritable, then the value of the property may be present in the dictionary
140  * itself or in one or more parents of the dictionary.
141  *
142  * If the key is not found in the tree, `undefined` is returned. Otherwise,
143  * the value for the key is returned or, if `stopWhenFound` is `false`, a list
144  * of values is returned.
145  *
146  * @param {Dict} dict - Dictionary from where to start the traversal.
147  * @param {string} key - The key of the property to find the value for.
148  * @param {boolean} getArray - Whether or not the value should be fetched as an
149  *   array. The default value is `false`.
150  * @param {boolean} stopWhenFound - Whether or not to stop the traversal when
151  *   the key is found. If set to `false`, we always walk up the entire parent
152  *   chain, for example to be able to find `\Resources` placed on multiple
153  *   levels of the tree. The default value is `true`.
154  */
155 function getInheritableProperty({
156   dict,
157   key,
158   getArray = false,
159   stopWhenFound = true,
160 }) {
161   let values;
162   const visited = new RefSet();
163 
164   while (dict instanceof Dict && !(dict.objId && visited.has(dict.objId))) {
165     if (dict.objId) {
166       visited.put(dict.objId);
167     }
168     const value = getArray ? dict.getArray(key) : dict.get(key);
169     if (value !== undefined) {
170       if (stopWhenFound) {
171         return value;
172       }
173       (values ||= []).push(value);
174     }
175     dict = dict.get("Parent");
176   }
177   return values;
178 }
179 
180 /**
181  * Get the parent dictionary to update when a property is set.
182  *
183  * @param {Dict} dict - Dictionary from where to start the traversal.
184  * @param {Ref} ref - The reference to the dictionary.
185  * @param {XRef} xref - The `XRef` instance.
186  */
187 function getParentToUpdate(dict, ref, xref) {
188   const visited = new RefSet();
189   const firstDict = dict;
190   const result = { dict: null, ref: null };
191 
192   while (dict instanceof Dict && !visited.has(ref)) {
193     visited.put(ref);
194     if (dict.has("T")) {
195       break;
196     }
197     ref = dict.getRaw("Parent");
198     if (!(ref instanceof Ref)) {
199       return result;
200     }
201     dict = xref.fetch(ref);
202   }
203   if (dict instanceof Dict && dict !== firstDict) {
204     result.dict = dict;
205     result.ref = ref;
206   }
207   return result;
208 }
209 
210 // prettier-ignore
211 const ROMAN_NUMBER_MAP = [
212   "", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM",
213   "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC",
214   "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"
215 ];
216 
217 /**
218  * Converts positive integers to (upper case) Roman numerals.
219  * @param {number} number - The number that should be converted.
220  * @param {boolean} lowerCase - Indicates if the result should be converted
221  *   to lower case letters. The default value is `false`.
222  * @returns {string} The resulting Roman number.
223  */
224 function toRomanNumerals(number, lowerCase = false) {
225   assert(
226     Number.isInteger(number) && number > 0,
227     "The number should be a positive integer."
228   );
229 
230   const roman =
231     "M".repeat((number / 1000) | 0) +
232     ROMAN_NUMBER_MAP[((number % 1000) / 100) | 0] +
233     ROMAN_NUMBER_MAP[10 + (((number % 100) / 10) | 0)] +
234     ROMAN_NUMBER_MAP[20 + (number % 10)];
235   return lowerCase ? roman.toLowerCase() : roman;
236 }
237 
238 // Calculate the base 2 logarithm of the number `x`. This differs from the
239 // native function in the sense that it returns the ceiling value and that it
240 // returns 0 instead of `Infinity`/`NaN` for `x` values smaller than/equal to 0.
241 function log2(x) {
242   return x > 0 ? Math.ceil(Math.log2(x)) : 0;
243 }
244 
245 function readInt8(data, offset) {
246   return (data[offset] << 24) >> 24;
247 }
248 
249 function readInt16(data, offset) {
250   return ((data[offset] << 24) | (data[offset + 1] << 16)) >> 16;
251 }
252 
253 function readUint16(data, offset) {
254   return (data[offset] << 8) | data[offset + 1];
255 }
256 
257 function readUint32(data, offset) {
258   return (
259     ((data[offset] << 24) |
260       (data[offset + 1] << 16) |
261       (data[offset + 2] << 8) |
262       data[offset + 3]) >>>
263     0
264   );
265 }
266 
267 // Checks if ch is one of the following characters: SPACE, TAB, CR or LF.
268 function isWhiteSpace(ch) {
269   return ch === 0x20 || ch === 0x09 || ch === 0x0d || ch === 0x0a;
270 }
271 
272 /**
273  * Checks if something is an Array containing only boolean values,
274  * and (optionally) checks its length.
275  * @param {any} arr
276  * @param {number | null} len
277  * @returns {boolean}
278  */
279 function isBooleanArray(arr, len) {
280   return (
281     Array.isArray(arr) &&
282     (len === null || arr.length === len) &&
283     arr.every(x => typeof x === "boolean")
284   );
285 }
286 
287 /**
288  * Checks if something is an Array containing only numbers,
289  * and (optionally) checks its length.
290  * @param {any} arr
291  * @param {number | null} len
292  * @returns {boolean}
293  */
294 function isNumberArray(arr, len) {
295   if (Array.isArray(arr)) {
296     return (
297       (len === null || arr.length === len) &&
298       arr.every(x => typeof x === "number")
299     );
300   }
301 
302   // This check allows us to have typed arrays but not the
303   // BigInt64Array/BigUint64Array types (their elements aren't "number").
304   return (
305     ArrayBuffer.isView(arr) &&
306     !(arr instanceof BigInt64Array || arr instanceof BigUint64Array) &&
307     (len === null || arr.length === len)
308   );
309 }
310 
311 // Returns the matrix, or the fallback value if it's invalid.
312 function lookupMatrix(arr, fallback) {
313   return isNumberArray(arr, 6) ? arr : fallback;
314 }
315 
316 // Returns the rectangle, or the fallback value if it's invalid.
317 function lookupRect(arr, fallback) {
318   return isNumberArray(arr, 4) ? arr : fallback;
319 }
320 
321 // Returns the normalized rectangle, or the fallback value if it's invalid.
322 function lookupNormalRect(arr, fallback) {
323   return isNumberArray(arr, 4) ? Util.normalizeRect(arr) : fallback;
324 }
325 
326 /**
327  * AcroForm field names use an array like notation to refer to
328  * repeated XFA elements e.g. foo.bar[nnn].
329  * see: XFA Spec Chapter 3 - Repeated Elements
330  *
331  * @param {string} path - XFA path name.
332  * @returns {Array} - Array of Objects with the name and pos of
333  * each part of the path.
334  */
335 function parseXFAPath(path) {
336   const positionPattern = /(.+)\[(\d+)\]$/;
337   return path.split(".").map(component => {
338     const m = component.match(positionPattern);
339     if (m) {
340       return { name: m[1], pos: parseInt(m[2], 10) };
341     }
342     return { name: component, pos: 0 };
343   });
344 }
345 
346 function escapePDFName(str) {
347   const buffer = [];
348   let start = 0;
349   for (let i = 0, ii = str.length; i < ii; i++) {
350     const char = str.charCodeAt(i);
351     // Whitespace or delimiters aren't regular chars, so escape them.
352     if (
353       char < 0x21 ||
354       char > 0x7e ||
355       char === 0x23 /* # */ ||
356       char === 0x28 /* ( */ ||
357       char === 0x29 /* ) */ ||
358       char === 0x3c /* < */ ||
359       char === 0x3e /* > */ ||
360       char === 0x5b /* [ */ ||
361       char === 0x5d /* ] */ ||
362       char === 0x7b /* { */ ||
363       char === 0x7d /* } */ ||
364       char === 0x2f /* / */ ||
365       char === 0x25 /* % */
366     ) {
367       if (start < i) {
368         buffer.push(str.substring(start, i));
369       }
370       buffer.push(`#${char.toString(16)}`);
371       start = i + 1;
372     }
373   }
374 
375   if (buffer.length === 0) {
376     return str;
377   }
378 
379   if (start < str.length) {
380     buffer.push(str.substring(start, str.length));
381   }
382 
383   return buffer.join("");
384 }
385 
386 // Replace "(", ")", "\n", "\r" and "\" by "\(", "\)", "\\n", "\\r" and "\\"
387 // in order to write it in a PDF file.
388 function escapeString(str) {
389   return str.replaceAll(/([()\\\n\r])/g, match => {
390     if (match === "\n") {
391       return "\\n";
392     } else if (match === "\r") {
393       return "\\r";
394     }
395     return `\\${match}`;
396   });
397 }
398 
399 function _collectJS(entry, xref, list, parents) {
400   if (!entry) {
401     return;
402   }
403 
404   let parent = null;
405   if (entry instanceof Ref) {
406     if (parents.has(entry)) {
407       // If we've already found entry then we've a cycle.
408       return;
409     }
410     parent = entry;
411     parents.put(parent);
412     entry = xref.fetch(entry);
413   }
414   if (Array.isArray(entry)) {
415     for (const element of entry) {
416       _collectJS(element, xref, list, parents);
417     }
418   } else if (entry instanceof Dict) {
419     if (isName(entry.get("S"), "JavaScript")) {
420       const js = entry.get("JS");
421       let code;
422       if (js instanceof BaseStream) {
423         code = js.getString();
424       } else if (typeof js === "string") {
425         code = js;
426       }
427       code &&= stringToPDFString(code).replaceAll("\x00", "");
428       if (code) {
429         list.push(code);
430       }
431     }
432     _collectJS(entry.getRaw("Next"), xref, list, parents);
433   }
434 
435   if (parent) {
436     parents.remove(parent);
437   }
438 }
439 
440 function collectActions(xref, dict, eventType) {
441   const actions = Object.create(null);
442   const additionalActionsDicts = getInheritableProperty({
443     dict,
444     key: "AA",
445     stopWhenFound: false,
446   });
447   if (additionalActionsDicts) {
448     // additionalActionsDicts contains dicts from ancestors
449     // as they're found in the tree from bottom to top.
450     // So the dicts are visited in reverse order to guarantee
451     // that actions from elder ancestors will be overwritten
452     // by ones from younger ancestors.
453     for (let i = additionalActionsDicts.length - 1; i >= 0; i--) {
454       const additionalActions = additionalActionsDicts[i];
455       if (!(additionalActions instanceof Dict)) {
456         continue;
457       }
458       for (const key of additionalActions.getKeys()) {
459         const action = eventType[key];
460         if (!action) {
461           continue;
462         }
463         const actionDict = additionalActions.getRaw(key);
464         const parents = new RefSet();
465         const list = [];
466         _collectJS(actionDict, xref, list, parents);
467         if (list.length > 0) {
468           actions[action] = list;
469         }
470       }
471     }
472   }
473   // Collect the Action if any (we may have one on pushbutton).
474   if (dict.has("A")) {
475     const actionDict = dict.get("A");
476     const parents = new RefSet();
477     const list = [];
478     _collectJS(actionDict, xref, list, parents);
479     if (list.length > 0) {
480       actions.Action = list;
481     }
482   }
483   return objectSize(actions) > 0 ? actions : null;
484 }
485 
486 const XMLEntities = {
487   /* < */ 0x3c: "&lt;",
488   /* > */ 0x3e: "&gt;",
489   /* & */ 0x26: "&amp;",
490   /* " */ 0x22: "&quot;",
491   /* ' */ 0x27: "&apos;",
492 };
493 
494 function* codePointIter(str) {
495   for (let i = 0, ii = str.length; i < ii; i++) {
496     const char = str.codePointAt(i);
497     if (char > 0xd7ff && (char < 0xe000 || char > 0xfffd)) {
498       // char is represented by two u16
499       i++;
500     }
501     yield char;
502   }
503 }
504 
505 function encodeToXmlString(str) {
506   const buffer = [];
507   let start = 0;
508   for (let i = 0, ii = str.length; i < ii; i++) {
509     const char = str.codePointAt(i);
510     if (0x20 <= char && char <= 0x7e) {
511       // ascii
512       const entity = XMLEntities[char];
513       if (entity) {
514         if (start < i) {
515           buffer.push(str.substring(start, i));
516         }
517         buffer.push(entity);
518         start = i + 1;
519       }
520     } else {
521       if (start < i) {
522         buffer.push(str.substring(start, i));
523       }
524       buffer.push(`&#x${char.toString(16).toUpperCase()};`);
525       if (char > 0xd7ff && (char < 0xe000 || char > 0xfffd)) {
526         // char is represented by two u16
527         i++;
528       }
529       start = i + 1;
530     }
531   }
532 
533   if (buffer.length === 0) {
534     return str;
535   }
536   if (start < str.length) {
537     buffer.push(str.substring(start, str.length));
538   }
539   return buffer.join("");
540 }
541 
542 function validateFontName(fontFamily, mustWarn = false) {
543   // See https://developer.mozilla.org/en-US/docs/Web/CSS/string.
544   const m = /^("|').*("|')$/.exec(fontFamily);
545   if (m && m[1] === m[2]) {
546     const re = new RegExp(`[^\\\\]${m[1]}`);
547     if (re.test(fontFamily.slice(1, -1))) {
548       if (mustWarn) {
549         warn(`FontFamily contains unescaped ${m[1]}: ${fontFamily}.`);
550       }
551       return false;
552     }
553   } else {
554     // See https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident.
555     for (const ident of fontFamily.split(/[ \t]+/)) {
556       if (/^(\d|(-(\d|-)))/.test(ident) || !/^[\w-\\]+$/.test(ident)) {
557         if (mustWarn) {
558           warn(`FontFamily contains invalid <custom-ident>: ${fontFamily}.`);
559         }
560         return false;
561       }
562     }
563   }
564   return true;
565 }
566 
567 function validateCSSFont(cssFontInfo) {
568   // See https://developer.mozilla.org/en-US/docs/Web/CSS/font-style.
569   const DEFAULT_CSS_FONT_OBLIQUE = "14";
570   // See https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight.
571   const DEFAULT_CSS_FONT_WEIGHT = "400";
572   const CSS_FONT_WEIGHT_VALUES = new Set([
573     "100",
574     "200",
575     "300",
576     "400",
577     "500",
578     "600",
579     "700",
580     "800",
581     "900",
582     "1000",
583     "normal",
584     "bold",
585     "bolder",
586     "lighter",
587   ]);
588 
589   const { fontFamily, fontWeight, italicAngle } = cssFontInfo;
590 
591   if (!validateFontName(fontFamily, true)) {
592     return false;
593   }
594 
595   const weight = fontWeight ? fontWeight.toString() : "";
596   cssFontInfo.fontWeight = CSS_FONT_WEIGHT_VALUES.has(weight)
597     ? weight
598     : DEFAULT_CSS_FONT_WEIGHT;
599 
600   const angle = parseFloat(italicAngle);
601   cssFontInfo.italicAngle =
602     isNaN(angle) || angle < -90 || angle > 90
603       ? DEFAULT_CSS_FONT_OBLIQUE
604       : italicAngle.toString();
605 
606   return true;
607 }
608 
609 function recoverJsURL(str) {
610   // Attempt to recover valid URLs from `JS` entries with certain
611   // white-listed formats:
612   //  - window.open('http://example.com')
613   //  - app.launchURL('http://example.com', true)
614   //  - xfa.host.gotoURL('http://example.com')
615   const URL_OPEN_METHODS = ["app.launchURL", "window.open", "xfa.host.gotoURL"];
616   const regex = new RegExp(
617     "^\\s*(" +
618       URL_OPEN_METHODS.join("|").replaceAll(".", "\\.") +
619       ")\\((?:'|\")([^'\"]*)(?:'|\")(?:,\\s*(\\w+)\\)|\\))",
620     "i"
621   );
622 
623   const jsUrl = regex.exec(str);
624   if (jsUrl?.[2]) {
625     return {
626       url: jsUrl[2],
627       newWindow: jsUrl[1] === "app.launchURL" && jsUrl[3] === "true",
628     };
629   }
630 
631   return null;
632 }
633 
634 function numberToString(value) {
635   if (Number.isInteger(value)) {
636     return value.toString();
637   }
638 
639   const roundedValue = Math.round(value * 100);
640   if (roundedValue % 100 === 0) {
641     return (roundedValue / 100).toString();
642   }
643 
644   if (roundedValue % 10 === 0) {
645     return value.toFixed(1);
646   }
647 
648   return value.toFixed(2);
649 }
650 
651 function getNewAnnotationsMap(annotationStorage) {
652   if (!annotationStorage) {
653     return null;
654   }
655   const newAnnotationsByPage = new Map();
656   // The concept of page in a XFA is very different, so
657   // editing is just not implemented.
658   for (const [key, value] of annotationStorage) {
659     if (!key.startsWith(AnnotationEditorPrefix)) {
660       continue;
661     }
662     let annotations = newAnnotationsByPage.get(value.pageIndex);
663     if (!annotations) {
664       annotations = [];
665       newAnnotationsByPage.set(value.pageIndex, annotations);
666     }
667     annotations.push(value);
668   }
669   return newAnnotationsByPage.size > 0 ? newAnnotationsByPage : null;
670 }
671 
672 function stringToAsciiOrUTF16BE(str) {
673   return isAscii(str) ? str : stringToUTF16String(str, /* bigEndian = */ true);
674 }
675 
676 function isAscii(str) {
677   return /^[\x00-\x7F]*$/.test(str);
678 }
679 
680 function stringToUTF16HexString(str) {
681   const buf = [];
682   for (let i = 0, ii = str.length; i < ii; i++) {
683     const char = str.charCodeAt(i);
684     buf.push(hexNumbers[(char >> 8) & 0xff], hexNumbers[char & 0xff]);
685   }
686   return buf.join("");
687 }
688 
689 function stringToUTF16String(str, bigEndian = false) {
690   const buf = [];
691   if (bigEndian) {
692     buf.push("\xFE\xFF");
693   }
694   for (let i = 0, ii = str.length; i < ii; i++) {
695     const char = str.charCodeAt(i);
696     buf.push(
697       String.fromCharCode((char >> 8) & 0xff),
698       String.fromCharCode(char & 0xff)
699     );
700   }
701   return buf.join("");
702 }
703 
704 function getRotationMatrix(rotation, width, height) {
705   switch (rotation) {
706     case 90:
707       return [0, 1, -1, 0, width, 0];
708     case 180:
709       return [-1, 0, 0, -1, width, height];
710     case 270:
711       return [0, -1, 1, 0, 0, height];
712     default:
713       throw new Error("Invalid rotation");
714   }
715 }
716 
717 /**
718  * Get the number of bytes to use to represent the given positive integer.
719  * If n is zero, the function returns 0 which means that we don't need to waste
720  * a byte to represent it.
721  * @param {number} x - a positive integer.
722  * @returns {number}
723  */
724 function getSizeInBytes(x) {
725   // n bits are required for numbers up to 2^n - 1.
726   // So for a number x, we need ceil(log2(1 + x)) bits.
727   return Math.ceil(Math.ceil(Math.log2(1 + x)) / 8);
728 }
729 
730 export {
731   arrayBuffersToBytes,
732   codePointIter,
733   collectActions,
734   encodeToXmlString,
735   escapePDFName,
736   escapeString,
737   fetchBinaryData,
738   getInheritableProperty,
739   getLookupTableFactory,
740   getNewAnnotationsMap,
741   getParentToUpdate,
742   getRotationMatrix,
743   getSizeInBytes,
744   IDENTITY_MATRIX,
745   isAscii,
746   isBooleanArray,
747   isNumberArray,
748   isWhiteSpace,
749   log2,
750   lookupMatrix,
751   lookupNormalRect,
752   lookupRect,
753   MAX_INT_32,
754   MIN_INT_32,
755   MissingDataException,
756   numberToString,
757   ParserEOFException,
758   parseXFAPath,
759   PDF_VERSION_REGEXP,
760   readInt16,
761   readInt8,
762   readUint16,
763   readUint32,
764   recoverJsURL,
765   RESOURCES_KEYS_OPERATOR_LIST,
766   RESOURCES_KEYS_TEXT_CONTENT,
767   stringToAsciiOrUTF16BE,
768   stringToUTF16HexString,
769   stringToUTF16String,
770   toRomanNumerals,
771   validateCSSFont,
772   validateFontName,
773   XRefEntryException,
774   XRefParseException,
775 };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

