Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
memory usage ballooning when scrolling through pdf
</issue>

Patch:
<patch>
diff --git a/src/display/api.js b/src/display/api.js
--- a/src/display/api.js
+++ b/src/display/api.js
@@ -2768,6 +2768,11 @@ class WorkerTransport {
       if (pageProxy.objs.has(id)) {
         return;
       }
+      // Don't store data *after* cleanup has successfully run, see bug 1854145.
+      if (pageProxy._intentStates.size === 0) {
+        imageData?.bitmap?.close(); // Release any `ImageBitmap` data.
+        return;
+      }
 
       switch (type) {
         case "Image":


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.22.20
- @babel/plugin-transform-modules-commonjs: ^7.22.15
- @babel/preset-env: ^7.22.20
- @babel/runtime: ^7.22.15
- @javascript-obfuscator/escodegen: 2.3.0
- acorn: ^8.10.0
- autoprefixer: ^10.4.16
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001538
- canvas: ^2.11.2
- core-js: ^3.32.2
- cross-env: ^7.0.3
- es-module-shims: 1.4.7
- eslint: ^8.50.0
- eslint-config-prettier: ^8.10.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.28.1
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.2.0
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.0.0
- eslint-plugin-sort-exports: ^0.8.0
- eslint-plugin-unicorn: ^48.0.1
- globals: ^13.22.0
- gulp: ^4.0.2
- gulp-postcss: ^9.0.1
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^5.1.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.2.0
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.31
- postcss-dir-pseudo-class: ^8.0.0
- postcss-discard-comments: ^6.0.0
- postcss-nesting: ^12.0.1
- prettier: ^3.0.3
- puppeteer: ^21.3.4
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^15.10.3
- stylelint-prettier: ^4.0.2
- terser: ^5.20.0
- through2: ^4.0.2
- tsc-alias: ^1.8.8
- ttest: ^4.0.0
- typescript: ^5.2.2
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.88.2
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isArrayBuffer, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/l10n_utils.js`: NullL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/display/api.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
20 import {
21   AbortException,
22   AnnotationMode,
23   assert,
24   getVerbosityLevel,
25   info,
26   InvalidPDFException,
27   isArrayBuffer,
28   isNodeJS,
29   MAX_IMAGE_SIZE_TO_CACHE,
30   MissingPDFException,
31   PasswordException,
32   PromiseCapability,
33   RenderingIntentFlag,
34   setVerbosityLevel,
35   shadow,
36   stringToBytes,
37   UnexpectedResponseException,
38   UnknownErrorException,
39   unreachable,
40   warn,
41 } from "../shared/util.js";
42 import {
43   AnnotationStorage,
44   PrintAnnotationStorage,
45   SerializableEmpty,
46 } from "./annotation_storage.js";
47 import {
48   DOMCanvasFactory,
49   DOMCMapReaderFactory,
50   DOMFilterFactory,
51   DOMStandardFontDataFactory,
52   isDataScheme,
53   isValidFetchUrl,
54   PageViewport,
55   RenderingCancelledException,
56   StatTimer,
57 } from "./display_utils.js";
58 import { FontFaceObject, FontLoader } from "./font_loader.js";
59 import {
60   NodeCanvasFactory,
61   NodeCMapReaderFactory,
62   NodeFilterFactory,
63   NodeStandardFontDataFactory,
64 } from "display-node_utils";
65 import { CanvasGraphics } from "./canvas.js";
66 import { GlobalWorkerOptions } from "./worker_options.js";
67 import { MessageHandler } from "../shared/message_handler.js";
68 import { Metadata } from "./metadata.js";
69 import { OptionalContentConfig } from "./optional_content_config.js";
70 import { PDFDataTransportStream } from "./transport_stream.js";
71 import { PDFFetchStream } from "display-fetch_stream";
72 import { PDFNetworkStream } from "display-network";
73 import { PDFNodeStream } from "display-node_stream";
74 import { XfaText } from "./xfa_text.js";
75 
76 const DEFAULT_RANGE_CHUNK_SIZE = 65536; // 2^16 = 65536
77 const RENDERING_CANCELLED_TIMEOUT = 100; // ms
78 const DELAYED_CLEANUP_TIMEOUT = 5000; // ms
79 
80 const DefaultCanvasFactory =
81   typeof PDFJSDev !== "undefined" && PDFJSDev.test("GENERIC") && isNodeJS
82     ? NodeCanvasFactory
83     : DOMCanvasFactory;
84 const DefaultCMapReaderFactory =
85   typeof PDFJSDev !== "undefined" && PDFJSDev.test("GENERIC") && isNodeJS
86     ? NodeCMapReaderFactory
87     : DOMCMapReaderFactory;
88 const DefaultFilterFactory =
89   typeof PDFJSDev !== "undefined" && PDFJSDev.test("GENERIC") && isNodeJS
90     ? NodeFilterFactory
91     : DOMFilterFactory;
92 const DefaultStandardFontDataFactory =
93   typeof PDFJSDev !== "undefined" && PDFJSDev.test("GENERIC") && isNodeJS
94     ? NodeStandardFontDataFactory
95     : DOMStandardFontDataFactory;
96 
1976 const PDFWorkerUtil = {
1977   isWorkerDisabled: false,
1978   fakeWorkerId: 0,
1979 };
2014 
2317 /**
2318  * For internal use only.
2319  * @ignore
2320  */
2321 class WorkerTransport {
2322   #methodPromises = new Map();
2323 
2324   #pageCache = new Map();
2325 
2326   #pagePromises = new Map();
2327 
2328   #passwordCapability = null;
2329 
2330   constructor(messageHandler, loadingTask, networkStream, params, factory) {
2331     this.messageHandler = messageHandler;
2332     this.loadingTask = loadingTask;
2333     this.commonObjs = new PDFObjects();
2334     this.fontLoader = new FontLoader({
2335       ownerDocument: params.ownerDocument,
2336       styleElement: params.styleElement,
2337     });
2338     this._params = params;
2339 
2340     this.canvasFactory = factory.canvasFactory;
2341     this.filterFactory = factory.filterFactory;
2342     this.cMapReaderFactory = factory.cMapReaderFactory;
2343     this.standardFontDataFactory = factory.standardFontDataFactory;
2344 
2345     this.destroyed = false;
2346     this.destroyCapability = null;
2347 
2348     this._networkStream = networkStream;
2349     this._fullReader = null;
2350     this._lastProgress = null;
2351     this.downloadInfoCapability = new PromiseCapability();
2352 
2353     this.setupMessageHandler();
2354 
2355     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
2356       // For testing purposes.
2357       Object.defineProperty(this, "getXFADatasets", {
2358         value: () => {
2359           return this.messageHandler.sendWithPromise("GetXFADatasets", null);
2360         },
2361       });
2362       Object.defineProperty(this, "getXRefPrevValue", {
2363         value: () => {
2364           return this.messageHandler.sendWithPromise("GetXRefPrevValue", null);
2365         },
2366       });
2367       Object.defineProperty(this, "getAnnotArray", {
2368         value: pageIndex => {
2369           return this.messageHandler.sendWithPromise("GetAnnotArray", {
2370             pageIndex,
2371           });
2372         },
2373       });
2374     }
2375   }
2376 
2496   setupMessageHandler() {
2497     const { messageHandler, loadingTask } = this;
2498 
2499     messageHandler.on("GetReader", (data, sink) => {
2500       assert(
2501         this._networkStream,
2502         "GetReader - no `IPDFStream` instance available."
2503       );
2504       this._fullReader = this._networkStream.getFullReader();
2505       this._fullReader.onProgress = evt => {
2506         this._lastProgress = {
2507           loaded: evt.loaded,
2508           total: evt.total,
2509         };
2510       };
2511       sink.onPull = () => {
2512         this._fullReader
2513           .read()
2514           .then(function ({ value, done }) {
2515             if (done) {
2516               sink.close();
2517               return;
2518             }
2519             assert(
2520               value instanceof ArrayBuffer,
2521               "GetReader - expected an ArrayBuffer."
2522             );
2523             // Enqueue data chunk into sink, and transfer it
2524             // to other side as `Transferable` object.
2525             sink.enqueue(new Uint8Array(value), 1, [value]);
2526           })
2527           .catch(reason => {
2528             sink.error(reason);
2529           });
2530       };
2531 
2532       sink.onCancel = reason => {
2533         this._fullReader.cancel(reason);
2534 
2535         sink.ready.catch(readyReason => {
2536           if (this.destroyed) {
2537             return; // Ignore any pending requests if the worker was terminated.
2538           }
2539           throw readyReason;
2540         });
2541       };
2542     });
2543 
2544     messageHandler.on("ReaderHeadersReady", data => {
2545       const headersCapability = new PromiseCapability();
2546       const fullReader = this._fullReader;
2547       fullReader.headersReady.then(() => {
2548         // If stream or range are disabled, it's our only way to report
2549         // loading progress.
2550         if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
2551           if (this._lastProgress) {
2552             loadingTask.onProgress?.(this._lastProgress);
2553           }
2554           fullReader.onProgress = evt => {
2555             loadingTask.onProgress?.({
2556               loaded: evt.loaded,
2557               total: evt.total,
2558             });
2559           };
2560         }
2561 
2562         headersCapability.resolve({
2563           isStreamingSupported: fullReader.isStreamingSupported,
2564           isRangeSupported: fullReader.isRangeSupported,
2565           contentLength: fullReader.contentLength,
2566         });
2567       }, headersCapability.reject);
2568 
2569       return headersCapability.promise;
2570     });
2571 
2572     messageHandler.on("GetRangeReader", (data, sink) => {
2573       assert(
2574         this._networkStream,
2575         "GetRangeReader - no `IPDFStream` instance available."
2576       );
2577       const rangeReader = this._networkStream.getRangeReader(
2578         data.begin,
2579         data.end
2580       );
2581 
2582       // When streaming is enabled, it's possible that the data requested here
2583       // has already been fetched via the `_fullRequestReader` implementation.
2584       // However, given that the PDF data is loaded asynchronously on the
2585       // main-thread and then sent via `postMessage` to the worker-thread,
2586       // it may not have been available during parsing (hence the attempt to
2587       // use range requests here).
2588       //
2589       // To avoid wasting time and resources here, we'll thus *not* dispatch
2590       // range requests if the data was already loaded but has not been sent to
2591       // the worker-thread yet (which will happen via the `_fullRequestReader`).
2592       if (!rangeReader) {
2593         sink.close();
2594         return;
2595       }
2596 
2597       sink.onPull = () => {
2598         rangeReader
2599           .read()
2600           .then(function ({ value, done }) {
2601             if (done) {
2602               sink.close();
2603               return;
2604             }
2605             assert(
2606               value instanceof ArrayBuffer,
2607               "GetRangeReader - expected an ArrayBuffer."
2608             );
2609             sink.enqueue(new Uint8Array(value), 1, [value]);
2610           })
2611           .catch(reason => {
2612             sink.error(reason);
2613           });
2614       };
2615 
2616       sink.onCancel = reason => {
2617         rangeReader.cancel(reason);
2618 
2619         sink.ready.catch(readyReason => {
2620           if (this.destroyed) {
2621             return; // Ignore any pending requests if the worker was terminated.
2622           }
2623           throw readyReason;
2624         });
2625       };
2626     });
2627 
2628     messageHandler.on("GetDoc", ({ pdfInfo }) => {
2629       this._numPages = pdfInfo.numPages;
2630       this._htmlForXfa = pdfInfo.htmlForXfa;
2631       delete pdfInfo.htmlForXfa;
2632       loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
2633     });
2634 
2635     messageHandler.on("DocException", function (ex) {
2636       let reason;
2637       switch (ex.name) {
2638         case "PasswordException":
2639           reason = new PasswordException(ex.message, ex.code);
2640           break;
2641         case "InvalidPDFException":
2642           reason = new InvalidPDFException(ex.message);
2643           break;
2644         case "MissingPDFException":
2645           reason = new MissingPDFException(ex.message);
2646           break;
2647         case "UnexpectedResponseException":
2648           reason = new UnexpectedResponseException(ex.message, ex.status);
2649           break;
2650         case "UnknownErrorException":
2651           reason = new UnknownErrorException(ex.message, ex.details);
2652           break;
2653         default:
2654           unreachable("DocException - expected a valid Error.");
2655       }
2656       loadingTask._capability.reject(reason);
2657     });
2658 
2659     messageHandler.on("PasswordRequest", exception => {
2660       this.#passwordCapability = new PromiseCapability();
2661 
2662       if (loadingTask.onPassword) {
2663         const updatePassword = password => {
2664           if (password instanceof Error) {
2665             this.#passwordCapability.reject(password);
2666           } else {
2667             this.#passwordCapability.resolve({ password });
2668           }
2669         };
2670         try {
2671           loadingTask.onPassword(updatePassword, exception.code);
2672         } catch (ex) {
2673           this.#passwordCapability.reject(ex);
2674         }
2675       } else {
2676         this.#passwordCapability.reject(
2677           new PasswordException(exception.message, exception.code)
2678         );
2679       }
2680       return this.#passwordCapability.promise;
2681     });
2682 
2683     messageHandler.on("DataLoaded", data => {
2684       // For consistency: Ensure that progress is always reported when the
2685       // entire PDF file has been loaded, regardless of how it was fetched.
2686       loadingTask.onProgress?.({
2687         loaded: data.length,
2688         total: data.length,
2689       });
2690 
2691       this.downloadInfoCapability.resolve(data);
2692     });
2693 
2694     messageHandler.on("StartRenderPage", data => {
2695       if (this.destroyed) {
2696         return; // Ignore any pending requests if the worker was terminated.
2697       }
2698 
2699       const page = this.#pageCache.get(data.pageIndex);
2700       page._startRenderPage(data.transparency, data.cacheKey);
2701     });
2702 
2703     messageHandler.on("commonobj", ([id, type, exportedData]) => {
2704       if (this.destroyed) {
2705         return; // Ignore any pending requests if the worker was terminated.
2706       }
2707 
2708       if (this.commonObjs.has(id)) {
2709         return;
2710       }
2711 
2712       switch (type) {
2713         case "Font":
2714           const params = this._params;
2715 
2716           if ("error" in exportedData) {
2717             const exportedError = exportedData.error;
2718             warn(`Error during font loading: ${exportedError}`);
2719             this.commonObjs.resolve(id, exportedError);
2720             break;
2721           }
2722 
2723           const inspectFont =
2724             params.pdfBug && globalThis.FontInspector?.enabled
2725               ? (font, url) => globalThis.FontInspector.fontAdded(font, url)
2726               : null;
2727           const font = new FontFaceObject(exportedData, {
2728             isEvalSupported: params.isEvalSupported,
2729             disableFontFace: params.disableFontFace,
2730             ignoreErrors: params.ignoreErrors,
2731             inspectFont,
2732           });
2733 
2734           this.fontLoader
2735             .bind(font)
2736             .catch(reason => {
2737               return messageHandler.sendWithPromise("FontFallback", { id });
2738             })
2739             .finally(() => {
2740               if (!params.fontExtraProperties && font.data) {
2741                 // Immediately release the `font.data` property once the font
2742                 // has been attached to the DOM, since it's no longer needed,
2743                 // rather than waiting for a `PDFDocumentProxy.cleanup` call.
2744                 // Since `font.data` could be very large, e.g. in some cases
2745                 // multiple megabytes, this will help reduce memory usage.
2746                 font.data = null;
2747               }
2748               this.commonObjs.resolve(id, font);
2749             });
2750           break;
2751         case "FontPath":
2752         case "Image":
2753         case "Pattern":
2754           this.commonObjs.resolve(id, exportedData);
2755           break;
2756         default:
2757           throw new Error(`Got unknown common object type ${type}`);
2758       }
2759     });
2760 
2761     messageHandler.on("obj", ([id, pageIndex, type, imageData]) => {
2762       if (this.destroyed) {
2763         // Ignore any pending requests if the worker was terminated.
2764         return;
2765       }
2766 
2767       const pageProxy = this.#pageCache.get(pageIndex);
2768       if (pageProxy.objs.has(id)) {
2769         return;
2770       }
2771 
2772       switch (type) {
2773         case "Image":
2774           pageProxy.objs.resolve(id, imageData);
2775 
2776           // Heuristic that will allow us not to store large data.
2777           if (imageData) {
2778             let length;
2779             if (imageData.bitmap) {
2780               const { width, height } = imageData;
2781               length = width * height * 4;
2782             } else {
2783               length = imageData.data?.length || 0;
2784             }
2785 
2786             if (length > MAX_IMAGE_SIZE_TO_CACHE) {
2787               pageProxy._maybeCleanupAfterRender = true;
2788             }
2789           }
2790           break;
2791         case "Pattern":
2792           pageProxy.objs.resolve(id, imageData);
2793           break;
2794         default:
2795           throw new Error(`Got unknown object type ${type}`);
2796       }
2797     });
2798 
2799     messageHandler.on("DocProgress", data => {
2800       if (this.destroyed) {
2801         return; // Ignore any pending requests if the worker was terminated.
2802       }
2803       loadingTask.onProgress?.({
2804         loaded: data.loaded,
2805         total: data.total,
2806       });
2807     });
2808 
2809     messageHandler.on("FetchBuiltInCMap", data => {
2810       if (this.destroyed) {
2811         return Promise.reject(new Error("Worker was destroyed."));
2812       }
2813       if (!this.cMapReaderFactory) {
2814         return Promise.reject(
2815           new Error(
2816             "CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."
2817           )
2818         );
2819       }
2820       return this.cMapReaderFactory.fetch(data);
2821     });
2822 
2823     messageHandler.on("FetchStandardFontData", data => {
2824       if (this.destroyed) {
2825         return Promise.reject(new Error("Worker was destroyed."));
2826       }
2827       if (!this.standardFontDataFactory) {
2828         return Promise.reject(
2829           new Error(
2830             "StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."
2831           )
2832         );
2833       }
2834       return this.standardFontDataFactory.fetch(data);
2835     });
2836   }
2837 
3061 }
3062 
3372 const version =
3373   typeof PDFJSDev !== "undefined" ? PDFJSDev.eval("BUNDLE_VERSION") : null;
3375 const build =
3376   typeof PDFJSDev !== "undefined" ? PDFJSDev.eval("BUNDLE_BUILD") : null;
3377 
</code>

PR summary:
<pr_summary>
Don't store page-level data, in the API, after cleanup has run (bug 1854145)
For large/complex images it's possible that the image-data arrives in the API *after* the page has been scrolled out-of-view and thus been cleaned-up. In this case we obviously shouldn't cache such page-level data, since it'll first of all be unused and secondly can increase memory usage *a lot*.
Also, ensure that we *immediately* release any `ImageBitmap` data in this case to help reclaim memory faster.
</pr_summary>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

