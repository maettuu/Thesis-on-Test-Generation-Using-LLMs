it("should not cache large images after cleanup", async () => {
  const { PDFDocument } = await import("../../src/display/api.js");
  const { XRefMock } = await import("../../src/display/test_utils.js");
  const { createIdFactory } = await import("../../src/display/test_utils.js");

  const fakeWorker = {
    sendWithPromise: jest.fn(),
    on: jest.fn(),
    off: jest.fn(),
    postMessage: jest.fn(),
  };

  const xref = new XRefMock();
  const idFactory = createIdFactory(0);
  const largeImageId = idFactory.next().value;
  const pageId = idFactory.next().value;

  // Mock a large image
  xref.mockData(largeImageId, {
    type: "Image",
    data: new Uint8Array(1024 * 1024 * 4), // 4MB array buffer
  });

  // Create a PDF document proxy
  const pdfDocument = new PDFDocument({
    numPages: 1,
    pageIndices: [pageId],
    commonObjs: new Map(),
    worker: fakeWorker,
    xref,
  });

  // Get the page proxy
  const pageProxy = pdfDocument.getPage(pageId);

  // Simulate loading the page with the large image
  await pageProxy.startRender();

  // Simulate scrolling away and cleanup
  pageProxy.close();

  // Check if the large image is still cached
  expect(pageProxy.objs.has(largeImageId)).toBe(false);
});