Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: Character spacing wrong for embedded WinAnsiEncoding font
### Attach (recommended) or Link to PDF file

The attached file doesn't render correctly (overlapping characters). It's using a font with WinAnsiEncoding encoding

[PDFcustomFontTest.pdf](https://github.com/user-attachments/files/19700949/PDFcustomFontTest.pdf)

<img width="623" alt="Image" src="https://github.com/user-attachments/assets/1f09720d-223a-4904-bab6-f11b9614a2d6" />

### Web browser and its version

Firefox 137.0 64 bit Windows

### Operating system and its version

Windows 11

### PDF.js version

v5.1.91

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

* load attached .PDF file into https://mozilla.github.io/pdf.js/web/viewer.html
* or Firefox 137.0 64 bit Windows


### What is the expected behavior?

* text spacing is correct
* renders the same as Acrobat & Chrome

<img width="623" alt="Image" src="https://github.com/user-attachments/assets/eca06089-45b3-4de1-97f9-bbc756389deb" />

### What went wrong?

* text is overlapping
* 

<img width="623" alt="Image" src="https://github.com/user-attachments/assets/b12b3253-d84e-471f-8229-51a937c9bda3" />

### Link to a viewer

_No response_

### Additional context

_No response_
</issue>

Patch:
<patch>
diff --git a/src/core/fonts.js b/src/core/fonts.js
--- a/src/core/fonts.js
+++ b/src/core/fonts.js
@@ -1108,9 +1108,10 @@ class Font {
           // Repair the TrueType file. It is can be damaged in the point of
           // view of the sanitizer
           data = this.checkAndRepair(name, file, properties);
-          if (this.isOpenType) {
-            adjustWidths(properties);
 
+          adjustWidths(properties);
+
+          if (this.isOpenType) {
             type = "OpenType";
           }
           break;
@@ -2645,8 +2646,6 @@ class Font {
         cffFile = new Stream(tables["CFF "].data);
         cff = new CFFFont(cffFile, properties);
 
-        adjustWidths(properties);
-
         return this.convert(name, cff, properties);
       }


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.10
- @babel/preset-env: ^7.26.9
- @babel/runtime: ^7.27.0
- @fluent/bundle: ^0.19.0
- @fluent/dom: ^0.10.1
- @metalsmith/layouts: ^3.0.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.68
- @types/node: ^22.13.14
- autoprefixer: ^10.4.21
- babel-loader: ^10.0.0
- caniuse-lite: ^1.0.30001707
- core-js: ^3.41.0
- eslint: ^9.23.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.10.1
- eslint-plugin-prettier: ^5.2.5
- eslint-plugin-unicorn: ^58.0.0
- globals: ^16.0.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.6.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.5.3
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.5.3
- puppeteer: ^24.4.0
- stylelint: ^16.17.0
- stylelint-prettier: ^5.0.3
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.14
- tsc-alias: ^1.8.13
- ttest: ^4.0.0
- typescript: ^5.8.2
- vinyl: ^3.0.0
- webpack: ^5.98.0
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20.16.0

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/calculate_md5.js`: calculateMD5
- `../../src/core/calculate_sha256.js`: calculateSHA256
- `../../src/core/calculate_sha_other.js`: calculateSHA384, calculateSHA512
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/colorspace_utils.js`: ColorSpaceUtils
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalColorSpaceCache, GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, isValidExplicitDest, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/cmap_reader_factory.js`: DOMCMapReaderFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, SupportedImageMimeTypes, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/drawers/signaturedraw.js`: SignatureExtractor
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodeCMapReaderFactory, NodeStandardFontDataFactory, fetchData
- `../../src/display/standard_fontdata_factory.js`: DOMStandardFontDataFactory
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, DrawOPS, FeatureTest, FormatError, ImageKind, InvalidPDFException, MathClamp, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, ResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/autolinker.js`: Autolinker
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultCMapReaderFactory, DefaultFileReaderFactory, DefaultStandardFontDataFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/core/fonts.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   assert,
18   bytesToString,
19   FONT_IDENTITY_MATRIX,
20   FormatError,
21   info,
22   shadow,
23   string32,
24   warn,
25 } from "../shared/util.js";
26 import { CFFCompiler, CFFParser } from "./cff_parser.js";
27 import {
28   FontFlags,
29   getVerticalPresentationForm,
30   MacStandardGlyphOrdering,
31   normalizeFontName,
32   recoverGlyphName,
33   SEAC_ANALYSIS_ENABLED,
34 } from "./fonts_utils.js";
35 import {
36   getCharUnicodeCategory,
37   getUnicodeForGlyph,
38   getUnicodeRangeFor,
39   mapSpecialUnicodeValues,
40 } from "./unicode.js";
41 import { getDingbatsGlyphsUnicode, getGlyphsUnicode } from "./glyphlist.js";
42 import {
43   getEncoding,
44   MacRomanEncoding,
45   StandardEncoding,
46   SymbolSetEncoding,
47   WinAnsiEncoding,
48   ZapfDingbatsEncoding,
49 } from "./encodings.js";
50 import {
51   getGlyphMapForStandardFonts,
52   getNonStdFontMap,
53   getSerifFonts,
54   getStdFontMap,
55   getSupplementalGlyphMapForArialBlack,
56   getSupplementalGlyphMapForCalibri,
57 } from "./standard_fonts.js";
58 import { IdentityToUnicodeMap, ToUnicodeMap } from "./to_unicode_map.js";
59 import { CFFFont } from "./cff_font.js";
60 import { FontRendererFactory } from "./font_renderer.js";
61 import { getFontBasicMetrics } from "./metrics.js";
62 import { GlyfTable } from "./glyf.js";
63 import { IdentityCMap } from "./cmap.js";
64 import { OpenTypeFileBuilder } from "./opentype_file_builder.js";
65 import { readUint32 } from "./core_utils.js";
66 import { Stream } from "./stream.js";
67 import { Type1Font } from "./type1_font.js";
68 
69 // Unicode Private Use Areas:
70 const PRIVATE_USE_AREAS = [
71   [0xe000, 0xf8ff], // BMP (0)
72   [0x100000, 0x10fffd], // PUP (16)
73 ];
74 
75 // PDF Glyph Space Units are one Thousandth of a TextSpace Unit
76 // except for Type 3 fonts
77 const PDF_GLYPH_SPACE_UNITS = 1000;
78 
79 const EXPORT_DATA_PROPERTIES = [
80   "ascent",
81   "bbox",
82   "black",
83   "bold",
84   "charProcOperatorList",
85   "cssFontInfo",
86   "data",
87   "defaultVMetrics",
88   "defaultWidth",
89   "descent",
90   "disableFontFace",
91   "fallbackName",
92   "fontExtraProperties",
93   "fontMatrix",
94   "isInvalidPDFjsFont",
95   "isType3Font",
96   "italic",
97   "loadedName",
98   "mimetype",
99   "missingFile",
100   "name",
101   "remeasure",
102   "systemFontInfo",
103   "vertical",
104 ];
105 
106 const EXPORT_DATA_EXTRA_PROPERTIES = [
107   "cMap",
108   "composite",
109   "defaultEncoding",
110   "differences",
111   "isMonospace",
112   "isSerifFont",
113   "isSymbolicFont",
114   "seacMap",
115   "subtype",
116   "toFontChar",
117   "toUnicode",
118   "type",
119   "vmetrics",
120   "widths",
121 ];
122 
439 // Please refer to:
440 //  - https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html
444 
445 // Please refer to:
446 //  - https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html
447 //  - https://learn.microsoft.com/en-us/typography/opentype/spec/name#windows-language-ids
451 
968 /**
969  * 'Font' is the class the outside world should use, it encapsulate all the font
970  * decoding logics whatever type it is (assuming the font type is supported).
971  */
972 class Font {
973   constructor(name, file, properties, evaluatorOptions) {
974     this.name = name;
975     this.psName = null;
976     this.mimetype = null;
977     this.disableFontFace = evaluatorOptions.disableFontFace;
978     this.fontExtraProperties = evaluatorOptions.fontExtraProperties;
979 
980     this.loadedName = properties.loadedName;
981     this.isType3Font = properties.isType3Font;
982     this.missingFile = false;
983     this.cssFontInfo = properties.cssFontInfo;
984 
985     this._charsCache = Object.create(null);
986     this._glyphCache = Object.create(null);
987 
988     let isSerifFont = !!(properties.flags & FontFlags.Serif);
989     // Fallback to checking the font name, in order to improve text-selection,
990     // since the /Flags-entry is often wrong (fixes issue13845.pdf).
991     if (!isSerifFont && !properties.isSimulatedFlags) {
992       const baseName = name.replaceAll(/[,_]/g, "-").split("-", 1)[0],
993         serifFonts = getSerifFonts();
994       for (const namePart of baseName.split("+")) {
995         if (serifFonts[namePart]) {
996           isSerifFont = true;
997           break;
998         }
999       }
1000     }
1001     this.isSerifFont = isSerifFont;
1002 
1003     this.isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
1004     this.isMonospace = !!(properties.flags & FontFlags.FixedPitch);
1005 
1006     let { type, subtype } = properties;
1007     this.type = type;
1008     this.subtype = subtype;
1009     this.systemFontInfo = properties.systemFontInfo;
1010 
1011     const matches = name.match(/^InvalidPDFjsFont_(.*)_\d+$/);
1012     this.isInvalidPDFjsFont = !!matches;
1013     if (this.isInvalidPDFjsFont) {
1014       this.fallbackName = matches[1];
1015     } else if (this.isMonospace) {
1016       this.fallbackName = "monospace";
1017     } else if (this.isSerifFont) {
1018       this.fallbackName = "serif";
1019     } else {
1020       this.fallbackName = "sans-serif";
1021     }
1022 
1023     if (this.systemFontInfo?.guessFallback) {
1024       // Once the fallback name is guessed, we don't want to guess it again.
1025       this.systemFontInfo.guessFallback = false;
1026       this.systemFontInfo.css += `,${this.fallbackName}`;
1027     }
1028 
1029     this.differences = properties.differences;
1030     this.widths = properties.widths;
1031     this.defaultWidth = properties.defaultWidth;
1032     this.composite = properties.composite;
1033     this.cMap = properties.cMap;
1034     this.capHeight = properties.capHeight / PDF_GLYPH_SPACE_UNITS;
1035     this.ascent = properties.ascent / PDF_GLYPH_SPACE_UNITS;
1036     this.descent = properties.descent / PDF_GLYPH_SPACE_UNITS;
1037     this.lineHeight = this.ascent - this.descent;
1038     this.fontMatrix = properties.fontMatrix;
1039     this.bbox = properties.bbox;
1040     this.defaultEncoding = properties.defaultEncoding;
1041 
1042     this.toUnicode = properties.toUnicode;
1043     this.toFontChar = [];
1044 
1045     if (properties.type === "Type3") {
1046       for (let charCode = 0; charCode < 256; charCode++) {
1047         this.toFontChar[charCode] =
1048           this.differences[charCode] || properties.defaultEncoding[charCode];
1049       }
1050       return;
1051     }
1052 
1053     this.cidEncoding = properties.cidEncoding || "";
1054     this.vertical = !!properties.vertical;
1055     if (this.vertical) {
1056       this.vmetrics = properties.vmetrics;
1057       this.defaultVMetrics = properties.defaultVMetrics;
1058     }
1059 
1060     if (!file || file.isEmpty) {
1061       if (file) {
1062         // Some bad PDF generators will include empty font files,
1063         // attempting to recover by assuming that no file exists.
1064         warn('Font file is empty in "' + name + '" (' + this.loadedName + ")");
1065       }
1066       this.fallbackToSystemFont(properties);
1067       return;
1068     }
1069 
1070     // Parse the font file to determine the correct type/subtype, rather than
1071     // relying on the (often incorrect) data in the font dictionary; (see e.g.
1072     //  issue6782.pdf, issue7598.pdf, and issue9949.pdf).
1073     [type, subtype] = getFontFileType(file, properties);
1074 
1075     if (type !== this.type || subtype !== this.subtype) {
1076       info(
1077         "Inconsistent font file Type/SubType, expected: " +
1078           `${this.type}/${this.subtype} but found: ${type}/${subtype}.`
1079       );
1080     }
1081 
1082     let data;
1083     try {
1084       switch (type) {
1085         case "MMType1":
1086           info("MMType1 font (" + name + "), falling back to Type1.");
1087         /* falls through */
1088         case "Type1":
1089         case "CIDFontType0":
1090           this.mimetype = "font/opentype";
1091 
1092           const cff =
1093             subtype === "Type1C" || subtype === "CIDFontType0C"
1094               ? new CFFFont(file, properties)
1095               : new Type1Font(name, file, properties);
1096 
1097           adjustWidths(properties);
1098 
1099           // Wrap the CFF data inside an OTF font file
1100           data = this.convert(name, cff, properties);
1101           break;
1102 
1103         case "OpenType":
1104         case "TrueType":
1105         case "CIDFontType2":
1106           this.mimetype = "font/opentype";
1107 
1108           // Repair the TrueType file. It is can be damaged in the point of
1109           // view of the sanitizer
1110           data = this.checkAndRepair(name, file, properties);
1111           if (this.isOpenType) {
1112             adjustWidths(properties);
1113 
1114             type = "OpenType";
1115           }
1116           break;
1117 
1118         default:
1119           throw new FormatError(`Font ${type} is not supported`);
1120       }
1121     } catch (e) {
1122       warn(e);
1123       this.fallbackToSystemFont(properties);
1124       return;
1125     }
1126 
1127     amendFallbackToUnicode(properties);
1128     this.data = data;
1129 
1130     // Transfer some properties again that could change during font conversion
1131     this.type = type;
1132     this.subtype = subtype;
1133     this.fontMatrix = properties.fontMatrix;
1134     this.widths = properties.widths;
1135     this.defaultWidth = properties.defaultWidth;
1136     this.toUnicode = properties.toUnicode;
1137     this.seacMap = properties.seacMap;
1138   }
1139 
1312   checkAndRepair(name, font, properties) {
1313     const VALID_TABLES = [
1314       "OS/2",
1315       "cmap",
1316       "head",
1317       "hhea",
1318       "hmtx",
1319       "maxp",
1320       "name",
1321       "post",
1322       "loca",
1323       "glyf",
1324       "fpgm",
1325       "prep",
1326       "cvt ",
1327       "CFF ",
1328     ];
1329 
1330     function readTables(file, numTables) {
1331       const tables = Object.create(null);
1332       tables["OS/2"] = null;
1333       tables.cmap = null;
1334       tables.head = null;
1335       tables.hhea = null;
1336       tables.hmtx = null;
1337       tables.maxp = null;
1338       tables.name = null;
1339       tables.post = null;
1340 
1341       for (let i = 0; i < numTables; i++) {
1342         const table = readTableEntry(file);
1343         if (!VALID_TABLES.includes(table.tag)) {
1344           continue; // skipping table if it's not a required or optional table
1345         }
1346         if (table.length === 0) {
1347           continue; // skipping empty tables
1348         }
1349         tables[table.tag] = table;
1350       }
1351       return tables;
1352     }
1353 
1354     function readTableEntry(file) {
1355       const tag = file.getString(4);
1356 
1357       const checksum = file.getInt32() >>> 0;
1358       const offset = file.getInt32() >>> 0;
1359       const length = file.getInt32() >>> 0;
1360 
1361       // Read the table associated data
1362       const previousPosition = file.pos;
1363       file.pos = file.start || 0;
1364       file.skip(offset);
1365       const data = file.getBytes(length);
1366       file.pos = previousPosition;
1367 
1368       if (tag === "head") {
1369         // clearing checksum adjustment
1370         data[8] = data[9] = data[10] = data[11] = 0;
1371         data[17] |= 0x20; // Set font optimized for cleartype flag.
1372       }
1373 
1374       return {
1375         tag,
1376         checksum,
1377         length,
1378         offset,
1379         data,
1380       };
1381     }
1382 
1383     function readOpenTypeHeader(ttf) {
1384       return {
1385         version: ttf.getString(4),
1386         numTables: ttf.getUint16(),
1387         searchRange: ttf.getUint16(),
1388         entrySelector: ttf.getUint16(),
1389         rangeShift: ttf.getUint16(),
1390       };
1391     }
1392 
1393     function readTrueTypeCollectionHeader(ttc) {
1394       const ttcTag = ttc.getString(4);
1395       assert(ttcTag === "ttcf", "Must be a TrueType Collection font.");
1396 
1397       const majorVersion = ttc.getUint16();
1398       const minorVersion = ttc.getUint16();
1399       const numFonts = ttc.getInt32() >>> 0;
1400       const offsetTable = [];
1401       for (let i = 0; i < numFonts; i++) {
1402         offsetTable.push(ttc.getInt32() >>> 0);
1403       }
1404 
1405       const header = {
1406         ttcTag,
1407         majorVersion,
1408         minorVersion,
1409         numFonts,
1410         offsetTable,
1411       };
1412       switch (majorVersion) {
1413         case 1:
1414           return header;
1415         case 2:
1416           header.dsigTag = ttc.getInt32() >>> 0;
1417           header.dsigLength = ttc.getInt32() >>> 0;
1418           header.dsigOffset = ttc.getInt32() >>> 0;
1419           return header;
1420       }
1421       throw new FormatError(
1422         `Invalid TrueType Collection majorVersion: ${majorVersion}.`
1423       );
1424     }
1425 
1426     function readTrueTypeCollectionData(ttc, fontName) {
1427       const { numFonts, offsetTable } = readTrueTypeCollectionHeader(ttc);
1428       const fontNameParts = fontName.split("+");
1429       let fallbackData;
1430 
1431       for (let i = 0; i < numFonts; i++) {
1432         ttc.pos = (ttc.start || 0) + offsetTable[i];
1433         const potentialHeader = readOpenTypeHeader(ttc);
1434         const potentialTables = readTables(ttc, potentialHeader.numTables);
1435 
1436         if (!potentialTables.name) {
1437           throw new FormatError(
1438             'TrueType Collection font must contain a "name" table.'
1439           );
1440         }
1441         const [nameTable] = readNameTable(potentialTables.name);
1442 
1443         for (let j = 0, jj = nameTable.length; j < jj; j++) {
1444           for (let k = 0, kk = nameTable[j].length; k < kk; k++) {
1445             const nameEntry = nameTable[j][k]?.replaceAll(/\s/g, "");
1446             if (!nameEntry) {
1447               continue;
1448             }
1449             if (nameEntry === fontName) {
1450               return {
1451                 header: potentialHeader,
1452                 tables: potentialTables,
1453               };
1454             }
1455             if (fontNameParts.length < 2) {
1456               continue;
1457             }
1458             for (const part of fontNameParts) {
1459               if (nameEntry === part) {
1460                 fallbackData = {
1461                   name: part,
1462                   header: potentialHeader,
1463                   tables: potentialTables,
1464                 };
1465               }
1466             }
1467           }
1468         }
1469       }
1470       if (fallbackData) {
1471         warn(
1472           `TrueType Collection does not contain "${fontName}" font, ` +
1473             `falling back to "${fallbackData.name}" font instead.`
1474         );
1475         return {
1476           header: fallbackData.header,
1477           tables: fallbackData.tables,
1478         };
1479       }
1480       throw new FormatError(
1481         `TrueType Collection does not contain "${fontName}" font.`
1482       );
1483     }
1484 
1485     /**
1486      * Read the appropriate subtable from the cmap according to 9.6.6.4 from
1487      * PDF spec
1488      */
1489     function readCmapTable(cmap, file, isSymbolicFont, hasEncoding) {
1490       if (!cmap) {
1491         warn("No cmap table available.");
1492         return {
1493           platformId: -1,
1494           encodingId: -1,
1495           mappings: [],
1496           hasShortCmap: false,
1497         };
1498       }
1499       let segment;
1500       let start = (file.start || 0) + cmap.offset;
1501       file.pos = start;
1502 
1503       file.skip(2); // version
1504       const numTables = file.getUint16();
1505 
1506       let potentialTable;
1507       let canBreak = false;
1508       // There's an order of preference in terms of which cmap subtable to
1509       // use:
1510       // - non-symbolic fonts the preference is a 3,1 table then a 1,0 table
1511       // - symbolic fonts the preference is a 3,0 table then a 1,0 table
1512       // The following takes advantage of the fact that the tables are sorted
1513       // to work.
1514       for (let i = 0; i < numTables; i++) {
1515         const platformId = file.getUint16();
1516         const encodingId = file.getUint16();
1517         const offset = file.getInt32() >>> 0;
1518         let useTable = false;
1519 
1520         // Sometimes there are multiple of the same type of table. Default
1521         // to choosing the first table and skip the rest.
1522         if (
1523           potentialTable?.platformId === platformId &&
1524           potentialTable?.encodingId === encodingId
1525         ) {
1526           continue;
1527         }
1528 
1529         if (
1530           platformId === 0 &&
1531           (encodingId === /* Unicode Default */ 0 ||
1532             encodingId === /* Unicode 1.1 */ 1 ||
1533             encodingId === /* Unicode BMP */ 3)
1534         ) {
1535           useTable = true;
1536           // Continue the loop since there still may be a higher priority
1537           // table.
1538         } else if (platformId === 1 && encodingId === 0) {
1539           useTable = true;
1540           // Continue the loop since there still may be a higher priority
1541           // table.
1542         } else if (
1543           platformId === 3 &&
1544           encodingId === 1 &&
1545           (hasEncoding || !potentialTable)
1546         ) {
1547           useTable = true;
1548           if (!isSymbolicFont) {
1549             canBreak = true;
1550           }
1551         } else if (isSymbolicFont && platformId === 3 && encodingId === 0) {
1552           useTable = true;
1553 
1554           let correctlySorted = true;
1555           if (i < numTables - 1) {
1556             const nextBytes = file.peekBytes(2),
1557               nextPlatformId = int16(nextBytes[0], nextBytes[1]);
1558             if (nextPlatformId < platformId) {
1559               correctlySorted = false;
1560             }
1561           }
1562           if (correctlySorted) {
1563             canBreak = true;
1564           }
1565         }
1566 
1567         if (useTable) {
1568           potentialTable = {
1569             platformId,
1570             encodingId,
1571             offset,
1572           };
1573         }
1574         if (canBreak) {
1575           break;
1576         }
1577       }
1578 
1579       if (potentialTable) {
1580         file.pos = start + potentialTable.offset;
1581       }
1582       if (!potentialTable || file.peekByte() === -1) {
1583         warn("Could not find a preferred cmap table.");
1584         return {
1585           platformId: -1,
1586           encodingId: -1,
1587           mappings: [],
1588           hasShortCmap: false,
1589         };
1590       }
1591 
1592       const format = file.getUint16();
1593       let hasShortCmap = false;
1594       const mappings = [];
1595       let j, glyphId;
1596 
1597       // TODO(mack): refactor this cmap subtable reading logic out
1598       if (format === 0) {
1599         file.skip(2 + 2); // length + language
1600 
1601         for (j = 0; j < 256; j++) {
1602           const index = file.getByte();
1603           if (!index) {
1604             continue;
1605           }
1606           mappings.push({
1607             charCode: j,
1608             glyphId: index,
1609           });
1610         }
1611         hasShortCmap = true;
1612       } else if (format === 2) {
1613         file.skip(2 + 2); // length + language
1614 
1615         const subHeaderKeys = [];
1616         let maxSubHeaderKey = 0;
1617         // Read subHeaderKeys. If subHeaderKeys[i] === 0, then i is a
1618         // single-byte character. Otherwise, i is the first byte of a
1619         // multi-byte character, and the value is 8*index into
1620         // subHeaders.
1621         for (let i = 0; i < 256; i++) {
1622           const subHeaderKey = file.getUint16() >> 3;
1623           subHeaderKeys.push(subHeaderKey);
1624           maxSubHeaderKey = Math.max(subHeaderKey, maxSubHeaderKey);
1625         }
1626         // Read subHeaders. The number of entries is determined
1627         // dynamically based on the subHeaderKeys found above.
1628         const subHeaders = [];
1629         for (let i = 0; i <= maxSubHeaderKey; i++) {
1630           subHeaders.push({
1631             firstCode: file.getUint16(),
1632             entryCount: file.getUint16(),
1633             idDelta: signedInt16(file.getByte(), file.getByte()),
1634             idRangePos: file.pos + file.getUint16(),
1635           });
1636         }
1637         for (let i = 0; i < 256; i++) {
1638           if (subHeaderKeys[i] === 0) {
1639             // i is a single-byte code.
1640             file.pos = subHeaders[0].idRangePos + 2 * i;
1641             glyphId = file.getUint16();
1642             mappings.push({
1643               charCode: i,
1644               glyphId,
1645             });
1646           } else {
1647             // i is the first byte of a two-byte code.
1648             const s = subHeaders[subHeaderKeys[i]];
1649             for (j = 0; j < s.entryCount; j++) {
1650               const charCode = (i << 8) + j + s.firstCode;
1651               file.pos = s.idRangePos + 2 * j;
1652               glyphId = file.getUint16();
1653               if (glyphId !== 0) {
1654                 glyphId = (glyphId + s.idDelta) % 65536;
1655               }
1656               mappings.push({
1657                 charCode,
1658                 glyphId,
1659               });
1660             }
1661           }
1662         }
1663       } else if (format === 4) {
1664         file.skip(2 + 2); // length + language
1665 
1666         // re-creating the table in format 4 since the encoding
1667         // might be changed
1668         const segCount = file.getUint16() >> 1;
1669         file.skip(6); // skipping range fields
1670         const segments = [];
1671         let segIndex;
1672         for (segIndex = 0; segIndex < segCount; segIndex++) {
1673           segments.push({ end: file.getUint16() });
1674         }
1675         file.skip(2);
1676         for (segIndex = 0; segIndex < segCount; segIndex++) {
1677           segments[segIndex].start = file.getUint16();
1678         }
1679 
1680         for (segIndex = 0; segIndex < segCount; segIndex++) {
1681           segments[segIndex].delta = file.getUint16();
1682         }
1683 
1684         let offsetsCount = 0,
1685           offsetIndex;
1686         for (segIndex = 0; segIndex < segCount; segIndex++) {
1687           segment = segments[segIndex];
1688           const rangeOffset = file.getUint16();
1689           if (!rangeOffset) {
1690             segment.offsetIndex = -1;
1691             continue;
1692           }
1693 
1694           offsetIndex = (rangeOffset >> 1) - (segCount - segIndex);
1695           segment.offsetIndex = offsetIndex;
1696           offsetsCount = Math.max(
1697             offsetsCount,
1698             offsetIndex + segment.end - segment.start + 1
1699           );
1700         }
1701 
1702         const offsets = [];
1703         for (j = 0; j < offsetsCount; j++) {
1704           offsets.push(file.getUint16());
1705         }
1706 
1707         for (segIndex = 0; segIndex < segCount; segIndex++) {
1708           segment = segments[segIndex];
1709           start = segment.start;
1710           const end = segment.end;
1711           const delta = segment.delta;
1712           offsetIndex = segment.offsetIndex;
1713 
1714           for (j = start; j <= end; j++) {
1715             if (j === 0xffff) {
1716               continue;
1717             }
1718 
1719             glyphId = offsetIndex < 0 ? j : offsets[offsetIndex + j - start];
1720             glyphId = (glyphId + delta) & 0xffff;
1721             mappings.push({
1722               charCode: j,
1723               glyphId,
1724             });
1725           }
1726         }
1727       } else if (format === 6) {
1728         file.skip(2 + 2); // length + language
1729 
1730         // Format 6 is a 2-bytes dense mapping, which means the font data
1731         // lives glue together even if they are pretty far in the unicode
1732         // table. (This looks weird, so I can have missed something), this
1733         // works on Linux but seems to fails on Mac so let's rewrite the
1734         // cmap table to a 3-1-4 style
1735         const firstCode = file.getUint16();
1736         const entryCount = file.getUint16();
1737 
1738         for (j = 0; j < entryCount; j++) {
1739           glyphId = file.getUint16();
1740           const charCode = firstCode + j;
1741 
1742           mappings.push({
1743             charCode,
1744             glyphId,
1745           });
1746         }
1747       } else if (format === 12) {
1748         file.skip(2 + 4 + 4); // reserved + length + language
1749 
1750         const nGroups = file.getInt32() >>> 0;
1751         for (j = 0; j < nGroups; j++) {
1752           const startCharCode = file.getInt32() >>> 0;
1753           const endCharCode = file.getInt32() >>> 0;
1754           let glyphCode = file.getInt32() >>> 0;
1755 
1756           for (
1757             let charCode = startCharCode;
1758             charCode <= endCharCode;
1759             charCode++
1760           ) {
1761             mappings.push({
1762               charCode,
1763               glyphId: glyphCode++,
1764             });
1765           }
1766         }
1767       } else {
1768         warn("cmap table has unsupported format: " + format);
1769         return {
1770           platformId: -1,
1771           encodingId: -1,
1772           mappings: [],
1773           hasShortCmap: false,
1774         };
1775       }
1776 
1777       // removing duplicate entries
1778       mappings.sort((a, b) => a.charCode - b.charCode);
1779       const finalMappings = [],
1780         seenCharCodes = new Set();
1781       for (const map of mappings) {
1782         const { charCode } = map;
1783 
1784         if (seenCharCodes.has(charCode)) {
1785           continue;
1786         }
1787         seenCharCodes.add(charCode);
1788         finalMappings.push(map);
1789       }
1790 
1791       return {
1792         platformId: potentialTable.platformId,
1793         encodingId: potentialTable.encodingId,
1794         mappings: finalMappings,
1795         hasShortCmap,
1796       };
1797     }
1798 
1799     function sanitizeMetrics(
1800       file,
1801       header,
1802       metrics,
1803       headTable,
1804       numGlyphs,
1805       dupFirstEntry
1806     ) {
1807       if (!header) {
1808         if (metrics) {
1809           metrics.data = null;
1810         }
1811         return;
1812       }
1813 
1814       file.pos = (file.start || 0) + header.offset;
1815       file.pos += 4; // version
1816       file.pos += 2; // ascent
1817       file.pos += 2; // descent
1818       file.pos += 2; // linegap
1819       file.pos += 2; // adv_width_max
1820       file.pos += 2; // min_sb1
1821       file.pos += 2; // min_sb2
1822       file.pos += 2; // max_extent
1823       file.pos += 2; // caret_slope_rise
1824       file.pos += 2; // caret_slope_run
1825       const caretOffset = file.getUint16();
1826       file.pos += 8; // reserved
1827       file.pos += 2; // format
1828       let numOfMetrics = file.getUint16();
1829 
1830       if (caretOffset !== 0) {
1831         const macStyle = int16(headTable.data[44], headTable.data[45]);
1832         if (!(macStyle & 2)) {
1833           // Suppress OTS warnings about the `caretOffset` in the hhea-table.
1834           header.data[22] = 0;
1835           header.data[23] = 0;
1836         }
1837       }
1838 
1839       if (numOfMetrics > numGlyphs) {
1840         info(
1841           `The numOfMetrics (${numOfMetrics}) should not be ` +
1842             `greater than the numGlyphs (${numGlyphs}).`
1843         );
1844         // Reduce numOfMetrics if it is greater than numGlyphs
1845         numOfMetrics = numGlyphs;
1846         header.data[34] = (numOfMetrics & 0xff00) >> 8;
1847         header.data[35] = numOfMetrics & 0x00ff;
1848       }
1849 
1850       const numOfSidebearings = numGlyphs - numOfMetrics;
1851       const numMissing =
1852         numOfSidebearings - ((metrics.length - numOfMetrics * 4) >> 1);
1853 
1854       if (numMissing > 0) {
1855         // For each missing glyph, we set both the width and lsb to 0 (zero).
1856         // Since we need to add two properties for each glyph, this explains
1857         // the use of |numMissing * 2| when initializing the typed array.
1858         const entries = new Uint8Array(metrics.length + numMissing * 2);
1859         entries.set(metrics.data);
1860         if (dupFirstEntry) {
1861           // Set the sidebearing value of the duplicated glyph.
1862           entries[metrics.length] = metrics.data[2];
1863           entries[metrics.length + 1] = metrics.data[3];
1864         }
1865         metrics.data = entries;
1866       }
1867     }
1868 
1869     function sanitizeGlyph(
1870       source,
1871       sourceStart,
1872       sourceEnd,
1873       dest,
1874       destStart,
1875       hintsValid
1876     ) {
1877       const glyphProfile = {
1878         length: 0,
1879         sizeOfInstructions: 0,
1880       };
1881       if (
1882         sourceStart < 0 ||
1883         sourceStart >= source.length ||
1884         sourceEnd > source.length ||
1885         sourceEnd - sourceStart <= 12
1886       ) {
1887         // If the offsets are wrong or the glyph is too small, remove it.
1888         return glyphProfile;
1889       }
1890       const glyf = source.subarray(sourceStart, sourceEnd);
1891 
1892       // Sanitize the glyph bounding box.
1893       const xMin = signedInt16(glyf[2], glyf[3]);
1894       const yMin = signedInt16(glyf[4], glyf[5]);
1895       const xMax = signedInt16(glyf[6], glyf[7]);
1896       const yMax = signedInt16(glyf[8], glyf[9]);
1897 
1898       if (xMin > xMax) {
1899         writeSignedInt16(glyf, 2, xMax);
1900         writeSignedInt16(glyf, 6, xMin);
1901       }
1902       if (yMin > yMax) {
1903         writeSignedInt16(glyf, 4, yMax);
1904         writeSignedInt16(glyf, 8, yMin);
1905       }
1906 
1907       const contoursCount = signedInt16(glyf[0], glyf[1]);
1908       if (contoursCount < 0) {
1909         if (contoursCount < -1) {
1910           // OTS doesn't like contour count to be less than -1.
1911           // The glyph data offsets are very likely wrong and
1912           // having something lower than -1, very likely, implies
1913           // to have some garbage data.
1914           return glyphProfile;
1915         }
1916         // complex glyph, writing as is
1917         dest.set(glyf, destStart);
1918         glyphProfile.length = glyf.length;
1919         return glyphProfile;
1920       }
1921 
1922       let i,
1923         j = 10,
1924         flagsCount = 0;
1925       for (i = 0; i < contoursCount; i++) {
1926         const endPoint = (glyf[j] << 8) | glyf[j + 1];
1927         flagsCount = endPoint + 1;
1928         j += 2;
1929       }
1930       // skipping instructions
1931       const instructionsStart = j;
1932       const instructionsLength = (glyf[j] << 8) | glyf[j + 1];
1933       glyphProfile.sizeOfInstructions = instructionsLength;
1934       j += 2 + instructionsLength;
1935       const instructionsEnd = j;
1936       // validating flags
1937       let coordinatesLength = 0;
1938       for (i = 0; i < flagsCount; i++) {
1939         const flag = glyf[j++];
1940         if (flag & 0xc0) {
1941           // reserved flags must be zero, cleaning up
1942           glyf[j - 1] = flag & 0x3f;
1943         }
1944         let xLength = 2;
1945         if (flag & 2) {
1946           xLength = 1;
1947         } else if (flag & 16) {
1948           xLength = 0;
1949         }
1950         let yLength = 2;
1951         if (flag & 4) {
1952           yLength = 1;
1953         } else if (flag & 32) {
1954           yLength = 0;
1955         }
1956         const xyLength = xLength + yLength;
1957         coordinatesLength += xyLength;
1958         if (flag & 8) {
1959           const repeat = glyf[j++];
1960           if (repeat === 0) {
1961             // The repeat count should be non-zero when the repeat flag is set.
1962             glyf[j - 1] ^= 8;
1963           }
1964           i += repeat;
1965           coordinatesLength += repeat * xyLength;
1966         }
1967       }
1968       // glyph without coordinates will be rejected
1969       if (coordinatesLength === 0) {
1970         return glyphProfile;
1971       }
1972       let glyphDataLength = j + coordinatesLength;
1973       if (glyphDataLength > glyf.length) {
1974         // not enough data for coordinates
1975         return glyphProfile;
1976       }
1977       if (!hintsValid && instructionsLength > 0) {
1978         dest.set(glyf.subarray(0, instructionsStart), destStart);
1979         dest.set([0, 0], destStart + instructionsStart);
1980         dest.set(
1981           glyf.subarray(instructionsEnd, glyphDataLength),
1982           destStart + instructionsStart + 2
1983         );
1984         glyphDataLength -= instructionsLength;
1985         if (glyf.length - glyphDataLength > 3) {
1986           glyphDataLength = (glyphDataLength + 3) & ~3;
1987         }
1988         glyphProfile.length = glyphDataLength;
1989         return glyphProfile;
1990       }
1991       if (glyf.length - glyphDataLength > 3) {
1992         // truncating and aligning to 4 bytes the long glyph data
1993         glyphDataLength = (glyphDataLength + 3) & ~3;
1994         dest.set(glyf.subarray(0, glyphDataLength), destStart);
1995         glyphProfile.length = glyphDataLength;
1996         return glyphProfile;
1997       }
1998       // glyph data is fine
1999       dest.set(glyf, destStart);
2000       glyphProfile.length = glyf.length;
2001       return glyphProfile;
2002     }
2003 
2004     function sanitizeHead(head, numGlyphs, locaLength) {
2005       const data = head.data;
2006 
2007       // Validate version:
2008       // Should always be 0x00010000
2009       const version = int32(data[0], data[1], data[2], data[3]);
2010       if (version >> 16 !== 1) {
2011         info("Attempting to fix invalid version in head table: " + version);
2012         data[0] = 0;
2013         data[1] = 1;
2014         data[2] = 0;
2015         data[3] = 0;
2016       }
2017 
2018       const indexToLocFormat = int16(data[50], data[51]);
2019       if (indexToLocFormat < 0 || indexToLocFormat > 1) {
2020         info(
2021           "Attempting to fix invalid indexToLocFormat in head table: " +
2022             indexToLocFormat
2023         );
2024 
2025         // The value of indexToLocFormat should be 0 if the loca table
2026         // consists of short offsets, and should be 1 if the loca table
2027         // consists of long offsets.
2028         //
2029         // The number of entries in the loca table should be numGlyphs + 1.
2030         //
2031         // Using this information, we can work backwards to deduce if the
2032         // size of each offset in the loca table, and thus figure out the
2033         // appropriate value for indexToLocFormat.
2034 
2035         const numGlyphsPlusOne = numGlyphs + 1;
2036         if (locaLength === numGlyphsPlusOne << 1) {
2037           // 0x0000 indicates the loca table consists of short offsets
2038           data[50] = 0;
2039           data[51] = 0;
2040         } else if (locaLength === numGlyphsPlusOne << 2) {
2041           // 0x0001 indicates the loca table consists of long offsets
2042           data[50] = 0;
2043           data[51] = 1;
2044         } else {
2045           throw new FormatError(
2046             "Could not fix indexToLocFormat: " + indexToLocFormat
2047           );
2048         }
2049       }
2050     }
2051 
2052     function sanitizeGlyphLocations(
2053       loca,
2054       glyf,
2055       numGlyphs,
2056       isGlyphLocationsLong,
2057       hintsValid,
2058       dupFirstEntry,
2059       maxSizeOfInstructions
2060     ) {
2061       let itemSize, itemDecode, itemEncode;
2062       if (isGlyphLocationsLong) {
2063         itemSize = 4;
2064         itemDecode = function fontItemDecodeLong(data, offset) {
2065           return (
2066             (data[offset] << 24) |
2067             (data[offset + 1] << 16) |
2068             (data[offset + 2] << 8) |
2069             data[offset + 3]
2070           );
2071         };
2072         itemEncode = function fontItemEncodeLong(data, offset, value) {
2073           data[offset] = (value >>> 24) & 0xff;
2074           data[offset + 1] = (value >> 16) & 0xff;
2075           data[offset + 2] = (value >> 8) & 0xff;
2076           data[offset + 3] = value & 0xff;
2077         };
2078       } else {
2079         itemSize = 2;
2080         itemDecode = function fontItemDecode(data, offset) {
2081           return (data[offset] << 9) | (data[offset + 1] << 1);
2082         };
2083         itemEncode = function fontItemEncode(data, offset, value) {
2084           data[offset] = (value >> 9) & 0xff;
2085           data[offset + 1] = (value >> 1) & 0xff;
2086         };
2087       }
2088       // The first glyph is duplicated.
2089       const numGlyphsOut = dupFirstEntry ? numGlyphs + 1 : numGlyphs;
2090       const locaDataSize = itemSize * (1 + numGlyphsOut);
2091       // Resize loca table to account for duplicated glyph.
2092       const locaData = new Uint8Array(locaDataSize);
2093       locaData.set(loca.data.subarray(0, locaDataSize));
2094       loca.data = locaData;
2095       // removing the invalid glyphs
2096       const oldGlyfData = glyf.data;
2097       const oldGlyfDataLength = oldGlyfData.length;
2098       const newGlyfData = new Uint8Array(oldGlyfDataLength);
2099 
2100       // The spec says the offsets should be in ascending order, however
2101       // this is not true for some fonts or they use the offset of 0 to mark a
2102       // glyph as missing. OTS requires the offsets to be in order and not to
2103       // be zero, so we must sort and rebuild the loca table and potentially
2104       // re-arrange the glyf data.
2105       let i, j;
2106       const locaEntries = [];
2107       // There are numGlyphs + 1 loca table entries.
2108       for (i = 0, j = 0; i < numGlyphs + 1; i++, j += itemSize) {
2109         let offset = itemDecode(locaData, j);
2110         if (offset > oldGlyfDataLength) {
2111           offset = oldGlyfDataLength;
2112         }
2113         locaEntries.push({
2114           index: i,
2115           offset,
2116           endOffset: 0,
2117         });
2118       }
2119       locaEntries.sort((a, b) => a.offset - b.offset);
2120       // Now the offsets are sorted, calculate the end offset of each glyph.
2121       // The last loca entry's endOffset is not calculated since it's the end
2122       // of the data and will be stored on the previous entry's endOffset.
2123       for (i = 0; i < numGlyphs; i++) {
2124         locaEntries[i].endOffset = locaEntries[i + 1].offset;
2125       }
2126       // Re-sort so glyphs aren't out of order.
2127       locaEntries.sort((a, b) => a.index - b.index);
2128       // Calculate the endOffset of the "first" glyph correctly when there are
2129       // *multiple* empty ones at the start of the data (fixes issue14618.pdf).
2130       for (i = 0; i < numGlyphs; i++) {
2131         const { offset, endOffset } = locaEntries[i];
2132         if (offset !== 0 || endOffset !== 0) {
2133           break;
2134         }
2135         const nextOffset = locaEntries[i + 1].offset;
2136         if (nextOffset === 0) {
2137           continue;
2138         }
2139         locaEntries[i].endOffset = nextOffset;
2140         break;
2141       }
2142 
2143       // If the last offset is 0 in the loca table then we can't compute the
2144       // endOffset for the last glyph. So in such a case we set the endOffset
2145       // to the end of the data (fixes issue #17671).
2146       const last = locaEntries.at(-2);
2147       if (last.offset !== 0 && last.endOffset === 0) {
2148         last.endOffset = oldGlyfDataLength;
2149       }
2150 
2151       const missingGlyphs = Object.create(null);
2152       let writeOffset = 0;
2153       itemEncode(locaData, 0, writeOffset);
2154       for (i = 0, j = itemSize; i < numGlyphs; i++, j += itemSize) {
2155         const glyphProfile = sanitizeGlyph(
2156           oldGlyfData,
2157           locaEntries[i].offset,
2158           locaEntries[i].endOffset,
2159           newGlyfData,
2160           writeOffset,
2161           hintsValid
2162         );
2163         const newLength = glyphProfile.length;
2164         if (newLength === 0) {
2165           missingGlyphs[i] = true;
2166         }
2167         if (glyphProfile.sizeOfInstructions > maxSizeOfInstructions) {
2168           maxSizeOfInstructions = glyphProfile.sizeOfInstructions;
2169         }
2170         writeOffset += newLength;
2171         itemEncode(locaData, j, writeOffset);
2172       }
2173 
2174       if (writeOffset === 0) {
2175         // glyf table cannot be empty -- redoing the glyf and loca tables
2176         // to have single glyph with one point
2177         const simpleGlyph = new Uint8Array([
2178           0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0,
2179         ]);
2180         for (i = 0, j = itemSize; i < numGlyphsOut; i++, j += itemSize) {
2181           itemEncode(locaData, j, simpleGlyph.length);
2182         }
2183         glyf.data = simpleGlyph;
2184       } else if (dupFirstEntry) {
2185         // Browsers will not display a glyph at position 0. Typically glyph 0
2186         // is notdef, but a number of fonts put a valid glyph there so it must
2187         // be duplicated and appended.
2188         const firstEntryLength = itemDecode(locaData, itemSize);
2189         if (newGlyfData.length > firstEntryLength + writeOffset) {
2190           glyf.data = newGlyfData.subarray(0, firstEntryLength + writeOffset);
2191         } else {
2192           glyf.data = new Uint8Array(firstEntryLength + writeOffset);
2193           glyf.data.set(newGlyfData.subarray(0, writeOffset));
2194         }
2195         glyf.data.set(newGlyfData.subarray(0, firstEntryLength), writeOffset);
2196         itemEncode(
2197           loca.data,
2198           locaData.length - itemSize,
2199           writeOffset + firstEntryLength
2200         );
2201       } else {
2202         glyf.data = newGlyfData.subarray(0, writeOffset);
2203       }
2204       return {
2205         missingGlyphs,
2206         maxSizeOfInstructions,
2207       };
2208     }
2209 
2210     function readPostScriptTable(post, propertiesObj, maxpNumGlyphs) {
2211       const start = (font.start || 0) + post.offset;
2212       font.pos = start;
2213 
2214       const length = post.length,
2215         end = start + length;
2216       const version = font.getInt32();
2217       // skip rest to the tables
2218       font.skip(28);
2219 
2220       let glyphNames;
2221       let valid = true;
2222       let i;
2223 
2224       switch (version) {
2225         case 0x00010000:
2226           glyphNames = MacStandardGlyphOrdering;
2227           break;
2228         case 0x00020000:
2229           const numGlyphs = font.getUint16();
2230           if (numGlyphs !== maxpNumGlyphs) {
2231             valid = false;
2232             break;
2233           }
2234           const glyphNameIndexes = [];
2235           for (i = 0; i < numGlyphs; ++i) {
2236             const index = font.getUint16();
2237             if (index >= 32768) {
2238               valid = false;
2239               break;
2240             }
2241             glyphNameIndexes.push(index);
2242           }
2243           if (!valid) {
2244             break;
2245           }
2246           const customNames = [],
2247             strBuf = [];
2248           while (font.pos < end) {
2249             const stringLength = font.getByte();
2250             strBuf.length = stringLength;
2251             for (i = 0; i < stringLength; ++i) {
2252               strBuf[i] = String.fromCharCode(font.getByte());
2253             }
2254             customNames.push(strBuf.join(""));
2255           }
2256           glyphNames = [];
2257           for (i = 0; i < numGlyphs; ++i) {
2258             const j = glyphNameIndexes[i];
2259             if (j < 258) {
2260               glyphNames.push(MacStandardGlyphOrdering[j]);
2261               continue;
2262             }
2263             glyphNames.push(customNames[j - 258]);
2264           }
2265           break;
2266         case 0x00030000:
2267           break;
2268         default:
2269           warn("Unknown/unsupported post table version " + version);
2270           valid = false;
2271           if (propertiesObj.defaultEncoding) {
2272             glyphNames = propertiesObj.defaultEncoding;
2273           }
2274           break;
2275       }
2276       propertiesObj.glyphNames = glyphNames;
2277       return valid;
2278     }
2279 
2280     function readNameTable(nameTable) {
2281       const start = (font.start || 0) + nameTable.offset;
2282       font.pos = start;
2283 
2284       const names = [[], []],
2285         records = [];
2286       const length = nameTable.length,
2287         end = start + length;
2288       const format = font.getUint16();
2289       const FORMAT_0_HEADER_LENGTH = 6;
2290       if (format !== 0 || length < FORMAT_0_HEADER_LENGTH) {
2291         // unsupported name table format or table "too" small
2292         return [names, records];
2293       }
2294       const numRecords = font.getUint16();
2295       const stringsStart = font.getUint16();
2296       const NAME_RECORD_LENGTH = 12;
2297       let i, ii;
2298 
2299       for (i = 0; i < numRecords && font.pos + NAME_RECORD_LENGTH <= end; i++) {
2300         const r = {
2301           platform: font.getUint16(),
2302           encoding: font.getUint16(),
2303           language: font.getUint16(),
2304           name: font.getUint16(),
2305           length: font.getUint16(),
2306           offset: font.getUint16(),
2307         };
2308         // using only Macintosh and Windows platform/encoding names
2309         if (isMacNameRecord(r) || isWinNameRecord(r)) {
2310           records.push(r);
2311         }
2312       }
2313       for (i = 0, ii = records.length; i < ii; i++) {
2314         const record = records[i];
2315         if (record.length <= 0) {
2316           continue; // Nothing to process, ignoring.
2317         }
2318         const pos = start + stringsStart + record.offset;
2319         if (pos + record.length > end) {
2320           continue; // outside of name table, ignoring
2321         }
2322         font.pos = pos;
2323         const nameIndex = record.name;
2324         if (record.encoding) {
2325           // unicode
2326           let str = "";
2327           for (let j = 0, jj = record.length; j < jj; j += 2) {
2328             str += String.fromCharCode(font.getUint16());
2329           }
2330           names[1][nameIndex] = str;
2331         } else {
2332           names[0][nameIndex] = font.getString(record.length);
2333         }
2334       }
2335       return [names, records];
2336     }
2337 
2338     // prettier-ignore
2339     const TTOpsStackDeltas = [
2340       0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5,
2341       -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1,
2342       1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1,
2343       0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2,
2344       0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1,
2345       -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1,
2346       -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2347       -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1,
2348       -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
2349     // 0xC0-DF == -1 and 0xE0-FF == -2
2350 
2351     function sanitizeTTProgram(table, ttContext) {
2352       let data = table.data;
2353       let i = 0,
2354         j,
2355         n,
2356         b,
2357         funcId,
2358         pc,
2359         lastEndf = 0,
2360         lastDeff = 0;
2361       const stack = [];
2362       const callstack = [];
2363       const functionsCalled = [];
2364       let tooComplexToFollowFunctions = ttContext.tooComplexToFollowFunctions;
2365       let inFDEF = false,
2366         ifLevel = 0,
2367         inELSE = 0;
2368       for (let ii = data.length; i < ii; ) {
2369         const op = data[i++];
2370         // The TrueType instruction set docs can be found at
2371         // https://developer.apple.com/fonts/TTRefMan/RM05/Chap5.html
2372         if (op === 0x40) {
2373           // NPUSHB - pushes n bytes
2374           n = data[i++];
2375           if (inFDEF || inELSE) {
2376             i += n;
2377           } else {
2378             for (j = 0; j < n; j++) {
2379               stack.push(data[i++]);
2380             }
2381           }
2382         } else if (op === 0x41) {
2383           // NPUSHW - pushes n words
2384           n = data[i++];
2385           if (inFDEF || inELSE) {
2386             i += n * 2;
2387           } else {
2388             for (j = 0; j < n; j++) {
2389               b = data[i++];
2390               stack.push((b << 8) | data[i++]);
2391             }
2392           }
2393         } else if ((op & 0xf8) === 0xb0) {
2394           // PUSHB - pushes bytes
2395           n = op - 0xb0 + 1;
2396           if (inFDEF || inELSE) {
2397             i += n;
2398           } else {
2399             for (j = 0; j < n; j++) {
2400               stack.push(data[i++]);
2401             }
2402           }
2403         } else if ((op & 0xf8) === 0xb8) {
2404           // PUSHW - pushes words
2405           n = op - 0xb8 + 1;
2406           if (inFDEF || inELSE) {
2407             i += n * 2;
2408           } else {
2409             for (j = 0; j < n; j++) {
2410               b = data[i++];
2411               stack.push(signedInt16(b, data[i++]));
2412             }
2413           }
2414         } else if (op === 0x2b && !tooComplexToFollowFunctions) {
2415           // CALL
2416           if (!inFDEF && !inELSE) {
2417             // collecting information about which functions are used
2418             funcId = stack.at(-1);
2419             if (isNaN(funcId)) {
2420               info("TT: CALL empty stack (or invalid entry).");
2421             } else {
2422               ttContext.functionsUsed[funcId] = true;
2423               if (funcId in ttContext.functionsStackDeltas) {
2424                 const newStackLength =
2425                   stack.length + ttContext.functionsStackDeltas[funcId];
2426                 if (newStackLength < 0) {
2427                   warn("TT: CALL invalid functions stack delta.");
2428                   ttContext.hintsValid = false;
2429                   return;
2430                 }
2431                 stack.length = newStackLength;
2432               } else if (
2433                 funcId in ttContext.functionsDefined &&
2434                 !functionsCalled.includes(funcId)
2435               ) {
2436                 callstack.push({ data, i, stackTop: stack.length - 1 });
2437                 functionsCalled.push(funcId);
2438                 pc = ttContext.functionsDefined[funcId];
2439                 if (!pc) {
2440                   warn("TT: CALL non-existent function");
2441                   ttContext.hintsValid = false;
2442                   return;
2443                 }
2444                 data = pc.data;
2445                 i = pc.i;
2446               }
2447             }
2448           }
2449         } else if (op === 0x2c && !tooComplexToFollowFunctions) {
2450           // FDEF
2451           if (inFDEF || inELSE) {
2452             warn("TT: nested FDEFs not allowed");
2453             tooComplexToFollowFunctions = true;
2454           }
2455           inFDEF = true;
2456           // collecting information about which functions are defined
2457           lastDeff = i;
2458           funcId = stack.pop();
2459           ttContext.functionsDefined[funcId] = { data, i };
2460         } else if (op === 0x2d) {
2461           // ENDF - end of function
2462           if (inFDEF) {
2463             inFDEF = false;
2464             lastEndf = i;
2465           } else {
2466             pc = callstack.pop();
2467             if (!pc) {
2468               warn("TT: ENDF bad stack");
2469               ttContext.hintsValid = false;
2470               return;
2471             }
2472             funcId = functionsCalled.pop();
2473             data = pc.data;
2474             i = pc.i;
2475             ttContext.functionsStackDeltas[funcId] = stack.length - pc.stackTop;
2476           }
2477         } else if (op === 0x89) {
2478           // IDEF - instruction definition
2479           if (inFDEF || inELSE) {
2480             warn("TT: nested IDEFs not allowed");
2481             tooComplexToFollowFunctions = true;
2482           }
2483           inFDEF = true;
2484           // recording it as a function to track ENDF
2485           lastDeff = i;
2486         } else if (op === 0x58) {
2487           // IF
2488           ++ifLevel;
2489         } else if (op === 0x1b) {
2490           // ELSE
2491           inELSE = ifLevel;
2492         } else if (op === 0x59) {
2493           // EIF
2494           if (inELSE === ifLevel) {
2495             inELSE = 0;
2496           }
2497           --ifLevel;
2498         } else if (op === 0x1c) {
2499           // JMPR
2500           if (!inFDEF && !inELSE) {
2501             const offset = stack.at(-1);
2502             // only jumping forward to prevent infinite loop
2503             if (offset > 0) {
2504               i += offset - 1;
2505             }
2506           }
2507         }
2508         // Adjusting stack not extactly, but just enough to get function id
2509         if (!inFDEF && !inELSE) {
2510           let stackDelta = 0;
2511           if (op <= 0x8e) {
2512             stackDelta = TTOpsStackDeltas[op];
2513           } else if (op >= 0xc0 && op <= 0xdf) {
2514             stackDelta = -1;
2515           } else if (op >= 0xe0) {
2516             stackDelta = -2;
2517           }
2518           if (op >= 0x71 && op <= 0x75) {
2519             n = stack.pop();
2520             if (!isNaN(n)) {
2521               stackDelta = -n * 2;
2522             }
2523           }
2524           while (stackDelta < 0 && stack.length > 0) {
2525             stack.pop();
2526             stackDelta++;
2527           }
2528           while (stackDelta > 0) {
2529             stack.push(NaN); // pushing any number into stack
2530             stackDelta--;
2531           }
2532         }
2533       }
2534       ttContext.tooComplexToFollowFunctions = tooComplexToFollowFunctions;
2535       const content = [data];
2536       if (i > data.length) {
2537         content.push(new Uint8Array(i - data.length));
2538       }
2539       if (lastDeff > lastEndf) {
2540         warn("TT: complementing a missing function tail");
2541         // new function definition started, but not finished
2542         // complete function by [CLEAR, ENDF]
2543         content.push(new Uint8Array([0x22, 0x2d]));
2544       }
2545       foldTTTable(table, content);
2546     }
2547 
2548     function checkInvalidFunctions(ttContext, maxFunctionDefs) {
2549       if (ttContext.tooComplexToFollowFunctions) {
2550         return;
2551       }
2552       if (ttContext.functionsDefined.length > maxFunctionDefs) {
2553         warn("TT: more functions defined than expected");
2554         ttContext.hintsValid = false;
2555         return;
2556       }
2557       for (let j = 0, jj = ttContext.functionsUsed.length; j < jj; j++) {
2558         if (j > maxFunctionDefs) {
2559           warn("TT: invalid function id: " + j);
2560           ttContext.hintsValid = false;
2561           return;
2562         }
2563         if (ttContext.functionsUsed[j] && !ttContext.functionsDefined[j]) {
2564           warn("TT: undefined function: " + j);
2565           ttContext.hintsValid = false;
2566           return;
2567         }
2568       }
2569     }
2570 
2571     function foldTTTable(table, content) {
2572       if (content.length > 1) {
2573         // concatenating the content items
2574         let newLength = 0;
2575         let j, jj;
2576         for (j = 0, jj = content.length; j < jj; j++) {
2577           newLength += content[j].length;
2578         }
2579         newLength = (newLength + 3) & ~3;
2580         const result = new Uint8Array(newLength);
2581         let pos = 0;
2582         for (j = 0, jj = content.length; j < jj; j++) {
2583           result.set(content[j], pos);
2584           pos += content[j].length;
2585         }
2586         table.data = result;
2587         table.length = newLength;
2588       }
2589     }
2590 
2591     function sanitizeTTPrograms(fpgm, prep, cvt, maxFunctionDefs) {
2592       const ttContext = {
2593         functionsDefined: [],
2594         functionsUsed: [],
2595         functionsStackDeltas: [],
2596         tooComplexToFollowFunctions: false,
2597         hintsValid: true,
2598       };
2599       if (fpgm) {
2600         sanitizeTTProgram(fpgm, ttContext);
2601       }
2602       if (prep) {
2603         sanitizeTTProgram(prep, ttContext);
2604       }
2605       if (fpgm) {
2606         checkInvalidFunctions(ttContext, maxFunctionDefs);
2607       }
2608       if (cvt && cvt.length & 1) {
2609         const cvtData = new Uint8Array(cvt.length + 1);
2610         cvtData.set(cvt.data);
2611         cvt.data = cvtData;
2612       }
2613       return ttContext.hintsValid;
2614     }
2615 
2616     // The following steps modify the original font data, making copy
2617     font = new Stream(new Uint8Array(font.getBytes()));
2618 
2619     let header, tables;
2620     if (isTrueTypeCollectionFile(font)) {
2621       const ttcData = readTrueTypeCollectionData(font, this.name);
2622       header = ttcData.header;
2623       tables = ttcData.tables;
2624     } else {
2625       header = readOpenTypeHeader(font);
2626       tables = readTables(font, header.numTables);
2627     }
2628     let cff, cffFile;
2629 
2630     const isTrueType = !tables["CFF "];
2631     if (!isTrueType) {
2632       const isComposite =
2633         properties.composite &&
2634         (properties.cidToGidMap?.length > 0 ||
2635           !(properties.cMap instanceof IdentityCMap));
2636       // OpenType font (skip composite fonts with non-default glyph mapping).
2637       if (
2638         (header.version === "OTTO" && !isComposite) ||
2639         !tables.head ||
2640         !tables.hhea ||
2641         !tables.maxp ||
2642         !tables.post
2643       ) {
2644         // No major tables: throwing everything at `CFFFont`.
2645         cffFile = new Stream(tables["CFF "].data);
2646         cff = new CFFFont(cffFile, properties);
2647 
2648         adjustWidths(properties);
2649 
2650         return this.convert(name, cff, properties);
2651       }
2652 
2653       delete tables.glyf;
2654       delete tables.loca;
2655       delete tables.fpgm;
2656       delete tables.prep;
2657       delete tables["cvt "];
2658       this.isOpenType = true;
2659     } else {
2660       if (!tables.loca) {
2661         throw new FormatError('Required "loca" table is not found');
2662       }
2663       if (!tables.glyf) {
2664         warn('Required "glyf" table is not found -- trying to recover.');
2665         // Note: We use `sanitizeGlyphLocations` to add dummy glyf data below.
2666         tables.glyf = {
2667           tag: "glyf",
2668           data: new Uint8Array(0),
2669         };
2670       }
2671       this.isOpenType = false;
2672     }
2673 
2674     if (!tables.maxp) {
2675       throw new FormatError('Required "maxp" table is not found');
2676     }
2677 
2678     font.pos = (font.start || 0) + tables.maxp.offset;
2679     let version = font.getInt32();
2680     const numGlyphs = font.getUint16();
2681 
2682     if (version !== 0x00010000 && version !== 0x00005000) {
2683       // https://learn.microsoft.com/en-us/typography/opentype/spec/maxp
2684       if (tables.maxp.length === 6) {
2685         version = 0x0005000;
2686       } else if (tables.maxp.length >= 32) {
2687         version = 0x00010000;
2688       } else {
2689         throw new FormatError(`"maxp" table has a wrong version number`);
2690       }
2691       writeUint32(tables.maxp.data, 0, version);
2692     }
2693 
2694     if (properties.scaleFactors?.length === numGlyphs && isTrueType) {
2695       const { scaleFactors } = properties;
2696       const isGlyphLocationsLong = int16(
2697         tables.head.data[50],
2698         tables.head.data[51]
2699       );
2700 
2701       const glyphs = new GlyfTable({
2702         glyfTable: tables.glyf.data,
2703         isGlyphLocationsLong,
2704         locaTable: tables.loca.data,
2705         numGlyphs,
2706       });
2707       glyphs.scale(scaleFactors);
2708 
2709       const { glyf, loca, isLocationLong } = glyphs.write();
2710       tables.glyf.data = glyf;
2711       tables.loca.data = loca;
2712 
2713       if (isLocationLong !== !!isGlyphLocationsLong) {
2714         tables.head.data[50] = 0;
2715         tables.head.data[51] = isLocationLong ? 1 : 0;
2716       }
2717 
2718       const metrics = tables.hmtx.data;
2719 
2720       for (let i = 0; i < numGlyphs; i++) {
2721         const j = 4 * i;
2722         const advanceWidth = Math.round(
2723           scaleFactors[i] * int16(metrics[j], metrics[j + 1])
2724         );
2725         metrics[j] = (advanceWidth >> 8) & 0xff;
2726         metrics[j + 1] = advanceWidth & 0xff;
2727         const lsb = Math.round(
2728           scaleFactors[i] * signedInt16(metrics[j + 2], metrics[j + 3])
2729         );
2730         writeSignedInt16(metrics, j + 2, lsb);
2731       }
2732     }
2733 
2734     // Glyph 0 is duplicated and appended.
2735     let numGlyphsOut = numGlyphs + 1;
2736     let dupFirstEntry = true;
2737     if (numGlyphsOut > 0xffff) {
2738       dupFirstEntry = false;
2739       numGlyphsOut = numGlyphs;
2740       warn("Not enough space in glyfs to duplicate first glyph.");
2741     }
2742     let maxFunctionDefs = 0;
2743     let maxSizeOfInstructions = 0;
2744     if (version >= 0x00010000 && tables.maxp.length >= 32) {
2745       // maxZones can be invalid
2746       font.pos += 8;
2747       const maxZones = font.getUint16();
2748       if (maxZones > 2) {
2749         // reset to 2 if font has invalid maxZones
2750         tables.maxp.data[14] = 0;
2751         tables.maxp.data[15] = 2;
2752       }
2753       font.pos += 4;
2754       maxFunctionDefs = font.getUint16();
2755       font.pos += 4;
2756       maxSizeOfInstructions = font.getUint16();
2757     }
2758 
2759     tables.maxp.data[4] = numGlyphsOut >> 8;
2760     tables.maxp.data[5] = numGlyphsOut & 255;
2761 
2762     const hintsValid = sanitizeTTPrograms(
2763       tables.fpgm,
2764       tables.prep,
2765       tables["cvt "],
2766       maxFunctionDefs
2767     );
2768     if (!hintsValid) {
2769       delete tables.fpgm;
2770       delete tables.prep;
2771       delete tables["cvt "];
2772     }
2773 
2774     // Ensure the hmtx table contains the advance width and
2775     // sidebearings information for numGlyphs in the maxp table
2776     sanitizeMetrics(
2777       font,
2778       tables.hhea,
2779       tables.hmtx,
2780       tables.head,
2781       numGlyphsOut,
2782       dupFirstEntry
2783     );
2784 
2785     if (!tables.head) {
2786       throw new FormatError('Required "head" table is not found');
2787     }
2788 
2789     sanitizeHead(tables.head, numGlyphs, isTrueType ? tables.loca.length : 0);
2790 
2791     let missingGlyphs = Object.create(null);
2792     if (isTrueType) {
2793       const isGlyphLocationsLong = int16(
2794         tables.head.data[50],
2795         tables.head.data[51]
2796       );
2797       const glyphsInfo = sanitizeGlyphLocations(
2798         tables.loca,
2799         tables.glyf,
2800         numGlyphs,
2801         isGlyphLocationsLong,
2802         hintsValid,
2803         dupFirstEntry,
2804         maxSizeOfInstructions
2805       );
2806       missingGlyphs = glyphsInfo.missingGlyphs;
2807 
2808       // Some fonts have incorrect maxSizeOfInstructions values, so we use
2809       // the computed value instead.
2810       if (version >= 0x00010000 && tables.maxp.length >= 32) {
2811         tables.maxp.data[26] = glyphsInfo.maxSizeOfInstructions >> 8;
2812         tables.maxp.data[27] = glyphsInfo.maxSizeOfInstructions & 255;
2813       }
2814     }
2815     if (!tables.hhea) {
2816       throw new FormatError('Required "hhea" table is not found');
2817     }
2818 
2819     // Sanitizer reduces the glyph advanceWidth to the maxAdvanceWidth
2820     // Sometimes it's 0. That needs to be fixed
2821     if (tables.hhea.data[10] === 0 && tables.hhea.data[11] === 0) {
2822       tables.hhea.data[10] = 0xff;
2823       tables.hhea.data[11] = 0xff;
2824     }
2825 
2826     // Extract some more font properties from the OpenType head and
2827     // hhea tables; yMin and descent value are always negative.
2828     const metricsOverride = {
2829       unitsPerEm: int16(tables.head.data[18], tables.head.data[19]),
2830       yMax: signedInt16(tables.head.data[42], tables.head.data[43]),
2831       yMin: signedInt16(tables.head.data[38], tables.head.data[39]),
2832       ascent: signedInt16(tables.hhea.data[4], tables.hhea.data[5]),
2833       descent: signedInt16(tables.hhea.data[6], tables.hhea.data[7]),
2834       lineGap: signedInt16(tables.hhea.data[8], tables.hhea.data[9]),
2835     };
2836 
2837     // PDF FontDescriptor metrics lie -- using data from actual font.
2838     this.ascent = metricsOverride.ascent / metricsOverride.unitsPerEm;
2839     this.descent = metricsOverride.descent / metricsOverride.unitsPerEm;
2840     this.lineGap = metricsOverride.lineGap / metricsOverride.unitsPerEm;
2841 
2842     if (this.cssFontInfo?.lineHeight) {
2843       this.lineHeight = this.cssFontInfo.metrics.lineHeight;
2844       this.lineGap = this.cssFontInfo.metrics.lineGap;
2845     } else {
2846       this.lineHeight = this.ascent - this.descent + this.lineGap;
2847     }
2848 
2849     // The 'post' table has glyphs names.
2850     if (tables.post) {
2851       readPostScriptTable(tables.post, properties, numGlyphs);
2852     }
2853 
2854     // The original 'post' table is not needed, replace it.
2855     tables.post = {
2856       tag: "post",
2857       data: createPostTable(properties),
2858     };
2859 
2860     const charCodeToGlyphId = Object.create(null);
2861 
2862     // Helper function to try to skip mapping of empty glyphs.
2863     function hasGlyph(glyphId) {
2864       return !missingGlyphs[glyphId];
2865     }
2866 
2867     if (properties.composite) {
2868       const cidToGidMap = properties.cidToGidMap || [];
2869       const isCidToGidMapEmpty = cidToGidMap.length === 0;
2870 
2871       properties.cMap.forEach(function (charCode, cid) {
2872         if (typeof cid === "string") {
2873           cid = convertCidString(charCode, cid, /* shouldThrow = */ true);
2874         }
2875         if (cid > 0xffff) {
2876           throw new FormatError("Max size of CID is 65,535");
2877         }
2878         let glyphId = -1;
2879         if (isCidToGidMapEmpty) {
2880           glyphId = cid;
2881         } else if (cidToGidMap[cid] !== undefined) {
2882           glyphId = cidToGidMap[cid];
2883         }
2884 
2885         if (glyphId >= 0 && glyphId < numGlyphs && hasGlyph(glyphId)) {
2886           charCodeToGlyphId[charCode] = glyphId;
2887         }
2888       });
2889     } else {
2890       // Most of the following logic in this code branch is based on the
2891       // 9.6.6.4 of the PDF spec.
2892       const cmapTable = readCmapTable(
2893         tables.cmap,
2894         font,
2895         this.isSymbolicFont,
2896         properties.hasEncoding
2897       );
2898       const cmapPlatformId = cmapTable.platformId;
2899       const cmapEncodingId = cmapTable.encodingId;
2900       const cmapMappings = cmapTable.mappings;
2901       let baseEncoding = [],
2902         forcePostTable = false;
2903       if (
2904         properties.hasEncoding &&
2905         (properties.baseEncodingName === "MacRomanEncoding" ||
2906           properties.baseEncodingName === "WinAnsiEncoding")
2907       ) {
2908         baseEncoding = getEncoding(properties.baseEncodingName);
2909       }
2910 
2911       // If the font has an encoding and is not symbolic then follow the rules
2912       // in section 9.6.6.4 of the spec on how to map 3,1 and 1,0 cmaps.
2913       if (
2914         properties.hasEncoding &&
2915         !this.isSymbolicFont &&
2916         ((cmapPlatformId === 3 && cmapEncodingId === 1) ||
2917           (cmapPlatformId === 1 && cmapEncodingId === 0))
2918       ) {
2919         const glyphsUnicodeMap = getGlyphsUnicode();
2920         for (let charCode = 0; charCode < 256; charCode++) {
2921           let glyphName;
2922           if (this.differences[charCode] !== undefined) {
2923             glyphName = this.differences[charCode];
2924           } else if (baseEncoding.length && baseEncoding[charCode] !== "") {
2925             glyphName = baseEncoding[charCode];
2926           } else {
2927             glyphName = StandardEncoding[charCode];
2928           }
2929           if (!glyphName) {
2930             continue;
2931           }
2932           // Ensure that non-standard glyph names are resolved to valid ones.
2933           const standardGlyphName = recoverGlyphName(
2934             glyphName,
2935             glyphsUnicodeMap
2936           );
2937 
2938           let unicodeOrCharCode;
2939           if (cmapPlatformId === 3 && cmapEncodingId === 1) {
2940             unicodeOrCharCode = glyphsUnicodeMap[standardGlyphName];
2941           } else if (cmapPlatformId === 1 && cmapEncodingId === 0) {
2942             // TODO: the encoding needs to be updated with mac os table.
2943             unicodeOrCharCode = MacRomanEncoding.indexOf(standardGlyphName);
2944           }
2945 
2946           if (unicodeOrCharCode === undefined) {
2947             // Not a valid glyph name, fallback to using the /ToUnicode map
2948             // when no post-table exists (fixes issue13316_reduced.pdf).
2949             if (
2950               !properties.glyphNames &&
2951               properties.hasIncludedToUnicodeMap &&
2952               !(this.toUnicode instanceof IdentityToUnicodeMap)
2953             ) {
2954               const unicode = this.toUnicode.get(charCode);
2955               if (unicode) {
2956                 unicodeOrCharCode = unicode.codePointAt(0);
2957               }
2958             }
2959 
2960             if (unicodeOrCharCode === undefined) {
2961               continue; // No valid glyph mapping found.
2962             }
2963           }
2964 
2965           for (const mapping of cmapMappings) {
2966             if (mapping.charCode !== unicodeOrCharCode) {
2967               continue;
2968             }
2969             charCodeToGlyphId[charCode] = mapping.glyphId;
2970             break;
2971           }
2972         }
2973       } else if (cmapPlatformId === 0) {
2974         // Default Unicode semantics, use the charcodes as is.
2975         for (const mapping of cmapMappings) {
2976           charCodeToGlyphId[mapping.charCode] = mapping.glyphId;
2977         }
2978         // Always prefer the BaseEncoding/Differences arrays, when they exist
2979         // (fixes issue13433.pdf).
2980         forcePostTable = true;
2981       } else if (cmapPlatformId === 3 && cmapEncodingId === 0) {
2982         // When a (3, 0) cmap table is present, it is used instead but the
2983         // spec has special rules for char codes in the range of 0xF000 to
2984         // 0xF0FF and it says the (3, 0) table should map the values from
2985         // the (1, 0) table by prepending 0xF0 to the char codes. To reverse
2986         // this, the upper bits of the char code are cleared, but only for the
2987         // special range since some PDFs have char codes outside of this range
2988         // (e.g. 0x2013) which when masked would overwrite other values in the
2989         // cmap.
2990         for (const mapping of cmapMappings) {
2991           let charCode = mapping.charCode;
2992           if (charCode >= 0xf000 && charCode <= 0xf0ff) {
2993             charCode &= 0xff;
2994           }
2995           charCodeToGlyphId[charCode] = mapping.glyphId;
2996         }
2997       } else {
2998         // When there is only a (1, 0) cmap table, the char code is a single
2999         // byte and it is used directly as the char code.
3000         for (const mapping of cmapMappings) {
3001           charCodeToGlyphId[mapping.charCode] = mapping.glyphId;
3002         }
3003       }
3004 
3005       // Last, try to map any missing charcodes using the post table.
3006       if (
3007         properties.glyphNames &&
3008         (baseEncoding.length || this.differences.length)
3009       ) {
3010         for (let i = 0; i < 256; ++i) {
3011           if (!forcePostTable && charCodeToGlyphId[i] !== undefined) {
3012             continue;
3013           }
3014           const glyphName = this.differences[i] || baseEncoding[i];
3015           if (!glyphName) {
3016             continue;
3017           }
3018           const glyphId = properties.glyphNames.indexOf(glyphName);
3019           if (glyphId > 0 && hasGlyph(glyphId)) {
3020             charCodeToGlyphId[i] = glyphId;
3021           }
3022         }
3023       }
3024     }
3025 
3026     if (charCodeToGlyphId.length === 0) {
3027       // defines at least one glyph
3028       charCodeToGlyphId[0] = 0;
3029     }
3030 
3031     // Typically glyph 0 is duplicated and the mapping must be updated, but if
3032     // there isn't enough room to duplicate, the glyph id is left the same. In
3033     // this case, glyph 0 may not work correctly, but that is better than
3034     // having the whole font fail.
3035     let glyphZeroId = numGlyphsOut - 1;
3036     if (!dupFirstEntry) {
3037       glyphZeroId = 0;
3038     }
3039 
3040     // When `cssFontInfo` is set, the font is used to render text in the HTML
3041     // view (e.g. with Xfa) so nothing must be moved in the private use area.
3042     if (!properties.cssFontInfo) {
3043       // Converting glyphs and ids into font's cmap table
3044       const newMapping = adjustMapping(
3045         charCodeToGlyphId,
3046         hasGlyph,
3047         glyphZeroId,
3048         this.toUnicode
3049       );
3050       this.toFontChar = newMapping.toFontChar;
3051       tables.cmap = {
3052         tag: "cmap",
3053         data: createCmapTable(
3054           newMapping.charCodeToGlyphId,
3055           newMapping.toUnicodeExtraMap,
3056           numGlyphsOut
3057         ),
3058       };
3059 
3060       if (!tables["OS/2"] || !validateOS2Table(tables["OS/2"], font)) {
3061         tables["OS/2"] = {
3062           tag: "OS/2",
3063           data: createOS2Table(
3064             properties,
3065             newMapping.charCodeToGlyphId,
3066             metricsOverride
3067           ),
3068         };
3069       }
3070     }
3071 
3072     if (!isTrueType) {
3073       try {
3074         // Trying to repair CFF file
3075         cffFile = new Stream(tables["CFF "].data);
3076         const parser = new CFFParser(
3077           cffFile,
3078           properties,
3079           SEAC_ANALYSIS_ENABLED
3080         );
3081         cff = parser.parse();
3082         cff.duplicateFirstGlyph();
3083         const compiler = new CFFCompiler(cff);
3084         tables["CFF "].data = compiler.compile();
3085       } catch {
3086         warn("Failed to compile font " + properties.loadedName);
3087       }
3088     }
3089 
3090     // Re-creating 'name' table
3091     if (!tables.name) {
3092       tables.name = {
3093         tag: "name",
3094         data: createNameTable(this.name),
3095       };
3096     } else {
3097       // ... using existing 'name' table as prototype
3098       const [namePrototype, nameRecords] = readNameTable(tables.name);
3099 
3100       tables.name.data = createNameTable(name, namePrototype);
3101       this.psName = namePrototype[0][6] || null;
3102 
3103       if (!properties.composite) {
3104         // For TrueType fonts that do not include `ToUnicode` or `Encoding`
3105         // data, attempt to use the name-table to improve text selection.
3106         adjustTrueTypeToUnicode(properties, this.isSymbolicFont, nameRecords);
3107       }
3108     }
3109 
3110     const builder = new OpenTypeFileBuilder(header.version);
3111     for (const tableTag in tables) {
3112       builder.addTable(tableTag, tables[tableTag].data);
3113     }
3114     return builder.toArray();
3115   }
3116 
3586 }
3587 
3607 
</code>

Test file:
<test_file>
File:
test/unit/api_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  AnnotationEditorType,
  AnnotationMode,
  AnnotationType,
  DrawOPS,
  ImageKind,
  InvalidPDFException,
  isNodeJS,
  objectSize,
  OPS,
  PasswordException,
  PasswordResponses,
  PermissionFlag,
  ResponseException,
  UnknownErrorException,
} from "../../src/shared/util.js";
import {
  buildGetDocumentParams,
  CMAP_URL,
  DefaultFileReaderFactory,
  getCrossOriginHostname,
  TEST_PDFS_PATH,
  TestPdfsServer,
} from "./test_utils.js";
import {
  fetchData as fetchDataDOM,
  PageViewport,
  RenderingCancelledException,
  StatTimer,
} from "../../src/display/display_utils.js";
import {
  getDocument,
  PDFDataRangeTransport,
  PDFDocumentLoadingTask,
  PDFDocumentProxy,
  PDFPageProxy,
  PDFWorker,
  RenderTask,
} from "../../src/display/api.js";
import { AutoPrintRegExp } from "../../web/ui_utils.js";
import { GlobalImageCache } from "../../src/core/image_utils.js";
import { GlobalWorkerOptions } from "../../src/display/worker_options.js";
import { Metadata } from "../../src/display/metadata.js";
const WORKER_SRC = "../../build/generic/build/pdf.worker.mjs";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

