Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: From second page onwards pdf is not loading
### Attach (recommended) or Link to PDF file

[2023-ESG-report-eng.pdf](https://github.com/user-attachments/files/18396493/2023-ESG-report-eng.pdf)

### Web browser and its version

134

### Operating system and its version

Mac M2 pro

### PDF.js version

4.10.38

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

1. Open the [link](https://www.chinagoldintl.com/_resources/esg/2023-ESG-report-eng.pdf?v=011310) in Mozilla (in order to load in pdfJs)
2. It will open the first page only and rest of the pages are showing empty with loading symbol.

### What is the expected behavior?

It should load all the pages like chrome pdfium is loading all the pages.

### What went wrong?

Pages are blank with loading symbol

<img width="1278" alt="image" src="https://github.com/user-attachments/assets/1c30c8d1-afc7-4426-bb71-bcbed35a5b56" />

### Link to a viewer

_No response_

### Additional context

Hi,
On trying to open [PDF File](https://www.chinagoldintl.com/_resources/esg/2023-ESG-report-eng.pdf?v=011310) in PdfJs it is opening only the first page and from second page onwards it's showing only the loading icon.
Tried to test this in Mozilla latest version v.134 and I can see the same issue there too.
It's opening fine in Pdfium of chrome browser.
</issue>

Patch:
<patch>
diff --git a/src/core/fonts.js b/src/core/fonts.js
--- a/src/core/fonts.js
+++ b/src/core/fonts.js
@@ -1760,17 +1760,22 @@ class Font {
       mappings.sort(function (a, b) {
         return a.charCode - b.charCode;
       });
-      for (let i = 1; i < mappings.length; i++) {
-        if (mappings[i - 1].charCode === mappings[i].charCode) {
-          mappings.splice(i, 1);
-          i--;
+      const finalMappings = [],
+        seenCharCodes = new Set();
+      for (const map of mappings) {
+        const { charCode } = map;
+
+        if (seenCharCodes.has(charCode)) {
+          continue;
         }
+        seenCharCodes.add(charCode);
+        finalMappings.push(map);
       }
 
       return {
         platformId: potentialTable.platformId,
         encodingId: potentialTable.encodingId,
-        mappings,
+        mappings: finalMappings,
         hasShortCmap,
       };
     }


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.0
- @babel/preset-env: ^7.26.0
- @babel/runtime: ^7.26.0
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.65
- @types/node: ^22.10.5
- autoprefixer: ^10.4.20
- babel-loader: ^9.2.1
- caniuse-lite: ^1.0.30001692
- core-js: ^3.40.0
- eslint: ^9.17.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.6.0
- eslint-plugin-prettier: ^5.2.1
- eslint-plugin-unicorn: ^56.0.1
- globals: ^15.14.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.5.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.4.49
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.4.2
- puppeteer: ^23.11.1
- stylelint: ^16.12.0
- stylelint-prettier: ^5.0.2
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.11
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.7.3
- vinyl: ^3.0.0
- webpack: ^5.97.1
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: fetchData
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/core/fonts.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   assert,
18   bytesToString,
19   FONT_IDENTITY_MATRIX,
20   FormatError,
21   info,
22   shadow,
23   string32,
24   warn,
25 } from "../shared/util.js";
26 import { CFFCompiler, CFFParser } from "./cff_parser.js";
27 import {
28   FontFlags,
29   getVerticalPresentationForm,
30   MacStandardGlyphOrdering,
31   normalizeFontName,
32   recoverGlyphName,
33   SEAC_ANALYSIS_ENABLED,
34 } from "./fonts_utils.js";
35 import {
36   getCharUnicodeCategory,
37   getUnicodeForGlyph,
38   getUnicodeRangeFor,
39   mapSpecialUnicodeValues,
40 } from "./unicode.js";
41 import { getDingbatsGlyphsUnicode, getGlyphsUnicode } from "./glyphlist.js";
42 import {
43   getEncoding,
44   MacRomanEncoding,
45   StandardEncoding,
46   SymbolSetEncoding,
47   WinAnsiEncoding,
48   ZapfDingbatsEncoding,
49 } from "./encodings.js";
50 import {
51   getGlyphMapForStandardFonts,
52   getNonStdFontMap,
53   getSerifFonts,
54   getStdFontMap,
55   getSupplementalGlyphMapForArialBlack,
56   getSupplementalGlyphMapForCalibri,
57 } from "./standard_fonts.js";
58 import { IdentityToUnicodeMap, ToUnicodeMap } from "./to_unicode_map.js";
59 import { CFFFont } from "./cff_font.js";
60 import { FontRendererFactory } from "./font_renderer.js";
61 import { getFontBasicMetrics } from "./metrics.js";
62 import { GlyfTable } from "./glyf.js";
63 import { IdentityCMap } from "./cmap.js";
64 import { OpenTypeFileBuilder } from "./opentype_file_builder.js";
65 import { readUint32 } from "./core_utils.js";
66 import { Stream } from "./stream.js";
67 import { Type1Font } from "./type1_font.js";
68 
69 // Unicode Private Use Areas:
70 const PRIVATE_USE_AREAS = [
71   [0xe000, 0xf8ff], // BMP (0)
72   [0x100000, 0x10fffd], // PUP (16)
73 ];
74 
75 // PDF Glyph Space Units are one Thousandth of a TextSpace Unit
76 // except for Type 3 fonts
77 const PDF_GLYPH_SPACE_UNITS = 1000;
78 
79 const EXPORT_DATA_PROPERTIES = [
80   "ascent",
81   "bbox",
82   "black",
83   "bold",
84   "charProcOperatorList",
85   "composite",
86   "cssFontInfo",
87   "data",
88   "defaultVMetrics",
89   "defaultWidth",
90   "descent",
91   "fallbackName",
92   "fontMatrix",
93   "isInvalidPDFjsFont",
94   "isType3Font",
95   "italic",
96   "loadedName",
97   "mimetype",
98   "missingFile",
99   "name",
100   "remeasure",
101   "subtype",
102   "systemFontInfo",
103   "type",
104   "vertical",
105 ];
106 
107 const EXPORT_DATA_EXTRA_PROPERTIES = [
108   "cMap",
109   "defaultEncoding",
110   "differences",
111   "isMonospace",
112   "isSerifFont",
113   "isSymbolicFont",
114   "seacMap",
115   "toFontChar",
116   "toUnicode",
117   "vmetrics",
118   "widths",
119 ];
120 
437 // Please refer to:
438 //  - https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html
442 
443 // Please refer to:
444 //  - https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html
445 //  - https://learn.microsoft.com/en-us/typography/opentype/spec/name#windows-language-ids
449 
950 /**
951  * 'Font' is the class the outside world should use, it encapsulate all the font
952  * decoding logics whatever type it is (assuming the font type is supported).
953  */
954 class Font {
955   constructor(name, file, properties) {
956     this.name = name;
957     this.psName = null;
958     this.mimetype = null;
959     this.disableFontFace = false;
960 
961     this.loadedName = properties.loadedName;
962     this.isType3Font = properties.isType3Font;
963     this.missingFile = false;
964     this.cssFontInfo = properties.cssFontInfo;
965 
966     this._charsCache = Object.create(null);
967     this._glyphCache = Object.create(null);
968 
969     let isSerifFont = !!(properties.flags & FontFlags.Serif);
970     // Fallback to checking the font name, in order to improve text-selection,
971     // since the /Flags-entry is often wrong (fixes issue13845.pdf).
972     if (!isSerifFont && !properties.isSimulatedFlags) {
973       const baseName = name.replaceAll(/[,_]/g, "-").split("-", 1)[0],
974         serifFonts = getSerifFonts();
975       for (const namePart of baseName.split("+")) {
976         if (serifFonts[namePart]) {
977           isSerifFont = true;
978           break;
979         }
980       }
981     }
982     this.isSerifFont = isSerifFont;
983 
984     this.isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
985     this.isMonospace = !!(properties.flags & FontFlags.FixedPitch);
986 
987     let { type, subtype } = properties;
988     this.type = type;
989     this.subtype = subtype;
990     this.systemFontInfo = properties.systemFontInfo;
991 
992     const matches = name.match(/^InvalidPDFjsFont_(.*)_\d+$/);
993     this.isInvalidPDFjsFont = !!matches;
994     if (this.isInvalidPDFjsFont) {
995       this.fallbackName = matches[1];
996     } else if (this.isMonospace) {
997       this.fallbackName = "monospace";
998     } else if (this.isSerifFont) {
999       this.fallbackName = "serif";
1000     } else {
1001       this.fallbackName = "sans-serif";
1002     }
1003 
1004     if (this.systemFontInfo?.guessFallback) {
1005       // Once the fallback name is guessed, we don't want to guess it again.
1006       this.systemFontInfo.guessFallback = false;
1007       this.systemFontInfo.css += `,${this.fallbackName}`;
1008     }
1009 
1010     this.differences = properties.differences;
1011     this.widths = properties.widths;
1012     this.defaultWidth = properties.defaultWidth;
1013     this.composite = properties.composite;
1014     this.cMap = properties.cMap;
1015     this.capHeight = properties.capHeight / PDF_GLYPH_SPACE_UNITS;
1016     this.ascent = properties.ascent / PDF_GLYPH_SPACE_UNITS;
1017     this.descent = properties.descent / PDF_GLYPH_SPACE_UNITS;
1018     this.lineHeight = this.ascent - this.descent;
1019     this.fontMatrix = properties.fontMatrix;
1020     this.bbox = properties.bbox;
1021     this.defaultEncoding = properties.defaultEncoding;
1022 
1023     this.toUnicode = properties.toUnicode;
1024     this.toFontChar = [];
1025 
1026     if (properties.type === "Type3") {
1027       for (let charCode = 0; charCode < 256; charCode++) {
1028         this.toFontChar[charCode] =
1029           this.differences[charCode] || properties.defaultEncoding[charCode];
1030       }
1031       return;
1032     }
1033 
1034     this.cidEncoding = properties.cidEncoding || "";
1035     this.vertical = !!properties.vertical;
1036     if (this.vertical) {
1037       this.vmetrics = properties.vmetrics;
1038       this.defaultVMetrics = properties.defaultVMetrics;
1039     }
1040 
1041     if (!file || file.isEmpty) {
1042       if (file) {
1043         // Some bad PDF generators will include empty font files,
1044         // attempting to recover by assuming that no file exists.
1045         warn('Font file is empty in "' + name + '" (' + this.loadedName + ")");
1046       }
1047       this.fallbackToSystemFont(properties);
1048       return;
1049     }
1050 
1051     // Parse the font file to determine the correct type/subtype, rather than
1052     // relying on the (often incorrect) data in the font dictionary; (see e.g.
1053     //  issue6782.pdf, issue7598.pdf, and issue9949.pdf).
1054     [type, subtype] = getFontFileType(file, properties);
1055 
1056     if (type !== this.type || subtype !== this.subtype) {
1057       info(
1058         "Inconsistent font file Type/SubType, expected: " +
1059           `${this.type}/${this.subtype} but found: ${type}/${subtype}.`
1060       );
1061     }
1062 
1063     let data;
1064     try {
1065       switch (type) {
1066         case "MMType1":
1067           info("MMType1 font (" + name + "), falling back to Type1.");
1068         /* falls through */
1069         case "Type1":
1070         case "CIDFontType0":
1071           this.mimetype = "font/opentype";
1072 
1073           const cff =
1074             subtype === "Type1C" || subtype === "CIDFontType0C"
1075               ? new CFFFont(file, properties)
1076               : new Type1Font(name, file, properties);
1077 
1078           adjustWidths(properties);
1079 
1080           // Wrap the CFF data inside an OTF font file
1081           data = this.convert(name, cff, properties);
1082           break;
1083 
1084         case "OpenType":
1085         case "TrueType":
1086         case "CIDFontType2":
1087           this.mimetype = "font/opentype";
1088 
1089           // Repair the TrueType file. It is can be damaged in the point of
1090           // view of the sanitizer
1091           data = this.checkAndRepair(name, file, properties);
1092           if (this.isOpenType) {
1093             adjustWidths(properties);
1094 
1095             type = "OpenType";
1096           }
1097           break;
1098 
1099         default:
1100           throw new FormatError(`Font ${type} is not supported`);
1101       }
1102     } catch (e) {
1103       warn(e);
1104       this.fallbackToSystemFont(properties);
1105       return;
1106     }
1107 
1108     amendFallbackToUnicode(properties);
1109     this.data = data;
1110 
1111     // Transfer some properties again that could change during font conversion
1112     this.type = type;
1113     this.subtype = subtype;
1114     this.fontMatrix = properties.fontMatrix;
1115     this.widths = properties.widths;
1116     this.defaultWidth = properties.defaultWidth;
1117     this.toUnicode = properties.toUnicode;
1118     this.seacMap = properties.seacMap;
1119   }
1120 
1294   checkAndRepair(name, font, properties) {
1295     const VALID_TABLES = [
1296       "OS/2",
1297       "cmap",
1298       "head",
1299       "hhea",
1300       "hmtx",
1301       "maxp",
1302       "name",
1303       "post",
1304       "loca",
1305       "glyf",
1306       "fpgm",
1307       "prep",
1308       "cvt ",
1309       "CFF ",
1310     ];
1311 
1312     function readTables(file, numTables) {
1313       const tables = Object.create(null);
1314       tables["OS/2"] = null;
1315       tables.cmap = null;
1316       tables.head = null;
1317       tables.hhea = null;
1318       tables.hmtx = null;
1319       tables.maxp = null;
1320       tables.name = null;
1321       tables.post = null;
1322 
1323       for (let i = 0; i < numTables; i++) {
1324         const table = readTableEntry(file);
1325         if (!VALID_TABLES.includes(table.tag)) {
1326           continue; // skipping table if it's not a required or optional table
1327         }
1328         if (table.length === 0) {
1329           continue; // skipping empty tables
1330         }
1331         tables[table.tag] = table;
1332       }
1333       return tables;
1334     }
1335 
1336     function readTableEntry(file) {
1337       const tag = file.getString(4);
1338 
1339       const checksum = file.getInt32() >>> 0;
1340       const offset = file.getInt32() >>> 0;
1341       const length = file.getInt32() >>> 0;
1342 
1343       // Read the table associated data
1344       const previousPosition = file.pos;
1345       file.pos = file.start || 0;
1346       file.skip(offset);
1347       const data = file.getBytes(length);
1348       file.pos = previousPosition;
1349 
1350       if (tag === "head") {
1351         // clearing checksum adjustment
1352         data[8] = data[9] = data[10] = data[11] = 0;
1353         data[17] |= 0x20; // Set font optimized for cleartype flag.
1354       }
1355 
1356       return {
1357         tag,
1358         checksum,
1359         length,
1360         offset,
1361         data,
1362       };
1363     }
1364 
1365     function readOpenTypeHeader(ttf) {
1366       return {
1367         version: ttf.getString(4),
1368         numTables: ttf.getUint16(),
1369         searchRange: ttf.getUint16(),
1370         entrySelector: ttf.getUint16(),
1371         rangeShift: ttf.getUint16(),
1372       };
1373     }
1374 
1375     function readTrueTypeCollectionHeader(ttc) {
1376       const ttcTag = ttc.getString(4);
1377       assert(ttcTag === "ttcf", "Must be a TrueType Collection font.");
1378 
1379       const majorVersion = ttc.getUint16();
1380       const minorVersion = ttc.getUint16();
1381       const numFonts = ttc.getInt32() >>> 0;
1382       const offsetTable = [];
1383       for (let i = 0; i < numFonts; i++) {
1384         offsetTable.push(ttc.getInt32() >>> 0);
1385       }
1386 
1387       const header = {
1388         ttcTag,
1389         majorVersion,
1390         minorVersion,
1391         numFonts,
1392         offsetTable,
1393       };
1394       switch (majorVersion) {
1395         case 1:
1396           return header;
1397         case 2:
1398           header.dsigTag = ttc.getInt32() >>> 0;
1399           header.dsigLength = ttc.getInt32() >>> 0;
1400           header.dsigOffset = ttc.getInt32() >>> 0;
1401           return header;
1402       }
1403       throw new FormatError(
1404         `Invalid TrueType Collection majorVersion: ${majorVersion}.`
1405       );
1406     }
1407 
1408     function readTrueTypeCollectionData(ttc, fontName) {
1409       const { numFonts, offsetTable } = readTrueTypeCollectionHeader(ttc);
1410       const fontNameParts = fontName.split("+");
1411       let fallbackData;
1412 
1413       for (let i = 0; i < numFonts; i++) {
1414         ttc.pos = (ttc.start || 0) + offsetTable[i];
1415         const potentialHeader = readOpenTypeHeader(ttc);
1416         const potentialTables = readTables(ttc, potentialHeader.numTables);
1417 
1418         if (!potentialTables.name) {
1419           throw new FormatError(
1420             'TrueType Collection font must contain a "name" table.'
1421           );
1422         }
1423         const [nameTable] = readNameTable(potentialTables.name);
1424 
1425         for (let j = 0, jj = nameTable.length; j < jj; j++) {
1426           for (let k = 0, kk = nameTable[j].length; k < kk; k++) {
1427             const nameEntry = nameTable[j][k]?.replaceAll(/\s/g, "");
1428             if (!nameEntry) {
1429               continue;
1430             }
1431             if (nameEntry === fontName) {
1432               return {
1433                 header: potentialHeader,
1434                 tables: potentialTables,
1435               };
1436             }
1437             if (fontNameParts.length < 2) {
1438               continue;
1439             }
1440             for (const part of fontNameParts) {
1441               if (nameEntry === part) {
1442                 fallbackData = {
1443                   name: part,
1444                   header: potentialHeader,
1445                   tables: potentialTables,
1446                 };
1447               }
1448             }
1449           }
1450         }
1451       }
1452       if (fallbackData) {
1453         warn(
1454           `TrueType Collection does not contain "${fontName}" font, ` +
1455             `falling back to "${fallbackData.name}" font instead.`
1456         );
1457         return {
1458           header: fallbackData.header,
1459           tables: fallbackData.tables,
1460         };
1461       }
1462       throw new FormatError(
1463         `TrueType Collection does not contain "${fontName}" font.`
1464       );
1465     }
1466 
1467     /**
1468      * Read the appropriate subtable from the cmap according to 9.6.6.4 from
1469      * PDF spec
1470      */
1471     function readCmapTable(cmap, file, isSymbolicFont, hasEncoding) {
1472       if (!cmap) {
1473         warn("No cmap table available.");
1474         return {
1475           platformId: -1,
1476           encodingId: -1,
1477           mappings: [],
1478           hasShortCmap: false,
1479         };
1480       }
1481       let segment;
1482       let start = (file.start || 0) + cmap.offset;
1483       file.pos = start;
1484 
1485       file.skip(2); // version
1486       const numTables = file.getUint16();
1487 
1488       let potentialTable;
1489       let canBreak = false;
1490       // There's an order of preference in terms of which cmap subtable to
1491       // use:
1492       // - non-symbolic fonts the preference is a 3,1 table then a 1,0 table
1493       // - symbolic fonts the preference is a 3,0 table then a 1,0 table
1494       // The following takes advantage of the fact that the tables are sorted
1495       // to work.
1496       for (let i = 0; i < numTables; i++) {
1497         const platformId = file.getUint16();
1498         const encodingId = file.getUint16();
1499         const offset = file.getInt32() >>> 0;
1500         let useTable = false;
1501 
1502         // Sometimes there are multiple of the same type of table. Default
1503         // to choosing the first table and skip the rest.
1504         if (
1505           potentialTable?.platformId === platformId &&
1506           potentialTable?.encodingId === encodingId
1507         ) {
1508           continue;
1509         }
1510 
1511         if (
1512           platformId === 0 &&
1513           (encodingId === /* Unicode Default */ 0 ||
1514             encodingId === /* Unicode 1.1 */ 1 ||
1515             encodingId === /* Unicode BMP */ 3)
1516         ) {
1517           useTable = true;
1518           // Continue the loop since there still may be a higher priority
1519           // table.
1520         } else if (platformId === 1 && encodingId === 0) {
1521           useTable = true;
1522           // Continue the loop since there still may be a higher priority
1523           // table.
1524         } else if (
1525           platformId === 3 &&
1526           encodingId === 1 &&
1527           (hasEncoding || !potentialTable)
1528         ) {
1529           useTable = true;
1530           if (!isSymbolicFont) {
1531             canBreak = true;
1532           }
1533         } else if (isSymbolicFont && platformId === 3 && encodingId === 0) {
1534           useTable = true;
1535 
1536           let correctlySorted = true;
1537           if (i < numTables - 1) {
1538             const nextBytes = file.peekBytes(2),
1539               nextPlatformId = int16(nextBytes[0], nextBytes[1]);
1540             if (nextPlatformId < platformId) {
1541               correctlySorted = false;
1542             }
1543           }
1544           if (correctlySorted) {
1545             canBreak = true;
1546           }
1547         }
1548 
1549         if (useTable) {
1550           potentialTable = {
1551             platformId,
1552             encodingId,
1553             offset,
1554           };
1555         }
1556         if (canBreak) {
1557           break;
1558         }
1559       }
1560 
1561       if (potentialTable) {
1562         file.pos = start + potentialTable.offset;
1563       }
1564       if (!potentialTable || file.peekByte() === -1) {
1565         warn("Could not find a preferred cmap table.");
1566         return {
1567           platformId: -1,
1568           encodingId: -1,
1569           mappings: [],
1570           hasShortCmap: false,
1571         };
1572       }
1573 
1574       const format = file.getUint16();
1575       let hasShortCmap = false;
1576       const mappings = [];
1577       let j, glyphId;
1578 
1579       // TODO(mack): refactor this cmap subtable reading logic out
1580       if (format === 0) {
1581         file.skip(2 + 2); // length + language
1582 
1583         for (j = 0; j < 256; j++) {
1584           const index = file.getByte();
1585           if (!index) {
1586             continue;
1587           }
1588           mappings.push({
1589             charCode: j,
1590             glyphId: index,
1591           });
1592         }
1593         hasShortCmap = true;
1594       } else if (format === 2) {
1595         file.skip(2 + 2); // length + language
1596 
1597         const subHeaderKeys = [];
1598         let maxSubHeaderKey = 0;
1599         // Read subHeaderKeys. If subHeaderKeys[i] === 0, then i is a
1600         // single-byte character. Otherwise, i is the first byte of a
1601         // multi-byte character, and the value is 8*index into
1602         // subHeaders.
1603         for (let i = 0; i < 256; i++) {
1604           const subHeaderKey = file.getUint16() >> 3;
1605           subHeaderKeys.push(subHeaderKey);
1606           maxSubHeaderKey = Math.max(subHeaderKey, maxSubHeaderKey);
1607         }
1608         // Read subHeaders. The number of entries is determined
1609         // dynamically based on the subHeaderKeys found above.
1610         const subHeaders = [];
1611         for (let i = 0; i <= maxSubHeaderKey; i++) {
1612           subHeaders.push({
1613             firstCode: file.getUint16(),
1614             entryCount: file.getUint16(),
1615             idDelta: signedInt16(file.getByte(), file.getByte()),
1616             idRangePos: file.pos + file.getUint16(),
1617           });
1618         }
1619         for (let i = 0; i < 256; i++) {
1620           if (subHeaderKeys[i] === 0) {
1621             // i is a single-byte code.
1622             file.pos = subHeaders[0].idRangePos + 2 * i;
1623             glyphId = file.getUint16();
1624             mappings.push({
1625               charCode: i,
1626               glyphId,
1627             });
1628           } else {
1629             // i is the first byte of a two-byte code.
1630             const s = subHeaders[subHeaderKeys[i]];
1631             for (j = 0; j < s.entryCount; j++) {
1632               const charCode = (i << 8) + j + s.firstCode;
1633               file.pos = s.idRangePos + 2 * j;
1634               glyphId = file.getUint16();
1635               if (glyphId !== 0) {
1636                 glyphId = (glyphId + s.idDelta) % 65536;
1637               }
1638               mappings.push({
1639                 charCode,
1640                 glyphId,
1641               });
1642             }
1643           }
1644         }
1645       } else if (format === 4) {
1646         file.skip(2 + 2); // length + language
1647 
1648         // re-creating the table in format 4 since the encoding
1649         // might be changed
1650         const segCount = file.getUint16() >> 1;
1651         file.skip(6); // skipping range fields
1652         const segments = [];
1653         let segIndex;
1654         for (segIndex = 0; segIndex < segCount; segIndex++) {
1655           segments.push({ end: file.getUint16() });
1656         }
1657         file.skip(2);
1658         for (segIndex = 0; segIndex < segCount; segIndex++) {
1659           segments[segIndex].start = file.getUint16();
1660         }
1661 
1662         for (segIndex = 0; segIndex < segCount; segIndex++) {
1663           segments[segIndex].delta = file.getUint16();
1664         }
1665 
1666         let offsetsCount = 0,
1667           offsetIndex;
1668         for (segIndex = 0; segIndex < segCount; segIndex++) {
1669           segment = segments[segIndex];
1670           const rangeOffset = file.getUint16();
1671           if (!rangeOffset) {
1672             segment.offsetIndex = -1;
1673             continue;
1674           }
1675 
1676           offsetIndex = (rangeOffset >> 1) - (segCount - segIndex);
1677           segment.offsetIndex = offsetIndex;
1678           offsetsCount = Math.max(
1679             offsetsCount,
1680             offsetIndex + segment.end - segment.start + 1
1681           );
1682         }
1683 
1684         const offsets = [];
1685         for (j = 0; j < offsetsCount; j++) {
1686           offsets.push(file.getUint16());
1687         }
1688 
1689         for (segIndex = 0; segIndex < segCount; segIndex++) {
1690           segment = segments[segIndex];
1691           start = segment.start;
1692           const end = segment.end;
1693           const delta = segment.delta;
1694           offsetIndex = segment.offsetIndex;
1695 
1696           for (j = start; j <= end; j++) {
1697             if (j === 0xffff) {
1698               continue;
1699             }
1700 
1701             glyphId = offsetIndex < 0 ? j : offsets[offsetIndex + j - start];
1702             glyphId = (glyphId + delta) & 0xffff;
1703             mappings.push({
1704               charCode: j,
1705               glyphId,
1706             });
1707           }
1708         }
1709       } else if (format === 6) {
1710         file.skip(2 + 2); // length + language
1711 
1712         // Format 6 is a 2-bytes dense mapping, which means the font data
1713         // lives glue together even if they are pretty far in the unicode
1714         // table. (This looks weird, so I can have missed something), this
1715         // works on Linux but seems to fails on Mac so let's rewrite the
1716         // cmap table to a 3-1-4 style
1717         const firstCode = file.getUint16();
1718         const entryCount = file.getUint16();
1719 
1720         for (j = 0; j < entryCount; j++) {
1721           glyphId = file.getUint16();
1722           const charCode = firstCode + j;
1723 
1724           mappings.push({
1725             charCode,
1726             glyphId,
1727           });
1728         }
1729       } else if (format === 12) {
1730         file.skip(2 + 4 + 4); // reserved + length + language
1731 
1732         const nGroups = file.getInt32() >>> 0;
1733         for (j = 0; j < nGroups; j++) {
1734           const startCharCode = file.getInt32() >>> 0;
1735           const endCharCode = file.getInt32() >>> 0;
1736           let glyphCode = file.getInt32() >>> 0;
1737 
1738           for (
1739             let charCode = startCharCode;
1740             charCode <= endCharCode;
1741             charCode++
1742           ) {
1743             mappings.push({
1744               charCode,
1745               glyphId: glyphCode++,
1746             });
1747           }
1748         }
1749       } else {
1750         warn("cmap table has unsupported format: " + format);
1751         return {
1752           platformId: -1,
1753           encodingId: -1,
1754           mappings: [],
1755           hasShortCmap: false,
1756         };
1757       }
1758 
1759       // removing duplicate entries
1760       mappings.sort(function (a, b) {
1761         return a.charCode - b.charCode;
1762       });
1763       for (let i = 1; i < mappings.length; i++) {
1764         if (mappings[i - 1].charCode === mappings[i].charCode) {
1765           mappings.splice(i, 1);
1766           i--;
1767         }
1768       }
1769 
1770       return {
1771         platformId: potentialTable.platformId,
1772         encodingId: potentialTable.encodingId,
1773         mappings,
1774         hasShortCmap,
1775       };
1776     }
1777 
1778     function sanitizeMetrics(
1779       file,
1780       header,
1781       metrics,
1782       headTable,
1783       numGlyphs,
1784       dupFirstEntry
1785     ) {
1786       if (!header) {
1787         if (metrics) {
1788           metrics.data = null;
1789         }
1790         return;
1791       }
1792 
1793       file.pos = (file.start || 0) + header.offset;
1794       file.pos += 4; // version
1795       file.pos += 2; // ascent
1796       file.pos += 2; // descent
1797       file.pos += 2; // linegap
1798       file.pos += 2; // adv_width_max
1799       file.pos += 2; // min_sb1
1800       file.pos += 2; // min_sb2
1801       file.pos += 2; // max_extent
1802       file.pos += 2; // caret_slope_rise
1803       file.pos += 2; // caret_slope_run
1804       const caretOffset = file.getUint16();
1805       file.pos += 8; // reserved
1806       file.pos += 2; // format
1807       let numOfMetrics = file.getUint16();
1808 
1809       if (caretOffset !== 0) {
1810         const macStyle = int16(headTable.data[44], headTable.data[45]);
1811         if (!(macStyle & 2)) {
1812           // Suppress OTS warnings about the `caretOffset` in the hhea-table.
1813           header.data[22] = 0;
1814           header.data[23] = 0;
1815         }
1816       }
1817 
1818       if (numOfMetrics > numGlyphs) {
1819         info(
1820           `The numOfMetrics (${numOfMetrics}) should not be ` +
1821             `greater than the numGlyphs (${numGlyphs}).`
1822         );
1823         // Reduce numOfMetrics if it is greater than numGlyphs
1824         numOfMetrics = numGlyphs;
1825         header.data[34] = (numOfMetrics & 0xff00) >> 8;
1826         header.data[35] = numOfMetrics & 0x00ff;
1827       }
1828 
1829       const numOfSidebearings = numGlyphs - numOfMetrics;
1830       const numMissing =
1831         numOfSidebearings - ((metrics.length - numOfMetrics * 4) >> 1);
1832 
1833       if (numMissing > 0) {
1834         // For each missing glyph, we set both the width and lsb to 0 (zero).
1835         // Since we need to add two properties for each glyph, this explains
1836         // the use of |numMissing * 2| when initializing the typed array.
1837         const entries = new Uint8Array(metrics.length + numMissing * 2);
1838         entries.set(metrics.data);
1839         if (dupFirstEntry) {
1840           // Set the sidebearing value of the duplicated glyph.
1841           entries[metrics.length] = metrics.data[2];
1842           entries[metrics.length + 1] = metrics.data[3];
1843         }
1844         metrics.data = entries;
1845       }
1846     }
1847 
1848     function sanitizeGlyph(
1849       source,
1850       sourceStart,
1851       sourceEnd,
1852       dest,
1853       destStart,
1854       hintsValid
1855     ) {
1856       const glyphProfile = {
1857         length: 0,
1858         sizeOfInstructions: 0,
1859       };
1860       if (
1861         sourceStart < 0 ||
1862         sourceStart >= source.length ||
1863         sourceEnd > source.length ||
1864         sourceEnd - sourceStart <= 12
1865       ) {
1866         // If the offsets are wrong or the glyph is too small, remove it.
1867         return glyphProfile;
1868       }
1869       const glyf = source.subarray(sourceStart, sourceEnd);
1870 
1871       // Sanitize the glyph bounding box.
1872       const xMin = signedInt16(glyf[2], glyf[3]);
1873       const yMin = signedInt16(glyf[4], glyf[5]);
1874       const xMax = signedInt16(glyf[6], glyf[7]);
1875       const yMax = signedInt16(glyf[8], glyf[9]);
1876 
1877       if (xMin > xMax) {
1878         writeSignedInt16(glyf, 2, xMax);
1879         writeSignedInt16(glyf, 6, xMin);
1880       }
1881       if (yMin > yMax) {
1882         writeSignedInt16(glyf, 4, yMax);
1883         writeSignedInt16(glyf, 8, yMin);
1884       }
1885 
1886       const contoursCount = signedInt16(glyf[0], glyf[1]);
1887       if (contoursCount < 0) {
1888         if (contoursCount < -1) {
1889           // OTS doesn't like contour count to be less than -1.
1890           // The glyph data offsets are very likely wrong and
1891           // having something lower than -1, very likely, implies
1892           // to have some garbage data.
1893           return glyphProfile;
1894         }
1895         // complex glyph, writing as is
1896         dest.set(glyf, destStart);
1897         glyphProfile.length = glyf.length;
1898         return glyphProfile;
1899       }
1900 
1901       let i,
1902         j = 10,
1903         flagsCount = 0;
1904       for (i = 0; i < contoursCount; i++) {
1905         const endPoint = (glyf[j] << 8) | glyf[j + 1];
1906         flagsCount = endPoint + 1;
1907         j += 2;
1908       }
1909       // skipping instructions
1910       const instructionsStart = j;
1911       const instructionsLength = (glyf[j] << 8) | glyf[j + 1];
1912       glyphProfile.sizeOfInstructions = instructionsLength;
1913       j += 2 + instructionsLength;
1914       const instructionsEnd = j;
1915       // validating flags
1916       let coordinatesLength = 0;
1917       for (i = 0; i < flagsCount; i++) {
1918         const flag = glyf[j++];
1919         if (flag & 0xc0) {
1920           // reserved flags must be zero, cleaning up
1921           glyf[j - 1] = flag & 0x3f;
1922         }
1923         let xLength = 2;
1924         if (flag & 2) {
1925           xLength = 1;
1926         } else if (flag & 16) {
1927           xLength = 0;
1928         }
1929         let yLength = 2;
1930         if (flag & 4) {
1931           yLength = 1;
1932         } else if (flag & 32) {
1933           yLength = 0;
1934         }
1935         const xyLength = xLength + yLength;
1936         coordinatesLength += xyLength;
1937         if (flag & 8) {
1938           const repeat = glyf[j++];
1939           if (repeat === 0) {
1940             // The repeat count should be non-zero when the repeat flag is set.
1941             glyf[j - 1] ^= 8;
1942           }
1943           i += repeat;
1944           coordinatesLength += repeat * xyLength;
1945         }
1946       }
1947       // glyph without coordinates will be rejected
1948       if (coordinatesLength === 0) {
1949         return glyphProfile;
1950       }
1951       let glyphDataLength = j + coordinatesLength;
1952       if (glyphDataLength > glyf.length) {
1953         // not enough data for coordinates
1954         return glyphProfile;
1955       }
1956       if (!hintsValid && instructionsLength > 0) {
1957         dest.set(glyf.subarray(0, instructionsStart), destStart);
1958         dest.set([0, 0], destStart + instructionsStart);
1959         dest.set(
1960           glyf.subarray(instructionsEnd, glyphDataLength),
1961           destStart + instructionsStart + 2
1962         );
1963         glyphDataLength -= instructionsLength;
1964         if (glyf.length - glyphDataLength > 3) {
1965           glyphDataLength = (glyphDataLength + 3) & ~3;
1966         }
1967         glyphProfile.length = glyphDataLength;
1968         return glyphProfile;
1969       }
1970       if (glyf.length - glyphDataLength > 3) {
1971         // truncating and aligning to 4 bytes the long glyph data
1972         glyphDataLength = (glyphDataLength + 3) & ~3;
1973         dest.set(glyf.subarray(0, glyphDataLength), destStart);
1974         glyphProfile.length = glyphDataLength;
1975         return glyphProfile;
1976       }
1977       // glyph data is fine
1978       dest.set(glyf, destStart);
1979       glyphProfile.length = glyf.length;
1980       return glyphProfile;
1981     }
1982 
1983     function sanitizeHead(head, numGlyphs, locaLength) {
1984       const data = head.data;
1985 
1986       // Validate version:
1987       // Should always be 0x00010000
1988       const version = int32(data[0], data[1], data[2], data[3]);
1989       if (version >> 16 !== 1) {
1990         info("Attempting to fix invalid version in head table: " + version);
1991         data[0] = 0;
1992         data[1] = 1;
1993         data[2] = 0;
1994         data[3] = 0;
1995       }
1996 
1997       const indexToLocFormat = int16(data[50], data[51]);
1998       if (indexToLocFormat < 0 || indexToLocFormat > 1) {
1999         info(
2000           "Attempting to fix invalid indexToLocFormat in head table: " +
2001             indexToLocFormat
2002         );
2003 
2004         // The value of indexToLocFormat should be 0 if the loca table
2005         // consists of short offsets, and should be 1 if the loca table
2006         // consists of long offsets.
2007         //
2008         // The number of entries in the loca table should be numGlyphs + 1.
2009         //
2010         // Using this information, we can work backwards to deduce if the
2011         // size of each offset in the loca table, and thus figure out the
2012         // appropriate value for indexToLocFormat.
2013 
2014         const numGlyphsPlusOne = numGlyphs + 1;
2015         if (locaLength === numGlyphsPlusOne << 1) {
2016           // 0x0000 indicates the loca table consists of short offsets
2017           data[50] = 0;
2018           data[51] = 0;
2019         } else if (locaLength === numGlyphsPlusOne << 2) {
2020           // 0x0001 indicates the loca table consists of long offsets
2021           data[50] = 0;
2022           data[51] = 1;
2023         } else {
2024           throw new FormatError(
2025             "Could not fix indexToLocFormat: " + indexToLocFormat
2026           );
2027         }
2028       }
2029     }
2030 
2031     function sanitizeGlyphLocations(
2032       loca,
2033       glyf,
2034       numGlyphs,
2035       isGlyphLocationsLong,
2036       hintsValid,
2037       dupFirstEntry,
2038       maxSizeOfInstructions
2039     ) {
2040       let itemSize, itemDecode, itemEncode;
2041       if (isGlyphLocationsLong) {
2042         itemSize = 4;
2043         itemDecode = function fontItemDecodeLong(data, offset) {
2044           return (
2045             (data[offset] << 24) |
2046             (data[offset + 1] << 16) |
2047             (data[offset + 2] << 8) |
2048             data[offset + 3]
2049           );
2050         };
2051         itemEncode = function fontItemEncodeLong(data, offset, value) {
2052           data[offset] = (value >>> 24) & 0xff;
2053           data[offset + 1] = (value >> 16) & 0xff;
2054           data[offset + 2] = (value >> 8) & 0xff;
2055           data[offset + 3] = value & 0xff;
2056         };
2057       } else {
2058         itemSize = 2;
2059         itemDecode = function fontItemDecode(data, offset) {
2060           return (data[offset] << 9) | (data[offset + 1] << 1);
2061         };
2062         itemEncode = function fontItemEncode(data, offset, value) {
2063           data[offset] = (value >> 9) & 0xff;
2064           data[offset + 1] = (value >> 1) & 0xff;
2065         };
2066       }
2067       // The first glyph is duplicated.
2068       const numGlyphsOut = dupFirstEntry ? numGlyphs + 1 : numGlyphs;
2069       const locaDataSize = itemSize * (1 + numGlyphsOut);
2070       // Resize loca table to account for duplicated glyph.
2071       const locaData = new Uint8Array(locaDataSize);
2072       locaData.set(loca.data.subarray(0, locaDataSize));
2073       loca.data = locaData;
2074       // removing the invalid glyphs
2075       const oldGlyfData = glyf.data;
2076       const oldGlyfDataLength = oldGlyfData.length;
2077       const newGlyfData = new Uint8Array(oldGlyfDataLength);
2078 
2079       // The spec says the offsets should be in ascending order, however
2080       // this is not true for some fonts or they use the offset of 0 to mark a
2081       // glyph as missing. OTS requires the offsets to be in order and not to
2082       // be zero, so we must sort and rebuild the loca table and potentially
2083       // re-arrange the glyf data.
2084       let i, j;
2085       const locaEntries = [];
2086       // There are numGlyphs + 1 loca table entries.
2087       for (i = 0, j = 0; i < numGlyphs + 1; i++, j += itemSize) {
2088         let offset = itemDecode(locaData, j);
2089         if (offset > oldGlyfDataLength) {
2090           offset = oldGlyfDataLength;
2091         }
2092         locaEntries.push({
2093           index: i,
2094           offset,
2095           endOffset: 0,
2096         });
2097       }
2098       locaEntries.sort((a, b) => a.offset - b.offset);
2099       // Now the offsets are sorted, calculate the end offset of each glyph.
2100       // The last loca entry's endOffset is not calculated since it's the end
2101       // of the data and will be stored on the previous entry's endOffset.
2102       for (i = 0; i < numGlyphs; i++) {
2103         locaEntries[i].endOffset = locaEntries[i + 1].offset;
2104       }
2105       // Re-sort so glyphs aren't out of order.
2106       locaEntries.sort((a, b) => a.index - b.index);
2107       // Calculate the endOffset of the "first" glyph correctly when there are
2108       // *multiple* empty ones at the start of the data (fixes issue14618.pdf).
2109       for (i = 0; i < numGlyphs; i++) {
2110         const { offset, endOffset } = locaEntries[i];
2111         if (offset !== 0 || endOffset !== 0) {
2112           break;
2113         }
2114         const nextOffset = locaEntries[i + 1].offset;
2115         if (nextOffset === 0) {
2116           continue;
2117         }
2118         locaEntries[i].endOffset = nextOffset;
2119         break;
2120       }
2121 
2122       // If the last offset is 0 in the loca table then we can't compute the
2123       // endOffset for the last glyph. So in such a case we set the endOffset
2124       // to the end of the data (fixes issue #17671).
2125       const last = locaEntries.at(-2);
2126       if (last.offset !== 0 && last.endOffset === 0) {
2127         last.endOffset = oldGlyfDataLength;
2128       }
2129 
2130       const missingGlyphs = Object.create(null);
2131       let writeOffset = 0;
2132       itemEncode(locaData, 0, writeOffset);
2133       for (i = 0, j = itemSize; i < numGlyphs; i++, j += itemSize) {
2134         const glyphProfile = sanitizeGlyph(
2135           oldGlyfData,
2136           locaEntries[i].offset,
2137           locaEntries[i].endOffset,
2138           newGlyfData,
2139           writeOffset,
2140           hintsValid
2141         );
2142         const newLength = glyphProfile.length;
2143         if (newLength === 0) {
2144           missingGlyphs[i] = true;
2145         }
2146         if (glyphProfile.sizeOfInstructions > maxSizeOfInstructions) {
2147           maxSizeOfInstructions = glyphProfile.sizeOfInstructions;
2148         }
2149         writeOffset += newLength;
2150         itemEncode(locaData, j, writeOffset);
2151       }
2152 
2153       if (writeOffset === 0) {
2154         // glyf table cannot be empty -- redoing the glyf and loca tables
2155         // to have single glyph with one point
2156         const simpleGlyph = new Uint8Array([
2157           0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0,
2158         ]);
2159         for (i = 0, j = itemSize; i < numGlyphsOut; i++, j += itemSize) {
2160           itemEncode(locaData, j, simpleGlyph.length);
2161         }
2162         glyf.data = simpleGlyph;
2163       } else if (dupFirstEntry) {
2164         // Browsers will not display a glyph at position 0. Typically glyph 0
2165         // is notdef, but a number of fonts put a valid glyph there so it must
2166         // be duplicated and appended.
2167         const firstEntryLength = itemDecode(locaData, itemSize);
2168         if (newGlyfData.length > firstEntryLength + writeOffset) {
2169           glyf.data = newGlyfData.subarray(0, firstEntryLength + writeOffset);
2170         } else {
2171           glyf.data = new Uint8Array(firstEntryLength + writeOffset);
2172           glyf.data.set(newGlyfData.subarray(0, writeOffset));
2173         }
2174         glyf.data.set(newGlyfData.subarray(0, firstEntryLength), writeOffset);
2175         itemEncode(
2176           loca.data,
2177           locaData.length - itemSize,
2178           writeOffset + firstEntryLength
2179         );
2180       } else {
2181         glyf.data = newGlyfData.subarray(0, writeOffset);
2182       }
2183       return {
2184         missingGlyphs,
2185         maxSizeOfInstructions,
2186       };
2187     }
2188 
2189     function readPostScriptTable(post, propertiesObj, maxpNumGlyphs) {
2190       const start = (font.start || 0) + post.offset;
2191       font.pos = start;
2192 
2193       const length = post.length,
2194         end = start + length;
2195       const version = font.getInt32();
2196       // skip rest to the tables
2197       font.skip(28);
2198 
2199       let glyphNames;
2200       let valid = true;
2201       let i;
2202 
2203       switch (version) {
2204         case 0x00010000:
2205           glyphNames = MacStandardGlyphOrdering;
2206           break;
2207         case 0x00020000:
2208           const numGlyphs = font.getUint16();
2209           if (numGlyphs !== maxpNumGlyphs) {
2210             valid = false;
2211             break;
2212           }
2213           const glyphNameIndexes = [];
2214           for (i = 0; i < numGlyphs; ++i) {
2215             const index = font.getUint16();
2216             if (index >= 32768) {
2217               valid = false;
2218               break;
2219             }
2220             glyphNameIndexes.push(index);
2221           }
2222           if (!valid) {
2223             break;
2224           }
2225           const customNames = [],
2226             strBuf = [];
2227           while (font.pos < end) {
2228             const stringLength = font.getByte();
2229             strBuf.length = stringLength;
2230             for (i = 0; i < stringLength; ++i) {
2231               strBuf[i] = String.fromCharCode(font.getByte());
2232             }
2233             customNames.push(strBuf.join(""));
2234           }
2235           glyphNames = [];
2236           for (i = 0; i < numGlyphs; ++i) {
2237             const j = glyphNameIndexes[i];
2238             if (j < 258) {
2239               glyphNames.push(MacStandardGlyphOrdering[j]);
2240               continue;
2241             }
2242             glyphNames.push(customNames[j - 258]);
2243           }
2244           break;
2245         case 0x00030000:
2246           break;
2247         default:
2248           warn("Unknown/unsupported post table version " + version);
2249           valid = false;
2250           if (propertiesObj.defaultEncoding) {
2251             glyphNames = propertiesObj.defaultEncoding;
2252           }
2253           break;
2254       }
2255       propertiesObj.glyphNames = glyphNames;
2256       return valid;
2257     }
2258 
2259     function readNameTable(nameTable) {
2260       const start = (font.start || 0) + nameTable.offset;
2261       font.pos = start;
2262 
2263       const names = [[], []],
2264         records = [];
2265       const length = nameTable.length,
2266         end = start + length;
2267       const format = font.getUint16();
2268       const FORMAT_0_HEADER_LENGTH = 6;
2269       if (format !== 0 || length < FORMAT_0_HEADER_LENGTH) {
2270         // unsupported name table format or table "too" small
2271         return [names, records];
2272       }
2273       const numRecords = font.getUint16();
2274       const stringsStart = font.getUint16();
2275       const NAME_RECORD_LENGTH = 12;
2276       let i, ii;
2277 
2278       for (i = 0; i < numRecords && font.pos + NAME_RECORD_LENGTH <= end; i++) {
2279         const r = {
2280           platform: font.getUint16(),
2281           encoding: font.getUint16(),
2282           language: font.getUint16(),
2283           name: font.getUint16(),
2284           length: font.getUint16(),
2285           offset: font.getUint16(),
2286         };
2287         // using only Macintosh and Windows platform/encoding names
2288         if (isMacNameRecord(r) || isWinNameRecord(r)) {
2289           records.push(r);
2290         }
2291       }
2292       for (i = 0, ii = records.length; i < ii; i++) {
2293         const record = records[i];
2294         if (record.length <= 0) {
2295           continue; // Nothing to process, ignoring.
2296         }
2297         const pos = start + stringsStart + record.offset;
2298         if (pos + record.length > end) {
2299           continue; // outside of name table, ignoring
2300         }
2301         font.pos = pos;
2302         const nameIndex = record.name;
2303         if (record.encoding) {
2304           // unicode
2305           let str = "";
2306           for (let j = 0, jj = record.length; j < jj; j += 2) {
2307             str += String.fromCharCode(font.getUint16());
2308           }
2309           names[1][nameIndex] = str;
2310         } else {
2311           names[0][nameIndex] = font.getString(record.length);
2312         }
2313       }
2314       return [names, records];
2315     }
2316 
2317     // prettier-ignore
2318     const TTOpsStackDeltas = [
2319       0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5,
2320       -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1,
2321       1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1,
2322       0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2,
2323       0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1,
2324       -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1,
2325       -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2326       -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1,
2327       -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
2328     // 0xC0-DF == -1 and 0xE0-FF == -2
2329 
2330     function sanitizeTTProgram(table, ttContext) {
2331       let data = table.data;
2332       let i = 0,
2333         j,
2334         n,
2335         b,
2336         funcId,
2337         pc,
2338         lastEndf = 0,
2339         lastDeff = 0;
2340       const stack = [];
2341       const callstack = [];
2342       const functionsCalled = [];
2343       let tooComplexToFollowFunctions = ttContext.tooComplexToFollowFunctions;
2344       let inFDEF = false,
2345         ifLevel = 0,
2346         inELSE = 0;
2347       for (let ii = data.length; i < ii; ) {
2348         const op = data[i++];
2349         // The TrueType instruction set docs can be found at
2350         // https://developer.apple.com/fonts/TTRefMan/RM05/Chap5.html
2351         if (op === 0x40) {
2352           // NPUSHB - pushes n bytes
2353           n = data[i++];
2354           if (inFDEF || inELSE) {
2355             i += n;
2356           } else {
2357             for (j = 0; j < n; j++) {
2358               stack.push(data[i++]);
2359             }
2360           }
2361         } else if (op === 0x41) {
2362           // NPUSHW - pushes n words
2363           n = data[i++];
2364           if (inFDEF || inELSE) {
2365             i += n * 2;
2366           } else {
2367             for (j = 0; j < n; j++) {
2368               b = data[i++];
2369               stack.push((b << 8) | data[i++]);
2370             }
2371           }
2372         } else if ((op & 0xf8) === 0xb0) {
2373           // PUSHB - pushes bytes
2374           n = op - 0xb0 + 1;
2375           if (inFDEF || inELSE) {
2376             i += n;
2377           } else {
2378             for (j = 0; j < n; j++) {
2379               stack.push(data[i++]);
2380             }
2381           }
2382         } else if ((op & 0xf8) === 0xb8) {
2383           // PUSHW - pushes words
2384           n = op - 0xb8 + 1;
2385           if (inFDEF || inELSE) {
2386             i += n * 2;
2387           } else {
2388             for (j = 0; j < n; j++) {
2389               b = data[i++];
2390               stack.push(signedInt16(b, data[i++]));
2391             }
2392           }
2393         } else if (op === 0x2b && !tooComplexToFollowFunctions) {
2394           // CALL
2395           if (!inFDEF && !inELSE) {
2396             // collecting information about which functions are used
2397             funcId = stack.at(-1);
2398             if (isNaN(funcId)) {
2399               info("TT: CALL empty stack (or invalid entry).");
2400             } else {
2401               ttContext.functionsUsed[funcId] = true;
2402               if (funcId in ttContext.functionsStackDeltas) {
2403                 const newStackLength =
2404                   stack.length + ttContext.functionsStackDeltas[funcId];
2405                 if (newStackLength < 0) {
2406                   warn("TT: CALL invalid functions stack delta.");
2407                   ttContext.hintsValid = false;
2408                   return;
2409                 }
2410                 stack.length = newStackLength;
2411               } else if (
2412                 funcId in ttContext.functionsDefined &&
2413                 !functionsCalled.includes(funcId)
2414               ) {
2415                 callstack.push({ data, i, stackTop: stack.length - 1 });
2416                 functionsCalled.push(funcId);
2417                 pc = ttContext.functionsDefined[funcId];
2418                 if (!pc) {
2419                   warn("TT: CALL non-existent function");
2420                   ttContext.hintsValid = false;
2421                   return;
2422                 }
2423                 data = pc.data;
2424                 i = pc.i;
2425               }
2426             }
2427           }
2428         } else if (op === 0x2c && !tooComplexToFollowFunctions) {
2429           // FDEF
2430           if (inFDEF || inELSE) {
2431             warn("TT: nested FDEFs not allowed");
2432             tooComplexToFollowFunctions = true;
2433           }
2434           inFDEF = true;
2435           // collecting information about which functions are defined
2436           lastDeff = i;
2437           funcId = stack.pop();
2438           ttContext.functionsDefined[funcId] = { data, i };
2439         } else if (op === 0x2d) {
2440           // ENDF - end of function
2441           if (inFDEF) {
2442             inFDEF = false;
2443             lastEndf = i;
2444           } else {
2445             pc = callstack.pop();
2446             if (!pc) {
2447               warn("TT: ENDF bad stack");
2448               ttContext.hintsValid = false;
2449               return;
2450             }
2451             funcId = functionsCalled.pop();
2452             data = pc.data;
2453             i = pc.i;
2454             ttContext.functionsStackDeltas[funcId] = stack.length - pc.stackTop;
2455           }
2456         } else if (op === 0x89) {
2457           // IDEF - instruction definition
2458           if (inFDEF || inELSE) {
2459             warn("TT: nested IDEFs not allowed");
2460             tooComplexToFollowFunctions = true;
2461           }
2462           inFDEF = true;
2463           // recording it as a function to track ENDF
2464           lastDeff = i;
2465         } else if (op === 0x58) {
2466           // IF
2467           ++ifLevel;
2468         } else if (op === 0x1b) {
2469           // ELSE
2470           inELSE = ifLevel;
2471         } else if (op === 0x59) {
2472           // EIF
2473           if (inELSE === ifLevel) {
2474             inELSE = 0;
2475           }
2476           --ifLevel;
2477         } else if (op === 0x1c) {
2478           // JMPR
2479           if (!inFDEF && !inELSE) {
2480             const offset = stack.at(-1);
2481             // only jumping forward to prevent infinite loop
2482             if (offset > 0) {
2483               i += offset - 1;
2484             }
2485           }
2486         }
2487         // Adjusting stack not extactly, but just enough to get function id
2488         if (!inFDEF && !inELSE) {
2489           let stackDelta = 0;
2490           if (op <= 0x8e) {
2491             stackDelta = TTOpsStackDeltas[op];
2492           } else if (op >= 0xc0 && op <= 0xdf) {
2493             stackDelta = -1;
2494           } else if (op >= 0xe0) {
2495             stackDelta = -2;
2496           }
2497           if (op >= 0x71 && op <= 0x75) {
2498             n = stack.pop();
2499             if (!isNaN(n)) {
2500               stackDelta = -n * 2;
2501             }
2502           }
2503           while (stackDelta < 0 && stack.length > 0) {
2504             stack.pop();
2505             stackDelta++;
2506           }
2507           while (stackDelta > 0) {
2508             stack.push(NaN); // pushing any number into stack
2509             stackDelta--;
2510           }
2511         }
2512       }
2513       ttContext.tooComplexToFollowFunctions = tooComplexToFollowFunctions;
2514       const content = [data];
2515       if (i > data.length) {
2516         content.push(new Uint8Array(i - data.length));
2517       }
2518       if (lastDeff > lastEndf) {
2519         warn("TT: complementing a missing function tail");
2520         // new function definition started, but not finished
2521         // complete function by [CLEAR, ENDF]
2522         content.push(new Uint8Array([0x22, 0x2d]));
2523       }
2524       foldTTTable(table, content);
2525     }
2526 
2527     function checkInvalidFunctions(ttContext, maxFunctionDefs) {
2528       if (ttContext.tooComplexToFollowFunctions) {
2529         return;
2530       }
2531       if (ttContext.functionsDefined.length > maxFunctionDefs) {
2532         warn("TT: more functions defined than expected");
2533         ttContext.hintsValid = false;
2534         return;
2535       }
2536       for (let j = 0, jj = ttContext.functionsUsed.length; j < jj; j++) {
2537         if (j > maxFunctionDefs) {
2538           warn("TT: invalid function id: " + j);
2539           ttContext.hintsValid = false;
2540           return;
2541         }
2542         if (ttContext.functionsUsed[j] && !ttContext.functionsDefined[j]) {
2543           warn("TT: undefined function: " + j);
2544           ttContext.hintsValid = false;
2545           return;
2546         }
2547       }
2548     }
2549 
2550     function foldTTTable(table, content) {
2551       if (content.length > 1) {
2552         // concatenating the content items
2553         let newLength = 0;
2554         let j, jj;
2555         for (j = 0, jj = content.length; j < jj; j++) {
2556           newLength += content[j].length;
2557         }
2558         newLength = (newLength + 3) & ~3;
2559         const result = new Uint8Array(newLength);
2560         let pos = 0;
2561         for (j = 0, jj = content.length; j < jj; j++) {
2562           result.set(content[j], pos);
2563           pos += content[j].length;
2564         }
2565         table.data = result;
2566         table.length = newLength;
2567       }
2568     }
2569 
2570     function sanitizeTTPrograms(fpgm, prep, cvt, maxFunctionDefs) {
2571       const ttContext = {
2572         functionsDefined: [],
2573         functionsUsed: [],
2574         functionsStackDeltas: [],
2575         tooComplexToFollowFunctions: false,
2576         hintsValid: true,
2577       };
2578       if (fpgm) {
2579         sanitizeTTProgram(fpgm, ttContext);
2580       }
2581       if (prep) {
2582         sanitizeTTProgram(prep, ttContext);
2583       }
2584       if (fpgm) {
2585         checkInvalidFunctions(ttContext, maxFunctionDefs);
2586       }
2587       if (cvt && cvt.length & 1) {
2588         const cvtData = new Uint8Array(cvt.length + 1);
2589         cvtData.set(cvt.data);
2590         cvt.data = cvtData;
2591       }
2592       return ttContext.hintsValid;
2593     }
2594 
2595     // The following steps modify the original font data, making copy
2596     font = new Stream(new Uint8Array(font.getBytes()));
2597 
2598     let header, tables;
2599     if (isTrueTypeCollectionFile(font)) {
2600       const ttcData = readTrueTypeCollectionData(font, this.name);
2601       header = ttcData.header;
2602       tables = ttcData.tables;
2603     } else {
2604       header = readOpenTypeHeader(font);
2605       tables = readTables(font, header.numTables);
2606     }
2607     let cff, cffFile;
2608 
2609     const isTrueType = !tables["CFF "];
2610     if (!isTrueType) {
2611       const isComposite =
2612         properties.composite &&
2613         (properties.cidToGidMap?.length > 0 ||
2614           !(properties.cMap instanceof IdentityCMap));
2615       // OpenType font (skip composite fonts with non-default glyph mapping).
2616       if (
2617         (header.version === "OTTO" && !isComposite) ||
2618         !tables.head ||
2619         !tables.hhea ||
2620         !tables.maxp ||
2621         !tables.post
2622       ) {
2623         // No major tables: throwing everything at `CFFFont`.
2624         cffFile = new Stream(tables["CFF "].data);
2625         cff = new CFFFont(cffFile, properties);
2626 
2627         adjustWidths(properties);
2628 
2629         return this.convert(name, cff, properties);
2630       }
2631 
2632       delete tables.glyf;
2633       delete tables.loca;
2634       delete tables.fpgm;
2635       delete tables.prep;
2636       delete tables["cvt "];
2637       this.isOpenType = true;
2638     } else {
2639       if (!tables.loca) {
2640         throw new FormatError('Required "loca" table is not found');
2641       }
2642       if (!tables.glyf) {
2643         warn('Required "glyf" table is not found -- trying to recover.');
2644         // Note: We use `sanitizeGlyphLocations` to add dummy glyf data below.
2645         tables.glyf = {
2646           tag: "glyf",
2647           data: new Uint8Array(0),
2648         };
2649       }
2650       this.isOpenType = false;
2651     }
2652 
2653     if (!tables.maxp) {
2654       throw new FormatError('Required "maxp" table is not found');
2655     }
2656 
2657     font.pos = (font.start || 0) + tables.maxp.offset;
2658     let version = font.getInt32();
2659     const numGlyphs = font.getUint16();
2660 
2661     if (version !== 0x00010000 && version !== 0x00005000) {
2662       // https://learn.microsoft.com/en-us/typography/opentype/spec/maxp
2663       if (tables.maxp.length === 6) {
2664         version = 0x0005000;
2665       } else if (tables.maxp.length >= 32) {
2666         version = 0x00010000;
2667       } else {
2668         throw new FormatError(`"maxp" table has a wrong version number`);
2669       }
2670       writeUint32(tables.maxp.data, 0, version);
2671     }
2672 
2673     if (properties.scaleFactors?.length === numGlyphs && isTrueType) {
2674       const { scaleFactors } = properties;
2675       const isGlyphLocationsLong = int16(
2676         tables.head.data[50],
2677         tables.head.data[51]
2678       );
2679 
2680       const glyphs = new GlyfTable({
2681         glyfTable: tables.glyf.data,
2682         isGlyphLocationsLong,
2683         locaTable: tables.loca.data,
2684         numGlyphs,
2685       });
2686       glyphs.scale(scaleFactors);
2687 
2688       const { glyf, loca, isLocationLong } = glyphs.write();
2689       tables.glyf.data = glyf;
2690       tables.loca.data = loca;
2691 
2692       if (isLocationLong !== !!isGlyphLocationsLong) {
2693         tables.head.data[50] = 0;
2694         tables.head.data[51] = isLocationLong ? 1 : 0;
2695       }
2696 
2697       const metrics = tables.hmtx.data;
2698 
2699       for (let i = 0; i < numGlyphs; i++) {
2700         const j = 4 * i;
2701         const advanceWidth = Math.round(
2702           scaleFactors[i] * int16(metrics[j], metrics[j + 1])
2703         );
2704         metrics[j] = (advanceWidth >> 8) & 0xff;
2705         metrics[j + 1] = advanceWidth & 0xff;
2706         const lsb = Math.round(
2707           scaleFactors[i] * signedInt16(metrics[j + 2], metrics[j + 3])
2708         );
2709         writeSignedInt16(metrics, j + 2, lsb);
2710       }
2711     }
2712 
2713     // Glyph 0 is duplicated and appended.
2714     let numGlyphsOut = numGlyphs + 1;
2715     let dupFirstEntry = true;
2716     if (numGlyphsOut > 0xffff) {
2717       dupFirstEntry = false;
2718       numGlyphsOut = numGlyphs;
2719       warn("Not enough space in glyfs to duplicate first glyph.");
2720     }
2721     let maxFunctionDefs = 0;
2722     let maxSizeOfInstructions = 0;
2723     if (version >= 0x00010000 && tables.maxp.length >= 32) {
2724       // maxZones can be invalid
2725       font.pos += 8;
2726       const maxZones = font.getUint16();
2727       if (maxZones > 2) {
2728         // reset to 2 if font has invalid maxZones
2729         tables.maxp.data[14] = 0;
2730         tables.maxp.data[15] = 2;
2731       }
2732       font.pos += 4;
2733       maxFunctionDefs = font.getUint16();
2734       font.pos += 4;
2735       maxSizeOfInstructions = font.getUint16();
2736     }
2737 
2738     tables.maxp.data[4] = numGlyphsOut >> 8;
2739     tables.maxp.data[5] = numGlyphsOut & 255;
2740 
2741     const hintsValid = sanitizeTTPrograms(
2742       tables.fpgm,
2743       tables.prep,
2744       tables["cvt "],
2745       maxFunctionDefs
2746     );
2747     if (!hintsValid) {
2748       delete tables.fpgm;
2749       delete tables.prep;
2750       delete tables["cvt "];
2751     }
2752 
2753     // Ensure the hmtx table contains the advance width and
2754     // sidebearings information for numGlyphs in the maxp table
2755     sanitizeMetrics(
2756       font,
2757       tables.hhea,
2758       tables.hmtx,
2759       tables.head,
2760       numGlyphsOut,
2761       dupFirstEntry
2762     );
2763 
2764     if (!tables.head) {
2765       throw new FormatError('Required "head" table is not found');
2766     }
2767 
2768     sanitizeHead(tables.head, numGlyphs, isTrueType ? tables.loca.length : 0);
2769 
2770     let missingGlyphs = Object.create(null);
2771     if (isTrueType) {
2772       const isGlyphLocationsLong = int16(
2773         tables.head.data[50],
2774         tables.head.data[51]
2775       );
2776       const glyphsInfo = sanitizeGlyphLocations(
2777         tables.loca,
2778         tables.glyf,
2779         numGlyphs,
2780         isGlyphLocationsLong,
2781         hintsValid,
2782         dupFirstEntry,
2783         maxSizeOfInstructions
2784       );
2785       missingGlyphs = glyphsInfo.missingGlyphs;
2786 
2787       // Some fonts have incorrect maxSizeOfInstructions values, so we use
2788       // the computed value instead.
2789       if (version >= 0x00010000 && tables.maxp.length >= 32) {
2790         tables.maxp.data[26] = glyphsInfo.maxSizeOfInstructions >> 8;
2791         tables.maxp.data[27] = glyphsInfo.maxSizeOfInstructions & 255;
2792       }
2793     }
2794     if (!tables.hhea) {
2795       throw new FormatError('Required "hhea" table is not found');
2796     }
2797 
2798     // Sanitizer reduces the glyph advanceWidth to the maxAdvanceWidth
2799     // Sometimes it's 0. That needs to be fixed
2800     if (tables.hhea.data[10] === 0 && tables.hhea.data[11] === 0) {
2801       tables.hhea.data[10] = 0xff;
2802       tables.hhea.data[11] = 0xff;
2803     }
2804 
2805     // Extract some more font properties from the OpenType head and
2806     // hhea tables; yMin and descent value are always negative.
2807     const metricsOverride = {
2808       unitsPerEm: int16(tables.head.data[18], tables.head.data[19]),
2809       yMax: signedInt16(tables.head.data[42], tables.head.data[43]),
2810       yMin: signedInt16(tables.head.data[38], tables.head.data[39]),
2811       ascent: signedInt16(tables.hhea.data[4], tables.hhea.data[5]),
2812       descent: signedInt16(tables.hhea.data[6], tables.hhea.data[7]),
2813       lineGap: signedInt16(tables.hhea.data[8], tables.hhea.data[9]),
2814     };
2815 
2816     // PDF FontDescriptor metrics lie -- using data from actual font.
2817     this.ascent = metricsOverride.ascent / metricsOverride.unitsPerEm;
2818     this.descent = metricsOverride.descent / metricsOverride.unitsPerEm;
2819     this.lineGap = metricsOverride.lineGap / metricsOverride.unitsPerEm;
2820 
2821     if (this.cssFontInfo?.lineHeight) {
2822       this.lineHeight = this.cssFontInfo.metrics.lineHeight;
2823       this.lineGap = this.cssFontInfo.metrics.lineGap;
2824     } else {
2825       this.lineHeight = this.ascent - this.descent + this.lineGap;
2826     }
2827 
2828     // The 'post' table has glyphs names.
2829     if (tables.post) {
2830       readPostScriptTable(tables.post, properties, numGlyphs);
2831     }
2832 
2833     // The original 'post' table is not needed, replace it.
2834     tables.post = {
2835       tag: "post",
2836       data: createPostTable(properties),
2837     };
2838 
2839     const charCodeToGlyphId = Object.create(null);
2840 
2841     // Helper function to try to skip mapping of empty glyphs.
2842     function hasGlyph(glyphId) {
2843       return !missingGlyphs[glyphId];
2844     }
2845 
2846     if (properties.composite) {
2847       const cidToGidMap = properties.cidToGidMap || [];
2848       const isCidToGidMapEmpty = cidToGidMap.length === 0;
2849 
2850       properties.cMap.forEach(function (charCode, cid) {
2851         if (typeof cid === "string") {
2852           cid = convertCidString(charCode, cid, /* shouldThrow = */ true);
2853         }
2854         if (cid > 0xffff) {
2855           throw new FormatError("Max size of CID is 65,535");
2856         }
2857         let glyphId = -1;
2858         if (isCidToGidMapEmpty) {
2859           glyphId = cid;
2860         } else if (cidToGidMap[cid] !== undefined) {
2861           glyphId = cidToGidMap[cid];
2862         }
2863 
2864         if (glyphId >= 0 && glyphId < numGlyphs && hasGlyph(glyphId)) {
2865           charCodeToGlyphId[charCode] = glyphId;
2866         }
2867       });
2868     } else {
2869       // Most of the following logic in this code branch is based on the
2870       // 9.6.6.4 of the PDF spec.
2871       const cmapTable = readCmapTable(
2872         tables.cmap,
2873         font,
2874         this.isSymbolicFont,
2875         properties.hasEncoding
2876       );
2877       const cmapPlatformId = cmapTable.platformId;
2878       const cmapEncodingId = cmapTable.encodingId;
2879       const cmapMappings = cmapTable.mappings;
2880       let baseEncoding = [],
2881         forcePostTable = false;
2882       if (
2883         properties.hasEncoding &&
2884         (properties.baseEncodingName === "MacRomanEncoding" ||
2885           properties.baseEncodingName === "WinAnsiEncoding")
2886       ) {
2887         baseEncoding = getEncoding(properties.baseEncodingName);
2888       }
2889 
2890       // If the font has an encoding and is not symbolic then follow the rules
2891       // in section 9.6.6.4 of the spec on how to map 3,1 and 1,0 cmaps.
2892       if (
2893         properties.hasEncoding &&
2894         !this.isSymbolicFont &&
2895         ((cmapPlatformId === 3 && cmapEncodingId === 1) ||
2896           (cmapPlatformId === 1 && cmapEncodingId === 0))
2897       ) {
2898         const glyphsUnicodeMap = getGlyphsUnicode();
2899         for (let charCode = 0; charCode < 256; charCode++) {
2900           let glyphName;
2901           if (this.differences[charCode] !== undefined) {
2902             glyphName = this.differences[charCode];
2903           } else if (baseEncoding.length && baseEncoding[charCode] !== "") {
2904             glyphName = baseEncoding[charCode];
2905           } else {
2906             glyphName = StandardEncoding[charCode];
2907           }
2908           if (!glyphName) {
2909             continue;
2910           }
2911           // Ensure that non-standard glyph names are resolved to valid ones.
2912           const standardGlyphName = recoverGlyphName(
2913             glyphName,
2914             glyphsUnicodeMap
2915           );
2916 
2917           let unicodeOrCharCode;
2918           if (cmapPlatformId === 3 && cmapEncodingId === 1) {
2919             unicodeOrCharCode = glyphsUnicodeMap[standardGlyphName];
2920           } else if (cmapPlatformId === 1 && cmapEncodingId === 0) {
2921             // TODO: the encoding needs to be updated with mac os table.
2922             unicodeOrCharCode = MacRomanEncoding.indexOf(standardGlyphName);
2923           }
2924 
2925           if (unicodeOrCharCode === undefined) {
2926             // Not a valid glyph name, fallback to using the /ToUnicode map
2927             // when no post-table exists (fixes issue13316_reduced.pdf).
2928             if (
2929               !properties.glyphNames &&
2930               properties.hasIncludedToUnicodeMap &&
2931               !(this.toUnicode instanceof IdentityToUnicodeMap)
2932             ) {
2933               const unicode = this.toUnicode.get(charCode);
2934               if (unicode) {
2935                 unicodeOrCharCode = unicode.codePointAt(0);
2936               }
2937             }
2938 
2939             if (unicodeOrCharCode === undefined) {
2940               continue; // No valid glyph mapping found.
2941             }
2942           }
2943 
2944           for (const mapping of cmapMappings) {
2945             if (mapping.charCode !== unicodeOrCharCode) {
2946               continue;
2947             }
2948             charCodeToGlyphId[charCode] = mapping.glyphId;
2949             break;
2950           }
2951         }
2952       } else if (cmapPlatformId === 0) {
2953         // Default Unicode semantics, use the charcodes as is.
2954         for (const mapping of cmapMappings) {
2955           charCodeToGlyphId[mapping.charCode] = mapping.glyphId;
2956         }
2957         // Always prefer the BaseEncoding/Differences arrays, when they exist
2958         // (fixes issue13433.pdf).
2959         forcePostTable = true;
2960       } else if (cmapPlatformId === 3 && cmapEncodingId === 0) {
2961         // When a (3, 0) cmap table is present, it is used instead but the
2962         // spec has special rules for char codes in the range of 0xF000 to
2963         // 0xF0FF and it says the (3, 0) table should map the values from
2964         // the (1, 0) table by prepending 0xF0 to the char codes. To reverse
2965         // this, the upper bits of the char code are cleared, but only for the
2966         // special range since some PDFs have char codes outside of this range
2967         // (e.g. 0x2013) which when masked would overwrite other values in the
2968         // cmap.
2969         for (const mapping of cmapMappings) {
2970           let charCode = mapping.charCode;
2971           if (charCode >= 0xf000 && charCode <= 0xf0ff) {
2972             charCode &= 0xff;
2973           }
2974           charCodeToGlyphId[charCode] = mapping.glyphId;
2975         }
2976       } else {
2977         // When there is only a (1, 0) cmap table, the char code is a single
2978         // byte and it is used directly as the char code.
2979         for (const mapping of cmapMappings) {
2980           charCodeToGlyphId[mapping.charCode] = mapping.glyphId;
2981         }
2982       }
2983 
2984       // Last, try to map any missing charcodes using the post table.
2985       if (
2986         properties.glyphNames &&
2987         (baseEncoding.length || this.differences.length)
2988       ) {
2989         for (let i = 0; i < 256; ++i) {
2990           if (!forcePostTable && charCodeToGlyphId[i] !== undefined) {
2991             continue;
2992           }
2993           const glyphName = this.differences[i] || baseEncoding[i];
2994           if (!glyphName) {
2995             continue;
2996           }
2997           const glyphId = properties.glyphNames.indexOf(glyphName);
2998           if (glyphId > 0 && hasGlyph(glyphId)) {
2999             charCodeToGlyphId[i] = glyphId;
3000           }
3001         }
3002       }
3003     }
3004 
3005     if (charCodeToGlyphId.length === 0) {
3006       // defines at least one glyph
3007       charCodeToGlyphId[0] = 0;
3008     }
3009 
3010     // Typically glyph 0 is duplicated and the mapping must be updated, but if
3011     // there isn't enough room to duplicate, the glyph id is left the same. In
3012     // this case, glyph 0 may not work correctly, but that is better than
3013     // having the whole font fail.
3014     let glyphZeroId = numGlyphsOut - 1;
3015     if (!dupFirstEntry) {
3016       glyphZeroId = 0;
3017     }
3018 
3019     // When `cssFontInfo` is set, the font is used to render text in the HTML
3020     // view (e.g. with Xfa) so nothing must be moved in the private use area.
3021     if (!properties.cssFontInfo) {
3022       // Converting glyphs and ids into font's cmap table
3023       const newMapping = adjustMapping(
3024         charCodeToGlyphId,
3025         hasGlyph,
3026         glyphZeroId,
3027         this.toUnicode
3028       );
3029       this.toFontChar = newMapping.toFontChar;
3030       tables.cmap = {
3031         tag: "cmap",
3032         data: createCmapTable(
3033           newMapping.charCodeToGlyphId,
3034           newMapping.toUnicodeExtraMap,
3035           numGlyphsOut
3036         ),
3037       };
3038 
3039       if (!tables["OS/2"] || !validateOS2Table(tables["OS/2"], font)) {
3040         tables["OS/2"] = {
3041           tag: "OS/2",
3042           data: createOS2Table(
3043             properties,
3044             newMapping.charCodeToGlyphId,
3045             metricsOverride
3046           ),
3047         };
3048       }
3049     }
3050 
3051     if (!isTrueType) {
3052       try {
3053         // Trying to repair CFF file
3054         cffFile = new Stream(tables["CFF "].data);
3055         const parser = new CFFParser(
3056           cffFile,
3057           properties,
3058           SEAC_ANALYSIS_ENABLED
3059         );
3060         cff = parser.parse();
3061         cff.duplicateFirstGlyph();
3062         const compiler = new CFFCompiler(cff);
3063         tables["CFF "].data = compiler.compile();
3064       } catch {
3065         warn("Failed to compile font " + properties.loadedName);
3066       }
3067     }
3068 
3069     // Re-creating 'name' table
3070     if (!tables.name) {
3071       tables.name = {
3072         tag: "name",
3073         data: createNameTable(this.name),
3074       };
3075     } else {
3076       // ... using existing 'name' table as prototype
3077       const [namePrototype, nameRecords] = readNameTable(tables.name);
3078 
3079       tables.name.data = createNameTable(name, namePrototype);
3080       this.psName = namePrototype[0][6] || null;
3081 
3082       if (!properties.composite) {
3083         // For TrueType fonts that do not include `ToUnicode` or `Encoding`
3084         // data, attempt to use the name-table to improve text selection.
3085         adjustTrueTypeToUnicode(properties, this.isSymbolicFont, nameRecords);
3086       }
3087     }
3088 
3089     const builder = new OpenTypeFileBuilder(header.version);
3090     for (const tableTag in tables) {
3091       builder.addTable(tableTag, tables[tableTag].data);
3092     }
3093     return builder.toArray();
3094   }
3095 
3565 }
3566 
3586 
</code>

PR summary:
<pr_summary>
Improve performance when reading very large TrueType "cmap" tables (issue 19319)
In the affected font the total number of mapping-entries is `1142348`, and no less than `997473` of them are duplicates.
Given that every duplicate causes a lot of Array elements to be moved this becomes extremely inefficient, which we can avoid by keeping track of seen `charCode`s and directly build the final mappings-Array instead.
</pr_summary>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

