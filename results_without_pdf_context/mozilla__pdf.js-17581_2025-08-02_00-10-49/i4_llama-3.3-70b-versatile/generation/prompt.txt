Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Change the cursors used to highlight
</issue>

Patch:
<patch>
diff --git a/src/display/editor/annotation_editor_layer.js b/src/display/editor/annotation_editor_layer.js
--- a/src/display/editor/annotation_editor_layer.js
+++ b/src/display/editor/annotation_editor_layer.js
@@ -334,7 +334,7 @@ class AnnotationEditorLayer {
         "pointerdown",
         this.#boundTextLayerPointerDown
       );
-      this.#textLayer.div.classList.add("drawing");
+      this.#textLayer.div.classList.add("highlighting");
     }
   }
 
@@ -345,7 +345,7 @@ class AnnotationEditorLayer {
         "pointerdown",
         this.#boundTextLayerPointerDown
       );
-      this.#textLayer.div.classList.remove("drawing");
+      this.#textLayer.div.classList.remove("highlighting");
     }
   }
 
@@ -359,11 +359,19 @@ class AnnotationEditorLayer {
         // Do nothing on right click.
         return;
       }
+      this.#textLayer.div.classList.add("free");
       HighlightEditor.startHighlighting(
         this,
         this.#uiManager.direction === "ltr",
         event
       );
+      this.#textLayer.div.addEventListener(
+        "pointerup",
+        () => {
+          this.#textLayer.div.classList.remove("free");
+        },
+        { once: true }
+      );
       event.preventDefault();
     }
   }


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.23.7
- @babel/preset-env: ^7.23.8
- @babel/runtime: ^7.23.8
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.9.0
- @jazzer.js/core: ^2.1.0
- autoprefixer: ^10.4.17
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001579
- canvas: ^2.11.2
- core-js: ^3.35.0
- cross-env: ^7.0.3
- eslint: ^8.56.0
- eslint-config-prettier: ^8.10.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.29.1
- eslint-plugin-jasmine: ^4.1.3
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.3.2
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.1.3
- eslint-plugin-sort-exports: ^0.8.0
- eslint-plugin-unicorn: ^50.0.1
- globals: ^13.24.0
- gulp: ^4.0.2
- gulp-cli: ^2.3.0
- gulp-postcss: ^9.1.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.3.1
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.33
- postcss-dark-theme-class: ^1.1.0
- postcss-dir-pseudo-class: ^8.0.1
- postcss-discard-comments: ^6.0.1
- postcss-nesting: ^12.0.2
- prettier: ^3.2.4
- puppeteer: ^21.7.0
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^16.2.0
- stylelint-prettier: ^5.0.0
- terser: ^5.27.0
- through2: ^4.0.2
- tsc-alias: ^1.8.8
- ttest: ^4.0.0
- typescript: ^5.3.3
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.89.0
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/outliner.js`: Outliner
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/l10n.js`: L10n
- `../../web/l10n_utils.js`: NullL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/display/editor/annotation_editor_layer.js
1 /* Copyright 2022 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 // eslint-disable-next-line max-len
17 /** @typedef {import("./tools.js").AnnotationEditorUIManager} AnnotationEditorUIManager */
18 /** @typedef {import("../display_utils.js").PageViewport} PageViewport */
19 // eslint-disable-next-line max-len
20 /** @typedef {import("../../../web/text_accessibility.js").TextAccessibilityManager} TextAccessibilityManager */
21 /** @typedef {import("../../../web/interfaces").IL10n} IL10n */
22 // eslint-disable-next-line max-len
23 /** @typedef {import("../annotation_layer.js").AnnotationLayer} AnnotationLayer */
24 /** @typedef {import("../draw_layer.js").DrawLayer} DrawLayer */
25 
26 import { AnnotationEditorType, FeatureTest } from "../../shared/util.js";
27 import { AnnotationEditor } from "./editor.js";
28 import { FreeTextEditor } from "./freetext.js";
29 import { HighlightEditor } from "./highlight.js";
30 import { InkEditor } from "./ink.js";
31 import { setLayerDimensions } from "../display_utils.js";
32 import { StampEditor } from "./stamp.js";
33 
34 /**
35  * @typedef {Object} AnnotationEditorLayerOptions
36  * @property {Object} mode
37  * @property {HTMLDivElement} div
38  * @property {AnnotationEditorUIManager} uiManager
39  * @property {boolean} enabled
40  * @property {TextAccessibilityManager} [accessibilityManager]
41  * @property {number} pageIndex
42  * @property {IL10n} l10n
43  * @property {AnnotationLayer} [annotationLayer]
44  * @property {HTMLDivElement} [textLayer]
45  * @property {DrawLayer} drawLayer
46  * @property {PageViewport} viewport
47  */
48 
49 /**
50  * @typedef {Object} RenderEditorLayerOptions
51  * @property {PageViewport} viewport
52  */
53 
54 /**
55  * Manage all the different editors on a page.
56  */
57 class AnnotationEditorLayer {
58   #accessibilityManager;
59 
60   #allowClick = false;
61 
62   #annotationLayer = null;
63 
64   #boundPointerup = this.pointerup.bind(this);
65 
66   #boundPointerUpAfterSelection = this.pointerUpAfterSelection.bind(this);
67 
68   #boundPointerdown = this.pointerdown.bind(this);
69 
70   #boundTextLayerPointerDown = this.#textLayerPointerDown.bind(this);
71 
72   #editorFocusTimeoutId = null;
73 
74   #boundSelectionStart = this.selectionStart.bind(this);
75 
76   #editors = new Map();
77 
78   #hadPointerDown = false;
79 
80   #isCleaningUp = false;
81 
82   #isDisabling = false;
83 
84   #textLayer = null;
85 
86   #uiManager;
87 
88   static _initialized = false;
89 
90   static #editorTypes = new Map(
91     [FreeTextEditor, InkEditor, StampEditor, HighlightEditor].map(type => [
92       type._editorType,
93       type,
94     ])
95   );
96 
97   /**
98    * @param {AnnotationEditorLayerOptions} options
99    */
100   constructor({
101     uiManager,
102     pageIndex,
103     div,
104     accessibilityManager,
105     annotationLayer,
106     drawLayer,
107     textLayer,
108     viewport,
109     l10n,
110   }) {
111     const editorTypes = [...AnnotationEditorLayer.#editorTypes.values()];
112     if (!AnnotationEditorLayer._initialized) {
113       AnnotationEditorLayer._initialized = true;
114       for (const editorType of editorTypes) {
115         editorType.initialize(l10n, uiManager);
116       }
117     }
118     uiManager.registerEditorTypes(editorTypes);
119 
120     this.#uiManager = uiManager;
121     this.pageIndex = pageIndex;
122     this.div = div;
123     this.#accessibilityManager = accessibilityManager;
124     this.#annotationLayer = annotationLayer;
125     this.viewport = viewport;
126     this.#textLayer = textLayer;
127     this.drawLayer = drawLayer;
128 
129     this.#uiManager.addLayer(this);
130   }
131 
132   get isEmpty() {
133     return this.#editors.size === 0;
134   }
135 
136   /**
137    * Update the toolbar if it's required to reflect the tool currently used.
138    * @param {number} mode
139    */
140   updateToolbar(mode) {
141     this.#uiManager.updateToolbar(mode);
142   }
143 
144   /**
145    * The mode has changed: it must be updated.
146    * @param {number} mode
147    */
148   updateMode(mode = this.#uiManager.getMode()) {
149     this.#cleanup();
150     switch (mode) {
151       case AnnotationEditorType.NONE:
152         this.disableTextSelection();
153         this.togglePointerEvents(false);
154         this.disableClick();
155         break;
156       case AnnotationEditorType.INK:
157         // We always want to have an ink editor ready to draw in.
158         this.addInkEditorIfNeeded(false);
159 
160         this.disableTextSelection();
161         this.togglePointerEvents(true);
162         this.disableClick();
163         break;
164       case AnnotationEditorType.HIGHLIGHT:
165         this.enableTextSelection();
166         this.togglePointerEvents(false);
167         this.disableClick();
168         break;
169       default:
170         this.disableTextSelection();
171         this.togglePointerEvents(true);
172         this.enableClick();
173     }
174 
175     if (mode !== AnnotationEditorType.NONE) {
176       const { classList } = this.div;
177       for (const editorType of AnnotationEditorLayer.#editorTypes.values()) {
178         classList.toggle(
179           `${editorType._type}Editing`,
180           mode === editorType._editorType
181         );
182       }
183       this.div.hidden = false;
184     }
185   }
186 
187   addInkEditorIfNeeded(isCommitting) {
188     if (this.#uiManager.getMode() !== AnnotationEditorType.INK) {
189       // We don't want to add an ink editor if we're not in ink mode!
190       return;
191     }
192 
193     if (!isCommitting) {
194       // We're removing an editor but an empty one can already exist so in this
195       // case we don't need to create a new one.
196       for (const editor of this.#editors.values()) {
197         if (editor.isEmpty()) {
198           editor.setInBackground();
199           return;
200         }
201       }
202     }
203 
204     const editor = this.createAndAddNewEditor(
205       { offsetX: 0, offsetY: 0 },
206       /* isCentered = */ false
207     );
208     editor.setInBackground();
209   }
210 
211   /**
212    * Set the editing state.
213    * @param {boolean} isEditing
214    */
215   setEditingState(isEditing) {
216     this.#uiManager.setEditingState(isEditing);
217   }
218 
219   /**
220    * Add some commands into the CommandManager (undo/redo stuff).
221    * @param {Object} params
222    */
223   addCommands(params) {
224     this.#uiManager.addCommands(params);
225   }
226 
227   togglePointerEvents(enabled = false) {
228     this.div.classList.toggle("disabled", !enabled);
229   }
230 
231   /**
232    * Enable pointer events on the main div in order to enable
233    * editor creation.
234    */
235   enable() {
236     this.togglePointerEvents(true);
237     const annotationElementIds = new Set();
238     for (const editor of this.#editors.values()) {
239       editor.enableEditing();
240       if (editor.annotationElementId) {
241         annotationElementIds.add(editor.annotationElementId);
242       }
243     }
244 
245     if (!this.#annotationLayer) {
246       return;
247     }
248 
249     const editables = this.#annotationLayer.getEditableAnnotations();
250     for (const editable of editables) {
251       // The element must be hidden whatever its state is.
252       editable.hide();
253       if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {
254         continue;
255       }
256       if (annotationElementIds.has(editable.data.id)) {
257         continue;
258       }
259       const editor = this.deserialize(editable);
260       if (!editor) {
261         continue;
262       }
263       this.addOrRebuild(editor);
264       editor.enableEditing();
265     }
266   }
267 
268   /**
269    * Disable editor creation.
270    */
271   disable() {
272     this.#isDisabling = true;
273     this.togglePointerEvents(false);
274     const hiddenAnnotationIds = new Set();
275     for (const editor of this.#editors.values()) {
276       editor.disableEditing();
277       if (!editor.annotationElementId || editor.serialize() !== null) {
278         hiddenAnnotationIds.add(editor.annotationElementId);
279         continue;
280       }
281       this.getEditableAnnotation(editor.annotationElementId)?.show();
282       editor.remove();
283     }
284 
285     if (this.#annotationLayer) {
286       // Show the annotations that were hidden in enable().
287       const editables = this.#annotationLayer.getEditableAnnotations();
288       for (const editable of editables) {
289         const { id } = editable.data;
290         if (
291           hiddenAnnotationIds.has(id) ||
292           this.#uiManager.isDeletedAnnotationElement(id)
293         ) {
294           continue;
295         }
296         editable.show();
297       }
298     }
299 
300     this.#cleanup();
301     if (this.isEmpty) {
302       this.div.hidden = true;
303     }
304     const { classList } = this.div;
305     for (const editorType of AnnotationEditorLayer.#editorTypes.values()) {
306       classList.remove(`${editorType._type}Editing`);
307     }
308     this.disableTextSelection();
309 
310     this.#isDisabling = false;
311   }
312 
313   getEditableAnnotation(id) {
314     return this.#annotationLayer?.getEditableAnnotation(id) || null;
315   }
316 
317   /**
318    * Set the current editor.
319    * @param {AnnotationEditor} editor
320    */
321   setActiveEditor(editor) {
322     const currentActive = this.#uiManager.getActive();
323     if (currentActive === editor) {
324       return;
325     }
326 
327     this.#uiManager.setActiveEditor(editor);
328   }
329 
330   enableTextSelection() {
331     if (this.#textLayer?.div) {
332       document.addEventListener("selectstart", this.#boundSelectionStart);
333       this.#textLayer.div.addEventListener(
334         "pointerdown",
335         this.#boundTextLayerPointerDown
336       );
337       this.#textLayer.div.classList.add("drawing");
338     }
339   }
340 
341   disableTextSelection() {
342     if (this.#textLayer?.div) {
343       document.removeEventListener("selectstart", this.#boundSelectionStart);
344       this.#textLayer.div.removeEventListener(
345         "pointerdown",
346         this.#boundTextLayerPointerDown
347       );
348       this.#textLayer.div.classList.remove("drawing");
349     }
350   }
351 
352   #textLayerPointerDown(event) {
353     // Unselect all the editors in order to let the user select some text
354     // without being annoyed by an editor toolbar.
355     this.#uiManager.unselectAll();
356     if (event.target === this.#textLayer.div) {
357       const { isMac } = FeatureTest.platform;
358       if (event.button !== 0 || (event.ctrlKey && isMac)) {
359         // Do nothing on right click.
360         return;
361       }
362       HighlightEditor.startHighlighting(
363         this,
364         this.#uiManager.direction === "ltr",
365         event
366       );
367       event.preventDefault();
368     }
369   }
370 
371   enableClick() {
372     this.div.addEventListener("pointerdown", this.#boundPointerdown);
373     this.div.addEventListener("pointerup", this.#boundPointerup);
374   }
375 
376   disableClick() {
377     this.div.removeEventListener("pointerdown", this.#boundPointerdown);
378     this.div.removeEventListener("pointerup", this.#boundPointerup);
379   }
380 
381   attach(editor) {
382     this.#editors.set(editor.id, editor);
383     const { annotationElementId } = editor;
384     if (
385       annotationElementId &&
386       this.#uiManager.isDeletedAnnotationElement(annotationElementId)
387     ) {
388       this.#uiManager.removeDeletedAnnotationElement(editor);
389     }
390   }
391 
392   detach(editor) {
393     this.#editors.delete(editor.id);
394     this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);
395 
396     if (!this.#isDisabling && editor.annotationElementId) {
397       this.#uiManager.addDeletedAnnotationElement(editor);
398     }
399   }
400 
401   /**
402    * Remove an editor.
403    * @param {AnnotationEditor} editor
404    */
405   remove(editor) {
406     // Since we can undo a removal we need to keep the
407     // parent property as it is, so don't null it!
408 
409     this.detach(editor);
410     this.#uiManager.removeEditor(editor);
411     editor.div.remove();
412     editor.isAttachedToDOM = false;
413 
414     if (!this.#isCleaningUp) {
415       this.addInkEditorIfNeeded(/* isCommitting = */ false);
416     }
417   }
418 
419   /**
420    * An editor can have a different parent, for example after having
421    * being dragged and droped from a page to another.
422    * @param {AnnotationEditor} editor
423    */
424   changeParent(editor) {
425     if (editor.parent === this) {
426       return;
427     }
428 
429     if (editor.annotationElementId) {
430       this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);
431       AnnotationEditor.deleteAnnotationElement(editor);
432       editor.annotationElementId = null;
433     }
434 
435     this.attach(editor);
436     editor.parent?.detach(editor);
437     editor.setParent(this);
438     if (editor.div && editor.isAttachedToDOM) {
439       editor.div.remove();
440       this.div.append(editor.div);
441     }
442   }
443 
444   /**
445    * Add a new editor in the current view.
446    * @param {AnnotationEditor} editor
447    */
448   add(editor) {
449     this.changeParent(editor);
450     this.#uiManager.addEditor(editor);
451     this.attach(editor);
452 
453     if (!editor.isAttachedToDOM) {
454       const div = editor.render();
455       this.div.append(div);
456       editor.isAttachedToDOM = true;
457     }
458 
459     // The editor will be correctly moved into the DOM (see fixAndSetPosition).
460     editor.fixAndSetPosition();
461     editor.onceAdded();
462     this.#uiManager.addToAnnotationStorage(editor);
463   }
464 
465   moveEditorInDOM(editor) {
466     if (!editor.isAttachedToDOM) {
467       return;
468     }
469 
470     const { activeElement } = document;
471     if (editor.div.contains(activeElement) && !this.#editorFocusTimeoutId) {
472       // When the div is moved in the DOM the focus can move somewhere else,
473       // so we want to be sure that the focus will stay on the editor but we
474       // don't want to call any focus callbacks, hence we disable them and only
475       // re-enable them when the editor has the focus.
476       editor._focusEventsAllowed = false;
477       this.#editorFocusTimeoutId = setTimeout(() => {
478         this.#editorFocusTimeoutId = null;
479         if (!editor.div.contains(document.activeElement)) {
480           editor.div.addEventListener(
481             "focusin",
482             () => {
483               editor._focusEventsAllowed = true;
484             },
485             { once: true }
486           );
487           activeElement.focus();
488         } else {
489           editor._focusEventsAllowed = true;
490         }
491       }, 0);
492     }
493 
494     editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(
495       this.div,
496       editor.div,
497       editor.contentDiv,
498       /* isRemovable = */ true
499     );
500   }
501 
502   /**
503    * Add or rebuild depending if it has been removed or not.
504    * @param {AnnotationEditor} editor
505    */
506   addOrRebuild(editor) {
507     if (editor.needsToBeRebuilt()) {
508       editor.parent ||= this;
509       editor.rebuild();
510     } else {
511       this.add(editor);
512     }
513   }
514 
515   /**
516    * Add a new editor and make this addition undoable.
517    * @param {AnnotationEditor} editor
518    */
519   addUndoableEditor(editor) {
520     const cmd = () => editor._uiManager.rebuild(editor);
521     const undo = () => {
522       editor.remove();
523     };
524 
525     this.addCommands({ cmd, undo, mustExec: false });
526   }
527 
528   /**
529    * Get an id for an editor.
530    * @returns {string}
531    */
532   getNextId() {
533     return this.#uiManager.getId();
534   }
535 
536   get #currentEditorType() {
537     return AnnotationEditorLayer.#editorTypes.get(this.#uiManager.getMode());
538   }
539 
540   /**
541    * Create a new editor
542    * @param {Object} params
543    * @returns {AnnotationEditor}
544    */
545   #createNewEditor(params) {
546     const editorType = this.#currentEditorType;
547     return editorType ? new editorType.prototype.constructor(params) : null;
548   }
549 
550   canCreateNewEmptyEditor() {
551     return this.#currentEditorType?.canCreateNewEmptyEditor();
552   }
553 
554   /**
555    * Paste some content into a new editor.
556    * @param {number} mode
557    * @param {Object} params
558    */
559   pasteEditor(mode, params) {
560     this.#uiManager.updateToolbar(mode);
561     this.#uiManager.updateMode(mode);
562 
563     const { offsetX, offsetY } = this.#getCenterPoint();
564     const id = this.getNextId();
565     const editor = this.#createNewEditor({
566       parent: this,
567       id,
568       x: offsetX,
569       y: offsetY,
570       uiManager: this.#uiManager,
571       isCentered: true,
572       ...params,
573     });
574     if (editor) {
575       this.add(editor);
576     }
577   }
578 
579   /**
580    * Create a new editor
581    * @param {Object} data
582    * @returns {AnnotationEditor | null}
583    */
584   deserialize(data) {
585     return (
586       AnnotationEditorLayer.#editorTypes
587         .get(data.annotationType ?? data.annotationEditorType)
588         ?.deserialize(data, this, this.#uiManager) || null
589     );
590   }
591 
592   /**
593    * Create and add a new editor.
594    * @param {PointerEvent} event
595    * @param {boolean} isCentered
596    * @param [Object] data
597    * @returns {AnnotationEditor}
598    */
599   createAndAddNewEditor(event, isCentered, data = {}) {
600     const id = this.getNextId();
601     const editor = this.#createNewEditor({
602       parent: this,
603       id,
604       x: event.offsetX,
605       y: event.offsetY,
606       uiManager: this.#uiManager,
607       isCentered,
608       ...data,
609     });
610     if (editor) {
611       this.add(editor);
612     }
613 
614     return editor;
615   }
616 
617   #getCenterPoint() {
618     const { x, y, width, height } = this.div.getBoundingClientRect();
619     const tlX = Math.max(0, x);
620     const tlY = Math.max(0, y);
621     const brX = Math.min(window.innerWidth, x + width);
622     const brY = Math.min(window.innerHeight, y + height);
623     const centerX = (tlX + brX) / 2 - x;
624     const centerY = (tlY + brY) / 2 - y;
625     const [offsetX, offsetY] =
626       this.viewport.rotation % 180 === 0
627         ? [centerX, centerY]
628         : [centerY, centerX];
629 
630     return { offsetX, offsetY };
631   }
632 
633   /**
634    * Create and add a new editor.
635    */
636   addNewEditor() {
637     this.createAndAddNewEditor(this.#getCenterPoint(), /* isCentered = */ true);
638   }
639 
640   /**
641    * Set the last selected editor.
642    * @param {AnnotationEditor} editor
643    */
644   setSelected(editor) {
645     this.#uiManager.setSelected(editor);
646   }
647 
648   /**
649    * Add or remove an editor the current selection.
650    * @param {AnnotationEditor} editor
651    */
652   toggleSelected(editor) {
653     this.#uiManager.toggleSelected(editor);
654   }
655 
656   /**
657    * Check if the editor is selected.
658    * @param {AnnotationEditor} editor
659    */
660   isSelected(editor) {
661     return this.#uiManager.isSelected(editor);
662   }
663 
664   /**
665    * Unselect an editor.
666    * @param {AnnotationEditor} editor
667    */
668   unselect(editor) {
669     this.#uiManager.unselect(editor);
670   }
671 
672   /**
673    * SelectionChange callback.
674    * @param {Event} _event
675    */
676   selectionStart(_event) {
677     this.#textLayer?.div.addEventListener(
678       "pointerup",
679       this.#boundPointerUpAfterSelection,
680       { once: true }
681     );
682   }
683 
684   /**
685    * Called when the user releases the mouse button after having selected
686    * some text.
687    * @param {PointerEvent} event
688    */
689   pointerUpAfterSelection(event) {
690     const selection = document.getSelection();
691     if (selection.rangeCount === 0) {
692       return;
693     }
694     const range = selection.getRangeAt(0);
695     if (range.collapsed) {
696       return;
697     }
698 
699     if (!this.#textLayer?.div.contains(range.commonAncestorContainer)) {
700       return;
701     }
702 
703     const {
704       x: layerX,
705       y: layerY,
706       width: parentWidth,
707       height: parentHeight,
708     } = this.#textLayer.div.getBoundingClientRect();
709     const bboxes = range.getClientRects();
710 
711     // We must rotate the boxes because we want to have them in the non-rotated
712     // page coordinates.
713     let rotator;
714     switch (this.viewport.rotation) {
715       case 90:
716         rotator = (x, y, w, h) => ({
717           x: (y - layerY) / parentHeight,
718           y: 1 - (x + w - layerX) / parentWidth,
719           width: h / parentHeight,
720           height: w / parentWidth,
721         });
722         break;
723       case 180:
724         rotator = (x, y, w, h) => ({
725           x: 1 - (x + w - layerX) / parentWidth,
726           y: 1 - (y + h - layerY) / parentHeight,
727           width: w / parentWidth,
728           height: h / parentHeight,
729         });
730         break;
731       case 270:
732         rotator = (x, y, w, h) => ({
733           x: 1 - (y + h - layerY) / parentHeight,
734           y: (x - layerX) / parentWidth,
735           width: h / parentHeight,
736           height: w / parentWidth,
737         });
738         break;
739       default:
740         rotator = (x, y, w, h) => ({
741           x: (x - layerX) / parentWidth,
742           y: (y - layerY) / parentHeight,
743           width: w / parentWidth,
744           height: h / parentHeight,
745         });
746         break;
747     }
748 
749     const boxes = [];
750     for (const { x, y, width, height } of bboxes) {
751       if (width === 0 || height === 0) {
752         continue;
753       }
754       boxes.push(rotator(x, y, width, height));
755     }
756     if (boxes.length !== 0) {
757       this.createAndAddNewEditor(event, false, {
758         boxes,
759       });
760     }
761     selection.empty();
762   }
763 
764   /**
765    * Pointerup callback.
766    * @param {PointerEvent} event
767    */
768   pointerup(event) {
769     const { isMac } = FeatureTest.platform;
770     if (event.button !== 0 || (event.ctrlKey && isMac)) {
771       // Don't create an editor on right click.
772       return;
773     }
774 
775     if (event.target !== this.div) {
776       return;
777     }
778 
779     if (!this.#hadPointerDown) {
780       // It can happen when the user starts a drag inside a text editor
781       // and then releases the mouse button outside of it. In such a case
782       // we don't want to create a new editor, hence we check that a pointerdown
783       // occurred on this div previously.
784       return;
785     }
786     this.#hadPointerDown = false;
787 
788     if (!this.#allowClick) {
789       this.#allowClick = true;
790       return;
791     }
792 
793     if (this.#uiManager.getMode() === AnnotationEditorType.STAMP) {
794       this.#uiManager.unselectAll();
795       return;
796     }
797 
798     this.createAndAddNewEditor(event, /* isCentered = */ false);
799   }
800 
801   /**
802    * Pointerdown callback.
803    * @param {PointerEvent} event
804    */
805   pointerdown(event) {
806     if (this.#uiManager.getMode() === AnnotationEditorType.HIGHLIGHT) {
807       this.enableTextSelection();
808     }
809     if (this.#hadPointerDown) {
810       // It's possible to have a second pointerdown event before a pointerup one
811       // when the user puts a finger on a touchscreen and then add a second one
812       // to start a pinch-to-zoom gesture.
813       // That said, in case it's possible to have two pointerdown events with
814       // a mouse, we don't want to create a new editor in such a case either.
815       this.#hadPointerDown = false;
816       return;
817     }
818     const { isMac } = FeatureTest.platform;
819     if (event.button !== 0 || (event.ctrlKey && isMac)) {
820       // Do nothing on right click.
821       return;
822     }
823 
824     if (event.target !== this.div) {
825       return;
826     }
827 
828     this.#hadPointerDown = true;
829 
830     const editor = this.#uiManager.getActive();
831     this.#allowClick = !editor || editor.isEmpty();
832   }
833 
834   /**
835    *
836    * @param {AnnotationEditor} editor
837    * @param {number} x
838    * @param {number} y
839    * @returns
840    */
841   findNewParent(editor, x, y) {
842     const layer = this.#uiManager.findParent(x, y);
843     if (layer === null || layer === this) {
844       return false;
845     }
846     layer.changeParent(editor);
847     return true;
848   }
849 
850   /**
851    * Destroy the main editor.
852    */
853   destroy() {
854     if (this.#uiManager.getActive()?.parent === this) {
855       // We need to commit the current editor before destroying the layer.
856       this.#uiManager.commitOrRemove();
857       this.#uiManager.setActiveEditor(null);
858     }
859 
860     if (this.#editorFocusTimeoutId) {
861       clearTimeout(this.#editorFocusTimeoutId);
862       this.#editorFocusTimeoutId = null;
863     }
864 
865     for (const editor of this.#editors.values()) {
866       this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);
867       editor.setParent(null);
868       editor.isAttachedToDOM = false;
869       editor.div.remove();
870     }
871     this.div = null;
872     this.#editors.clear();
873     this.#uiManager.removeLayer(this);
874   }
875 
876   #cleanup() {
877     // When we're cleaning up, some editors are removed but we don't want
878     // to add a new one which will induce an addition in this.#editors, hence
879     // an infinite loop.
880     this.#isCleaningUp = true;
881     for (const editor of this.#editors.values()) {
882       if (editor.isEmpty()) {
883         editor.remove();
884       }
885     }
886     this.#isCleaningUp = false;
887   }
888 
889   /**
890    * Render the main editor.
891    * @param {RenderEditorLayerOptions} parameters
892    */
893   render({ viewport }) {
894     this.viewport = viewport;
895     setLayerDimensions(this.div, viewport);
896     for (const editor of this.#uiManager.getEditors(this.pageIndex)) {
897       this.add(editor);
898     }
899     this.updateMode();
900   }
901 
902   /**
903    * Update the main editor.
904    * @param {RenderEditorLayerOptions} parameters
905    */
906   update({ viewport }) {
907     // Editors have their dimensions/positions in percent so to avoid any
908     // issues (see #15582), we must commit the current one before changing
909     // the viewport.
910     this.#uiManager.commitOrRemove();
911 
912     const oldRotation = this.viewport.rotation;
913     const rotation = viewport.rotation;
914     this.viewport = viewport;
915     setLayerDimensions(this.div, { rotation });
916     if (oldRotation !== rotation) {
917       for (const editor of this.#editors.values()) {
918         editor.rotate(rotation);
919       }
920     }
921     this.updateMode();
922   }
923 
924   /**
925    * Get page dimensions.
926    * @returns {Object} dimensions.
927    */
928   get pageDimensions() {
929     const { pageWidth, pageHeight } = this.viewport.rawDims;
930     return [pageWidth, pageHeight];
931   }
932 
933   get scale() {
934     return this.#uiManager.viewParameters.realScale;
935   }
936 }
937 
938 export { AnnotationEditorLayer };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

