Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: Certain text shows in the text layer but isn't rendered in canva behind it
### Attach (recommended) or Link to PDF file

[LUCID - Asif Rasha-1.pdf](https://github.com/user-attachments/files/17065251/LUCID.-.Asif.Rasha-1.pdf)


### Web browser and its version

Google Chrome Version 128.0.6613.138 (Official Build) (x86_64)

### Operating system and its version

Mac OS Sonoma 14.6

### PDF.js version

v4.6.82

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

Open the attached pdf and check the text on the left box.

### What is the expected behavior?

This or something similar would ideally show up:
<img width="317" alt="Screenshot 2024-09-19 at 16 18 13" src="https://github.com/user-attachments/assets/ddb9f2d3-2b2e-4801-aaad-065a1a31d961">

### What went wrong?

This is what is rendered (text layer is present with the needed text, and, if transparent font color is disabled temporarily, the text can be seen exactly where it should be):
<img width="341" alt="Screenshot 2024-09-19 at 16 18 29" src="https://github.com/user-attachments/assets/21388a54-1cfc-4ae2-8f41-fa2f36f11da2">



### Link to a viewer

_No response_

### Additional context

_No response_
</issue>

Patch:
<patch>
diff --git a/src/core/evaluator.js b/src/core/evaluator.js
--- a/src/core/evaluator.js
+++ b/src/core/evaluator.js
@@ -2132,14 +2132,26 @@ class PartialEvaluator {
             break;
 
           case OPS.shadingFill:
-            var shadingRes = resources.get("Shading");
-            if (!shadingRes) {
-              throw new FormatError("No shading resource found");
-            }
+            let shading;
+            try {
+              const shadingRes = resources.get("Shading");
+              if (!shadingRes) {
+                throw new FormatError("No shading resource found");
+              }
 
-            var shading = shadingRes.get(args[0].name);
-            if (!shading) {
-              throw new FormatError("No shading object found");
+              shading = shadingRes.get(args[0].name);
+              if (!shading) {
+                throw new FormatError("No shading object found");
+              }
+            } catch (reason) {
+              if (reason instanceof AbortException) {
+                continue;
+              }
+              if (self.options.ignoreErrors) {
+                warn(`getOperatorList - ignoring Shading: "${reason}".`);
+                continue;
+              }
+              throw reason;
             }
             const patternId = self.parseShading({
               shading,


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.25.2
- @babel/preset-env: ^7.25.4
- @babel/runtime: ^7.25.6
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @jazzer.js/core: ^2.1.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- autoprefixer: ^10.4.20
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001658
- canvas: ^2.11.2
- core-js: ^3.38.1
- eslint: ^8.57.0
- eslint-config-prettier: ^9.1.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^8.1.1
- eslint-plugin-import: ^2.30.0
- eslint-plugin-jasmine: ^4.2.1
- eslint-plugin-json: ^3.1.0
- eslint-plugin-no-unsanitized: ^4.1.0
- eslint-plugin-prettier: ^5.2.1
- eslint-plugin-sort-exports: ^0.9.1
- eslint-plugin-unicorn: ^55.0.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- highlight.js: ^11.10.0
- jasmine: ^5.3.0
- jsdoc: ^4.0.3
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.1
- ordered-read-streams: ^2.0.0
- path2d: ^0.2.1
- pngjs: ^7.0.0
- postcss: ^8.4.45
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.0
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.0
- prettier: ^3.3.3
- puppeteer: ^23.3.0
- stylelint: ^16.9.0
- stylelint-prettier: ^5.0.2
- svglint: ^3.0.0
- terser-webpack-plugin: ^5.3.10
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.5.4
- vinyl: ^3.0.0
- webpack: ^5.94.0
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodePackages
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory, createTemporaryNodeServer
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/evaluator.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 /* eslint-disable no-var */
16 
17 import {
18   AbortException,
19   assert,
20   CMapCompressionType,
21   FONT_IDENTITY_MATRIX,
22   FormatError,
23   IDENTITY_MATRIX,
24   info,
25   isArrayEqual,
26   normalizeUnicode,
27   OPS,
28   shadow,
29   stringToPDFString,
30   TextRenderingMode,
31   Util,
32   warn,
33 } from "../shared/util.js";
34 import { CMapFactory, IdentityCMap } from "./cmap.js";
35 import { Cmd, Dict, EOF, isName, Name, Ref, RefSet } from "./primitives.js";
36 import { ErrorFont, Font } from "./fonts.js";
37 import {
38   getEncoding,
39   MacRomanEncoding,
40   StandardEncoding,
41   SymbolSetEncoding,
42   WinAnsiEncoding,
43   ZapfDingbatsEncoding,
44 } from "./encodings.js";
45 import {
46   getFontNameToFileMap,
47   getSerifFonts,
48   getStandardFontName,
49   getStdFontMap,
50   getSymbolsFonts,
51   isKnownFontName,
52 } from "./standard_fonts.js";
53 import { getTilingPatternIR, Pattern } from "./pattern.js";
54 import { getXfaFontDict, getXfaFontName } from "./xfa_fonts.js";
55 import { IdentityToUnicodeMap, ToUnicodeMap } from "./to_unicode_map.js";
56 import { isNumberArray, lookupMatrix, lookupNormalRect } from "./core_utils.js";
57 import { isPDFFunction, PDFFunctionFactory } from "./function.js";
58 import { Lexer, Parser } from "./parser.js";
59 import {
60   LocalColorSpaceCache,
61   LocalGStateCache,
62   LocalImageCache,
63   LocalTilingPatternCache,
64   RegionalImageCache,
65 } from "./image_utils.js";
66 import { NullStream, Stream } from "./stream.js";
67 import { BaseStream } from "./base_stream.js";
68 import { bidi } from "./bidi.js";
69 import { ColorSpace } from "./colorspace.js";
70 import { DecodeStream } from "./decode_stream.js";
71 import { FontFlags } from "./fonts_utils.js";
72 import { getFontSubstitution } from "./font_substitutions.js";
73 import { getGlyphsUnicode } from "./glyphlist.js";
74 import { getMetrics } from "./metrics.js";
75 import { getUnicodeForGlyph } from "./unicode.js";
76 import { ImageResizer } from "./image_resizer.js";
77 import { MurmurHash3_64 } from "../shared/murmurhash3.js";
78 import { OperatorList } from "./operator_list.js";
79 import { PDFImage } from "./image.js";
80 
81 const DefaultPartialEvaluatorOptions = Object.freeze({
82   maxImageSize: -1,
83   disableFontFace: false,
84   ignoreErrors: false,
85   isEvalSupported: true,
86   isOffscreenCanvasSupported: false,
87   canvasMaxAreaInBytes: -1,
88   fontExtraProperties: false,
89   useSystemFonts: true,
90   cMapUrl: null,
91   standardFontDataUrl: null,
92 });
93 
94 const PatternType = {
95   TILING: 1,
96   SHADING: 2,
97 };
98 
99 // Optionally avoid sending individual, or very few, text chunks to reduce
100 // `postMessage` overhead with ReadableStream (see issue 13962).
101 //
102 // PLEASE NOTE: This value should *not* be too large (it's used as a lower limit
103 // in `enqueueChunk`), since that would cause streaming of textContent to become
104 // essentially useless in practice by sending all (or most) chunks at once.
105 // Also, a too large value would (indirectly) affect the main-thread `textLayer`
106 // building negatively by forcing all textContent to be handled at once, which
107 // could easily end up hurting *overall* performance (e.g. rendering as well).
108 const TEXT_CHUNK_BATCH_SIZE = 10;
109 
110 const deferred = Promise.resolve();
111 
112 // Convert PDF blend mode names to HTML5 blend mode names.
113 function normalizeBlendMode(value, parsingArray = false) {
114   if (Array.isArray(value)) {
115     // Use the first *supported* BM value in the Array (fixes issue11279.pdf).
116     for (const val of value) {
117       const maybeBM = normalizeBlendMode(val, /* parsingArray = */ true);
118       if (maybeBM) {
119         return maybeBM;
120       }
121     }
122     warn(`Unsupported blend mode Array: ${value}`);
123     return "source-over";
124   }
125 
126   if (!(value instanceof Name)) {
127     if (parsingArray) {
128       return null;
129     }
130     return "source-over";
131   }
132   switch (value.name) {
133     case "Normal":
134     case "Compatible":
135       return "source-over";
136     case "Multiply":
137       return "multiply";
138     case "Screen":
139       return "screen";
140     case "Overlay":
141       return "overlay";
142     case "Darken":
143       return "darken";
144     case "Lighten":
145       return "lighten";
146     case "ColorDodge":
147       return "color-dodge";
148     case "ColorBurn":
149       return "color-burn";
150     case "HardLight":
151       return "hard-light";
152     case "SoftLight":
153       return "soft-light";
154     case "Difference":
155       return "difference";
156     case "Exclusion":
157       return "exclusion";
158     case "Hue":
159       return "hue";
160     case "Saturation":
161       return "saturation";
162     case "Color":
163       return "color";
164     case "Luminosity":
165       return "luminosity";
166   }
167   if (parsingArray) {
168     return null;
169   }
170   warn(`Unsupported blend mode: ${value.name}`);
171   return "source-over";
172 }
173 
174 function addLocallyCachedImageOps(opList, data) {
175   if (data.objId) {
176     opList.addDependency(data.objId);
177   }
178   opList.addImageOps(data.fn, data.args, data.optionalContent);
179 
180   if (data.fn === OPS.paintImageMaskXObject && data.args[0]?.count > 0) {
181     data.args[0].count++;
182   }
183 }
184 
185 // Trying to minimize Date.now() usage and check every 100 time.
186 class TimeSlotManager {
187   static TIME_SLOT_DURATION_MS = 20;
188 
189   static CHECK_TIME_EVERY = 100;
190 
191   constructor() {
192     this.reset();
193   }
194 
195   check() {
196     if (++this.checked < TimeSlotManager.CHECK_TIME_EVERY) {
197       return false;
198     }
199     this.checked = 0;
200     return this.endTime <= Date.now();
201   }
202 
203   reset() {
204     this.endTime = Date.now() + TimeSlotManager.TIME_SLOT_DURATION_MS;
205     this.checked = 0;
206   }
207 }
208 
209 class PartialEvaluator {
210   constructor({
211     xref,
212     handler,
213     pageIndex,
214     idFactory,
215     fontCache,
216     builtInCMapCache,
217     standardFontDataCache,
218     globalImageCache,
219     systemFontCache,
220     options = null,
221   }) {
222     this.xref = xref;
223     this.handler = handler;
224     this.pageIndex = pageIndex;
225     this.idFactory = idFactory;
226     this.fontCache = fontCache;
227     this.builtInCMapCache = builtInCMapCache;
228     this.standardFontDataCache = standardFontDataCache;
229     this.globalImageCache = globalImageCache;
230     this.systemFontCache = systemFontCache;
231     this.options = options || DefaultPartialEvaluatorOptions;
232     this.type3FontRefs = null;
233 
234     this._regionalImageCache = new RegionalImageCache();
235     this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
236     ImageResizer.setMaxArea(this.options.canvasMaxAreaInBytes);
237   }
238 
239   /**
240    * Since Functions are only cached (locally) by reference, we can share one
241    * `PDFFunctionFactory` instance within this `PartialEvaluator` instance.
242    */
243   get _pdfFunctionFactory() {
244     const pdfFunctionFactory = new PDFFunctionFactory({
245       xref: this.xref,
246       isEvalSupported: this.options.isEvalSupported,
247     });
248     return shadow(this, "_pdfFunctionFactory", pdfFunctionFactory);
249   }
250 
251   get parsingType3Font() {
252     return !!this.type3FontRefs;
253   }
254 
255   clone(newOptions = null) {
256     const newEvaluator = Object.create(this);
257     newEvaluator.options = Object.assign(
258       Object.create(null),
259       this.options,
260       newOptions
261     );
262     return newEvaluator;
263   }
264 
265   hasBlendModes(resources, nonBlendModesSet) {
266     if (!(resources instanceof Dict)) {
267       return false;
268     }
269     if (resources.objId && nonBlendModesSet.has(resources.objId)) {
270       return false;
271     }
272 
273     const processed = new RefSet(nonBlendModesSet);
274     if (resources.objId) {
275       processed.put(resources.objId);
276     }
277 
278     const nodes = [resources],
279       xref = this.xref;
280     while (nodes.length) {
281       const node = nodes.shift();
282       // First check the current resources for blend modes.
283       const graphicStates = node.get("ExtGState");
284       if (graphicStates instanceof Dict) {
285         for (let graphicState of graphicStates.getRawValues()) {
286           if (graphicState instanceof Ref) {
287             if (processed.has(graphicState)) {
288               continue; // The ExtGState has already been processed.
289             }
290             try {
291               graphicState = xref.fetch(graphicState);
292             } catch (ex) {
293               // Avoid parsing a corrupt ExtGState more than once.
294               processed.put(graphicState);
295 
296               info(`hasBlendModes - ignoring ExtGState: "${ex}".`);
297               continue;
298             }
299           }
300           if (!(graphicState instanceof Dict)) {
301             continue;
302           }
303           if (graphicState.objId) {
304             processed.put(graphicState.objId);
305           }
306 
307           const bm = graphicState.get("BM");
308           if (bm instanceof Name) {
309             if (bm.name !== "Normal") {
310               return true;
311             }
312             continue;
313           }
314           if (bm !== undefined && Array.isArray(bm)) {
315             for (const element of bm) {
316               if (element instanceof Name && element.name !== "Normal") {
317                 return true;
318               }
319             }
320           }
321         }
322       }
323       // Descend into the XObjects to look for more resources and blend modes.
324       const xObjects = node.get("XObject");
325       if (!(xObjects instanceof Dict)) {
326         continue;
327       }
328       for (let xObject of xObjects.getRawValues()) {
329         if (xObject instanceof Ref) {
330           if (processed.has(xObject)) {
331             // The XObject has already been processed, and by avoiding a
332             // redundant `xref.fetch` we can *significantly* reduce the load
333             // time for badly generated PDF files (fixes issue6961.pdf).
334             continue;
335           }
336           try {
337             xObject = xref.fetch(xObject);
338           } catch (ex) {
339             // Avoid parsing a corrupt XObject more than once.
340             processed.put(xObject);
341 
342             info(`hasBlendModes - ignoring XObject: "${ex}".`);
343             continue;
344           }
345         }
346         if (!(xObject instanceof BaseStream)) {
347           continue;
348         }
349         if (xObject.dict.objId) {
350           processed.put(xObject.dict.objId);
351         }
352         const xResources = xObject.dict.get("Resources");
353         if (!(xResources instanceof Dict)) {
354           continue;
355         }
356         // Checking objId to detect an infinite loop.
357         if (xResources.objId && processed.has(xResources.objId)) {
358           continue;
359         }
360 
361         nodes.push(xResources);
362         if (xResources.objId) {
363           processed.put(xResources.objId);
364         }
365       }
366     }
367 
368     // When no blend modes exist, there's no need re-fetch/re-parse any of the
369     // processed `Ref`s again for subsequent pages. This helps reduce redundant
370     // `XRef.fetch` calls for some documents (e.g. issue6961.pdf).
371     for (const ref of processed) {
372       nonBlendModesSet.put(ref);
373     }
374     return false;
375   }
376 
377   async fetchBuiltInCMap(name) {
378     const cachedData = this.builtInCMapCache.get(name);
379     if (cachedData) {
380       return cachedData;
381     }
382     let data;
383 
384     if (this.options.cMapUrl !== null) {
385       // Only compressed CMaps are (currently) supported here.
386       const url = `${this.options.cMapUrl}${name}.bcmap`;
387       const response = await fetch(url);
388       if (!response.ok) {
389         throw new Error(
390           `fetchBuiltInCMap: failed to fetch file "${url}" with "${response.statusText}".`
391         );
392       }
393       data = {
394         cMapData: new Uint8Array(await response.arrayBuffer()),
395         compressionType: CMapCompressionType.BINARY,
396       };
397     } else {
398       // Get the data on the main-thread instead.
399       data = await this.handler.sendWithPromise("FetchBuiltInCMap", { name });
400     }
401 
402     if (data.compressionType !== CMapCompressionType.NONE) {
403       // Given the size of uncompressed CMaps, only cache compressed ones.
404       this.builtInCMapCache.set(name, data);
405     }
406     return data;
407   }
408 
409   async fetchStandardFontData(name) {
410     const cachedData = this.standardFontDataCache.get(name);
411     if (cachedData) {
412       return new Stream(cachedData);
413     }
414 
415     // The symbol fonts are not consistent across platforms, always load the
416     // standard font data for them.
417     if (
418       this.options.useSystemFonts &&
419       name !== "Symbol" &&
420       name !== "ZapfDingbats"
421     ) {
422       return null;
423     }
424 
425     const standardFontNameToFileName = getFontNameToFileMap(),
426       filename = standardFontNameToFileName[name];
427     let data;
428 
429     if (this.options.standardFontDataUrl !== null) {
430       const url = `${this.options.standardFontDataUrl}${filename}`;
431       const response = await fetch(url);
432       if (!response.ok) {
433         warn(
434           `fetchStandardFontData: failed to fetch file "${url}" with "${response.statusText}".`
435         );
436       } else {
437         data = new Uint8Array(await response.arrayBuffer());
438       }
439     } else {
440       // Get the data on the main-thread instead.
441       try {
442         data = await this.handler.sendWithPromise("FetchStandardFontData", {
443           filename,
444         });
445       } catch (e) {
446         warn(
447           `fetchStandardFontData: failed to fetch file "${filename}" with "${e}".`
448         );
449       }
450     }
451 
452     if (!data) {
453       return null;
454     }
455     // Cache the "raw" standard font data, to avoid fetching it repeatedly
456     // (see e.g. issue 11399).
457     this.standardFontDataCache.set(name, data);
458 
459     return new Stream(data);
460   }
461 
462   async buildFormXObject(
463     resources,
464     xobj,
465     smask,
466     operatorList,
467     task,
468     initialState,
469     localColorSpaceCache
470   ) {
471     const dict = xobj.dict;
472     const matrix = lookupMatrix(dict.getArray("Matrix"), null);
473     const bbox = lookupNormalRect(dict.getArray("BBox"), null);
474 
475     let optionalContent, groupOptions;
476     if (dict.has("OC")) {
477       optionalContent = await this.parseMarkedContentProps(
478         dict.get("OC"),
479         resources
480       );
481     }
482     if (optionalContent !== undefined) {
483       operatorList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
484     }
485     const group = dict.get("Group");
486     if (group) {
487       groupOptions = {
488         matrix,
489         bbox,
490         smask,
491         isolated: false,
492         knockout: false,
493       };
494 
495       const groupSubtype = group.get("S");
496       let colorSpace = null;
497       if (isName(groupSubtype, "Transparency")) {
498         groupOptions.isolated = group.get("I") || false;
499         groupOptions.knockout = group.get("K") || false;
500         if (group.has("CS")) {
501           const cs = group.getRaw("CS");
502 
503           const cachedColorSpace = ColorSpace.getCached(
504             cs,
505             this.xref,
506             localColorSpaceCache
507           );
508           if (cachedColorSpace) {
509             colorSpace = cachedColorSpace;
510           } else {
511             colorSpace = await this.parseColorSpace({
512               cs,
513               resources,
514               localColorSpaceCache,
515             });
516           }
517         }
518       }
519 
520       if (smask?.backdrop) {
521         colorSpace ||= ColorSpace.singletons.rgb;
522         smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
523       }
524 
525       operatorList.addOp(OPS.beginGroup, [groupOptions]);
526     }
527 
528     // If it's a group, a new canvas will be created that is the size of the
529     // bounding box and translated to the correct position so we don't need to
530     // apply the bounding box to it.
531     const args = group ? [matrix, null] : [matrix, bbox];
532     operatorList.addOp(OPS.paintFormXObjectBegin, args);
533 
534     await this.getOperatorList({
535       stream: xobj,
536       task,
537       resources: dict.get("Resources") || resources,
538       operatorList,
539       initialState,
540     });
541     operatorList.addOp(OPS.paintFormXObjectEnd, []);
542 
543     if (group) {
544       operatorList.addOp(OPS.endGroup, [groupOptions]);
545     }
546 
547     if (optionalContent !== undefined) {
548       operatorList.addOp(OPS.endMarkedContent, []);
549     }
550   }
551 
552   _sendImgData(objId, imgData, cacheGlobally = false) {
553     if (
554       (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) &&
555       imgData
556     ) {
557       assert(Number.isInteger(imgData.dataLen), "Expected dataLen to be set.");
558     }
559     const transfers = imgData ? [imgData.bitmap || imgData.data.buffer] : null;
560 
561     if (this.parsingType3Font || cacheGlobally) {
562       return this.handler.send(
563         "commonobj",
564         [objId, "Image", imgData],
565         transfers
566       );
567     }
568     return this.handler.send(
569       "obj",
570       [objId, this.pageIndex, "Image", imgData],
571       transfers
572     );
573   }
574 
575   async buildPaintImageXObject({
576     resources,
577     image,
578     isInline = false,
579     operatorList,
580     cacheKey,
581     localImageCache,
582     localColorSpaceCache,
583   }) {
584     const dict = image.dict;
585     const imageRef = dict.objId;
586     const w = dict.get("W", "Width");
587     const h = dict.get("H", "Height");
588 
589     if (!(w && typeof w === "number") || !(h && typeof h === "number")) {
590       warn("Image dimensions are missing, or not numbers.");
591       return;
592     }
593     const maxImageSize = this.options.maxImageSize;
594     if (maxImageSize !== -1 && w * h > maxImageSize) {
595       const msg = "Image exceeded maximum allowed size and was removed.";
596 
597       if (this.options.ignoreErrors) {
598         warn(msg);
599         return;
600       }
601       throw new Error(msg);
602     }
603 
604     let optionalContent;
605     if (dict.has("OC")) {
606       optionalContent = await this.parseMarkedContentProps(
607         dict.get("OC"),
608         resources
609       );
610     }
611 
612     const imageMask = dict.get("IM", "ImageMask") || false;
613     let imgData, args;
614     if (imageMask) {
615       // This depends on a tmpCanvas being filled with the
616       // current fillStyle, such that processing the pixel
617       // data can't be done here. Instead of creating a
618       // complete PDFImage, only read the information needed
619       // for later.
620       const interpolate = dict.get("I", "Interpolate");
621       const bitStrideLength = (w + 7) >> 3;
622       const imgArray = image.getBytes(bitStrideLength * h);
623       const decode = dict.getArray("D", "Decode");
624 
625       if (this.parsingType3Font) {
626         imgData = PDFImage.createRawMask({
627           imgArray,
628           width: w,
629           height: h,
630           imageIsFromDecodeStream: image instanceof DecodeStream,
631           inverseDecode: decode?.[0] > 0,
632           interpolate,
633         });
634 
635         imgData.cached = !!cacheKey;
636         args = [imgData];
637 
638         operatorList.addImageOps(
639           OPS.paintImageMaskXObject,
640           args,
641           optionalContent
642         );
643 
644         if (cacheKey) {
645           const cacheData = {
646             fn: OPS.paintImageMaskXObject,
647             args,
648             optionalContent,
649           };
650           localImageCache.set(cacheKey, imageRef, cacheData);
651 
652           if (imageRef) {
653             this._regionalImageCache.set(
654               /* name = */ null,
655               imageRef,
656               cacheData
657             );
658           }
659         }
660         return;
661       }
662 
663       imgData = await PDFImage.createMask({
664         imgArray,
665         width: w,
666         height: h,
667         imageIsFromDecodeStream: image instanceof DecodeStream,
668         inverseDecode: decode?.[0] > 0,
669         interpolate,
670         isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported,
671       });
672 
673       if (imgData.isSingleOpaquePixel) {
674         // Handles special case of mainly LaTeX documents which use image
675         // masks to draw lines with the current fill style.
676         operatorList.addImageOps(
677           OPS.paintSolidColorImageMask,
678           [],
679           optionalContent
680         );
681 
682         if (cacheKey) {
683           const cacheData = {
684             fn: OPS.paintSolidColorImageMask,
685             args: [],
686             optionalContent,
687           };
688           localImageCache.set(cacheKey, imageRef, cacheData);
689 
690           if (imageRef) {
691             this._regionalImageCache.set(
692               /* name = */ null,
693               imageRef,
694               cacheData
695             );
696           }
697         }
698         return;
699       }
700 
701       const objId = `mask_${this.idFactory.createObjId()}`;
702       operatorList.addDependency(objId);
703 
704       imgData.dataLen = imgData.bitmap
705         ? imgData.width * imgData.height * 4
706         : imgData.data.length;
707       this._sendImgData(objId, imgData);
708 
709       args = [
710         {
711           data: objId,
712           width: imgData.width,
713           height: imgData.height,
714           interpolate: imgData.interpolate,
715           count: 1,
716         },
717       ];
718       operatorList.addImageOps(
719         OPS.paintImageMaskXObject,
720         args,
721         optionalContent
722       );
723 
724       if (cacheKey) {
725         const cacheData = {
726           objId,
727           fn: OPS.paintImageMaskXObject,
728           args,
729           optionalContent,
730         };
731         localImageCache.set(cacheKey, imageRef, cacheData);
732 
733         if (imageRef) {
734           this._regionalImageCache.set(/* name = */ null, imageRef, cacheData);
735         }
736       }
737       return;
738     }
739 
740     const SMALL_IMAGE_DIMENSIONS = 200;
741     // Inlining small images into the queue as RGB data
742     if (
743       isInline &&
744       w + h < SMALL_IMAGE_DIMENSIONS &&
745       !dict.has("SMask") &&
746       !dict.has("Mask")
747     ) {
748       try {
749         const imageObj = new PDFImage({
750           xref: this.xref,
751           res: resources,
752           image,
753           isInline,
754           pdfFunctionFactory: this._pdfFunctionFactory,
755           localColorSpaceCache,
756         });
757         // We force the use of RGBA_32BPP images here, because we can't handle
758         // any other kind.
759         imgData = await imageObj.createImageData(
760           /* forceRGBA = */ true,
761           /* isOffscreenCanvasSupported = */ false
762         );
763         operatorList.isOffscreenCanvasSupported =
764           this.options.isOffscreenCanvasSupported;
765         operatorList.addImageOps(
766           OPS.paintInlineImageXObject,
767           [imgData],
768           optionalContent
769         );
770       } catch (reason) {
771         const msg = `Unable to decode inline image: "${reason}".`;
772 
773         if (!this.options.ignoreErrors) {
774           throw new Error(msg);
775         }
776         warn(msg);
777       }
778       return;
779     }
780 
781     // If there is no imageMask, create the PDFImage and a lot
782     // of image processing can be done here.
783     let objId = `img_${this.idFactory.createObjId()}`,
784       cacheGlobally = false;
785 
786     if (this.parsingType3Font) {
787       objId = `${this.idFactory.getDocId()}_type3_${objId}`;
788     } else if (cacheKey && imageRef) {
789       cacheGlobally = this.globalImageCache.shouldCache(
790         imageRef,
791         this.pageIndex
792       );
793 
794       if (cacheGlobally) {
795         assert(!isInline, "Cannot cache an inline image globally.");
796 
797         objId = `${this.idFactory.getDocId()}_${objId}`;
798       }
799     }
800 
801     // Ensure that the dependency is added before the image is decoded.
802     operatorList.addDependency(objId);
803     args = [objId, w, h];
804     operatorList.addImageOps(OPS.paintImageXObject, args, optionalContent);
805 
806     if (cacheGlobally) {
807       if (this.globalImageCache.hasDecodeFailed(imageRef)) {
808         this.globalImageCache.setData(imageRef, {
809           objId,
810           fn: OPS.paintImageXObject,
811           args,
812           optionalContent,
813           byteSize: 0, // Data is `null`, since decoding failed previously.
814         });
815 
816         this._sendImgData(objId, /* imgData = */ null, cacheGlobally);
817         return;
818       }
819 
820       // For large (at least 500x500) or more complex images that we'll cache
821       // globally, check if the image is still cached locally on the main-thread
822       // to avoid having to re-parse the image (since that can be slow).
823       if (w * h > 250000 || dict.has("SMask") || dict.has("Mask")) {
824         const localLength = await this.handler.sendWithPromise("commonobj", [
825           objId,
826           "CopyLocalImage",
827           { imageRef },
828         ]);
829 
830         if (localLength) {
831           this.globalImageCache.setData(imageRef, {
832             objId,
833             fn: OPS.paintImageXObject,
834             args,
835             optionalContent,
836             byteSize: 0, // Temporary entry, to avoid `setData` returning early.
837           });
838           this.globalImageCache.addByteSize(imageRef, localLength);
839           return;
840         }
841       }
842     }
843 
844     PDFImage.buildImage({
845       xref: this.xref,
846       res: resources,
847       image,
848       isInline,
849       pdfFunctionFactory: this._pdfFunctionFactory,
850       localColorSpaceCache,
851     })
852       .then(async imageObj => {
853         imgData = await imageObj.createImageData(
854           /* forceRGBA = */ false,
855           /* isOffscreenCanvasSupported = */ this.options
856             .isOffscreenCanvasSupported
857         );
858         imgData.dataLen = imgData.bitmap
859           ? imgData.width * imgData.height * 4
860           : imgData.data.length;
861         imgData.ref = imageRef;
862 
863         if (cacheGlobally) {
864           this.globalImageCache.addByteSize(imageRef, imgData.dataLen);
865         }
866         return this._sendImgData(objId, imgData, cacheGlobally);
867       })
868       .catch(reason => {
869         warn(`Unable to decode image "${objId}": "${reason}".`);
870 
871         if (imageRef) {
872           this.globalImageCache.addDecodeFailed(imageRef);
873         }
874         return this._sendImgData(objId, /* imgData = */ null, cacheGlobally);
875       });
876 
877     if (cacheKey) {
878       const cacheData = {
879         objId,
880         fn: OPS.paintImageXObject,
881         args,
882         optionalContent,
883       };
884       localImageCache.set(cacheKey, imageRef, cacheData);
885 
886       if (imageRef) {
887         this._regionalImageCache.set(/* name = */ null, imageRef, cacheData);
888 
889         if (cacheGlobally) {
890           this.globalImageCache.setData(imageRef, {
891             objId,
892             fn: OPS.paintImageXObject,
893             args,
894             optionalContent,
895             byteSize: 0, // Temporary entry, note `addByteSize` above.
896           });
897         }
898       }
899     }
900   }
901 
902   handleSMask(
903     smask,
904     resources,
905     operatorList,
906     task,
907     stateManager,
908     localColorSpaceCache
909   ) {
910     const smaskContent = smask.get("G");
911     const smaskOptions = {
912       subtype: smask.get("S").name,
913       backdrop: smask.get("BC"),
914     };
915 
916     // The SMask might have a alpha/luminosity value transfer function --
917     // we will build a map of integer values in range 0..255 to be fast.
918     const transferObj = smask.get("TR");
919     if (isPDFFunction(transferObj)) {
920       const transferFn = this._pdfFunctionFactory.create(transferObj);
921       const transferMap = new Uint8Array(256);
922       const tmp = new Float32Array(1);
923       for (let i = 0; i < 256; i++) {
924         tmp[0] = i / 255;
925         transferFn(tmp, 0, tmp, 0);
926         transferMap[i] = (tmp[0] * 255) | 0;
927       }
928       smaskOptions.transferMap = transferMap;
929     }
930 
931     return this.buildFormXObject(
932       resources,
933       smaskContent,
934       smaskOptions,
935       operatorList,
936       task,
937       stateManager.state.clone(),
938       localColorSpaceCache
939     );
940   }
941 
942   handleTransferFunction(tr) {
943     let transferArray;
944     if (Array.isArray(tr)) {
945       transferArray = tr;
946     } else if (isPDFFunction(tr)) {
947       transferArray = [tr];
948     } else {
949       return null; // Not a valid transfer function entry.
950     }
951 
952     const transferMaps = [];
953     let numFns = 0,
954       numEffectfulFns = 0;
955     for (const entry of transferArray) {
956       const transferObj = this.xref.fetchIfRef(entry);
957       numFns++;
958 
959       if (isName(transferObj, "Identity")) {
960         transferMaps.push(null);
961         continue;
962       } else if (!isPDFFunction(transferObj)) {
963         return null; // Not a valid transfer function object.
964       }
965 
966       const transferFn = this._pdfFunctionFactory.create(transferObj);
967       const transferMap = new Uint8Array(256),
968         tmp = new Float32Array(1);
969       for (let j = 0; j < 256; j++) {
970         tmp[0] = j / 255;
971         transferFn(tmp, 0, tmp, 0);
972         transferMap[j] = (tmp[0] * 255) | 0;
973       }
974       transferMaps.push(transferMap);
975       numEffectfulFns++;
976     }
977 
978     if (!(numFns === 1 || numFns === 4)) {
979       return null; // Only 1 or 4 functions are supported, by the specification.
980     }
981     if (numEffectfulFns === 0) {
982       return null; // Only /Identity transfer functions found, which are no-ops.
983     }
984     return transferMaps;
985   }
986 
987   handleTilingType(
988     fn,
989     color,
990     resources,
991     pattern,
992     patternDict,
993     operatorList,
994     task,
995     localTilingPatternCache
996   ) {
997     // Create an IR of the pattern code.
998     const tilingOpList = new OperatorList();
999     // Merge the available resources, to prevent issues when the patternDict
1000     // is missing some /Resources entries (fixes issue6541.pdf).
1001     const patternResources = Dict.merge({
1002       xref: this.xref,
1003       dictArray: [patternDict.get("Resources"), resources],
1004     });
1005 
1006     return this.getOperatorList({
1007       stream: pattern,
1008       task,
1009       resources: patternResources,
1010       operatorList: tilingOpList,
1011     })
1012       .then(function () {
1013         const operatorListIR = tilingOpList.getIR();
1014         const tilingPatternIR = getTilingPatternIR(
1015           operatorListIR,
1016           patternDict,
1017           color
1018         );
1019         // Add the dependencies to the parent operator list so they are
1020         // resolved before the sub operator list is executed synchronously.
1021         operatorList.addDependencies(tilingOpList.dependencies);
1022         operatorList.addOp(fn, tilingPatternIR);
1023 
1024         if (patternDict.objId) {
1025           localTilingPatternCache.set(/* name = */ null, patternDict.objId, {
1026             operatorListIR,
1027             dict: patternDict,
1028           });
1029         }
1030       })
1031       .catch(reason => {
1032         if (reason instanceof AbortException) {
1033           return;
1034         }
1035         if (this.options.ignoreErrors) {
1036           warn(`handleTilingType - ignoring pattern: "${reason}".`);
1037           return;
1038         }
1039         throw reason;
1040       });
1041   }
1042 
1043   async handleSetFont(
1044     resources,
1045     fontArgs,
1046     fontRef,
1047     operatorList,
1048     task,
1049     state,
1050     fallbackFontDict = null,
1051     cssFontInfo = null
1052   ) {
1053     const fontName = fontArgs?.[0] instanceof Name ? fontArgs[0].name : null;
1054 
1055     let translated = await this.loadFont(
1056       fontName,
1057       fontRef,
1058       resources,
1059       fallbackFontDict,
1060       cssFontInfo
1061     );
1062 
1063     if (translated.font.isType3Font) {
1064       try {
1065         await translated.loadType3Data(this, resources, task);
1066         // Add the dependencies to the parent operatorList so they are
1067         // resolved before Type3 operatorLists are executed synchronously.
1068         operatorList.addDependencies(translated.type3Dependencies);
1069       } catch (reason) {
1070         translated = new TranslatedFont({
1071           loadedName: "g_font_error",
1072           font: new ErrorFont(`Type3 font load error: ${reason}`),
1073           dict: translated.font,
1074           evaluatorOptions: this.options,
1075         });
1076       }
1077     }
1078 
1079     state.font = translated.font;
1080     translated.send(this.handler);
1081     return translated.loadedName;
1082   }
1083 
1084   handleText(chars, state) {
1085     const font = state.font;
1086     const glyphs = font.charsToGlyphs(chars);
1087 
1088     if (font.data) {
1089       const isAddToPathSet = !!(
1090         state.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG
1091       );
1092       if (
1093         isAddToPathSet ||
1094         state.fillColorSpace.name === "Pattern" ||
1095         font.disableFontFace ||
1096         this.options.disableFontFace
1097       ) {
1098         PartialEvaluator.buildFontPaths(
1099           font,
1100           glyphs,
1101           this.handler,
1102           this.options
1103         );
1104       }
1105     }
1106     return glyphs;
1107   }
1108 
1109   ensureStateFont(state) {
1110     if (state.font) {
1111       return;
1112     }
1113     const reason = new FormatError(
1114       "Missing setFont (Tf) operator before text rendering operator."
1115     );
1116 
1117     if (this.options.ignoreErrors) {
1118       warn(`ensureStateFont: "${reason}".`);
1119       return;
1120     }
1121     throw reason;
1122   }
1123 
1124   async setGState({
1125     resources,
1126     gState,
1127     operatorList,
1128     cacheKey,
1129     task,
1130     stateManager,
1131     localGStateCache,
1132     localColorSpaceCache,
1133   }) {
1134     const gStateRef = gState.objId;
1135     let isSimpleGState = true;
1136     // This array holds the converted/processed state data.
1137     const gStateObj = [];
1138     let promise = Promise.resolve();
1139     for (const key of gState.getKeys()) {
1140       const value = gState.get(key);
1141       switch (key) {
1142         case "Type":
1143           break;
1144         case "LW":
1145         case "LC":
1146         case "LJ":
1147         case "ML":
1148         case "D":
1149         case "RI":
1150         case "FL":
1151         case "CA":
1152         case "ca":
1153           gStateObj.push([key, value]);
1154           break;
1155         case "Font":
1156           isSimpleGState = false;
1157 
1158           promise = promise.then(() =>
1159             this.handleSetFont(
1160               resources,
1161               null,
1162               value[0],
1163               operatorList,
1164               task,
1165               stateManager.state
1166             ).then(function (loadedName) {
1167               operatorList.addDependency(loadedName);
1168               gStateObj.push([key, [loadedName, value[1]]]);
1169             })
1170           );
1171           break;
1172         case "BM":
1173           gStateObj.push([key, normalizeBlendMode(value)]);
1174           break;
1175         case "SMask":
1176           if (isName(value, "None")) {
1177             gStateObj.push([key, false]);
1178             break;
1179           }
1180           if (value instanceof Dict) {
1181             isSimpleGState = false;
1182 
1183             promise = promise.then(() =>
1184               this.handleSMask(
1185                 value,
1186                 resources,
1187                 operatorList,
1188                 task,
1189                 stateManager,
1190                 localColorSpaceCache
1191               )
1192             );
1193             gStateObj.push([key, true]);
1194           } else {
1195             warn("Unsupported SMask type");
1196           }
1197           break;
1198         case "TR":
1199           const transferMaps = this.handleTransferFunction(value);
1200           gStateObj.push([key, transferMaps]);
1201           break;
1202         // Only generate info log messages for the following since
1203         // they are unlikely to have a big impact on the rendering.
1204         case "OP":
1205         case "op":
1206         case "OPM":
1207         case "BG":
1208         case "BG2":
1209         case "UCR":
1210         case "UCR2":
1211         case "TR2":
1212         case "HT":
1213         case "SM":
1214         case "SA":
1215         case "AIS":
1216         case "TK":
1217           // TODO implement these operators.
1218           info("graphic state operator " + key);
1219           break;
1220         default:
1221           info("Unknown graphic state operator " + key);
1222           break;
1223       }
1224     }
1225     await promise;
1226 
1227     if (gStateObj.length > 0) {
1228       operatorList.addOp(OPS.setGState, [gStateObj]);
1229     }
1230 
1231     if (isSimpleGState) {
1232       localGStateCache.set(cacheKey, gStateRef, gStateObj);
1233     }
1234   }
1235 
1236   loadFont(
1237     fontName,
1238     font,
1239     resources,
1240     fallbackFontDict = null,
1241     cssFontInfo = null
1242   ) {
1243     // eslint-disable-next-line arrow-body-style
1244     const errorFont = async () => {
1245       return new TranslatedFont({
1246         loadedName: "g_font_error",
1247         font: new ErrorFont(`Font "${fontName}" is not available.`),
1248         dict: font,
1249         evaluatorOptions: this.options,
1250       });
1251     };
1252 
1253     let fontRef;
1254     if (font) {
1255       // Loading by ref.
1256       if (font instanceof Ref) {
1257         fontRef = font;
1258       }
1259     } else {
1260       // Loading by name.
1261       const fontRes = resources.get("Font");
1262       if (fontRes) {
1263         fontRef = fontRes.getRaw(fontName);
1264       }
1265     }
1266     if (fontRef) {
1267       if (this.type3FontRefs?.has(fontRef)) {
1268         return errorFont();
1269       }
1270 
1271       if (this.fontCache.has(fontRef)) {
1272         return this.fontCache.get(fontRef);
1273       }
1274 
1275       try {
1276         font = this.xref.fetchIfRef(fontRef);
1277       } catch (ex) {
1278         warn(`loadFont - lookup failed: "${ex}".`);
1279       }
1280     }
1281 
1282     if (!(font instanceof Dict)) {
1283       if (!this.options.ignoreErrors && !this.parsingType3Font) {
1284         warn(`Font "${fontName}" is not available.`);
1285         return errorFont();
1286       }
1287       warn(
1288         `Font "${fontName}" is not available -- attempting to fallback to a default font.`
1289       );
1290 
1291       // Falling back to a default font to avoid completely broken rendering,
1292       // but note that there're no guarantees that things will look "correct".
1293       font = fallbackFontDict || PartialEvaluator.fallbackFontDict;
1294     }
1295 
1296     // We are holding `font.cacheKey` references only for `fontRef`s that
1297     // are not actually `Ref`s, but rather `Dict`s. See explanation below.
1298     if (font.cacheKey && this.fontCache.has(font.cacheKey)) {
1299       return this.fontCache.get(font.cacheKey);
1300     }
1301 
1302     const { promise, resolve } = Promise.withResolvers();
1303 
1304     let preEvaluatedFont;
1305     try {
1306       preEvaluatedFont = this.preEvaluateFont(font);
1307       preEvaluatedFont.cssFontInfo = cssFontInfo;
1308     } catch (reason) {
1309       warn(`loadFont - preEvaluateFont failed: "${reason}".`);
1310       return errorFont();
1311     }
1312     const { descriptor, hash } = preEvaluatedFont;
1313 
1314     const fontRefIsRef = fontRef instanceof Ref;
1315     let fontID;
1316 
1317     if (hash && descriptor instanceof Dict) {
1318       const fontAliases = (descriptor.fontAliases ||= Object.create(null));
1319 
1320       if (fontAliases[hash]) {
1321         const aliasFontRef = fontAliases[hash].aliasRef;
1322         if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
1323           this.fontCache.putAlias(fontRef, aliasFontRef);
1324           return this.fontCache.get(fontRef);
1325         }
1326       } else {
1327         fontAliases[hash] = {
1328           fontID: this.idFactory.createFontId(),
1329         };
1330       }
1331 
1332       if (fontRefIsRef) {
1333         fontAliases[hash].aliasRef = fontRef;
1334       }
1335       fontID = fontAliases[hash].fontID;
1336     } else {
1337       fontID = this.idFactory.createFontId();
1338     }
1339     assert(
1340       fontID?.startsWith("f"),
1341       'The "fontID" must be (correctly) defined.'
1342     );
1343 
1344     // Workaround for bad PDF generators that reference fonts incorrectly,
1345     // where `fontRef` is a `Dict` rather than a `Ref` (fixes bug946506.pdf).
1346     // In this case we cannot put the font into `this.fontCache` (which is
1347     // a `RefSetCache`), since it's not possible to use a `Dict` as a key.
1348     //
1349     // However, if we don't cache the font it's not possible to remove it
1350     // when `cleanup` is triggered from the API, which causes issues on
1351     // subsequent rendering operations (see issue7403.pdf) and would force us
1352     // to unnecessarily load the same fonts over and over.
1353     //
1354     // Instead, we cheat a bit by using a modified `fontID` as a key in
1355     // `this.fontCache`, to allow the font to be cached.
1356     // NOTE: This works because `RefSetCache` calls `toString()` on provided
1357     //       keys. Also, since `fontRef` is used when getting cached fonts,
1358     //       we'll not accidentally match fonts cached with the `fontID`.
1359     if (fontRefIsRef) {
1360       this.fontCache.put(fontRef, promise);
1361     } else {
1362       font.cacheKey = `cacheKey_${fontID}`;
1363       this.fontCache.put(font.cacheKey, promise);
1364     }
1365 
1366     // Keep track of each font we translated so the caller can
1367     // load them asynchronously before calling display on a page.
1368     font.loadedName = `${this.idFactory.getDocId()}_${fontID}`;
1369 
1370     this.translateFont(preEvaluatedFont)
1371       .then(translatedFont => {
1372         resolve(
1373           new TranslatedFont({
1374             loadedName: font.loadedName,
1375             font: translatedFont,
1376             dict: font,
1377             evaluatorOptions: this.options,
1378           })
1379         );
1380       })
1381       .catch(reason => {
1382         // TODO reject?
1383         warn(`loadFont - translateFont failed: "${reason}".`);
1384 
1385         resolve(
1386           new TranslatedFont({
1387             loadedName: font.loadedName,
1388             font: new ErrorFont(
1389               reason instanceof Error ? reason.message : reason
1390             ),
1391             dict: font,
1392             evaluatorOptions: this.options,
1393           })
1394         );
1395       });
1396     return promise;
1397   }
1398 
1399   buildPath(operatorList, fn, args, parsingText = false) {
1400     const lastIndex = operatorList.length - 1;
1401     if (!args) {
1402       args = [];
1403     }
1404     if (
1405       lastIndex < 0 ||
1406       operatorList.fnArray[lastIndex] !== OPS.constructPath
1407     ) {
1408       // Handle corrupt PDF documents that contains path operators inside of
1409       // text objects, which may shift subsequent text, by enclosing the path
1410       // operator in save/restore operators (fixes issue10542_reduced.pdf).
1411       //
1412       // Note that this will effectively disable the optimization in the
1413       // `else` branch below, but given that this type of corruption is
1414       // *extremely* rare that shouldn't really matter much in practice.
1415       if (parsingText) {
1416         warn(`Encountered path operator "${fn}" inside of a text object.`);
1417         operatorList.addOp(OPS.save, null);
1418       }
1419 
1420       let minMax;
1421       switch (fn) {
1422         case OPS.rectangle:
1423           const x = args[0] + args[2];
1424           const y = args[1] + args[3];
1425           minMax = [
1426             Math.min(args[0], x),
1427             Math.min(args[1], y),
1428             Math.max(args[0], x),
1429             Math.max(args[1], y),
1430           ];
1431           break;
1432         case OPS.moveTo:
1433         case OPS.lineTo:
1434           minMax = [args[0], args[1], args[0], args[1]];
1435           break;
1436         default:
1437           minMax = [Infinity, Infinity, -Infinity, -Infinity];
1438           break;
1439       }
1440       operatorList.addOp(OPS.constructPath, [[fn], args, minMax]);
1441 
1442       if (parsingText) {
1443         operatorList.addOp(OPS.restore, null);
1444       }
1445     } else {
1446       const opArgs = operatorList.argsArray[lastIndex];
1447       opArgs[0].push(fn);
1448       opArgs[1].push(...args);
1449       const minMax = opArgs[2];
1450 
1451       // Compute min/max in the worker instead of the main thread.
1452       // If the current matrix (when drawing) is a scaling one
1453       // then min/max can be easily computed in using those values.
1454       // Only rectangle, lineTo and moveTo are handled here since
1455       // Bezier stuff requires to have the starting point.
1456       switch (fn) {
1457         case OPS.rectangle:
1458           const x = args[0] + args[2];
1459           const y = args[1] + args[3];
1460           minMax[0] = Math.min(minMax[0], args[0], x);
1461           minMax[1] = Math.min(minMax[1], args[1], y);
1462           minMax[2] = Math.max(minMax[2], args[0], x);
1463           minMax[3] = Math.max(minMax[3], args[1], y);
1464           break;
1465         case OPS.moveTo:
1466         case OPS.lineTo:
1467           minMax[0] = Math.min(minMax[0], args[0]);
1468           minMax[1] = Math.min(minMax[1], args[1]);
1469           minMax[2] = Math.max(minMax[2], args[0]);
1470           minMax[3] = Math.max(minMax[3], args[1]);
1471           break;
1472       }
1473     }
1474   }
1475 
1476   parseColorSpace({ cs, resources, localColorSpaceCache }) {
1477     return ColorSpace.parseAsync({
1478       cs,
1479       xref: this.xref,
1480       resources,
1481       pdfFunctionFactory: this._pdfFunctionFactory,
1482       localColorSpaceCache,
1483     }).catch(reason => {
1484       if (reason instanceof AbortException) {
1485         return null;
1486       }
1487       if (this.options.ignoreErrors) {
1488         warn(`parseColorSpace - ignoring ColorSpace: "${reason}".`);
1489         return null;
1490       }
1491       throw reason;
1492     });
1493   }
1494 
1495   parseShading({
1496     shading,
1497     resources,
1498     localColorSpaceCache,
1499     localShadingPatternCache,
1500   }) {
1501     // Shadings and patterns may be referenced by the same name but the resource
1502     // dictionary could be different so we can't use the name for the cache key.
1503     let id = localShadingPatternCache.get(shading);
1504     if (id) {
1505       return id;
1506     }
1507     let patternIR;
1508 
1509     try {
1510       const shadingFill = Pattern.parseShading(
1511         shading,
1512         this.xref,
1513         resources,
1514         this._pdfFunctionFactory,
1515         localColorSpaceCache
1516       );
1517       patternIR = shadingFill.getIR();
1518     } catch (reason) {
1519       if (reason instanceof AbortException) {
1520         return null;
1521       }
1522       if (this.options.ignoreErrors) {
1523         warn(`parseShading - ignoring shading: "${reason}".`);
1524 
1525         localShadingPatternCache.set(shading, null);
1526         return null;
1527       }
1528       throw reason;
1529     }
1530 
1531     id = `pattern_${this.idFactory.createObjId()}`;
1532     if (this.parsingType3Font) {
1533       id = `${this.idFactory.getDocId()}_type3_${id}`;
1534     }
1535     localShadingPatternCache.set(shading, id);
1536 
1537     if (this.parsingType3Font) {
1538       this.handler.send("commonobj", [id, "Pattern", patternIR]);
1539     } else {
1540       this.handler.send("obj", [id, this.pageIndex, "Pattern", patternIR]);
1541     }
1542     return id;
1543   }
1544 
1545   handleColorN(
1546     operatorList,
1547     fn,
1548     args,
1549     cs,
1550     patterns,
1551     resources,
1552     task,
1553     localColorSpaceCache,
1554     localTilingPatternCache,
1555     localShadingPatternCache
1556   ) {
1557     // compile tiling patterns
1558     const patternName = args.pop();
1559     // SCN/scn applies patterns along with normal colors
1560     if (patternName instanceof Name) {
1561       const rawPattern = patterns.getRaw(patternName.name);
1562 
1563       const localTilingPattern =
1564         rawPattern instanceof Ref &&
1565         localTilingPatternCache.getByRef(rawPattern);
1566       if (localTilingPattern) {
1567         try {
1568           const color = cs.base ? cs.base.getRgb(args, 0) : null;
1569           const tilingPatternIR = getTilingPatternIR(
1570             localTilingPattern.operatorListIR,
1571             localTilingPattern.dict,
1572             color
1573           );
1574           operatorList.addOp(fn, tilingPatternIR);
1575           return undefined;
1576         } catch {
1577           // Handle any errors during normal TilingPattern parsing.
1578         }
1579       }
1580 
1581       const pattern = this.xref.fetchIfRef(rawPattern);
1582       if (pattern) {
1583         const dict = pattern instanceof BaseStream ? pattern.dict : pattern;
1584         const typeNum = dict.get("PatternType");
1585 
1586         if (typeNum === PatternType.TILING) {
1587           const color = cs.base ? cs.base.getRgb(args, 0) : null;
1588           return this.handleTilingType(
1589             fn,
1590             color,
1591             resources,
1592             pattern,
1593             dict,
1594             operatorList,
1595             task,
1596             localTilingPatternCache
1597           );
1598         } else if (typeNum === PatternType.SHADING) {
1599           const shading = dict.get("Shading");
1600           const objId = this.parseShading({
1601             shading,
1602             resources,
1603             localColorSpaceCache,
1604             localShadingPatternCache,
1605           });
1606           if (objId) {
1607             const matrix = lookupMatrix(dict.getArray("Matrix"), null);
1608             operatorList.addOp(fn, ["Shading", objId, matrix]);
1609           }
1610           return undefined;
1611         }
1612         throw new FormatError(`Unknown PatternType: ${typeNum}`);
1613       }
1614     }
1615     throw new FormatError(`Unknown PatternName: ${patternName}`);
1616   }
1617 
1618   _parseVisibilityExpression(array, nestingCounter, currentResult) {
1619     const MAX_NESTING = 10;
1620     if (++nestingCounter > MAX_NESTING) {
1621       warn("Visibility expression is too deeply nested");
1622       return;
1623     }
1624     const length = array.length;
1625     const operator = this.xref.fetchIfRef(array[0]);
1626     if (length < 2 || !(operator instanceof Name)) {
1627       warn("Invalid visibility expression");
1628       return;
1629     }
1630     switch (operator.name) {
1631       case "And":
1632       case "Or":
1633       case "Not":
1634         currentResult.push(operator.name);
1635         break;
1636       default:
1637         warn(`Invalid operator ${operator.name} in visibility expression`);
1638         return;
1639     }
1640     for (let i = 1; i < length; i++) {
1641       const raw = array[i];
1642       const object = this.xref.fetchIfRef(raw);
1643       if (Array.isArray(object)) {
1644         const nestedResult = [];
1645         currentResult.push(nestedResult);
1646         // Recursively parse a subarray.
1647         this._parseVisibilityExpression(object, nestingCounter, nestedResult);
1648       } else if (raw instanceof Ref) {
1649         // Reference to an OCG dictionary.
1650         currentResult.push(raw.toString());
1651       }
1652     }
1653   }
1654 
1655   async parseMarkedContentProps(contentProperties, resources) {
1656     let optionalContent;
1657     if (contentProperties instanceof Name) {
1658       const properties = resources.get("Properties");
1659       optionalContent = properties.get(contentProperties.name);
1660     } else if (contentProperties instanceof Dict) {
1661       optionalContent = contentProperties;
1662     } else {
1663       throw new FormatError("Optional content properties malformed.");
1664     }
1665 
1666     const optionalContentType = optionalContent.get("Type")?.name;
1667     if (optionalContentType === "OCG") {
1668       return {
1669         type: optionalContentType,
1670         id: optionalContent.objId,
1671       };
1672     } else if (optionalContentType === "OCMD") {
1673       const expression = optionalContent.get("VE");
1674       if (Array.isArray(expression)) {
1675         const result = [];
1676         this._parseVisibilityExpression(expression, 0, result);
1677         if (result.length > 0) {
1678           return {
1679             type: "OCMD",
1680             expression: result,
1681           };
1682         }
1683       }
1684 
1685       const optionalContentGroups = optionalContent.get("OCGs");
1686       if (
1687         Array.isArray(optionalContentGroups) ||
1688         optionalContentGroups instanceof Dict
1689       ) {
1690         const groupIds = [];
1691         if (Array.isArray(optionalContentGroups)) {
1692           for (const ocg of optionalContentGroups) {
1693             groupIds.push(ocg.toString());
1694           }
1695         } else {
1696           // Dictionary, just use the obj id.
1697           groupIds.push(optionalContentGroups.objId);
1698         }
1699 
1700         return {
1701           type: optionalContentType,
1702           ids: groupIds,
1703           policy:
1704             optionalContent.get("P") instanceof Name
1705               ? optionalContent.get("P").name
1706               : null,
1707           expression: null,
1708         };
1709       } else if (optionalContentGroups instanceof Ref) {
1710         return {
1711           type: optionalContentType,
1712           id: optionalContentGroups.toString(),
1713         };
1714       }
1715     }
1716     return null;
1717   }
1718 
1719   getOperatorList({
1720     stream,
1721     task,
1722     resources,
1723     operatorList,
1724     initialState = null,
1725     fallbackFontDict = null,
1726   }) {
1727     // Ensure that `resources`/`initialState` is correctly initialized,
1728     // even if the provided parameter is e.g. `null`.
1729     resources ||= Dict.empty;
1730     initialState ||= new EvalState();
1731 
1732     if (!operatorList) {
1733       throw new Error('getOperatorList: missing "operatorList" parameter');
1734     }
1735 
1736     const self = this;
1737     const xref = this.xref;
1738     let parsingText = false;
1739     const localImageCache = new LocalImageCache();
1740     const localColorSpaceCache = new LocalColorSpaceCache();
1741     const localGStateCache = new LocalGStateCache();
1742     const localTilingPatternCache = new LocalTilingPatternCache();
1743     const localShadingPatternCache = new Map();
1744 
1745     const xobjs = resources.get("XObject") || Dict.empty;
1746     const patterns = resources.get("Pattern") || Dict.empty;
1747     const stateManager = new StateManager(initialState);
1748     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
1749     const timeSlotManager = new TimeSlotManager();
1750 
1751     function closePendingRestoreOPS(argument) {
1752       for (let i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
1753         operatorList.addOp(OPS.restore, []);
1754       }
1755     }
1756 
1757     return new Promise(function promiseBody(resolve, reject) {
1758       const next = function (promise) {
1759         Promise.all([promise, operatorList.ready]).then(function () {
1760           try {
1761             promiseBody(resolve, reject);
1762           } catch (ex) {
1763             reject(ex);
1764           }
1765         }, reject);
1766       };
1767       task.ensureNotTerminated();
1768       timeSlotManager.reset();
1769 
1770       const operation = {};
1771       let stop, i, ii, cs, name, isValidName;
1772       while (!(stop = timeSlotManager.check())) {
1773         // The arguments parsed by read() are used beyond this loop, so we
1774         // cannot reuse the same array on each iteration. Therefore we pass
1775         // in |null| as the initial value (see the comment on
1776         // EvaluatorPreprocessor_read() for why).
1777         operation.args = null;
1778         if (!preprocessor.read(operation)) {
1779           break;
1780         }
1781         let args = operation.args;
1782         let fn = operation.fn;
1783 
1784         switch (fn | 0) {
1785           case OPS.paintXObject:
1786             // eagerly compile XForm objects
1787             isValidName = args[0] instanceof Name;
1788             name = args[0].name;
1789 
1790             if (isValidName) {
1791               const localImage = localImageCache.getByName(name);
1792               if (localImage) {
1793                 addLocallyCachedImageOps(operatorList, localImage);
1794                 args = null;
1795                 continue;
1796               }
1797             }
1798 
1799             next(
1800               new Promise(function (resolveXObject, rejectXObject) {
1801                 if (!isValidName) {
1802                   throw new FormatError("XObject must be referred to by name.");
1803                 }
1804 
1805                 let xobj = xobjs.getRaw(name);
1806                 if (xobj instanceof Ref) {
1807                   const localImage =
1808                     localImageCache.getByRef(xobj) ||
1809                     self._regionalImageCache.getByRef(xobj);
1810                   if (localImage) {
1811                     addLocallyCachedImageOps(operatorList, localImage);
1812                     resolveXObject();
1813                     return;
1814                   }
1815 
1816                   const globalImage = self.globalImageCache.getData(
1817                     xobj,
1818                     self.pageIndex
1819                   );
1820                   if (globalImage) {
1821                     operatorList.addDependency(globalImage.objId);
1822                     operatorList.addImageOps(
1823                       globalImage.fn,
1824                       globalImage.args,
1825                       globalImage.optionalContent
1826                     );
1827 
1828                     resolveXObject();
1829                     return;
1830                   }
1831 
1832                   xobj = xref.fetch(xobj);
1833                 }
1834 
1835                 if (!(xobj instanceof BaseStream)) {
1836                   throw new FormatError("XObject should be a stream");
1837                 }
1838 
1839                 const type = xobj.dict.get("Subtype");
1840                 if (!(type instanceof Name)) {
1841                   throw new FormatError("XObject should have a Name subtype");
1842                 }
1843 
1844                 if (type.name === "Form") {
1845                   stateManager.save();
1846                   self
1847                     .buildFormXObject(
1848                       resources,
1849                       xobj,
1850                       null,
1851                       operatorList,
1852                       task,
1853                       stateManager.state.clone(),
1854                       localColorSpaceCache
1855                     )
1856                     .then(function () {
1857                       stateManager.restore();
1858                       resolveXObject();
1859                     }, rejectXObject);
1860                   return;
1861                 } else if (type.name === "Image") {
1862                   self
1863                     .buildPaintImageXObject({
1864                       resources,
1865                       image: xobj,
1866                       operatorList,
1867                       cacheKey: name,
1868                       localImageCache,
1869                       localColorSpaceCache,
1870                     })
1871                     .then(resolveXObject, rejectXObject);
1872                   return;
1873                 } else if (type.name === "PS") {
1874                   // PostScript XObjects are unused when viewing documents.
1875                   // See section 4.7.1 of Adobe's PDF reference.
1876                   info("Ignored XObject subtype PS");
1877                 } else {
1878                   throw new FormatError(
1879                     `Unhandled XObject subtype ${type.name}`
1880                   );
1881                 }
1882                 resolveXObject();
1883               }).catch(function (reason) {
1884                 if (reason instanceof AbortException) {
1885                   return;
1886                 }
1887                 if (self.options.ignoreErrors) {
1888                   warn(`getOperatorList - ignoring XObject: "${reason}".`);
1889                   return;
1890                 }
1891                 throw reason;
1892               })
1893             );
1894             return;
1895           case OPS.setFont:
1896             var fontSize = args[1];
1897             // eagerly collect all fonts
1898             next(
1899               self
1900                 .handleSetFont(
1901                   resources,
1902                   args,
1903                   null,
1904                   operatorList,
1905                   task,
1906                   stateManager.state,
1907                   fallbackFontDict
1908                 )
1909                 .then(function (loadedName) {
1910                   operatorList.addDependency(loadedName);
1911                   operatorList.addOp(OPS.setFont, [loadedName, fontSize]);
1912                 })
1913             );
1914             return;
1915           case OPS.beginText:
1916             parsingText = true;
1917             break;
1918           case OPS.endText:
1919             parsingText = false;
1920             break;
1921           case OPS.endInlineImage:
1922             var cacheKey = args[0].cacheKey;
1923             if (cacheKey) {
1924               const localImage = localImageCache.getByName(cacheKey);
1925               if (localImage) {
1926                 addLocallyCachedImageOps(operatorList, localImage);
1927                 args = null;
1928                 continue;
1929               }
1930             }
1931             next(
1932               self.buildPaintImageXObject({
1933                 resources,
1934                 image: args[0],
1935                 isInline: true,
1936                 operatorList,
1937                 cacheKey,
1938                 localImageCache,
1939                 localColorSpaceCache,
1940               })
1941             );
1942             return;
1943           case OPS.showText:
1944             if (!stateManager.state.font) {
1945               self.ensureStateFont(stateManager.state);
1946               continue;
1947             }
1948             args[0] = self.handleText(args[0], stateManager.state);
1949             break;
1950           case OPS.showSpacedText:
1951             if (!stateManager.state.font) {
1952               self.ensureStateFont(stateManager.state);
1953               continue;
1954             }
1955             var combinedGlyphs = [];
1956             var state = stateManager.state;
1957             for (const arrItem of args[0]) {
1958               if (typeof arrItem === "string") {
1959                 combinedGlyphs.push(...self.handleText(arrItem, state));
1960               } else if (typeof arrItem === "number") {
1961                 combinedGlyphs.push(arrItem);
1962               }
1963             }
1964             args[0] = combinedGlyphs;
1965             fn = OPS.showText;
1966             break;
1967           case OPS.nextLineShowText:
1968             if (!stateManager.state.font) {
1969               self.ensureStateFont(stateManager.state);
1970               continue;
1971             }
1972             operatorList.addOp(OPS.nextLine);
1973             args[0] = self.handleText(args[0], stateManager.state);
1974             fn = OPS.showText;
1975             break;
1976           case OPS.nextLineSetSpacingShowText:
1977             if (!stateManager.state.font) {
1978               self.ensureStateFont(stateManager.state);
1979               continue;
1980             }
1981             operatorList.addOp(OPS.nextLine);
1982             operatorList.addOp(OPS.setWordSpacing, [args.shift()]);
1983             operatorList.addOp(OPS.setCharSpacing, [args.shift()]);
1984             args[0] = self.handleText(args[0], stateManager.state);
1985             fn = OPS.showText;
1986             break;
1987           case OPS.setTextRenderingMode:
1988             stateManager.state.textRenderingMode = args[0];
1989             break;
1990 
1991           case OPS.setFillColorSpace: {
1992             const cachedColorSpace = ColorSpace.getCached(
1993               args[0],
1994               xref,
1995               localColorSpaceCache
1996             );
1997             if (cachedColorSpace) {
1998               stateManager.state.fillColorSpace = cachedColorSpace;
1999               continue;
2000             }
2001 
2002             next(
2003               self
2004                 .parseColorSpace({
2005                   cs: args[0],
2006                   resources,
2007                   localColorSpaceCache,
2008                 })
2009                 .then(function (colorSpace) {
2010                   stateManager.state.fillColorSpace =
2011                     colorSpace || ColorSpace.singletons.gray;
2012                 })
2013             );
2014             return;
2015           }
2016           case OPS.setStrokeColorSpace: {
2017             const cachedColorSpace = ColorSpace.getCached(
2018               args[0],
2019               xref,
2020               localColorSpaceCache
2021             );
2022             if (cachedColorSpace) {
2023               stateManager.state.strokeColorSpace = cachedColorSpace;
2024               continue;
2025             }
2026 
2027             next(
2028               self
2029                 .parseColorSpace({
2030                   cs: args[0],
2031                   resources,
2032                   localColorSpaceCache,
2033                 })
2034                 .then(function (colorSpace) {
2035                   stateManager.state.strokeColorSpace =
2036                     colorSpace || ColorSpace.singletons.gray;
2037                 })
2038             );
2039             return;
2040           }
2041           case OPS.setFillColor:
2042             cs = stateManager.state.fillColorSpace;
2043             args = cs.getRgb(args, 0);
2044             fn = OPS.setFillRGBColor;
2045             break;
2046           case OPS.setStrokeColor:
2047             cs = stateManager.state.strokeColorSpace;
2048             args = cs.getRgb(args, 0);
2049             fn = OPS.setStrokeRGBColor;
2050             break;
2051           case OPS.setFillGray:
2052             stateManager.state.fillColorSpace = ColorSpace.singletons.gray;
2053             args = ColorSpace.singletons.gray.getRgb(args, 0);
2054             fn = OPS.setFillRGBColor;
2055             break;
2056           case OPS.setStrokeGray:
2057             stateManager.state.strokeColorSpace = ColorSpace.singletons.gray;
2058             args = ColorSpace.singletons.gray.getRgb(args, 0);
2059             fn = OPS.setStrokeRGBColor;
2060             break;
2061           case OPS.setFillCMYKColor:
2062             stateManager.state.fillColorSpace = ColorSpace.singletons.cmyk;
2063             args = ColorSpace.singletons.cmyk.getRgb(args, 0);
2064             fn = OPS.setFillRGBColor;
2065             break;
2066           case OPS.setStrokeCMYKColor:
2067             stateManager.state.strokeColorSpace = ColorSpace.singletons.cmyk;
2068             args = ColorSpace.singletons.cmyk.getRgb(args, 0);
2069             fn = OPS.setStrokeRGBColor;
2070             break;
2071           case OPS.setFillRGBColor:
2072             stateManager.state.fillColorSpace = ColorSpace.singletons.rgb;
2073             args = ColorSpace.singletons.rgb.getRgb(args, 0);
2074             break;
2075           case OPS.setStrokeRGBColor:
2076             stateManager.state.strokeColorSpace = ColorSpace.singletons.rgb;
2077             args = ColorSpace.singletons.rgb.getRgb(args, 0);
2078             break;
2079           case OPS.setFillColorN:
2080             cs = stateManager.state.patternFillColorSpace;
2081             if (!cs) {
2082               args = [];
2083               fn = OPS.setFillTransparent;
2084               break;
2085             }
2086             if (cs.name === "Pattern") {
2087               next(
2088                 self.handleColorN(
2089                   operatorList,
2090                   OPS.setFillColorN,
2091                   args,
2092                   cs,
2093                   patterns,
2094                   resources,
2095                   task,
2096                   localColorSpaceCache,
2097                   localTilingPatternCache,
2098                   localShadingPatternCache
2099                 )
2100               );
2101               return;
2102             }
2103             args = cs.getRgb(args, 0);
2104             fn = OPS.setFillRGBColor;
2105             break;
2106           case OPS.setStrokeColorN:
2107             cs = stateManager.state.patternStrokeColorSpace;
2108             if (!cs) {
2109               args = [];
2110               fn = OPS.setStrokeTransparent;
2111               break;
2112             }
2113             if (cs.name === "Pattern") {
2114               next(
2115                 self.handleColorN(
2116                   operatorList,
2117                   OPS.setStrokeColorN,
2118                   args,
2119                   cs,
2120                   patterns,
2121                   resources,
2122                   task,
2123                   localColorSpaceCache,
2124                   localTilingPatternCache,
2125                   localShadingPatternCache
2126                 )
2127               );
2128               return;
2129             }
2130             args = cs.getRgb(args, 0);
2131             fn = OPS.setStrokeRGBColor;
2132             break;
2133 
2134           case OPS.shadingFill:
2135             var shadingRes = resources.get("Shading");
2136             if (!shadingRes) {
2137               throw new FormatError("No shading resource found");
2138             }
2139 
2140             var shading = shadingRes.get(args[0].name);
2141             if (!shading) {
2142               throw new FormatError("No shading object found");
2143             }
2144             const patternId = self.parseShading({
2145               shading,
2146               resources,
2147               localColorSpaceCache,
2148               localShadingPatternCache,
2149             });
2150             if (!patternId) {
2151               continue;
2152             }
2153             args = [patternId];
2154             fn = OPS.shadingFill;
2155             break;
2156           case OPS.setGState:
2157             isValidName = args[0] instanceof Name;
2158             name = args[0].name;
2159 
2160             if (isValidName) {
2161               const localGStateObj = localGStateCache.getByName(name);
2162               if (localGStateObj) {
2163                 if (localGStateObj.length > 0) {
2164                   operatorList.addOp(OPS.setGState, [localGStateObj]);
2165                 }
2166                 args = null;
2167                 continue;
2168               }
2169             }
2170 
2171             next(
2172               new Promise(function (resolveGState, rejectGState) {
2173                 if (!isValidName) {
2174                   throw new FormatError("GState must be referred to by name.");
2175                 }
2176 
2177                 const extGState = resources.get("ExtGState");
2178                 if (!(extGState instanceof Dict)) {
2179                   throw new FormatError("ExtGState should be a dictionary.");
2180                 }
2181 
2182                 const gState = extGState.get(name);
2183                 // TODO: Attempt to lookup cached GStates by reference as well,
2184                 //       if and only if there are PDF documents where doing so
2185                 //       would significantly improve performance.
2186                 if (!(gState instanceof Dict)) {
2187                   throw new FormatError("GState should be a dictionary.");
2188                 }
2189 
2190                 self
2191                   .setGState({
2192                     resources,
2193                     gState,
2194                     operatorList,
2195                     cacheKey: name,
2196                     task,
2197                     stateManager,
2198                     localGStateCache,
2199                     localColorSpaceCache,
2200                   })
2201                   .then(resolveGState, rejectGState);
2202               }).catch(function (reason) {
2203                 if (reason instanceof AbortException) {
2204                   return;
2205                 }
2206                 if (self.options.ignoreErrors) {
2207                   warn(`getOperatorList - ignoring ExtGState: "${reason}".`);
2208                   return;
2209                 }
2210                 throw reason;
2211               })
2212             );
2213             return;
2214           case OPS.moveTo:
2215           case OPS.lineTo:
2216           case OPS.curveTo:
2217           case OPS.curveTo2:
2218           case OPS.curveTo3:
2219           case OPS.closePath:
2220           case OPS.rectangle:
2221             self.buildPath(operatorList, fn, args, parsingText);
2222             continue;
2223           case OPS.markPoint:
2224           case OPS.markPointProps:
2225           case OPS.beginCompat:
2226           case OPS.endCompat:
2227             // Ignore operators where the corresponding handlers are known to
2228             // be no-op in CanvasGraphics (display/canvas.js). This prevents
2229             // serialization errors and is also a bit more efficient.
2230             // We could also try to serialize all objects in a general way,
2231             // e.g. as done in https://github.com/mozilla/pdf.js/pull/6266,
2232             // but doing so is meaningless without knowing the semantics.
2233             continue;
2234           case OPS.beginMarkedContentProps:
2235             if (!(args[0] instanceof Name)) {
2236               warn(`Expected name for beginMarkedContentProps arg0=${args[0]}`);
2237               operatorList.addOp(OPS.beginMarkedContentProps, ["OC", null]);
2238               continue;
2239             }
2240             if (args[0].name === "OC") {
2241               next(
2242                 self
2243                   .parseMarkedContentProps(args[1], resources)
2244                   .then(data => {
2245                     operatorList.addOp(OPS.beginMarkedContentProps, [
2246                       "OC",
2247                       data,
2248                     ]);
2249                   })
2250                   .catch(reason => {
2251                     if (reason instanceof AbortException) {
2252                       return;
2253                     }
2254                     if (self.options.ignoreErrors) {
2255                       warn(
2256                         `getOperatorList - ignoring beginMarkedContentProps: "${reason}".`
2257                       );
2258                       operatorList.addOp(OPS.beginMarkedContentProps, [
2259                         "OC",
2260                         null,
2261                       ]);
2262                       return;
2263                     }
2264                     throw reason;
2265                   })
2266               );
2267               return;
2268             }
2269             // Other marked content types aren't supported yet.
2270             args = [
2271               args[0].name,
2272               args[1] instanceof Dict ? args[1].get("MCID") : null,
2273             ];
2274 
2275             break;
2276           case OPS.beginMarkedContent:
2277           case OPS.endMarkedContent:
2278           default:
2279             // Note: Ignore the operator if it has `Dict` arguments, since
2280             // those are non-serializable, otherwise postMessage will throw
2281             // "An object could not be cloned.".
2282             if (args !== null) {
2283               for (i = 0, ii = args.length; i < ii; i++) {
2284                 if (args[i] instanceof Dict) {
2285                   break;
2286                 }
2287               }
2288               if (i < ii) {
2289                 warn("getOperatorList - ignoring operator: " + fn);
2290                 continue;
2291               }
2292             }
2293         }
2294         operatorList.addOp(fn, args);
2295       }
2296       if (stop) {
2297         next(deferred);
2298         return;
2299       }
2300       // Some PDFs don't close all restores inside object/form.
2301       // Closing those for them.
2302       closePendingRestoreOPS();
2303       resolve();
2304     }).catch(reason => {
2305       if (reason instanceof AbortException) {
2306         return;
2307       }
2308       if (this.options.ignoreErrors) {
2309         warn(
2310           `getOperatorList - ignoring errors during "${task.name}" ` +
2311             `task: "${reason}".`
2312         );
2313 
2314         closePendingRestoreOPS();
2315         return;
2316       }
2317       throw reason;
2318     });
2319   }
2320 
2321   getTextContent({
2322     stream,
2323     task,
2324     resources,
2325     stateManager = null,
2326     includeMarkedContent = false,
2327     sink,
2328     seenStyles = new Set(),
2329     viewBox,
2330     lang = null,
2331     markedContentData = null,
2332     disableNormalization = false,
2333     keepWhiteSpace = false,
2334   }) {
2335     // Ensure that `resources`/`stateManager` is correctly initialized,
2336     // even if the provided parameter is e.g. `null`.
2337     resources ||= Dict.empty;
2338     stateManager ||= new StateManager(new TextState());
2339 
2340     if (includeMarkedContent) {
2341       markedContentData ||= { level: 0 };
2342     }
2343 
2344     const textContent = {
2345       items: [],
2346       styles: Object.create(null),
2347       lang,
2348     };
2349     const textContentItem = {
2350       initialized: false,
2351       str: [],
2352       totalWidth: 0,
2353       totalHeight: 0,
2354       width: 0,
2355       height: 0,
2356       vertical: false,
2357       prevTransform: null,
2358       textAdvanceScale: 0,
2359       spaceInFlowMin: 0,
2360       spaceInFlowMax: 0,
2361       trackingSpaceMin: Infinity,
2362       negativeSpaceMax: -Infinity,
2363       notASpace: -Infinity,
2364       transform: null,
2365       fontName: null,
2366       hasEOL: false,
2367     };
2368 
2369     // Use a circular buffer (length === 2) to save the last chars in the
2370     // text stream.
2371     // This implementation of the circular buffer is using a fixed array
2372     // and the position of the next element:
2373     // function addElement(x) {
2374     //   buffer[pos] = x;
2375     //   pos = (pos + 1) % buffer.length;
2376     // }
2377     // It's a way faster than:
2378     // function addElement(x) {
2379     //   buffer.push(x);
2380     //   buffer.shift();
2381     // }
2382     //
2383     // It's useful to know when we need to add a whitespace in the
2384     // text chunk.
2385     const twoLastChars = [" ", " "];
2386     let twoLastCharsPos = 0;
2387 
2388     /**
2389      * Save the last char.
2390      * @param {string} char
2391      * @returns {boolean} true when the two last chars before adding the new one
2392      * are a non-whitespace followed by a whitespace.
2393      */
2394     function saveLastChar(char) {
2395       const nextPos = (twoLastCharsPos + 1) % 2;
2396       const ret =
2397         twoLastChars[twoLastCharsPos] !== " " && twoLastChars[nextPos] === " ";
2398       twoLastChars[twoLastCharsPos] = char;
2399       twoLastCharsPos = nextPos;
2400 
2401       return !keepWhiteSpace && ret;
2402     }
2403 
2404     function shouldAddWhitepsace() {
2405       return (
2406         !keepWhiteSpace &&
2407         twoLastChars[twoLastCharsPos] !== " " &&
2408         twoLastChars[(twoLastCharsPos + 1) % 2] === " "
2409       );
2410     }
2411 
2412     function resetLastChars() {
2413       twoLastChars[0] = twoLastChars[1] = " ";
2414       twoLastCharsPos = 0;
2415     }
2416 
2417     // Used in addFakeSpaces.
2418 
2419     // A white <= fontSize * TRACKING_SPACE_FACTOR is a tracking space
2420     // so it doesn't count as a space.
2421     const TRACKING_SPACE_FACTOR = 0.102;
2422 
2423     // When a white <= fontSize * NOT_A_SPACE_FACTOR, there is no space
2424     // even if one is present in the text stream.
2425     const NOT_A_SPACE_FACTOR = 0.03;
2426 
2427     // A negative white < fontSize * NEGATIVE_SPACE_FACTOR induces
2428     // a break (a new chunk of text is created).
2429     // It doesn't change anything when the text is copied but
2430     // it improves potential mismatch between text layer and canvas.
2431     const NEGATIVE_SPACE_FACTOR = -0.2;
2432 
2433     // A white with a width in [fontSize * MIN_FACTOR; fontSize * MAX_FACTOR]
2434     // is a space which will be inserted in the current flow of words.
2435     // If the width is outside of this range then the flow is broken
2436     // (which means a new span in the text layer).
2437     // It's useful to adjust the best as possible the span in the layer
2438     // to what is displayed in the canvas.
2439     const SPACE_IN_FLOW_MIN_FACTOR = 0.102;
2440     const SPACE_IN_FLOW_MAX_FACTOR = 0.6;
2441 
2442     // If a char is too high/too low compared to the previous we just create
2443     // a new chunk.
2444     // If the advance isn't in the +/-VERTICAL_SHIFT_RATIO * height range then
2445     // a new chunk is created.
2446     const VERTICAL_SHIFT_RATIO = 0.25;
2447 
2448     const self = this;
2449     const xref = this.xref;
2450     const showSpacedTextBuffer = [];
2451 
2452     // The xobj is parsed iff it's needed, e.g. if there is a `DO` cmd.
2453     let xobjs = null;
2454     const emptyXObjectCache = new LocalImageCache();
2455     const emptyGStateCache = new LocalGStateCache();
2456 
2457     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
2458 
2459     let textState;
2460 
2461     function pushWhitespace({
2462       width = 0,
2463       height = 0,
2464       transform = textContentItem.prevTransform,
2465       fontName = textContentItem.fontName,
2466     }) {
2467       textContent.items.push({
2468         str: " ",
2469         dir: "ltr",
2470         width,
2471         height,
2472         transform,
2473         fontName,
2474         hasEOL: false,
2475       });
2476     }
2477 
2478     function getCurrentTextTransform() {
2479       // 9.4.4 Text Space Details
2480       const font = textState.font;
2481       const tsm = [
2482         textState.fontSize * textState.textHScale,
2483         0,
2484         0,
2485         textState.fontSize,
2486         0,
2487         textState.textRise,
2488       ];
2489 
2490       if (
2491         font.isType3Font &&
2492         (textState.fontSize <= 1 || font.isCharBBox) &&
2493         !isArrayEqual(textState.fontMatrix, FONT_IDENTITY_MATRIX)
2494       ) {
2495         const glyphHeight = font.bbox[3] - font.bbox[1];
2496         if (glyphHeight > 0) {
2497           tsm[3] *= glyphHeight * textState.fontMatrix[3];
2498         }
2499       }
2500 
2501       return Util.transform(
2502         textState.ctm,
2503         Util.transform(textState.textMatrix, tsm)
2504       );
2505     }
2506 
2507     function ensureTextContentItem() {
2508       if (textContentItem.initialized) {
2509         return textContentItem;
2510       }
2511       const { font, loadedName } = textState;
2512       if (!seenStyles.has(loadedName)) {
2513         seenStyles.add(loadedName);
2514         textContent.styles[loadedName] = {
2515           fontFamily: font.fallbackName,
2516           ascent: font.ascent,
2517           descent: font.descent,
2518           vertical: font.vertical,
2519         };
2520         if (self.options.fontExtraProperties && font.systemFontInfo) {
2521           const style = textContent.styles[loadedName];
2522           style.fontSubstitution = font.systemFontInfo.css;
2523           style.fontSubstitutionLoadedName = font.systemFontInfo.loadedName;
2524         }
2525       }
2526       textContentItem.fontName = loadedName;
2527 
2528       const trm = (textContentItem.transform = getCurrentTextTransform());
2529       if (!font.vertical) {
2530         textContentItem.width = textContentItem.totalWidth = 0;
2531         textContentItem.height = textContentItem.totalHeight = Math.hypot(
2532           trm[2],
2533           trm[3]
2534         );
2535         textContentItem.vertical = false;
2536       } else {
2537         textContentItem.width = textContentItem.totalWidth = Math.hypot(
2538           trm[0],
2539           trm[1]
2540         );
2541         textContentItem.height = textContentItem.totalHeight = 0;
2542         textContentItem.vertical = true;
2543       }
2544 
2545       const scaleLineX = Math.hypot(
2546         textState.textLineMatrix[0],
2547         textState.textLineMatrix[1]
2548       );
2549       const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
2550       textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
2551 
2552       const { fontSize } = textState;
2553       textContentItem.trackingSpaceMin = fontSize * TRACKING_SPACE_FACTOR;
2554       textContentItem.notASpace = fontSize * NOT_A_SPACE_FACTOR;
2555       textContentItem.negativeSpaceMax = fontSize * NEGATIVE_SPACE_FACTOR;
2556       textContentItem.spaceInFlowMin = fontSize * SPACE_IN_FLOW_MIN_FACTOR;
2557       textContentItem.spaceInFlowMax = fontSize * SPACE_IN_FLOW_MAX_FACTOR;
2558       textContentItem.hasEOL = false;
2559 
2560       textContentItem.initialized = true;
2561       return textContentItem;
2562     }
2563 
2564     function updateAdvanceScale() {
2565       if (!textContentItem.initialized) {
2566         return;
2567       }
2568 
2569       const scaleLineX = Math.hypot(
2570         textState.textLineMatrix[0],
2571         textState.textLineMatrix[1]
2572       );
2573       const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
2574       const scaleFactor = scaleCtmX * scaleLineX;
2575       if (scaleFactor === textContentItem.textAdvanceScale) {
2576         return;
2577       }
2578 
2579       if (!textContentItem.vertical) {
2580         textContentItem.totalWidth +=
2581           textContentItem.width * textContentItem.textAdvanceScale;
2582         textContentItem.width = 0;
2583       } else {
2584         textContentItem.totalHeight +=
2585           textContentItem.height * textContentItem.textAdvanceScale;
2586         textContentItem.height = 0;
2587       }
2588 
2589       textContentItem.textAdvanceScale = scaleFactor;
2590     }
2591 
2592     function runBidiTransform(textChunk) {
2593       let text = textChunk.str.join("");
2594       if (!disableNormalization) {
2595         text = normalizeUnicode(text);
2596       }
2597       const bidiResult = bidi(text, -1, textChunk.vertical);
2598       return {
2599         str: bidiResult.str,
2600         dir: bidiResult.dir,
2601         width: Math.abs(textChunk.totalWidth),
2602         height: Math.abs(textChunk.totalHeight),
2603         transform: textChunk.transform,
2604         fontName: textChunk.fontName,
2605         hasEOL: textChunk.hasEOL,
2606       };
2607     }
2608 
2609     async function handleSetFont(fontName, fontRef) {
2610       const translated = await self.loadFont(fontName, fontRef, resources);
2611 
2612       if (translated.font.isType3Font) {
2613         try {
2614           await translated.loadType3Data(self, resources, task);
2615         } catch {
2616           // Ignore Type3-parsing errors, since we only use `loadType3Data`
2617           // here to ensure that we'll always obtain a useful /FontBBox.
2618         }
2619       }
2620 
2621       textState.loadedName = translated.loadedName;
2622       textState.font = translated.font;
2623       textState.fontMatrix = translated.font.fontMatrix || FONT_IDENTITY_MATRIX;
2624     }
2625 
2626     function applyInverseRotation(x, y, matrix) {
2627       const scale = Math.hypot(matrix[0], matrix[1]);
2628       return [
2629         (matrix[0] * x + matrix[1] * y) / scale,
2630         (matrix[2] * x + matrix[3] * y) / scale,
2631       ];
2632     }
2633 
2634     function compareWithLastPosition(glyphWidth) {
2635       const currentTransform = getCurrentTextTransform();
2636       let posX = currentTransform[4];
2637       let posY = currentTransform[5];
2638 
2639       // Check if the glyph is in the viewbox.
2640       if (textState.font?.vertical) {
2641         if (
2642           posX < viewBox[0] ||
2643           posX > viewBox[2] ||
2644           posY + glyphWidth < viewBox[1] ||
2645           posY > viewBox[3]
2646         ) {
2647           return false;
2648         }
2649       } else if (
2650         posX + glyphWidth < viewBox[0] ||
2651         posX > viewBox[2] ||
2652         posY < viewBox[1] ||
2653         posY > viewBox[3]
2654       ) {
2655         return false;
2656       }
2657 
2658       if (!textState.font || !textContentItem.prevTransform) {
2659         return true;
2660       }
2661 
2662       let lastPosX = textContentItem.prevTransform[4];
2663       let lastPosY = textContentItem.prevTransform[5];
2664 
2665       if (lastPosX === posX && lastPosY === posY) {
2666         return true;
2667       }
2668 
2669       let rotate = -1;
2670       // Take into account the rotation is the current transform.
2671       if (
2672         currentTransform[0] &&
2673         currentTransform[1] === 0 &&
2674         currentTransform[2] === 0
2675       ) {
2676         rotate = currentTransform[0] > 0 ? 0 : 180;
2677       } else if (
2678         currentTransform[1] &&
2679         currentTransform[0] === 0 &&
2680         currentTransform[3] === 0
2681       ) {
2682         rotate = currentTransform[1] > 0 ? 90 : 270;
2683       }
2684 
2685       switch (rotate) {
2686         case 0:
2687           break;
2688         case 90:
2689           [posX, posY] = [posY, posX];
2690           [lastPosX, lastPosY] = [lastPosY, lastPosX];
2691           break;
2692         case 180:
2693           [posX, posY, lastPosX, lastPosY] = [
2694             -posX,
2695             -posY,
2696             -lastPosX,
2697             -lastPosY,
2698           ];
2699           break;
2700         case 270:
2701           [posX, posY] = [-posY, -posX];
2702           [lastPosX, lastPosY] = [-lastPosY, -lastPosX];
2703           break;
2704         default:
2705           // This is not a 0, 90, 180, 270 rotation so:
2706           //  - remove the scale factor from the matrix to get a rotation matrix
2707           //  - apply the inverse (which is the transposed) to the positions
2708           // and we can then compare positions of the glyphes to detect
2709           // a whitespace.
2710           [posX, posY] = applyInverseRotation(posX, posY, currentTransform);
2711           [lastPosX, lastPosY] = applyInverseRotation(
2712             lastPosX,
2713             lastPosY,
2714             textContentItem.prevTransform
2715           );
2716       }
2717 
2718       if (textState.font.vertical) {
2719         const advanceY = (lastPosY - posY) / textContentItem.textAdvanceScale;
2720         const advanceX = posX - lastPosX;
2721 
2722         // When the total height of the current chunk is negative
2723         // then we're writing from bottom to top.
2724         const textOrientation = Math.sign(textContentItem.height);
2725         if (advanceY < textOrientation * textContentItem.negativeSpaceMax) {
2726           if (
2727             Math.abs(advanceX) >
2728             0.5 * textContentItem.width /* not the same column */
2729           ) {
2730             appendEOL();
2731             return true;
2732           }
2733 
2734           resetLastChars();
2735           flushTextContentItem();
2736           return true;
2737         }
2738 
2739         if (Math.abs(advanceX) > textContentItem.width) {
2740           appendEOL();
2741           return true;
2742         }
2743 
2744         if (advanceY <= textOrientation * textContentItem.notASpace) {
2745           // The real spacing between 2 consecutive chars is thin enough to be
2746           // considered a non-space.
2747           resetLastChars();
2748         }
2749 
2750         if (advanceY <= textOrientation * textContentItem.trackingSpaceMin) {
2751           if (shouldAddWhitepsace()) {
2752             // The space is very thin, hence it deserves to have its own span in
2753             // order to avoid too much shift between the canvas and the text
2754             // layer.
2755             resetLastChars();
2756             flushTextContentItem();
2757             pushWhitespace({ height: Math.abs(advanceY) });
2758           } else {
2759             textContentItem.height += advanceY;
2760           }
2761         } else if (
2762           !addFakeSpaces(
2763             advanceY,
2764             textContentItem.prevTransform,
2765             textOrientation
2766           )
2767         ) {
2768           if (textContentItem.str.length === 0) {
2769             resetLastChars();
2770             pushWhitespace({ height: Math.abs(advanceY) });
2771           } else {
2772             textContentItem.height += advanceY;
2773           }
2774         }
2775 
2776         if (Math.abs(advanceX) > textContentItem.width * VERTICAL_SHIFT_RATIO) {
2777           flushTextContentItem();
2778         }
2779 
2780         return true;
2781       }
2782 
2783       const advanceX = (posX - lastPosX) / textContentItem.textAdvanceScale;
2784       const advanceY = posY - lastPosY;
2785 
2786       // When the total width of the current chunk is negative
2787       // then we're writing from right to left.
2788       const textOrientation = Math.sign(textContentItem.width);
2789       if (advanceX < textOrientation * textContentItem.negativeSpaceMax) {
2790         if (
2791           Math.abs(advanceY) >
2792           0.5 * textContentItem.height /* not the same line */
2793         ) {
2794           appendEOL();
2795           return true;
2796         }
2797 
2798         // We're moving back so in case the last char was a whitespace
2799         // we cancel it: it doesn't make sense to insert it.
2800         resetLastChars();
2801         flushTextContentItem();
2802         return true;
2803       }
2804 
2805       if (Math.abs(advanceY) > textContentItem.height) {
2806         appendEOL();
2807         return true;
2808       }
2809 
2810       if (advanceX <= textOrientation * textContentItem.notASpace) {
2811         // The real spacing between 2 consecutive chars is thin enough to be
2812         // considered a non-space.
2813         resetLastChars();
2814       }
2815 
2816       if (advanceX <= textOrientation * textContentItem.trackingSpaceMin) {
2817         if (shouldAddWhitepsace()) {
2818           // The space is very thin, hence it deserves to have its own span in
2819           // order to avoid too much shift between the canvas and the text
2820           // layer.
2821           resetLastChars();
2822           flushTextContentItem();
2823           pushWhitespace({ width: Math.abs(advanceX) });
2824         } else {
2825           textContentItem.width += advanceX;
2826         }
2827       } else if (
2828         !addFakeSpaces(advanceX, textContentItem.prevTransform, textOrientation)
2829       ) {
2830         if (textContentItem.str.length === 0) {
2831           resetLastChars();
2832           pushWhitespace({ width: Math.abs(advanceX) });
2833         } else {
2834           textContentItem.width += advanceX;
2835         }
2836       }
2837 
2838       if (Math.abs(advanceY) > textContentItem.height * VERTICAL_SHIFT_RATIO) {
2839         flushTextContentItem();
2840       }
2841 
2842       return true;
2843     }
2844 
2845     function buildTextContentItem({ chars, extraSpacing }) {
2846       const font = textState.font;
2847       if (!chars) {
2848         // Just move according to the space we have.
2849         const charSpacing = textState.charSpacing + extraSpacing;
2850         if (charSpacing) {
2851           if (!font.vertical) {
2852             textState.translateTextMatrix(
2853               charSpacing * textState.textHScale,
2854               0
2855             );
2856           } else {
2857             textState.translateTextMatrix(0, -charSpacing);
2858           }
2859         }
2860 
2861         if (keepWhiteSpace) {
2862           compareWithLastPosition(0);
2863         }
2864 
2865         return;
2866       }
2867 
2868       const glyphs = font.charsToGlyphs(chars);
2869       const scale = textState.fontMatrix[0] * textState.fontSize;
2870 
2871       for (let i = 0, ii = glyphs.length; i < ii; i++) {
2872         const glyph = glyphs[i];
2873         const { category } = glyph;
2874 
2875         if (category.isInvisibleFormatMark) {
2876           continue;
2877         }
2878         let charSpacing =
2879           textState.charSpacing + (i + 1 === ii ? extraSpacing : 0);
2880 
2881         let glyphWidth = glyph.width;
2882         if (font.vertical) {
2883           glyphWidth = glyph.vmetric ? glyph.vmetric[0] : -glyphWidth;
2884         }
2885         let scaledDim = glyphWidth * scale;
2886 
2887         if (!keepWhiteSpace && category.isWhitespace) {
2888           // Don't push a " " in the textContentItem
2889           // (except when it's between two non-spaces chars),
2890           // it will be done (if required) in next call to
2891           // compareWithLastPosition.
2892           // This way we can merge real spaces and spaces due to cursor moves.
2893           if (!font.vertical) {
2894             charSpacing += scaledDim + textState.wordSpacing;
2895             textState.translateTextMatrix(
2896               charSpacing * textState.textHScale,
2897               0
2898             );
2899           } else {
2900             charSpacing += -scaledDim + textState.wordSpacing;
2901             textState.translateTextMatrix(0, -charSpacing);
2902           }
2903           saveLastChar(" ");
2904           continue;
2905         }
2906 
2907         if (
2908           !category.isZeroWidthDiacritic &&
2909           !compareWithLastPosition(scaledDim)
2910         ) {
2911           // The glyph is not in page so just skip it but move the cursor.
2912           if (!font.vertical) {
2913             textState.translateTextMatrix(scaledDim * textState.textHScale, 0);
2914           } else {
2915             textState.translateTextMatrix(0, scaledDim);
2916           }
2917           continue;
2918         }
2919 
2920         // Must be called after compareWithLastPosition because
2921         // the textContentItem could have been flushed.
2922         const textChunk = ensureTextContentItem();
2923         if (category.isZeroWidthDiacritic) {
2924           scaledDim = 0;
2925         }
2926 
2927         if (!font.vertical) {
2928           scaledDim *= textState.textHScale;
2929           textState.translateTextMatrix(scaledDim, 0);
2930           textChunk.width += scaledDim;
2931         } else {
2932           textState.translateTextMatrix(0, scaledDim);
2933           scaledDim = Math.abs(scaledDim);
2934           textChunk.height += scaledDim;
2935         }
2936 
2937         if (scaledDim) {
2938           // Save the position of the last visible character.
2939           textChunk.prevTransform = getCurrentTextTransform();
2940         }
2941 
2942         const glyphUnicode = glyph.unicode;
2943         if (saveLastChar(glyphUnicode)) {
2944           // The two last chars are a non-whitespace followed by a whitespace
2945           // and then this non-whitespace, so we insert a whitespace here.
2946           // Replaces all whitespaces with standard spaces (0x20), to avoid
2947           // alignment issues between the textLayer and the canvas if the text
2948           // contains e.g. tabs (fixes issue6612.pdf).
2949           textChunk.str.push(" ");
2950         }
2951         textChunk.str.push(glyphUnicode);
2952 
2953         if (charSpacing) {
2954           if (!font.vertical) {
2955             textState.translateTextMatrix(
2956               charSpacing * textState.textHScale,
2957               0
2958             );
2959           } else {
2960             textState.translateTextMatrix(0, -charSpacing);
2961           }
2962         }
2963       }
2964     }
2965 
2966     function appendEOL() {
2967       resetLastChars();
2968       if (textContentItem.initialized) {
2969         textContentItem.hasEOL = true;
2970         flushTextContentItem();
2971       } else {
2972         textContent.items.push({
2973           str: "",
2974           dir: "ltr",
2975           width: 0,
2976           height: 0,
2977           transform: getCurrentTextTransform(),
2978           fontName: textState.loadedName,
2979           hasEOL: true,
2980         });
2981       }
2982     }
2983 
2984     function addFakeSpaces(width, transf, textOrientation) {
2985       if (
2986         textOrientation * textContentItem.spaceInFlowMin <= width &&
2987         width <= textOrientation * textContentItem.spaceInFlowMax
2988       ) {
2989         if (textContentItem.initialized) {
2990           resetLastChars();
2991           textContentItem.str.push(" ");
2992         }
2993         return false;
2994       }
2995 
2996       const fontName = textContentItem.fontName;
2997 
2998       let height = 0;
2999       if (textContentItem.vertical) {
3000         height = width;
3001         width = 0;
3002       }
3003 
3004       flushTextContentItem();
3005       resetLastChars();
3006       pushWhitespace({
3007         width: Math.abs(width),
3008         height: Math.abs(height),
3009         transform: transf || getCurrentTextTransform(),
3010         fontName,
3011       });
3012 
3013       return true;
3014     }
3015 
3016     function flushTextContentItem() {
3017       if (!textContentItem.initialized || !textContentItem.str) {
3018         return;
3019       }
3020 
3021       // Do final text scaling.
3022       if (!textContentItem.vertical) {
3023         textContentItem.totalWidth +=
3024           textContentItem.width * textContentItem.textAdvanceScale;
3025       } else {
3026         textContentItem.totalHeight +=
3027           textContentItem.height * textContentItem.textAdvanceScale;
3028       }
3029 
3030       textContent.items.push(runBidiTransform(textContentItem));
3031       textContentItem.initialized = false;
3032       textContentItem.str.length = 0;
3033     }
3034 
3035     function enqueueChunk(batch = false) {
3036       const length = textContent.items.length;
3037       if (length === 0) {
3038         return;
3039       }
3040       if (batch && length < TEXT_CHUNK_BATCH_SIZE) {
3041         return;
3042       }
3043       sink.enqueue(textContent, length);
3044       textContent.items = [];
3045       textContent.styles = Object.create(null);
3046     }
3047 
3048     const timeSlotManager = new TimeSlotManager();
3049 
3050     return new Promise(function promiseBody(resolve, reject) {
3051       const next = function (promise) {
3052         enqueueChunk(/* batch = */ true);
3053         Promise.all([promise, sink.ready]).then(function () {
3054           try {
3055             promiseBody(resolve, reject);
3056           } catch (ex) {
3057             reject(ex);
3058           }
3059         }, reject);
3060       };
3061       task.ensureNotTerminated();
3062       timeSlotManager.reset();
3063 
3064       const operation = {};
3065       let stop,
3066         args = [];
3067       while (!(stop = timeSlotManager.check())) {
3068         // The arguments parsed by read() are not used beyond this loop, so
3069         // we can reuse the same array on every iteration, thus avoiding
3070         // unnecessary allocations.
3071         args.length = 0;
3072         operation.args = args;
3073         if (!preprocessor.read(operation)) {
3074           break;
3075         }
3076 
3077         const previousState = textState;
3078         textState = stateManager.state;
3079         const fn = operation.fn;
3080         args = operation.args;
3081 
3082         switch (fn | 0) {
3083           case OPS.setFont:
3084             // Optimization to ignore multiple identical Tf commands.
3085             var fontNameArg = args[0].name,
3086               fontSizeArg = args[1];
3087             if (
3088               textState.font &&
3089               fontNameArg === textState.fontName &&
3090               fontSizeArg === textState.fontSize
3091             ) {
3092               break;
3093             }
3094 
3095             flushTextContentItem();
3096             textState.fontName = fontNameArg;
3097             textState.fontSize = fontSizeArg;
3098             next(handleSetFont(fontNameArg, null));
3099             return;
3100           case OPS.setTextRise:
3101             textState.textRise = args[0];
3102             break;
3103           case OPS.setHScale:
3104             textState.textHScale = args[0] / 100;
3105             break;
3106           case OPS.setLeading:
3107             textState.leading = args[0];
3108             break;
3109           case OPS.moveText:
3110             textState.translateTextLineMatrix(args[0], args[1]);
3111             textState.textMatrix = textState.textLineMatrix.slice();
3112             break;
3113           case OPS.setLeadingMoveText:
3114             textState.leading = -args[1];
3115             textState.translateTextLineMatrix(args[0], args[1]);
3116             textState.textMatrix = textState.textLineMatrix.slice();
3117             break;
3118           case OPS.nextLine:
3119             textState.carriageReturn();
3120             break;
3121           case OPS.setTextMatrix:
3122             textState.setTextMatrix(
3123               args[0],
3124               args[1],
3125               args[2],
3126               args[3],
3127               args[4],
3128               args[5]
3129             );
3130             textState.setTextLineMatrix(
3131               args[0],
3132               args[1],
3133               args[2],
3134               args[3],
3135               args[4],
3136               args[5]
3137             );
3138             updateAdvanceScale();
3139             break;
3140           case OPS.setCharSpacing:
3141             textState.charSpacing = args[0];
3142             break;
3143           case OPS.setWordSpacing:
3144             textState.wordSpacing = args[0];
3145             break;
3146           case OPS.beginText:
3147             textState.textMatrix = IDENTITY_MATRIX.slice();
3148             textState.textLineMatrix = IDENTITY_MATRIX.slice();
3149             break;
3150           case OPS.showSpacedText:
3151             if (!stateManager.state.font) {
3152               self.ensureStateFont(stateManager.state);
3153               continue;
3154             }
3155 
3156             const spaceFactor =
3157               ((textState.font.vertical ? 1 : -1) * textState.fontSize) / 1000;
3158             const elements = args[0];
3159             for (let i = 0, ii = elements.length; i < ii; i++) {
3160               const item = elements[i];
3161               if (typeof item === "string") {
3162                 showSpacedTextBuffer.push(item);
3163               } else if (typeof item === "number" && item !== 0) {
3164                 // PDF Specification 5.3.2 states:
3165                 // The number is expressed in thousandths of a unit of text
3166                 // space.
3167                 // This amount is subtracted from the current horizontal or
3168                 // vertical coordinate, depending on the writing mode.
3169                 // In the default coordinate system, a positive adjustment
3170                 // has the effect of moving the next glyph painted either to
3171                 // the left or down by the given amount.
3172                 const str = showSpacedTextBuffer.join("");
3173                 showSpacedTextBuffer.length = 0;
3174                 buildTextContentItem({
3175                   chars: str,
3176                   extraSpacing: item * spaceFactor,
3177                 });
3178               }
3179             }
3180 
3181             if (showSpacedTextBuffer.length > 0) {
3182               const str = showSpacedTextBuffer.join("");
3183               showSpacedTextBuffer.length = 0;
3184               buildTextContentItem({
3185                 chars: str,
3186                 extraSpacing: 0,
3187               });
3188             }
3189             break;
3190           case OPS.showText:
3191             if (!stateManager.state.font) {
3192               self.ensureStateFont(stateManager.state);
3193               continue;
3194             }
3195             buildTextContentItem({
3196               chars: args[0],
3197               extraSpacing: 0,
3198             });
3199             break;
3200           case OPS.nextLineShowText:
3201             if (!stateManager.state.font) {
3202               self.ensureStateFont(stateManager.state);
3203               continue;
3204             }
3205             textState.carriageReturn();
3206             buildTextContentItem({
3207               chars: args[0],
3208               extraSpacing: 0,
3209             });
3210             break;
3211           case OPS.nextLineSetSpacingShowText:
3212             if (!stateManager.state.font) {
3213               self.ensureStateFont(stateManager.state);
3214               continue;
3215             }
3216             textState.wordSpacing = args[0];
3217             textState.charSpacing = args[1];
3218             textState.carriageReturn();
3219             buildTextContentItem({
3220               chars: args[2],
3221               extraSpacing: 0,
3222             });
3223             break;
3224           case OPS.paintXObject:
3225             flushTextContentItem();
3226             if (!xobjs) {
3227               xobjs = resources.get("XObject") || Dict.empty;
3228             }
3229 
3230             var isValidName = args[0] instanceof Name;
3231             var name = args[0].name;
3232 
3233             if (isValidName && emptyXObjectCache.getByName(name)) {
3234               break;
3235             }
3236 
3237             next(
3238               new Promise(function (resolveXObject, rejectXObject) {
3239                 if (!isValidName) {
3240                   throw new FormatError("XObject must be referred to by name.");
3241                 }
3242 
3243                 let xobj = xobjs.getRaw(name);
3244                 if (xobj instanceof Ref) {
3245                   if (emptyXObjectCache.getByRef(xobj)) {
3246                     resolveXObject();
3247                     return;
3248                   }
3249 
3250                   const globalImage = self.globalImageCache.getData(
3251                     xobj,
3252                     self.pageIndex
3253                   );
3254                   if (globalImage) {
3255                     resolveXObject();
3256                     return;
3257                   }
3258 
3259                   xobj = xref.fetch(xobj);
3260                 }
3261 
3262                 if (!(xobj instanceof BaseStream)) {
3263                   throw new FormatError("XObject should be a stream");
3264                 }
3265 
3266                 const type = xobj.dict.get("Subtype");
3267                 if (!(type instanceof Name)) {
3268                   throw new FormatError("XObject should have a Name subtype");
3269                 }
3270 
3271                 if (type.name !== "Form") {
3272                   emptyXObjectCache.set(name, xobj.dict.objId, true);
3273 
3274                   resolveXObject();
3275                   return;
3276                 }
3277 
3278                 // Use a new `StateManager` to prevent incorrect positioning
3279                 // of textItems *after* the Form XObject, since errors in the
3280                 // data can otherwise prevent `restore` operators from
3281                 // executing.
3282                 // NOTE: Only an issue when `options.ignoreErrors === true`.
3283                 const currentState = stateManager.state.clone();
3284                 const xObjStateManager = new StateManager(currentState);
3285 
3286                 const matrix = lookupMatrix(xobj.dict.getArray("Matrix"), null);
3287                 if (matrix) {
3288                   xObjStateManager.transform(matrix);
3289                 }
3290 
3291                 // Enqueue the `textContent` chunk before parsing the /Form
3292                 // XObject.
3293                 enqueueChunk();
3294                 const sinkWrapper = {
3295                   enqueueInvoked: false,
3296 
3297                   enqueue(chunk, size) {
3298                     this.enqueueInvoked = true;
3299                     sink.enqueue(chunk, size);
3300                   },
3301 
3302                   get desiredSize() {
3303                     return sink.desiredSize;
3304                   },
3305 
3306                   get ready() {
3307                     return sink.ready;
3308                   },
3309                 };
3310 
3311                 self
3312                   .getTextContent({
3313                     stream: xobj,
3314                     task,
3315                     resources: xobj.dict.get("Resources") || resources,
3316                     stateManager: xObjStateManager,
3317                     includeMarkedContent,
3318                     sink: sinkWrapper,
3319                     seenStyles,
3320                     viewBox,
3321                     lang,
3322                     markedContentData,
3323                     disableNormalization,
3324                     keepWhiteSpace,
3325                   })
3326                   .then(function () {
3327                     if (!sinkWrapper.enqueueInvoked) {
3328                       emptyXObjectCache.set(name, xobj.dict.objId, true);
3329                     }
3330                     resolveXObject();
3331                   }, rejectXObject);
3332               }).catch(function (reason) {
3333                 if (reason instanceof AbortException) {
3334                   return;
3335                 }
3336                 if (self.options.ignoreErrors) {
3337                   // Error(s) in the XObject -- allow text-extraction to
3338                   // continue.
3339                   warn(`getTextContent - ignoring XObject: "${reason}".`);
3340                   return;
3341                 }
3342                 throw reason;
3343               })
3344             );
3345             return;
3346           case OPS.setGState:
3347             isValidName = args[0] instanceof Name;
3348             name = args[0].name;
3349 
3350             if (isValidName && emptyGStateCache.getByName(name)) {
3351               break;
3352             }
3353 
3354             next(
3355               new Promise(function (resolveGState, rejectGState) {
3356                 if (!isValidName) {
3357                   throw new FormatError("GState must be referred to by name.");
3358                 }
3359 
3360                 const extGState = resources.get("ExtGState");
3361                 if (!(extGState instanceof Dict)) {
3362                   throw new FormatError("ExtGState should be a dictionary.");
3363                 }
3364 
3365                 const gState = extGState.get(name);
3366                 // TODO: Attempt to lookup cached GStates by reference as well,
3367                 //       if and only if there are PDF documents where doing so
3368                 //       would significantly improve performance.
3369                 if (!(gState instanceof Dict)) {
3370                   throw new FormatError("GState should be a dictionary.");
3371                 }
3372 
3373                 const gStateFont = gState.get("Font");
3374                 if (!gStateFont) {
3375                   emptyGStateCache.set(name, gState.objId, true);
3376 
3377                   resolveGState();
3378                   return;
3379                 }
3380                 flushTextContentItem();
3381 
3382                 textState.fontName = null;
3383                 textState.fontSize = gStateFont[1];
3384                 handleSetFont(null, gStateFont[0]).then(
3385                   resolveGState,
3386                   rejectGState
3387                 );
3388               }).catch(function (reason) {
3389                 if (reason instanceof AbortException) {
3390                   return;
3391                 }
3392                 if (self.options.ignoreErrors) {
3393                   // Error(s) in the ExtGState -- allow text-extraction to
3394                   // continue.
3395                   warn(`getTextContent - ignoring ExtGState: "${reason}".`);
3396                   return;
3397                 }
3398                 throw reason;
3399               })
3400             );
3401             return;
3402           case OPS.beginMarkedContent:
3403             flushTextContentItem();
3404             if (includeMarkedContent) {
3405               markedContentData.level++;
3406 
3407               textContent.items.push({
3408                 type: "beginMarkedContent",
3409                 tag: args[0] instanceof Name ? args[0].name : null,
3410               });
3411             }
3412             break;
3413           case OPS.beginMarkedContentProps:
3414             flushTextContentItem();
3415             if (includeMarkedContent) {
3416               markedContentData.level++;
3417 
3418               let mcid = null;
3419               if (args[1] instanceof Dict) {
3420                 mcid = args[1].get("MCID");
3421               }
3422               textContent.items.push({
3423                 type: "beginMarkedContentProps",
3424                 id: Number.isInteger(mcid)
3425                   ? `${self.idFactory.getPageObjId()}_mc${mcid}`
3426                   : null,
3427                 tag: args[0] instanceof Name ? args[0].name : null,
3428               });
3429             }
3430             break;
3431           case OPS.endMarkedContent:
3432             flushTextContentItem();
3433             if (includeMarkedContent) {
3434               if (markedContentData.level === 0) {
3435                 // Handle unbalanced beginMarkedContent/endMarkedContent
3436                 // operators (fixes issue15629.pdf).
3437                 break;
3438               }
3439               markedContentData.level--;
3440 
3441               textContent.items.push({
3442                 type: "endMarkedContent",
3443               });
3444             }
3445             break;
3446           case OPS.restore:
3447             if (
3448               previousState &&
3449               (previousState.font !== textState.font ||
3450                 previousState.fontSize !== textState.fontSize ||
3451                 previousState.fontName !== textState.fontName)
3452             ) {
3453               flushTextContentItem();
3454             }
3455             break;
3456         } // switch
3457         if (textContent.items.length >= sink.desiredSize) {
3458           // Wait for ready, if we reach highWaterMark.
3459           stop = true;
3460           break;
3461         }
3462       } // while
3463       if (stop) {
3464         next(deferred);
3465         return;
3466       }
3467       flushTextContentItem();
3468       enqueueChunk();
3469       resolve();
3470     }).catch(reason => {
3471       if (reason instanceof AbortException) {
3472         return;
3473       }
3474       if (this.options.ignoreErrors) {
3475         // Error(s) in the TextContent -- allow text-extraction to continue.
3476         warn(
3477           `getTextContent - ignoring errors during "${task.name}" ` +
3478             `task: "${reason}".`
3479         );
3480 
3481         flushTextContentItem();
3482         enqueueChunk();
3483         return;
3484       }
3485       throw reason;
3486     });
3487   }
3488 
3489   async extractDataStructures(dict, properties) {
3490     const xref = this.xref;
3491     let cidToGidBytes;
3492     // 9.10.2
3493     const toUnicodePromise = this.readToUnicode(properties.toUnicode);
3494 
3495     if (properties.composite) {
3496       // CIDSystemInfo helps to match CID to glyphs
3497       const cidSystemInfo = dict.get("CIDSystemInfo");
3498       if (cidSystemInfo instanceof Dict) {
3499         properties.cidSystemInfo = {
3500           registry: stringToPDFString(cidSystemInfo.get("Registry")),
3501           ordering: stringToPDFString(cidSystemInfo.get("Ordering")),
3502           supplement: cidSystemInfo.get("Supplement"),
3503         };
3504       }
3505 
3506       try {
3507         const cidToGidMap = dict.get("CIDToGIDMap");
3508         if (cidToGidMap instanceof BaseStream) {
3509           cidToGidBytes = cidToGidMap.getBytes();
3510         }
3511       } catch (ex) {
3512         if (!this.options.ignoreErrors) {
3513           throw ex;
3514         }
3515         warn(`extractDataStructures - ignoring CIDToGIDMap data: "${ex}".`);
3516       }
3517     }
3518 
3519     // Based on 9.6.6 of the spec the encoding can come from multiple places
3520     // and depends on the font type. The base encoding and differences are
3521     // read here, but the encoding that is actually used is chosen during
3522     // glyph mapping in the font.
3523     // TODO: Loading the built in encoding in the font would allow the
3524     // differences to be merged in here not require us to hold on to it.
3525     const differences = [];
3526     let baseEncodingName = null;
3527     let encoding;
3528     if (dict.has("Encoding")) {
3529       encoding = dict.get("Encoding");
3530       if (encoding instanceof Dict) {
3531         baseEncodingName = encoding.get("BaseEncoding");
3532         baseEncodingName =
3533           baseEncodingName instanceof Name ? baseEncodingName.name : null;
3534         // Load the differences between the base and original
3535         if (encoding.has("Differences")) {
3536           const diffEncoding = encoding.get("Differences");
3537           let index = 0;
3538           for (const entry of diffEncoding) {
3539             const data = xref.fetchIfRef(entry);
3540             if (typeof data === "number") {
3541               index = data;
3542             } else if (data instanceof Name) {
3543               differences[index++] = data.name;
3544             } else {
3545               throw new FormatError(
3546                 `Invalid entry in 'Differences' array: ${data}`
3547               );
3548             }
3549           }
3550         }
3551       } else if (encoding instanceof Name) {
3552         baseEncodingName = encoding.name;
3553       } else {
3554         const msg = "Encoding is not a Name nor a Dict";
3555 
3556         if (!this.options.ignoreErrors) {
3557           throw new FormatError(msg);
3558         }
3559         warn(msg);
3560       }
3561       // According to table 114 if the encoding is a named encoding it must be
3562       // one of these predefined encodings.
3563       if (
3564         baseEncodingName !== "MacRomanEncoding" &&
3565         baseEncodingName !== "MacExpertEncoding" &&
3566         baseEncodingName !== "WinAnsiEncoding"
3567       ) {
3568         baseEncodingName = null;
3569       }
3570     }
3571 
3572     const nonEmbeddedFont = !properties.file || properties.isInternalFont,
3573       isSymbolsFontName = getSymbolsFonts()[properties.name];
3574     // Ignore an incorrectly specified named encoding for non-embedded
3575     // symbol fonts (fixes issue16464.pdf).
3576     if (baseEncodingName && nonEmbeddedFont && isSymbolsFontName) {
3577       baseEncodingName = null;
3578     }
3579 
3580     if (baseEncodingName) {
3581       properties.defaultEncoding = getEncoding(baseEncodingName);
3582     } else {
3583       const isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
3584       const isNonsymbolicFont = !!(properties.flags & FontFlags.Nonsymbolic);
3585       // According to "Table 114" in section "9.6.6.1 General" (under
3586       // "9.6.6 Character Encoding") of the PDF specification, a Nonsymbolic
3587       // font should use the `StandardEncoding` if no encoding is specified.
3588       encoding = StandardEncoding;
3589       if (properties.type === "TrueType" && !isNonsymbolicFont) {
3590         encoding = WinAnsiEncoding;
3591       }
3592       // The Symbolic attribute can be misused for regular fonts
3593       // Heuristic: we have to check if the font is a standard one also
3594       if (isSymbolicFont || isSymbolsFontName) {
3595         encoding = MacRomanEncoding;
3596         if (nonEmbeddedFont) {
3597           if (/Symbol/i.test(properties.name)) {
3598             encoding = SymbolSetEncoding;
3599           } else if (/Dingbats/i.test(properties.name)) {
3600             encoding = ZapfDingbatsEncoding;
3601           } else if (/Wingdings/i.test(properties.name)) {
3602             encoding = WinAnsiEncoding;
3603           }
3604         }
3605       }
3606       properties.defaultEncoding = encoding;
3607     }
3608 
3609     properties.differences = differences;
3610     properties.baseEncodingName = baseEncodingName;
3611     properties.hasEncoding = !!baseEncodingName || differences.length > 0;
3612     properties.dict = dict;
3613 
3614     properties.toUnicode = await toUnicodePromise;
3615 
3616     const builtToUnicode = await this.buildToUnicode(properties);
3617     properties.toUnicode = builtToUnicode;
3618 
3619     if (cidToGidBytes) {
3620       properties.cidToGidMap = this.readCidToGidMap(
3621         cidToGidBytes,
3622         builtToUnicode
3623       );
3624     }
3625     return properties;
3626   }
3627 
3628   /**
3629    * @returns {Array}
3630    * @private
3631    */
3632   _simpleFontToUnicode(properties, forceGlyphs = false) {
3633     assert(!properties.composite, "Must be a simple font.");
3634 
3635     const toUnicode = [];
3636     const encoding = properties.defaultEncoding.slice();
3637     const baseEncodingName = properties.baseEncodingName;
3638     // Merge in the differences array.
3639     const differences = properties.differences;
3640     for (const charcode in differences) {
3641       const glyphName = differences[charcode];
3642       if (glyphName === ".notdef") {
3643         // Skip .notdef to prevent rendering errors, e.g. boxes appearing
3644         // where there should be spaces (fixes issue5256.pdf).
3645         continue;
3646       }
3647       encoding[charcode] = glyphName;
3648     }
3649     const glyphsUnicodeMap = getGlyphsUnicode();
3650     for (const charcode in encoding) {
3651       // a) Map the character code to a character name.
3652       let glyphName = encoding[charcode];
3653       if (glyphName === "") {
3654         continue;
3655       }
3656       // b) Look up the character name in the Adobe Glyph List (see the
3657       //    Bibliography) to obtain the corresponding Unicode value.
3658       let unicode = glyphsUnicodeMap[glyphName];
3659       if (unicode !== undefined) {
3660         toUnicode[charcode] = String.fromCharCode(unicode);
3661         continue;
3662       }
3663       // (undocumented) c) Few heuristics to recognize unknown glyphs
3664       // NOTE: Adobe Reader does not do this step, but OSX Preview does
3665       let code = 0;
3666       switch (glyphName[0]) {
3667         case "G": // Gxx glyph
3668           if (glyphName.length === 3) {
3669             code = parseInt(glyphName.substring(1), 16);
3670           }
3671           break;
3672         case "g": // g00xx glyph
3673           if (glyphName.length === 5) {
3674             code = parseInt(glyphName.substring(1), 16);
3675           }
3676           break;
3677         case "C": // Cdd{d} glyph
3678         case "c": // cdd{d} glyph
3679           if (glyphName.length >= 3 && glyphName.length <= 4) {
3680             const codeStr = glyphName.substring(1);
3681 
3682             if (forceGlyphs) {
3683               code = parseInt(codeStr, 16);
3684               break;
3685             }
3686             // Normally the Cdd{d}/cdd{d} glyphName format will contain
3687             // regular, i.e. base 10, charCodes (see issue4550.pdf)...
3688             code = +codeStr;
3689 
3690             // ... however some PDF generators violate that assumption by
3691             // containing glyph, i.e. base 16, codes instead.
3692             // In that case we need to re-parse the *entire* encoding to
3693             // prevent broken text-selection (fixes issue9655_reduced.pdf).
3694             if (Number.isNaN(code) && Number.isInteger(parseInt(codeStr, 16))) {
3695               return this._simpleFontToUnicode(
3696                 properties,
3697                 /* forceGlyphs */ true
3698               );
3699             }
3700           }
3701           break;
3702         case "u": // 'uniXXXX'/'uXXXX{XX}' glyphs
3703           unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
3704           if (unicode !== -1) {
3705             code = unicode;
3706           }
3707           break;
3708         default:
3709           // Support (some) non-standard ligatures.
3710           switch (glyphName) {
3711             case "f_h":
3712             case "f_t":
3713             case "T_h":
3714               toUnicode[charcode] = glyphName.replaceAll("_", "");
3715               continue;
3716           }
3717           break;
3718       }
3719       if (code > 0 && code <= 0x10ffff && Number.isInteger(code)) {
3720         // If `baseEncodingName` is one the predefined encodings, and `code`
3721         // equals `charcode`, using the glyph defined in the baseEncoding
3722         // seems to yield a better `toUnicode` mapping (fixes issue 5070).
3723         if (baseEncodingName && code === +charcode) {
3724           const baseEncoding = getEncoding(baseEncodingName);
3725           if (baseEncoding && (glyphName = baseEncoding[charcode])) {
3726             toUnicode[charcode] = String.fromCharCode(
3727               glyphsUnicodeMap[glyphName]
3728             );
3729             continue;
3730           }
3731         }
3732         toUnicode[charcode] = String.fromCodePoint(code);
3733       }
3734     }
3735     return toUnicode;
3736   }
3737 
3738   /**
3739    * Builds a char code to unicode map based on section 9.10 of the spec.
3740    * @param {Object} properties Font properties object.
3741    * @returns {Promise} A Promise that is resolved with a
3742    *   {ToUnicodeMap|IdentityToUnicodeMap} object.
3743    */
3744   async buildToUnicode(properties) {
3745     properties.hasIncludedToUnicodeMap = properties.toUnicode?.length > 0;
3746 
3747     // Section 9.10.2 Mapping Character Codes to Unicode Values
3748     if (properties.hasIncludedToUnicodeMap) {
3749       // Some fonts contain incomplete ToUnicode data, causing issues with
3750       // text-extraction. For simple fonts, containing encoding information,
3751       // use a fallback ToUnicode map to improve this (fixes issue8229.pdf).
3752       if (!properties.composite && properties.hasEncoding) {
3753         properties.fallbackToUnicode = this._simpleFontToUnicode(properties);
3754       }
3755       return properties.toUnicode;
3756     }
3757 
3758     // According to the spec if the font is a simple font we should only map
3759     // to unicode if the base encoding is MacRoman, MacExpert, or WinAnsi or
3760     // the differences array only contains adobe standard or symbol set names,
3761     // in pratice it seems better to always try to create a toUnicode map
3762     // based of the default encoding.
3763     if (!properties.composite /* is simple font */) {
3764       return new ToUnicodeMap(this._simpleFontToUnicode(properties));
3765     }
3766 
3767     // If the font is a composite font that uses one of the predefined CMaps
3768     // listed in Table 118 (except Identity–H and Identity–V) or whose
3769     // descendant CIDFont uses the Adobe-GB1, Adobe-CNS1, Adobe-Japan1, or
3770     // Adobe-Korea1 character collection:
3771     if (
3772       properties.composite &&
3773       ((properties.cMap.builtInCMap &&
3774         !(properties.cMap instanceof IdentityCMap)) ||
3775         // The font is supposed to have a CIDSystemInfo dictionary, but some
3776         // PDFs don't include it (fixes issue 17689), hence the `?'.
3777         (properties.cidSystemInfo?.registry === "Adobe" &&
3778           (properties.cidSystemInfo.ordering === "GB1" ||
3779             properties.cidSystemInfo.ordering === "CNS1" ||
3780             properties.cidSystemInfo.ordering === "Japan1" ||
3781             properties.cidSystemInfo.ordering === "Korea1")))
3782     ) {
3783       // Then:
3784       // a) Map the character code to a character identifier (CID) according
3785       // to the font’s CMap.
3786       // b) Obtain the registry and ordering of the character collection used
3787       // by the font’s CMap (for example, Adobe and Japan1) from its
3788       // CIDSystemInfo dictionary.
3789       const { registry, ordering } = properties.cidSystemInfo;
3790       // c) Construct a second CMap name by concatenating the registry and
3791       // ordering obtained in step (b) in the format registry–ordering–UCS2
3792       // (for example, Adobe–Japan1–UCS2).
3793       const ucs2CMapName = Name.get(`${registry}-${ordering}-UCS2`);
3794       // d) Obtain the CMap with the name constructed in step (c) (available
3795       // from the ASN Web site; see the Bibliography).
3796       const ucs2CMap = await CMapFactory.create({
3797         encoding: ucs2CMapName,
3798         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3799         useCMap: null,
3800       });
3801       const toUnicode = [],
3802         buf = [];
3803       properties.cMap.forEach(function (charcode, cid) {
3804         if (cid > 0xffff) {
3805           throw new FormatError("Max size of CID is 65,535");
3806         }
3807         // e) Map the CID obtained in step (a) according to the CMap
3808         // obtained in step (d), producing a Unicode value.
3809         const ucs2 = ucs2CMap.lookup(cid);
3810         if (ucs2) {
3811           buf.length = 0;
3812           // Support multi-byte entries (fixes issue16176.pdf).
3813           for (let i = 0, ii = ucs2.length; i < ii; i += 2) {
3814             buf.push((ucs2.charCodeAt(i) << 8) + ucs2.charCodeAt(i + 1));
3815           }
3816           toUnicode[charcode] = String.fromCharCode(...buf);
3817         }
3818       });
3819       return new ToUnicodeMap(toUnicode);
3820     }
3821 
3822     // The viewer's choice, just use an identity map.
3823     return new IdentityToUnicodeMap(properties.firstChar, properties.lastChar);
3824   }
3825 
3826   async readToUnicode(cmapObj) {
3827     if (!cmapObj) {
3828       return null;
3829     }
3830     if (cmapObj instanceof Name) {
3831       const cmap = await CMapFactory.create({
3832         encoding: cmapObj,
3833         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3834         useCMap: null,
3835       });
3836 
3837       if (cmap instanceof IdentityCMap) {
3838         return new IdentityToUnicodeMap(0, 0xffff);
3839       }
3840       return new ToUnicodeMap(cmap.getMap());
3841     }
3842     if (cmapObj instanceof BaseStream) {
3843       try {
3844         const cmap = await CMapFactory.create({
3845           encoding: cmapObj,
3846           fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3847           useCMap: null,
3848         });
3849 
3850         if (cmap instanceof IdentityCMap) {
3851           return new IdentityToUnicodeMap(0, 0xffff);
3852         }
3853         const map = new Array(cmap.length);
3854         // Convert UTF-16BE
3855         // NOTE: cmap can be a sparse array, so use forEach instead of
3856         // `for(;;)` to iterate over all keys.
3857         cmap.forEach(function (charCode, token) {
3858           // Some cmaps contain *only* CID characters (fixes issue9367.pdf).
3859           if (typeof token === "number") {
3860             map[charCode] = String.fromCodePoint(token);
3861             return;
3862           }
3863           // Add back omitted leading zeros on odd length tokens
3864           // (fixes issue #18099)
3865           if (token.length % 2 !== 0) {
3866             token = "\u0000" + token;
3867           }
3868           const str = [];
3869           for (let k = 0; k < token.length; k += 2) {
3870             const w1 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
3871             if ((w1 & 0xf800) !== 0xd800) {
3872               // w1 < 0xD800 || w1 > 0xDFFF
3873               str.push(w1);
3874               continue;
3875             }
3876             k += 2;
3877             const w2 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
3878             str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);
3879           }
3880           map[charCode] = String.fromCodePoint(...str);
3881         });
3882         return new ToUnicodeMap(map);
3883       } catch (reason) {
3884         if (reason instanceof AbortException) {
3885           return null;
3886         }
3887         if (this.options.ignoreErrors) {
3888           warn(`readToUnicode - ignoring ToUnicode data: "${reason}".`);
3889           return null;
3890         }
3891         throw reason;
3892       }
3893     }
3894     return null;
3895   }
3896 
3897   readCidToGidMap(glyphsData, toUnicode) {
3898     // Extract the encoding from the CIDToGIDMap
3899 
3900     // Set encoding 0 to later verify the font has an encoding
3901     const result = [];
3902     for (let j = 0, jj = glyphsData.length; j < jj; j++) {
3903       const glyphID = (glyphsData[j++] << 8) | glyphsData[j];
3904       const code = j >> 1;
3905       if (glyphID === 0 && !toUnicode.has(code)) {
3906         continue;
3907       }
3908       result[code] = glyphID;
3909     }
3910     return result;
3911   }
3912 
3913   extractWidths(dict, descriptor, properties) {
3914     const xref = this.xref;
3915     let glyphsWidths = [];
3916     let defaultWidth = 0;
3917     const glyphsVMetrics = [];
3918     let defaultVMetrics;
3919     if (properties.composite) {
3920       const dw = dict.get("DW");
3921       defaultWidth = typeof dw === "number" ? Math.ceil(dw) : 1000;
3922 
3923       const widths = dict.get("W");
3924       if (Array.isArray(widths)) {
3925         for (let i = 0, ii = widths.length; i < ii; i++) {
3926           let start = xref.fetchIfRef(widths[i++]);
3927           if (!Number.isInteger(start)) {
3928             break; // Invalid /W data.
3929           }
3930           const code = xref.fetchIfRef(widths[i]);
3931 
3932           if (Array.isArray(code)) {
3933             for (const c of code) {
3934               const width = xref.fetchIfRef(c);
3935               if (typeof width === "number") {
3936                 glyphsWidths[start] = width;
3937               }
3938               start++;
3939             }
3940           } else if (Number.isInteger(code)) {
3941             const width = xref.fetchIfRef(widths[++i]);
3942             if (typeof width !== "number") {
3943               continue;
3944             }
3945             for (let j = start; j <= code; j++) {
3946               glyphsWidths[j] = width;
3947             }
3948           } else {
3949             break; // Invalid /W data.
3950           }
3951         }
3952       }
3953 
3954       if (properties.vertical) {
3955         const dw2 = dict.getArray("DW2");
3956         let vmetrics = isNumberArray(dw2, 2) ? dw2 : [880, -1000];
3957         defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
3958         vmetrics = dict.get("W2");
3959         if (Array.isArray(vmetrics)) {
3960           for (let i = 0, ii = vmetrics.length; i < ii; i++) {
3961             let start = xref.fetchIfRef(vmetrics[i++]);
3962             if (!Number.isInteger(start)) {
3963               break; // Invalid /W2 data.
3964             }
3965             const code = xref.fetchIfRef(vmetrics[i]);
3966 
3967             if (Array.isArray(code)) {
3968               for (let j = 0, jj = code.length; j < jj; j++) {
3969                 const vmetric = [
3970                   xref.fetchIfRef(code[j++]),
3971                   xref.fetchIfRef(code[j++]),
3972                   xref.fetchIfRef(code[j]),
3973                 ];
3974                 if (isNumberArray(vmetric, null)) {
3975                   glyphsVMetrics[start] = vmetric;
3976                 }
3977                 start++;
3978               }
3979             } else if (Number.isInteger(code)) {
3980               const vmetric = [
3981                 xref.fetchIfRef(vmetrics[++i]),
3982                 xref.fetchIfRef(vmetrics[++i]),
3983                 xref.fetchIfRef(vmetrics[++i]),
3984               ];
3985               if (!isNumberArray(vmetric, null)) {
3986                 continue;
3987               }
3988               for (let j = start; j <= code; j++) {
3989                 glyphsVMetrics[j] = vmetric;
3990               }
3991             } else {
3992               break; // Invalid /W2 data.
3993             }
3994           }
3995         }
3996       }
3997     } else {
3998       const widths = dict.get("Widths");
3999       if (Array.isArray(widths)) {
4000         let j = properties.firstChar;
4001         for (const w of widths) {
4002           const width = xref.fetchIfRef(w);
4003           if (typeof width === "number") {
4004             glyphsWidths[j] = width;
4005           }
4006           j++;
4007         }
4008         const missingWidth = descriptor.get("MissingWidth");
4009         defaultWidth = typeof missingWidth === "number" ? missingWidth : 0;
4010       } else {
4011         // Trying get the BaseFont metrics (see comment above).
4012         const baseFontName = dict.get("BaseFont");
4013         if (baseFontName instanceof Name) {
4014           const metrics = this.getBaseFontMetrics(baseFontName.name);
4015 
4016           glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
4017           defaultWidth = metrics.defaultWidth;
4018         }
4019       }
4020     }
4021 
4022     // Heuristic: detection of monospace font by checking all non-zero widths
4023     let isMonospace = true;
4024     let firstWidth = defaultWidth;
4025     for (const glyph in glyphsWidths) {
4026       const glyphWidth = glyphsWidths[glyph];
4027       if (!glyphWidth) {
4028         continue;
4029       }
4030       if (!firstWidth) {
4031         firstWidth = glyphWidth;
4032         continue;
4033       }
4034       if (firstWidth !== glyphWidth) {
4035         isMonospace = false;
4036         break;
4037       }
4038     }
4039     if (isMonospace) {
4040       properties.flags |= FontFlags.FixedPitch;
4041     } else {
4042       // Clear the flag.
4043       properties.flags &= ~FontFlags.FixedPitch;
4044     }
4045 
4046     properties.defaultWidth = defaultWidth;
4047     properties.widths = glyphsWidths;
4048     properties.defaultVMetrics = defaultVMetrics;
4049     properties.vmetrics = glyphsVMetrics;
4050   }
4051 
4052   isSerifFont(baseFontName) {
4053     // Simulating descriptor flags attribute
4054     const fontNameWoStyle = baseFontName.split("-", 1)[0];
4055     return (
4056       fontNameWoStyle in getSerifFonts() || /serif/gi.test(fontNameWoStyle)
4057     );
4058   }
4059 
4060   getBaseFontMetrics(name) {
4061     let defaultWidth = 0;
4062     let widths = Object.create(null);
4063     let monospace = false;
4064     const stdFontMap = getStdFontMap();
4065     let lookupName = stdFontMap[name] || name;
4066     const Metrics = getMetrics();
4067 
4068     if (!(lookupName in Metrics)) {
4069       // Use default fonts for looking up font metrics if the passed
4070       // font is not a base font
4071       lookupName = this.isSerifFont(name) ? "Times-Roman" : "Helvetica";
4072     }
4073     const glyphWidths = Metrics[lookupName];
4074 
4075     if (typeof glyphWidths === "number") {
4076       defaultWidth = glyphWidths;
4077       monospace = true;
4078     } else {
4079       widths = glyphWidths(); // expand lazy widths array
4080     }
4081 
4082     return {
4083       defaultWidth,
4084       monospace,
4085       widths,
4086     };
4087   }
4088 
4089   buildCharCodeToWidth(widthsByGlyphName, properties) {
4090     const widths = Object.create(null);
4091     const differences = properties.differences;
4092     const encoding = properties.defaultEncoding;
4093     for (let charCode = 0; charCode < 256; charCode++) {
4094       if (charCode in differences && widthsByGlyphName[differences[charCode]]) {
4095         widths[charCode] = widthsByGlyphName[differences[charCode]];
4096         continue;
4097       }
4098       if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
4099         widths[charCode] = widthsByGlyphName[encoding[charCode]];
4100         continue;
4101       }
4102     }
4103     return widths;
4104   }
4105 
4106   preEvaluateFont(dict) {
4107     const baseDict = dict;
4108     let type = dict.get("Subtype");
4109     if (!(type instanceof Name)) {
4110       throw new FormatError("invalid font Subtype");
4111     }
4112 
4113     let composite = false;
4114     let hash;
4115     if (type.name === "Type0") {
4116       // If font is a composite
4117       //  - get the descendant font
4118       //  - set the type according to the descendant font
4119       //  - get the FontDescriptor from the descendant font
4120       const df = dict.get("DescendantFonts");
4121       if (!df) {
4122         throw new FormatError("Descendant fonts are not specified");
4123       }
4124       dict = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df;
4125 
4126       if (!(dict instanceof Dict)) {
4127         throw new FormatError("Descendant font is not a dictionary.");
4128       }
4129       type = dict.get("Subtype");
4130       if (!(type instanceof Name)) {
4131         throw new FormatError("invalid font Subtype");
4132       }
4133       composite = true;
4134     }
4135 
4136     let firstChar = dict.get("FirstChar");
4137     if (!Number.isInteger(firstChar)) {
4138       firstChar = 0;
4139     }
4140     let lastChar = dict.get("LastChar");
4141     if (!Number.isInteger(lastChar)) {
4142       lastChar = composite ? 0xffff : 0xff;
4143     }
4144     const descriptor = dict.get("FontDescriptor");
4145     const toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");
4146 
4147     if (descriptor) {
4148       hash = new MurmurHash3_64();
4149 
4150       const encoding = baseDict.getRaw("Encoding");
4151       if (encoding instanceof Name) {
4152         hash.update(encoding.name);
4153       } else if (encoding instanceof Ref) {
4154         hash.update(encoding.toString());
4155       } else if (encoding instanceof Dict) {
4156         for (const entry of encoding.getRawValues()) {
4157           if (entry instanceof Name) {
4158             hash.update(entry.name);
4159           } else if (entry instanceof Ref) {
4160             hash.update(entry.toString());
4161           } else if (Array.isArray(entry)) {
4162             // 'Differences' array (fixes bug1157493.pdf).
4163             const diffLength = entry.length,
4164               diffBuf = new Array(diffLength);
4165 
4166             for (let j = 0; j < diffLength; j++) {
4167               const diffEntry = entry[j];
4168               if (diffEntry instanceof Name) {
4169                 diffBuf[j] = diffEntry.name;
4170               } else if (
4171                 typeof diffEntry === "number" ||
4172                 diffEntry instanceof Ref
4173               ) {
4174                 diffBuf[j] = diffEntry.toString();
4175               }
4176             }
4177             hash.update(diffBuf.join());
4178           }
4179         }
4180       }
4181 
4182       hash.update(`${firstChar}-${lastChar}`); // Fixes issue10665_reduced.pdf
4183 
4184       if (toUnicode instanceof BaseStream) {
4185         const stream = toUnicode.str || toUnicode;
4186         const uint8array = stream.buffer
4187           ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength)
4188           : new Uint8Array(
4189               stream.bytes.buffer,
4190               stream.start,
4191               stream.end - stream.start
4192             );
4193         hash.update(uint8array);
4194       } else if (toUnicode instanceof Name) {
4195         hash.update(toUnicode.name);
4196       }
4197 
4198       const widths = dict.get("Widths") || baseDict.get("Widths");
4199       if (Array.isArray(widths)) {
4200         const widthsBuf = [];
4201         for (const entry of widths) {
4202           if (typeof entry === "number" || entry instanceof Ref) {
4203             widthsBuf.push(entry.toString());
4204           }
4205         }
4206         hash.update(widthsBuf.join());
4207       }
4208 
4209       if (composite) {
4210         hash.update("compositeFont");
4211 
4212         const compositeWidths = dict.get("W") || baseDict.get("W");
4213         if (Array.isArray(compositeWidths)) {
4214           const widthsBuf = [];
4215           for (const entry of compositeWidths) {
4216             if (typeof entry === "number" || entry instanceof Ref) {
4217               widthsBuf.push(entry.toString());
4218             } else if (Array.isArray(entry)) {
4219               const subWidthsBuf = [];
4220               for (const element of entry) {
4221                 if (typeof element === "number" || element instanceof Ref) {
4222                   subWidthsBuf.push(element.toString());
4223                 }
4224               }
4225               widthsBuf.push(`[${subWidthsBuf.join()}]`);
4226             }
4227           }
4228           hash.update(widthsBuf.join());
4229         }
4230 
4231         const cidToGidMap =
4232           dict.getRaw("CIDToGIDMap") || baseDict.getRaw("CIDToGIDMap");
4233         if (cidToGidMap instanceof Name) {
4234           hash.update(cidToGidMap.name);
4235         } else if (cidToGidMap instanceof Ref) {
4236           hash.update(cidToGidMap.toString());
4237         } else if (cidToGidMap instanceof BaseStream) {
4238           hash.update(cidToGidMap.peekBytes());
4239         }
4240       }
4241     }
4242 
4243     return {
4244       descriptor,
4245       dict,
4246       baseDict,
4247       composite,
4248       type: type.name,
4249       firstChar,
4250       lastChar,
4251       toUnicode,
4252       hash: hash ? hash.hexdigest() : "",
4253     };
4254   }
4255 
4256   async translateFont({
4257     descriptor,
4258     dict,
4259     baseDict,
4260     composite,
4261     type,
4262     firstChar,
4263     lastChar,
4264     toUnicode,
4265     cssFontInfo,
4266   }) {
4267     const isType3Font = type === "Type3";
4268 
4269     if (!descriptor) {
4270       if (isType3Font) {
4271         const bbox = lookupNormalRect(dict.getArray("FontBBox"), [0, 0, 0, 0]);
4272         // FontDescriptor is only required for Type3 fonts when the document
4273         // is a tagged pdf. Create a barbebones one to get by.
4274         descriptor = new Dict(null);
4275         descriptor.set("FontName", Name.get(type));
4276         descriptor.set("FontBBox", bbox);
4277       } else {
4278         // Before PDF 1.5 if the font was one of the base 14 fonts, having a
4279         // FontDescriptor was not required.
4280         // This case is here for compatibility.
4281         let baseFontName = dict.get("BaseFont");
4282         if (!(baseFontName instanceof Name)) {
4283           throw new FormatError("Base font is not specified");
4284         }
4285 
4286         // Using base font name as a font name.
4287         baseFontName = baseFontName.name.replaceAll(/[,_]/g, "-");
4288         const metrics = this.getBaseFontMetrics(baseFontName);
4289 
4290         // Simulating descriptor flags attribute
4291         const fontNameWoStyle = baseFontName.split("-", 1)[0];
4292         const flags =
4293           (this.isSerifFont(fontNameWoStyle) ? FontFlags.Serif : 0) |
4294           (metrics.monospace ? FontFlags.FixedPitch : 0) |
4295           (getSymbolsFonts()[fontNameWoStyle]
4296             ? FontFlags.Symbolic
4297             : FontFlags.Nonsymbolic);
4298 
4299         const properties = {
4300           type,
4301           name: baseFontName,
4302           loadedName: baseDict.loadedName,
4303           systemFontInfo: null,
4304           widths: metrics.widths,
4305           defaultWidth: metrics.defaultWidth,
4306           isSimulatedFlags: true,
4307           flags,
4308           firstChar,
4309           lastChar,
4310           toUnicode,
4311           xHeight: 0,
4312           capHeight: 0,
4313           italicAngle: 0,
4314           isType3Font,
4315         };
4316         const widths = dict.get("Widths");
4317 
4318         const standardFontName = getStandardFontName(baseFontName);
4319         let file = null;
4320         if (standardFontName) {
4321           file = await this.fetchStandardFontData(standardFontName);
4322           properties.isInternalFont = !!file;
4323         }
4324         if (!properties.isInternalFont && this.options.useSystemFonts) {
4325           properties.systemFontInfo = getFontSubstitution(
4326             this.systemFontCache,
4327             this.idFactory,
4328             this.options.standardFontDataUrl,
4329             baseFontName,
4330             standardFontName,
4331             type
4332           );
4333         }
4334 
4335         const newProperties = await this.extractDataStructures(
4336           dict,
4337           properties
4338         );
4339         if (Array.isArray(widths)) {
4340           const glyphWidths = [];
4341           let j = firstChar;
4342           for (const w of widths) {
4343             const width = this.xref.fetchIfRef(w);
4344             if (typeof width === "number") {
4345               glyphWidths[j] = width;
4346             }
4347             j++;
4348           }
4349           newProperties.widths = glyphWidths;
4350         } else {
4351           newProperties.widths = this.buildCharCodeToWidth(
4352             metrics.widths,
4353             newProperties
4354           );
4355         }
4356         return new Font(baseFontName, file, newProperties);
4357       }
4358     }
4359 
4360     // According to the spec if 'FontDescriptor' is declared, 'FirstChar',
4361     // 'LastChar' and 'Widths' should exist too, but some PDF encoders seem
4362     // to ignore this rule when a variant of a standard font is used.
4363     // TODO Fill the width array depending on which of the base font this is
4364     // a variant.
4365 
4366     let fontName = descriptor.get("FontName");
4367     let baseFont = dict.get("BaseFont");
4368     // Some bad PDFs have a string as the font name.
4369     if (typeof fontName === "string") {
4370       fontName = Name.get(fontName);
4371     }
4372     if (typeof baseFont === "string") {
4373       baseFont = Name.get(baseFont);
4374     }
4375 
4376     const fontNameStr = fontName?.name;
4377     const baseFontStr = baseFont?.name;
4378     if (!isType3Font && fontNameStr !== baseFontStr) {
4379       info(
4380         `The FontDescriptor's FontName is "${fontNameStr}" but ` +
4381           `should be the same as the Font's BaseFont "${baseFontStr}".`
4382       );
4383       // - Workaround for cases where e.g. fontNameStr = 'Arial' and
4384       //   baseFontStr = 'Arial,Bold' (needed when no font file is embedded).
4385       //
4386       // - Workaround for cases where e.g. fontNameStr = 'wg09np' and
4387       //   baseFontStr = 'Wingdings-Regular' (fixes issue7454.pdf).
4388       if (
4389         fontNameStr &&
4390         baseFontStr &&
4391         (baseFontStr.startsWith(fontNameStr) ||
4392           (!isKnownFontName(fontNameStr) && isKnownFontName(baseFontStr)))
4393       ) {
4394         fontName = null;
4395       }
4396     }
4397     fontName ||= baseFont;
4398 
4399     if (!(fontName instanceof Name)) {
4400       throw new FormatError("invalid font name");
4401     }
4402 
4403     let fontFile, subtype, length1, length2, length3;
4404     try {
4405       fontFile = descriptor.get("FontFile", "FontFile2", "FontFile3");
4406     } catch (ex) {
4407       if (!this.options.ignoreErrors) {
4408         throw ex;
4409       }
4410       warn(`translateFont - fetching "${fontName.name}" font file: "${ex}".`);
4411       fontFile = new NullStream();
4412     }
4413     let isInternalFont = false;
4414     let glyphScaleFactors = null;
4415     let systemFontInfo = null;
4416     if (fontFile) {
4417       if (fontFile.dict) {
4418         const subtypeEntry = fontFile.dict.get("Subtype");
4419         if (subtypeEntry instanceof Name) {
4420           subtype = subtypeEntry.name;
4421         }
4422         length1 = fontFile.dict.get("Length1");
4423         length2 = fontFile.dict.get("Length2");
4424         length3 = fontFile.dict.get("Length3");
4425       }
4426     } else if (cssFontInfo) {
4427       // We've a missing XFA font.
4428       const standardFontName = getXfaFontName(fontName.name);
4429       if (standardFontName) {
4430         cssFontInfo.fontFamily = `${cssFontInfo.fontFamily}-PdfJS-XFA`;
4431         cssFontInfo.metrics = standardFontName.metrics || null;
4432         glyphScaleFactors = standardFontName.factors || null;
4433         fontFile = await this.fetchStandardFontData(standardFontName.name);
4434         isInternalFont = !!fontFile;
4435 
4436         // We're using a substitution font but for example widths (if any)
4437         // are related to the glyph positions in the font.
4438         // So we overwrite everything here to be sure that widths are
4439         // correct.
4440         baseDict = dict = getXfaFontDict(fontName.name);
4441         composite = true;
4442       }
4443     } else if (!isType3Font) {
4444       const standardFontName = getStandardFontName(fontName.name);
4445       if (standardFontName) {
4446         fontFile = await this.fetchStandardFontData(standardFontName);
4447         isInternalFont = !!fontFile;
4448       }
4449       if (!isInternalFont && this.options.useSystemFonts) {
4450         systemFontInfo = getFontSubstitution(
4451           this.systemFontCache,
4452           this.idFactory,
4453           this.options.standardFontDataUrl,
4454           fontName.name,
4455           standardFontName,
4456           type
4457         );
4458       }
4459     }
4460 
4461     const fontMatrix = lookupMatrix(
4462       dict.getArray("FontMatrix"),
4463       FONT_IDENTITY_MATRIX
4464     );
4465     const bbox = lookupNormalRect(
4466       descriptor.getArray("FontBBox") || dict.getArray("FontBBox"),
4467       undefined
4468     );
4469     let ascent = descriptor.get("Ascent");
4470     if (typeof ascent !== "number") {
4471       ascent = undefined;
4472     }
4473     let descent = descriptor.get("Descent");
4474     if (typeof descent !== "number") {
4475       descent = undefined;
4476     }
4477     let xHeight = descriptor.get("XHeight");
4478     if (typeof xHeight !== "number") {
4479       xHeight = 0;
4480     }
4481     let capHeight = descriptor.get("CapHeight");
4482     if (typeof capHeight !== "number") {
4483       capHeight = 0;
4484     }
4485     let flags = descriptor.get("Flags");
4486     if (!Number.isInteger(flags)) {
4487       flags = 0;
4488     }
4489     let italicAngle = descriptor.get("ItalicAngle");
4490     if (typeof italicAngle !== "number") {
4491       italicAngle = 0;
4492     }
4493 
4494     const properties = {
4495       type,
4496       name: fontName.name,
4497       subtype,
4498       file: fontFile,
4499       length1,
4500       length2,
4501       length3,
4502       isInternalFont,
4503       loadedName: baseDict.loadedName,
4504       composite,
4505       fixedPitch: false,
4506       fontMatrix,
4507       firstChar,
4508       lastChar,
4509       toUnicode,
4510       bbox,
4511       ascent,
4512       descent,
4513       xHeight,
4514       capHeight,
4515       flags,
4516       italicAngle,
4517       isType3Font,
4518       cssFontInfo,
4519       scaleFactors: glyphScaleFactors,
4520       systemFontInfo,
4521     };
4522 
4523     if (composite) {
4524       const cidEncoding = baseDict.get("Encoding");
4525       if (cidEncoding instanceof Name) {
4526         properties.cidEncoding = cidEncoding.name;
4527       }
4528       const cMap = await CMapFactory.create({
4529         encoding: cidEncoding,
4530         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
4531         useCMap: null,
4532       });
4533       properties.cMap = cMap;
4534       properties.vertical = properties.cMap.vertical;
4535     }
4536 
4537     const newProperties = await this.extractDataStructures(dict, properties);
4538     this.extractWidths(dict, descriptor, newProperties);
4539 
4540     return new Font(fontName.name, fontFile, newProperties);
4541   }
4542 
4543   static buildFontPaths(font, glyphs, handler, evaluatorOptions) {
4544     function buildPath(fontChar) {
4545       const glyphName = `${font.loadedName}_path_${fontChar}`;
4546       try {
4547         if (font.renderer.hasBuiltPath(fontChar)) {
4548           return;
4549         }
4550         handler.send("commonobj", [
4551           glyphName,
4552           "FontPath",
4553           font.renderer.getPathJs(fontChar),
4554         ]);
4555       } catch (reason) {
4556         if (evaluatorOptions.ignoreErrors) {
4557           warn(`buildFontPaths - ignoring ${glyphName} glyph: "${reason}".`);
4558           return;
4559         }
4560         throw reason;
4561       }
4562     }
4563 
4564     for (const glyph of glyphs) {
4565       buildPath(glyph.fontChar);
4566 
4567       // If the glyph has an accent we need to build a path for its
4568       // fontChar too, otherwise CanvasGraphics_paintChar will fail.
4569       const accent = glyph.accent;
4570       if (accent?.fontChar) {
4571         buildPath(accent.fontChar);
4572       }
4573     }
4574   }
4575 
4576   static get fallbackFontDict() {
4577     const dict = new Dict();
4578     dict.set("BaseFont", Name.get("Helvetica"));
4579     dict.set("Type", Name.get("FallbackType"));
4580     dict.set("Subtype", Name.get("FallbackType"));
4581     dict.set("Encoding", Name.get("WinAnsiEncoding"));
4582 
4583     return shadow(this, "fallbackFontDict", dict);
4584   }
4585 }
4586 
4587 class TranslatedFont {
4588   constructor({ loadedName, font, dict, evaluatorOptions }) {
4589     this.loadedName = loadedName;
4590     this.font = font;
4591     this.dict = dict;
4592     this._evaluatorOptions = evaluatorOptions || DefaultPartialEvaluatorOptions;
4593     this.type3Loaded = null;
4594     this.type3Dependencies = font.isType3Font ? new Set() : null;
4595     this.sent = false;
4596   }
4597 
4598   send(handler) {
4599     if (this.sent) {
4600       return;
4601     }
4602     this.sent = true;
4603 
4604     handler.send("commonobj", [
4605       this.loadedName,
4606       "Font",
4607       this.font.exportData(this._evaluatorOptions.fontExtraProperties),
4608     ]);
4609   }
4610 
4611   fallback(handler) {
4612     if (!this.font.data) {
4613       return;
4614     }
4615     // When font loading failed, fall back to the built-in font renderer.
4616     this.font.disableFontFace = true;
4617     // An arbitrary number of text rendering operators could have been
4618     // encountered between the point in time when the 'Font' message was sent
4619     // to the main-thread, and the point in time when the 'FontFallback'
4620     // message was received on the worker-thread.
4621     // To ensure that all 'FontPath's are available on the main-thread, when
4622     // font loading failed, attempt to resend *all* previously parsed glyphs.
4623     PartialEvaluator.buildFontPaths(
4624       this.font,
4625       /* glyphs = */ this.font.glyphCacheValues,
4626       handler,
4627       this._evaluatorOptions
4628     );
4629   }
4630 
4631   loadType3Data(evaluator, resources, task) {
4632     if (this.type3Loaded) {
4633       return this.type3Loaded;
4634     }
4635     if (!this.font.isType3Font) {
4636       throw new Error("Must be a Type3 font.");
4637     }
4638     // When parsing Type3 glyphs, always ignore them if there are errors.
4639     // Compared to the parsing of e.g. an entire page, it doesn't really
4640     // make sense to only be able to render a Type3 glyph partially.
4641     const type3Evaluator = evaluator.clone({ ignoreErrors: false });
4642     // Prevent circular references in Type3 fonts.
4643     const type3FontRefs = new RefSet(evaluator.type3FontRefs);
4644     if (this.dict.objId && !type3FontRefs.has(this.dict.objId)) {
4645       type3FontRefs.put(this.dict.objId);
4646     }
4647     type3Evaluator.type3FontRefs = type3FontRefs;
4648 
4649     const translatedFont = this.font,
4650       type3Dependencies = this.type3Dependencies;
4651     let loadCharProcsPromise = Promise.resolve();
4652     const charProcs = this.dict.get("CharProcs");
4653     const fontResources = this.dict.get("Resources") || resources;
4654     const charProcOperatorList = Object.create(null);
4655 
4656     const fontBBox = Util.normalizeRect(translatedFont.bbox || [0, 0, 0, 0]),
4657       width = fontBBox[2] - fontBBox[0],
4658       height = fontBBox[3] - fontBBox[1];
4659     const fontBBoxSize = Math.hypot(width, height);
4660 
4661     for (const key of charProcs.getKeys()) {
4662       loadCharProcsPromise = loadCharProcsPromise.then(() => {
4663         const glyphStream = charProcs.get(key);
4664         const operatorList = new OperatorList();
4665         return type3Evaluator
4666           .getOperatorList({
4667             stream: glyphStream,
4668             task,
4669             resources: fontResources,
4670             operatorList,
4671           })
4672           .then(() => {
4673             // According to the PDF specification, section "9.6.5 Type 3 Fonts"
4674             // and "Table 113":
4675             //  "A glyph description that begins with the d1 operator should
4676             //   not execute any operators that set the colour (or other
4677             //   colour-related parameters) in the graphics state;
4678             //   any use of such operators shall be ignored."
4679             if (operatorList.fnArray[0] === OPS.setCharWidthAndBounds) {
4680               this._removeType3ColorOperators(operatorList, fontBBoxSize);
4681             }
4682             charProcOperatorList[key] = operatorList.getIR();
4683 
4684             for (const dependency of operatorList.dependencies) {
4685               type3Dependencies.add(dependency);
4686             }
4687           })
4688           .catch(function (reason) {
4689             warn(`Type3 font resource "${key}" is not available.`);
4690             const dummyOperatorList = new OperatorList();
4691             charProcOperatorList[key] = dummyOperatorList.getIR();
4692           });
4693       });
4694     }
4695     this.type3Loaded = loadCharProcsPromise.then(() => {
4696       translatedFont.charProcOperatorList = charProcOperatorList;
4697       if (this._bbox) {
4698         translatedFont.isCharBBox = true;
4699         translatedFont.bbox = this._bbox;
4700       }
4701     });
4702     return this.type3Loaded;
4703   }
4704 
4705   /**
4706    * @private
4707    */
4708   _removeType3ColorOperators(operatorList, fontBBoxSize = NaN) {
4709     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
4710       assert(
4711         operatorList.fnArray[0] === OPS.setCharWidthAndBounds,
4712         "Type3 glyph shall start with the d1 operator."
4713       );
4714     }
4715     const charBBox = Util.normalizeRect(operatorList.argsArray[0].slice(2)),
4716       width = charBBox[2] - charBBox[0],
4717       height = charBBox[3] - charBBox[1];
4718     const charBBoxSize = Math.hypot(width, height);
4719 
4720     if (width === 0 || height === 0) {
4721       // Skip the d1 operator when its bounds are bogus (fixes issue14953.pdf).
4722       operatorList.fnArray.splice(0, 1);
4723       operatorList.argsArray.splice(0, 1);
4724     } else if (
4725       fontBBoxSize === 0 ||
4726       Math.round(charBBoxSize / fontBBoxSize) >= 10
4727     ) {
4728       // Override the fontBBox when it's undefined/empty, or when it's at least
4729       // (approximately) one order of magnitude smaller than the charBBox
4730       // (fixes issue14999_reduced.pdf).
4731       if (!this._bbox) {
4732         this._bbox = [Infinity, Infinity, -Infinity, -Infinity];
4733       }
4734       this._bbox[0] = Math.min(this._bbox[0], charBBox[0]);
4735       this._bbox[1] = Math.min(this._bbox[1], charBBox[1]);
4736       this._bbox[2] = Math.max(this._bbox[2], charBBox[2]);
4737       this._bbox[3] = Math.max(this._bbox[3], charBBox[3]);
4738     }
4739 
4740     let i = 0,
4741       ii = operatorList.length;
4742     while (i < ii) {
4743       switch (operatorList.fnArray[i]) {
4744         case OPS.setCharWidthAndBounds:
4745           break; // Handled above.
4746         case OPS.setStrokeColorSpace:
4747         case OPS.setFillColorSpace:
4748         case OPS.setStrokeColor:
4749         case OPS.setStrokeColorN:
4750         case OPS.setFillColor:
4751         case OPS.setFillColorN:
4752         case OPS.setStrokeGray:
4753         case OPS.setFillGray:
4754         case OPS.setStrokeRGBColor:
4755         case OPS.setFillRGBColor:
4756         case OPS.setStrokeCMYKColor:
4757         case OPS.setFillCMYKColor:
4758         case OPS.shadingFill:
4759         case OPS.setRenderingIntent:
4760           operatorList.fnArray.splice(i, 1);
4761           operatorList.argsArray.splice(i, 1);
4762           ii--;
4763           continue;
4764 
4765         case OPS.setGState:
4766           const [gStateObj] = operatorList.argsArray[i];
4767           let j = 0,
4768             jj = gStateObj.length;
4769           while (j < jj) {
4770             const [gStateKey] = gStateObj[j];
4771             switch (gStateKey) {
4772               case "TR":
4773               case "TR2":
4774               case "HT":
4775               case "BG":
4776               case "BG2":
4777               case "UCR":
4778               case "UCR2":
4779                 gStateObj.splice(j, 1);
4780                 jj--;
4781                 continue;
4782             }
4783             j++;
4784           }
4785           break;
4786       }
4787       i++;
4788     }
4789   }
4790 }
4791 
4792 class StateManager {
4793   constructor(initialState = new EvalState()) {
4794     this.state = initialState;
4795     this.stateStack = [];
4796   }
4797 
4798   save() {
4799     const old = this.state;
4800     this.stateStack.push(this.state);
4801     this.state = old.clone();
4802   }
4803 
4804   restore() {
4805     const prev = this.stateStack.pop();
4806     if (prev) {
4807       this.state = prev;
4808     }
4809   }
4810 
4811   transform(args) {
4812     this.state.ctm = Util.transform(this.state.ctm, args);
4813   }
4814 }
4815 
4816 class TextState {
4817   constructor() {
4818     this.ctm = new Float32Array(IDENTITY_MATRIX);
4819     this.fontName = null;
4820     this.fontSize = 0;
4821     this.loadedName = null;
4822     this.font = null;
4823     this.fontMatrix = FONT_IDENTITY_MATRIX;
4824     this.textMatrix = IDENTITY_MATRIX.slice();
4825     this.textLineMatrix = IDENTITY_MATRIX.slice();
4826     this.charSpacing = 0;
4827     this.wordSpacing = 0;
4828     this.leading = 0;
4829     this.textHScale = 1;
4830     this.textRise = 0;
4831   }
4832 
4833   setTextMatrix(a, b, c, d, e, f) {
4834     const m = this.textMatrix;
4835     m[0] = a;
4836     m[1] = b;
4837     m[2] = c;
4838     m[3] = d;
4839     m[4] = e;
4840     m[5] = f;
4841   }
4842 
4843   setTextLineMatrix(a, b, c, d, e, f) {
4844     const m = this.textLineMatrix;
4845     m[0] = a;
4846     m[1] = b;
4847     m[2] = c;
4848     m[3] = d;
4849     m[4] = e;
4850     m[5] = f;
4851   }
4852 
4853   translateTextMatrix(x, y) {
4854     const m = this.textMatrix;
4855     m[4] = m[0] * x + m[2] * y + m[4];
4856     m[5] = m[1] * x + m[3] * y + m[5];
4857   }
4858 
4859   translateTextLineMatrix(x, y) {
4860     const m = this.textLineMatrix;
4861     m[4] = m[0] * x + m[2] * y + m[4];
4862     m[5] = m[1] * x + m[3] * y + m[5];
4863   }
4864 
4865   carriageReturn() {
4866     this.translateTextLineMatrix(0, -this.leading);
4867     this.textMatrix = this.textLineMatrix.slice();
4868   }
4869 
4870   clone() {
4871     const clone = Object.create(this);
4872     clone.textMatrix = this.textMatrix.slice();
4873     clone.textLineMatrix = this.textLineMatrix.slice();
4874     clone.fontMatrix = this.fontMatrix.slice();
4875     return clone;
4876   }
4877 }
4878 
4879 class EvalState {
4880   constructor() {
4881     this.ctm = new Float32Array(IDENTITY_MATRIX);
4882     this.font = null;
4883     this.textRenderingMode = TextRenderingMode.FILL;
4884     this._fillColorSpace = ColorSpace.singletons.gray;
4885     this._strokeColorSpace = ColorSpace.singletons.gray;
4886     this.patternFillColorSpace = null;
4887     this.patternStrokeColorSpace = null;
4888   }
4889 
4890   get fillColorSpace() {
4891     return this._fillColorSpace;
4892   }
4893 
4894   set fillColorSpace(colorSpace) {
4895     this._fillColorSpace = this.patternFillColorSpace = colorSpace;
4896   }
4897 
4898   get strokeColorSpace() {
4899     return this._strokeColorSpace;
4900   }
4901 
4902   set strokeColorSpace(colorSpace) {
4903     this._strokeColorSpace = this.patternStrokeColorSpace = colorSpace;
4904   }
4905 
4906   clone() {
4907     return Object.create(this);
4908   }
4909 }
4910 
4911 class EvaluatorPreprocessor {
4912   static get opMap() {
4913     // Specifies properties for each command
4914     //
4915     // If variableArgs === true: [0, `numArgs`] expected
4916     // If variableArgs === false: exactly `numArgs` expected
4917     return shadow(
4918       this,
4919       "opMap",
4920       Object.assign(Object.create(null), {
4921         // Graphic state
4922         w: { id: OPS.setLineWidth, numArgs: 1, variableArgs: false },
4923         J: { id: OPS.setLineCap, numArgs: 1, variableArgs: false },
4924         j: { id: OPS.setLineJoin, numArgs: 1, variableArgs: false },
4925         M: { id: OPS.setMiterLimit, numArgs: 1, variableArgs: false },
4926         d: { id: OPS.setDash, numArgs: 2, variableArgs: false },
4927         ri: { id: OPS.setRenderingIntent, numArgs: 1, variableArgs: false },
4928         i: { id: OPS.setFlatness, numArgs: 1, variableArgs: false },
4929         gs: { id: OPS.setGState, numArgs: 1, variableArgs: false },
4930         q: { id: OPS.save, numArgs: 0, variableArgs: false },
4931         Q: { id: OPS.restore, numArgs: 0, variableArgs: false },
4932         cm: { id: OPS.transform, numArgs: 6, variableArgs: false },
4933 
4934         // Path
4935         m: { id: OPS.moveTo, numArgs: 2, variableArgs: false },
4936         l: { id: OPS.lineTo, numArgs: 2, variableArgs: false },
4937         c: { id: OPS.curveTo, numArgs: 6, variableArgs: false },
4938         v: { id: OPS.curveTo2, numArgs: 4, variableArgs: false },
4939         y: { id: OPS.curveTo3, numArgs: 4, variableArgs: false },
4940         h: { id: OPS.closePath, numArgs: 0, variableArgs: false },
4941         re: { id: OPS.rectangle, numArgs: 4, variableArgs: false },
4942         S: { id: OPS.stroke, numArgs: 0, variableArgs: false },
4943         s: { id: OPS.closeStroke, numArgs: 0, variableArgs: false },
4944         f: { id: OPS.fill, numArgs: 0, variableArgs: false },
4945         F: { id: OPS.fill, numArgs: 0, variableArgs: false },
4946         "f*": { id: OPS.eoFill, numArgs: 0, variableArgs: false },
4947         B: { id: OPS.fillStroke, numArgs: 0, variableArgs: false },
4948         "B*": { id: OPS.eoFillStroke, numArgs: 0, variableArgs: false },
4949         b: { id: OPS.closeFillStroke, numArgs: 0, variableArgs: false },
4950         "b*": { id: OPS.closeEOFillStroke, numArgs: 0, variableArgs: false },
4951         n: { id: OPS.endPath, numArgs: 0, variableArgs: false },
4952 
4953         // Clipping
4954         W: { id: OPS.clip, numArgs: 0, variableArgs: false },
4955         "W*": { id: OPS.eoClip, numArgs: 0, variableArgs: false },
4956 
4957         // Text
4958         BT: { id: OPS.beginText, numArgs: 0, variableArgs: false },
4959         ET: { id: OPS.endText, numArgs: 0, variableArgs: false },
4960         Tc: { id: OPS.setCharSpacing, numArgs: 1, variableArgs: false },
4961         Tw: { id: OPS.setWordSpacing, numArgs: 1, variableArgs: false },
4962         Tz: { id: OPS.setHScale, numArgs: 1, variableArgs: false },
4963         TL: { id: OPS.setLeading, numArgs: 1, variableArgs: false },
4964         Tf: { id: OPS.setFont, numArgs: 2, variableArgs: false },
4965         Tr: { id: OPS.setTextRenderingMode, numArgs: 1, variableArgs: false },
4966         Ts: { id: OPS.setTextRise, numArgs: 1, variableArgs: false },
4967         Td: { id: OPS.moveText, numArgs: 2, variableArgs: false },
4968         TD: { id: OPS.setLeadingMoveText, numArgs: 2, variableArgs: false },
4969         Tm: { id: OPS.setTextMatrix, numArgs: 6, variableArgs: false },
4970         "T*": { id: OPS.nextLine, numArgs: 0, variableArgs: false },
4971         Tj: { id: OPS.showText, numArgs: 1, variableArgs: false },
4972         TJ: { id: OPS.showSpacedText, numArgs: 1, variableArgs: false },
4973         "'": { id: OPS.nextLineShowText, numArgs: 1, variableArgs: false },
4974         '"': {
4975           id: OPS.nextLineSetSpacingShowText,
4976           numArgs: 3,
4977           variableArgs: false,
4978         },
4979 
4980         // Type3 fonts
4981         d0: { id: OPS.setCharWidth, numArgs: 2, variableArgs: false },
4982         d1: {
4983           id: OPS.setCharWidthAndBounds,
4984           numArgs: 6,
4985           variableArgs: false,
4986         },
4987 
4988         // Color
4989         CS: { id: OPS.setStrokeColorSpace, numArgs: 1, variableArgs: false },
4990         cs: { id: OPS.setFillColorSpace, numArgs: 1, variableArgs: false },
4991         SC: { id: OPS.setStrokeColor, numArgs: 4, variableArgs: true },
4992         SCN: { id: OPS.setStrokeColorN, numArgs: 33, variableArgs: true },
4993         sc: { id: OPS.setFillColor, numArgs: 4, variableArgs: true },
4994         scn: { id: OPS.setFillColorN, numArgs: 33, variableArgs: true },
4995         G: { id: OPS.setStrokeGray, numArgs: 1, variableArgs: false },
4996         g: { id: OPS.setFillGray, numArgs: 1, variableArgs: false },
4997         RG: { id: OPS.setStrokeRGBColor, numArgs: 3, variableArgs: false },
4998         rg: { id: OPS.setFillRGBColor, numArgs: 3, variableArgs: false },
4999         K: { id: OPS.setStrokeCMYKColor, numArgs: 4, variableArgs: false },
5000         k: { id: OPS.setFillCMYKColor, numArgs: 4, variableArgs: false },
5001 
5002         // Shading
5003         sh: { id: OPS.shadingFill, numArgs: 1, variableArgs: false },
5004 
5005         // Images
5006         BI: { id: OPS.beginInlineImage, numArgs: 0, variableArgs: false },
5007         ID: { id: OPS.beginImageData, numArgs: 0, variableArgs: false },
5008         EI: { id: OPS.endInlineImage, numArgs: 1, variableArgs: false },
5009 
5010         // XObjects
5011         Do: { id: OPS.paintXObject, numArgs: 1, variableArgs: false },
5012         MP: { id: OPS.markPoint, numArgs: 1, variableArgs: false },
5013         DP: { id: OPS.markPointProps, numArgs: 2, variableArgs: false },
5014         BMC: { id: OPS.beginMarkedContent, numArgs: 1, variableArgs: false },
5015         BDC: {
5016           id: OPS.beginMarkedContentProps,
5017           numArgs: 2,
5018           variableArgs: false,
5019         },
5020         EMC: { id: OPS.endMarkedContent, numArgs: 0, variableArgs: false },
5021 
5022         // Compatibility
5023         BX: { id: OPS.beginCompat, numArgs: 0, variableArgs: false },
5024         EX: { id: OPS.endCompat, numArgs: 0, variableArgs: false },
5025 
5026         // (reserved partial commands for the lexer)
5027         BM: null,
5028         BD: null,
5029         true: null,
5030         fa: null,
5031         fal: null,
5032         fals: null,
5033         false: null,
5034         nu: null,
5035         nul: null,
5036         null: null,
5037       })
5038     );
5039   }
5040 
5041   static MAX_INVALID_PATH_OPS = 10;
5042 
5043   constructor(stream, xref, stateManager = new StateManager()) {
5044     // TODO(mduan): pass array of knownCommands rather than this.opMap
5045     // dictionary
5046     this.parser = new Parser({
5047       lexer: new Lexer(stream, EvaluatorPreprocessor.opMap),
5048       xref,
5049     });
5050     this.stateManager = stateManager;
5051     this.nonProcessedArgs = [];
5052     this._isPathOp = false;
5053     this._numInvalidPathOPS = 0;
5054   }
5055 
5056   get savedStatesDepth() {
5057     return this.stateManager.stateStack.length;
5058   }
5059 
5060   // |operation| is an object with two fields:
5061   //
5062   // - |fn| is an out param.
5063   //
5064   // - |args| is an inout param. On entry, it should have one of two values.
5065   //
5066   //   - An empty array. This indicates that the caller is providing the
5067   //     array in which the args will be stored in. The caller should use
5068   //     this value if it can reuse a single array for each call to read().
5069   //
5070   //   - |null|. This indicates that the caller needs this function to create
5071   //     the array in which any args are stored in. If there are zero args,
5072   //     this function will leave |operation.args| as |null| (thus avoiding
5073   //     allocations that would occur if we used an empty array to represent
5074   //     zero arguments). Otherwise, it will replace |null| with a new array
5075   //     containing the arguments. The caller should use this value if it
5076   //     cannot reuse an array for each call to read().
5077   //
5078   // These two modes are present because this function is very hot and so
5079   // avoiding allocations where possible is worthwhile.
5080   //
5081   read(operation) {
5082     let args = operation.args;
5083     while (true) {
5084       const obj = this.parser.getObj();
5085       if (obj instanceof Cmd) {
5086         const cmd = obj.cmd;
5087         // Check that the command is valid
5088         const opSpec = EvaluatorPreprocessor.opMap[cmd];
5089         if (!opSpec) {
5090           warn(`Unknown command "${cmd}".`);
5091           continue;
5092         }
5093 
5094         const fn = opSpec.id;
5095         const numArgs = opSpec.numArgs;
5096         let argsLength = args !== null ? args.length : 0;
5097 
5098         // If the *previous* command wasn't a path operator, reset the heuristic
5099         // used with incomplete path operators below (fixes issue14917.pdf).
5100         if (!this._isPathOp) {
5101           this._numInvalidPathOPS = 0;
5102         }
5103         this._isPathOp = fn >= OPS.moveTo && fn <= OPS.endPath;
5104 
5105         if (!opSpec.variableArgs) {
5106           // Postscript commands can be nested, e.g. /F2 /GS2 gs 5.711 Tf
5107           if (argsLength !== numArgs) {
5108             const nonProcessedArgs = this.nonProcessedArgs;
5109             while (argsLength > numArgs) {
5110               nonProcessedArgs.push(args.shift());
5111               argsLength--;
5112             }
5113             while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
5114               if (args === null) {
5115                 args = [];
5116               }
5117               args.unshift(nonProcessedArgs.pop());
5118               argsLength++;
5119             }
5120           }
5121 
5122           if (argsLength < numArgs) {
5123             const partialMsg =
5124               `command ${cmd}: expected ${numArgs} args, ` +
5125               `but received ${argsLength} args.`;
5126 
5127             // Incomplete path operators, in particular, can result in fairly
5128             // chaotic rendering artifacts. Hence the following heuristics is
5129             // used to error, rather than just warn, once a number of invalid
5130             // path operators have been encountered (fixes bug1443140.pdf).
5131             if (
5132               this._isPathOp &&
5133               ++this._numInvalidPathOPS >
5134                 EvaluatorPreprocessor.MAX_INVALID_PATH_OPS
5135             ) {
5136               throw new FormatError(`Invalid ${partialMsg}`);
5137             }
5138             // If we receive too few arguments, it's not possible to execute
5139             // the command, hence we skip the command.
5140             warn(`Skipping ${partialMsg}`);
5141             if (args !== null) {
5142               args.length = 0;
5143             }
5144             continue;
5145           }
5146         } else if (argsLength > numArgs) {
5147           info(
5148             `Command ${cmd}: expected [0, ${numArgs}] args, ` +
5149               `but received ${argsLength} args.`
5150           );
5151         }
5152 
5153         // TODO figure out how to type-check vararg functions
5154         this.preprocessCommand(fn, args);
5155 
5156         operation.fn = fn;
5157         operation.args = args;
5158         return true;
5159       }
5160       if (obj === EOF) {
5161         return false; // no more commands
5162       }
5163       // argument
5164       if (obj !== null) {
5165         if (args === null) {
5166           args = [];
5167         }
5168         args.push(obj);
5169         if (args.length > 33) {
5170           throw new FormatError("Too many arguments");
5171         }
5172       }
5173     }
5174   }
5175 
5176   preprocessCommand(fn, args) {
5177     switch (fn | 0) {
5178       case OPS.save:
5179         this.stateManager.save();
5180         break;
5181       case OPS.restore:
5182         this.stateManager.restore();
5183         break;
5184       case OPS.transform:
5185         this.stateManager.transform(args);
5186         break;
5187     }
5188   }
5189 }
5190 
5191 export { EvaluatorPreprocessor, PartialEvaluator };
</code>

Test file:
<test_file>
File:
test/unit/evaluator_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { createIdFactory, XRefMock } from "./test_utils.js";
import { Dict, Name } from "../../src/core/primitives.js";
import { FormatError, OPS } from "../../src/shared/util.js";
import { Stream, StringStream } from "../../src/core/stream.js";
import { OperatorList } from "../../src/core/operator_list.js";
import { PartialEvaluator } from "../../src/core/evaluator.js";
import { WorkerTask } from "../../src/core/worker.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

