it("should correctly apply transform to all points in a path", async () => {
  const { OperatorList } = await import("../../src/core/operator_list.js");
  const { Util } = await import("../../src/shared/util.js");

  // Create a sample path with multiple commands
  const operatorList = new OperatorList();
  const buffer = [
    DrawOPS.moveTo, 0, 0,
    DrawOPS.lineTo, 100, 100,
    DrawOPS.curveTo, 150, 150, 200, 200, 250, 250,
    DrawOPS.lineTo, 300, 300,
    DrawOPS.curveTo, 350, 350, 400, 400, 450, 450
  ];

  // Apply a sample transformation matrix
  const transform = [1, 0, 0, 1, 10, 20];

  // Apply transform to all points using the new methods
  let k = 0;
  while (k < buffer.length) {
    switch (buffer[k]) {
      case DrawOPS.moveTo:
      case DrawOPS.lineTo:
        Util.applyTransform(buffer, transform, k + 1);
        k += 2;
        break;
      case DrawOPS.curveTo:
        Util.applyTransformToBezier(buffer, transform, k + 1);
        k += 6;
        break;
      default:
        k++;
    }
  }

  // Expected transformed points
  const expectedPoints = [
    10, 20, // move
    110, 120, // line
    160, 170, 210, 220, 260, 270, // curve
    310, 330, // line
    360, 370, 410, 420, 460, 470 // curve
  ];

  // Check all points match expected values
  for (let i = 0; i < expectedPoints.length; i++) {
    if (buffer[i + 1] !== expectedPoints[i]) {
      throw new Error(`Point at index ${i} does not match expected value`);
    }
  }
});