Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Fields not rendered after saving and opening Dutch tax form
Attach (recommended) or Link to PDF file here:

- Direct link: https://download.belastingdienst.nl/belastingdienst/docs/model_opgaaf_gegevens_loonheffingen_lh0082z11fol.pdf
- Web Archive link: https://web.archive.org/web/20240309103139/https://download.belastingdienst.nl/belastingdienst/docs/model_opgaaf_gegevens_loonheffingen_lh0082z11fol.pdf

Configuration:
- Web browser and its version: Firefox 125.0.3
- Operating system and its version: Arch Linux
- PDF.js version: 4.1.342 embedded in Firefox and 4.3.21 from https://mozilla.github.io/pdf.js/web/viewer.html
- Is a browser extension: no

Steps to reproduce the problem:
1. Open the PDF file (Dutch tax form).
2. Click the first radio button on the second page. Notice that extra fields appear behind it.
3. Enter a date: 12-05-2024
4. Save the PDF file to disk.
5. Open the saved PDF file. Notice that the first radio button on the second page is checked, but the extra fields behind it are no longer visible. This makes it _seem_ as if data loss occurred, even though that's not the case.
6. Click the second radio button below it and click the first radio button again. Notice that the extra fields behind the first radio button are now correctly visible, including the entered date.

What is the expected behavior? (add screenshot)
![Expected](https://github.com/mozilla/pdf.js/assets/1993262/721ede30-1f5b-4dc9-bef1-58bba2c58cda)

What went wrong? (add screenshot)
![Actual](https://github.com/mozilla/pdf.js/assets/1993262/a9bbdcec-a4b0-4a20-9fef-bb400c81189e)

Link to a viewer (if hosted on a site other than mozilla.github.io/pdf.js or as Firefox/Chrome extension): https://mozilla.github.io/pdf.js/web/viewer.html
</issue>

Patch:
<patch>
diff --git a/src/core/annotation.js b/src/core/annotation.js
--- a/src/core/annotation.js
+++ b/src/core/annotation.js
@@ -27,6 +27,7 @@ import {
   getModificationDate,
   IDENTITY_MATRIX,
   info,
+  isArrayEqual,
   LINE_DESCENT_FACTOR,
   LINE_FACTOR,
   OPS,
@@ -723,6 +724,38 @@ class Annotation {
     return !!(flags & flag);
   }
 
+  _buildFlags(noView, noPrint) {
+    let { flags } = this;
+    if (noView === undefined) {
+      if (noPrint === undefined) {
+        return undefined;
+      }
+      if (noPrint) {
+        return flags & ~AnnotationFlag.PRINT;
+      }
+      return (flags & ~AnnotationFlag.HIDDEN) | AnnotationFlag.PRINT;
+    }
+
+    if (noView) {
+      flags |= AnnotationFlag.PRINT;
+      if (noPrint) {
+        // display === 1.
+        return (flags & ~AnnotationFlag.NOVIEW) | AnnotationFlag.HIDDEN;
+      }
+      // display === 3.
+      return (flags & ~AnnotationFlag.HIDDEN) | AnnotationFlag.NOVIEW;
+    }
+
+    flags &= ~(AnnotationFlag.HIDDEN | AnnotationFlag.NOVIEW);
+    if (noPrint) {
+      // display === 2.
+      return flags & ~AnnotationFlag.PRINT;
+    }
+
+    // display === 0.
+    return flags | AnnotationFlag.PRINT;
+  }
+
   /**
    * @private
    */
@@ -2073,10 +2106,15 @@ class WidgetAnnotation extends Annotation {
 
   async save(evaluator, task, annotationStorage) {
     const storageEntry = annotationStorage?.get(this.data.id);
+    const flags = this._buildFlags(storageEntry?.noView, storageEntry?.noPrint);
     let value = storageEntry?.value,
       rotation = storageEntry?.rotation;
     if (value === this.data.fieldValue || value === undefined) {
-      if (!this._hasValueFromXFA && rotation === undefined) {
+      if (
+        !this._hasValueFromXFA &&
+        rotation === undefined &&
+        flags === undefined
+      ) {
         return null;
       }
       value ||= this.data.fieldValue;
@@ -2088,8 +2126,8 @@ class WidgetAnnotation extends Annotation {
       !this._hasValueFromXFA &&
       Array.isArray(value) &&
       Array.isArray(this.data.fieldValue) &&
-      value.length === this.data.fieldValue.length &&
-      value.every((x, i) => x === this.data.fieldValue[i])
+      isArrayEqual(value, this.data.fieldValue) &&
+      flags === undefined
     ) {
       return null;
     }
@@ -2106,7 +2144,7 @@ class WidgetAnnotation extends Annotation {
         RenderingIntentFlag.SAVE,
         annotationStorage
       );
-      if (appearance === null) {
+      if (appearance === null && flags === undefined) {
         // Appearance didn't change.
         return null;
       }
@@ -2134,6 +2172,15 @@ class WidgetAnnotation extends Annotation {
         dict.set(key, originalDict.getRaw(key));
       }
     }
+    if (flags !== undefined) {
+      dict.set("F", flags);
+      if (appearance === null && !needAppearances) {
+        const ap = originalDict.getRaw("AP");
+        if (ap) {
+          dict.set("AP", ap);
+        }
+      }
+    }
 
     const xfa = {
       path: this.data.fieldName,
@@ -3019,10 +3066,11 @@ class ButtonWidgetAnnotation extends WidgetAnnotation {
       return null;
     }
     const storageEntry = annotationStorage.get(this.data.id);
+    const flags = this._buildFlags(storageEntry?.noView, storageEntry?.noPrint);
     let rotation = storageEntry?.rotation,
       value = storageEntry?.value;
 
-    if (rotation === undefined) {
+    if (rotation === undefined && flags === undefined) {
       if (value === undefined) {
         return null;
       }
@@ -3033,10 +3081,11 @@ class ButtonWidgetAnnotation extends WidgetAnnotation {
       }
     }
 
-    const dict = evaluator.xref.fetchIfRef(this.ref);
+    let dict = evaluator.xref.fetchIfRef(this.ref);
     if (!(dict instanceof Dict)) {
       return null;
     }
+    dict = dict.clone();
 
     if (rotation === undefined) {
       rotation = this.rotation;
@@ -3054,6 +3103,9 @@ class ButtonWidgetAnnotation extends WidgetAnnotation {
     dict.set("V", name);
     dict.set("AS", name);
     dict.set("M", `D:${getModificationDate()}`);
+    if (flags !== undefined) {
+      dict.set("F", flags);
+    }
 
     const maybeMK = this._getMKDict(rotation);
     if (maybeMK) {
@@ -3071,10 +3123,11 @@ class ButtonWidgetAnnotation extends WidgetAnnotation {
       return null;
     }
     const storageEntry = annotationStorage.get(this.data.id);
+    const flags = this._buildFlags(storageEntry?.noView, storageEntry?.noPrint);
     let rotation = storageEntry?.rotation,
       value = storageEntry?.value;
 
-    if (rotation === undefined) {
+    if (rotation === undefined && flags === undefined) {
       if (value === undefined) {
         return null;
       }
@@ -3085,10 +3138,11 @@ class ButtonWidgetAnnotation extends WidgetAnnotation {
       }
     }
 
-    const dict = evaluator.xref.fetchIfRef(this.ref);
+    let dict = evaluator.xref.fetchIfRef(this.ref);
     if (!(dict instanceof Dict)) {
       return null;
     }
+    dict = dict.clone();
 
     if (value === undefined) {
       value = this.data.fieldValue === this.data.buttonValue;
@@ -3121,6 +3175,9 @@ class ButtonWidgetAnnotation extends WidgetAnnotation {
 
     dict.set("AS", name);
     dict.set("M", `D:${getModificationDate()}`);
+    if (flags !== undefined) {
+      dict.set("F", flags);
+    }
 
     const maybeMK = this._getMKDict(rotation);
     if (maybeMK) {

diff --git a/src/core/document.js b/src/core/document.js
--- a/src/core/document.js
+++ b/src/core/document.js
@@ -378,9 +378,6 @@ class Page {
     return this._parsedAnnotations.then(function (annotations) {
       const newRefsPromises = [];
       for (const annotation of annotations) {
-        if (!annotation.mustBePrinted(annotationStorage)) {
-          continue;
-        }
         newRefsPromises.push(
           annotation
             .save(partialEvaluator, task, annotationStorage)


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.25.2
- @babel/preset-env: ^7.25.4
- @babel/runtime: ^7.25.6
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @jazzer.js/core: ^2.1.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- autoprefixer: ^10.4.20
- babel-loader: ^9.2.1
- caniuse-lite: ^1.0.30001662
- canvas: ^2.11.2
- core-js: ^3.38.1
- eslint: ^8.57.0
- eslint-config-prettier: ^9.1.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^8.1.1
- eslint-plugin-import: ^2.30.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^3.1.0
- eslint-plugin-no-unsanitized: ^4.1.0
- eslint-plugin-prettier: ^5.2.1
- eslint-plugin-sort-exports: ^0.9.1
- eslint-plugin-unicorn: ^55.0.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- highlight.js: ^11.10.0
- jasmine: ^5.3.0
- jsdoc: ^4.0.3
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.4
- ordered-read-streams: ^2.0.0
- path2d: ^0.2.1
- pngjs: ^7.0.0
- postcss: ^8.4.47
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.0
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.0
- prettier: ^3.3.3
- puppeteer: 23.3.1
- stylelint: ^16.9.0
- stylelint-prettier: ^5.0.2
- svglint: ^3.0.0
- terser-webpack-plugin: ^5.3.10
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.6.2
- vinyl: ^3.0.0
- webpack: ^5.94.0
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodePackages
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory, createTemporaryNodeServer
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/annotation.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AnnotationActionEventType,
18   AnnotationBorderStyleType,
19   AnnotationEditorType,
20   AnnotationFieldFlag,
21   AnnotationFlag,
22   AnnotationReplyType,
23   AnnotationType,
24   assert,
25   BASELINE_FACTOR,
26   FeatureTest,
27   getModificationDate,
28   IDENTITY_MATRIX,
29   info,
30   LINE_DESCENT_FACTOR,
31   LINE_FACTOR,
32   OPS,
33   RenderingIntentFlag,
34   shadow,
35   stringToPDFString,
36   unreachable,
37   Util,
38   warn,
39 } from "../shared/util.js";
40 import {
41   collectActions,
42   escapeString,
43   getInheritableProperty,
44   getRotationMatrix,
45   isNumberArray,
46   lookupMatrix,
47   lookupNormalRect,
48   lookupRect,
49   numberToString,
50   stringToAsciiOrUTF16BE,
51   stringToUTF16String,
52 } from "./core_utils.js";
53 import {
54   createDefaultAppearance,
55   FakeUnicodeFont,
56   getPdfColor,
57   parseAppearanceStream,
58   parseDefaultAppearance,
59 } from "./default_appearance.js";
60 import { Dict, isName, isRefsEqual, Name, Ref, RefSet } from "./primitives.js";
61 import { Stream, StringStream } from "./stream.js";
62 import { BaseStream } from "./base_stream.js";
63 import { bidi } from "./bidi.js";
64 import { Catalog } from "./catalog.js";
65 import { ColorSpace } from "./colorspace.js";
66 import { FileSpec } from "./file_spec.js";
67 import { JpegStream } from "./jpeg_stream.js";
68 import { ObjectLoader } from "./object_loader.js";
69 import { OperatorList } from "./operator_list.js";
70 import { writeObject } from "./writer.js";
71 import { XFAFactory } from "./xfa/factory.js";
72 
73 class AnnotationFactory {
74   static createGlobals(pdfManager) {
75     return Promise.all([
76       pdfManager.ensureCatalog("acroForm"),
77       pdfManager.ensureDoc("xfaDatasets"),
78       pdfManager.ensureCatalog("structTreeRoot"),
79       // Only necessary to prevent the `Catalog.baseUrl`-getter, used
80       // with some Annotations, from throwing and thus breaking parsing:
81       pdfManager.ensureCatalog("baseUrl"),
82       // Only necessary to prevent the `Catalog.attachments`-getter, used
83       // with "GoToE" actions, from throwing and thus breaking parsing:
84       pdfManager.ensureCatalog("attachments"),
85     ]).then(
86       // eslint-disable-next-line arrow-body-style
87       ([acroForm, xfaDatasets, structTreeRoot, baseUrl, attachments]) => {
88         return {
89           pdfManager,
90           acroForm: acroForm instanceof Dict ? acroForm : Dict.empty,
91           xfaDatasets,
92           structTreeRoot,
93           baseUrl,
94           attachments,
95         };
96       },
97       reason => {
98         warn(`createGlobals: "${reason}".`);
99         return null;
100       }
101     );
102   }
103 
104   /**
105    * Create an `Annotation` object of the correct type for the given reference
106    * to an annotation dictionary. This yields a promise that is resolved when
107    * the `Annotation` object is constructed.
108    *
109    * @param {XRef} xref
110    * @param {Object} ref
111    * @params {Object} annotationGlobals
112    * @param {Object} idFactory
113    * @param {boolean} [collectFields]
114    * @param {Object} [pageRef]
115    * @returns {Promise} A promise that is resolved with an {Annotation}
116    *   instance.
117    */
118   static async create(
119     xref,
120     ref,
121     annotationGlobals,
122     idFactory,
123     collectFields,
124     pageRef
125   ) {
126     const pageIndex = collectFields
127       ? await this._getPageIndex(xref, ref, annotationGlobals.pdfManager)
128       : null;
129 
130     return annotationGlobals.pdfManager.ensure(this, "_create", [
131       xref,
132       ref,
133       annotationGlobals,
134       idFactory,
135       collectFields,
136       pageIndex,
137       pageRef,
138     ]);
139   }
140 
141   /**
142    * @private
143    */
144   static _create(
145     xref,
146     ref,
147     annotationGlobals,
148     idFactory,
149     collectFields = false,
150     pageIndex = null,
151     pageRef = null
152   ) {
153     const dict = xref.fetchIfRef(ref);
154     if (!(dict instanceof Dict)) {
155       return undefined;
156     }
157 
158     const { acroForm, pdfManager } = annotationGlobals;
159     const id =
160       ref instanceof Ref ? ref.toString() : `annot_${idFactory.createObjId()}`;
161 
162     // Determine the annotation's subtype.
163     let subtype = dict.get("Subtype");
164     subtype = subtype instanceof Name ? subtype.name : null;
165 
166     // Return the right annotation object based on the subtype and field type.
167     const parameters = {
168       xref,
169       ref,
170       dict,
171       subtype,
172       id,
173       annotationGlobals,
174       collectFields,
175       needAppearances:
176         !collectFields && acroForm.get("NeedAppearances") === true,
177       pageIndex,
178       evaluatorOptions: pdfManager.evaluatorOptions,
179       pageRef,
180     };
181 
182     switch (subtype) {
183       case "Link":
184         return new LinkAnnotation(parameters);
185 
186       case "Text":
187         return new TextAnnotation(parameters);
188 
189       case "Widget":
190         let fieldType = getInheritableProperty({ dict, key: "FT" });
191         fieldType = fieldType instanceof Name ? fieldType.name : null;
192 
193         switch (fieldType) {
194           case "Tx":
195             return new TextWidgetAnnotation(parameters);
196           case "Btn":
197             return new ButtonWidgetAnnotation(parameters);
198           case "Ch":
199             return new ChoiceWidgetAnnotation(parameters);
200           case "Sig":
201             return new SignatureWidgetAnnotation(parameters);
202         }
203         warn(
204           `Unimplemented widget field type "${fieldType}", ` +
205             "falling back to base field type."
206         );
207         return new WidgetAnnotation(parameters);
208 
209       case "Popup":
210         return new PopupAnnotation(parameters);
211 
212       case "FreeText":
213         return new FreeTextAnnotation(parameters);
214 
215       case "Line":
216         return new LineAnnotation(parameters);
217 
218       case "Square":
219         return new SquareAnnotation(parameters);
220 
221       case "Circle":
222         return new CircleAnnotation(parameters);
223 
224       case "PolyLine":
225         return new PolylineAnnotation(parameters);
226 
227       case "Polygon":
228         return new PolygonAnnotation(parameters);
229 
230       case "Caret":
231         return new CaretAnnotation(parameters);
232 
233       case "Ink":
234         return new InkAnnotation(parameters);
235 
236       case "Highlight":
237         return new HighlightAnnotation(parameters);
238 
239       case "Underline":
240         return new UnderlineAnnotation(parameters);
241 
242       case "Squiggly":
243         return new SquigglyAnnotation(parameters);
244 
245       case "StrikeOut":
246         return new StrikeOutAnnotation(parameters);
247 
248       case "Stamp":
249         return new StampAnnotation(parameters);
250 
251       case "FileAttachment":
252         return new FileAttachmentAnnotation(parameters);
253 
254       default:
255         if (!collectFields) {
256           if (!subtype) {
257             warn("Annotation is missing the required /Subtype.");
258           } else {
259             warn(
260               `Unimplemented annotation type "${subtype}", ` +
261                 "falling back to base annotation."
262             );
263           }
264         }
265         return new Annotation(parameters);
266     }
267   }
268 
269   static async _getPageIndex(xref, ref, pdfManager) {
270     try {
271       const annotDict = await xref.fetchIfRefAsync(ref);
272       if (!(annotDict instanceof Dict)) {
273         return -1;
274       }
275       const pageRef = annotDict.getRaw("P");
276       if (pageRef instanceof Ref) {
277         try {
278           const pageIndex = await pdfManager.ensureCatalog("getPageIndex", [
279             pageRef,
280           ]);
281           return pageIndex;
282         } catch (ex) {
283           info(`_getPageIndex -- not a valid page reference: "${ex}".`);
284         }
285       }
286       if (annotDict.has("Kids")) {
287         return -1; // Not an annotation reference.
288       }
289       // Fallback to, potentially, checking the annotations of all pages.
290       // PLEASE NOTE: This could force the *entire* PDF document to load,
291       //              hence it absolutely cannot be done unconditionally.
292       const numPages = await pdfManager.ensureDoc("numPages");
293 
294       for (let pageIndex = 0; pageIndex < numPages; pageIndex++) {
295         const page = await pdfManager.getPage(pageIndex);
296         const annotations = await pdfManager.ensure(page, "annotations");
297 
298         for (const annotRef of annotations) {
299           if (annotRef instanceof Ref && isRefsEqual(annotRef, ref)) {
300             return pageIndex;
301           }
302         }
303       }
304     } catch (ex) {
305       warn(`_getPageIndex: "${ex}".`);
306     }
307     return -1;
308   }
309 
310   static generateImages(annotations, xref, isOffscreenCanvasSupported) {
311     if (!isOffscreenCanvasSupported) {
312       warn(
313         "generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images."
314       );
315       return null;
316     }
317     let imagePromises;
318     for (const { bitmapId, bitmap } of annotations) {
319       if (!bitmap) {
320         continue;
321       }
322       imagePromises ||= new Map();
323       imagePromises.set(bitmapId, StampAnnotation.createImage(bitmap, xref));
324     }
325 
326     return imagePromises;
327   }
328 
329   static async saveNewAnnotations(evaluator, task, annotations, imagePromises) {
330     const xref = evaluator.xref;
331     let baseFontRef;
332     const dependencies = [];
333     const promises = [];
334     const { isOffscreenCanvasSupported } = evaluator.options;
335 
336     for (const annotation of annotations) {
337       if (annotation.deleted) {
338         continue;
339       }
340       switch (annotation.annotationType) {
341         case AnnotationEditorType.FREETEXT:
342           if (!baseFontRef) {
343             const baseFont = new Dict(xref);
344             baseFont.set("BaseFont", Name.get("Helvetica"));
345             baseFont.set("Type", Name.get("Font"));
346             baseFont.set("Subtype", Name.get("Type1"));
347             baseFont.set("Encoding", Name.get("WinAnsiEncoding"));
348             const buffer = [];
349             baseFontRef = xref.getNewTemporaryRef();
350             await writeObject(baseFontRef, baseFont, buffer, xref);
351             dependencies.push({ ref: baseFontRef, data: buffer.join("") });
352           }
353           promises.push(
354             FreeTextAnnotation.createNewAnnotation(
355               xref,
356               annotation,
357               dependencies,
358               { evaluator, task, baseFontRef }
359             )
360           );
361           break;
362         case AnnotationEditorType.HIGHLIGHT:
363           if (annotation.quadPoints) {
364             promises.push(
365               HighlightAnnotation.createNewAnnotation(
366                 xref,
367                 annotation,
368                 dependencies
369               )
370             );
371           } else {
372             promises.push(
373               InkAnnotation.createNewAnnotation(xref, annotation, dependencies)
374             );
375           }
376           break;
377         case AnnotationEditorType.INK:
378           promises.push(
379             InkAnnotation.createNewAnnotation(xref, annotation, dependencies)
380           );
381           break;
382         case AnnotationEditorType.STAMP:
383           if (!isOffscreenCanvasSupported) {
384             break;
385           }
386           const image = await imagePromises.get(annotation.bitmapId);
387           if (image.imageStream) {
388             const { imageStream, smaskStream } = image;
389             const buffer = [];
390             if (smaskStream) {
391               const smaskRef = xref.getNewTemporaryRef();
392               await writeObject(smaskRef, smaskStream, buffer, xref);
393               dependencies.push({ ref: smaskRef, data: buffer.join("") });
394               imageStream.dict.set("SMask", smaskRef);
395               buffer.length = 0;
396             }
397             const imageRef = (image.imageRef = xref.getNewTemporaryRef());
398             await writeObject(imageRef, imageStream, buffer, xref);
399             dependencies.push({ ref: imageRef, data: buffer.join("") });
400             image.imageStream = image.smaskStream = null;
401           }
402           promises.push(
403             StampAnnotation.createNewAnnotation(
404               xref,
405               annotation,
406               dependencies,
407               { image }
408             )
409           );
410           break;
411       }
412     }
413 
414     return {
415       annotations: await Promise.all(promises),
416       dependencies,
417     };
418   }
419 
420   static async printNewAnnotations(
421     annotationGlobals,
422     evaluator,
423     task,
424     annotations,
425     imagePromises
426   ) {
427     if (!annotations) {
428       return null;
429     }
430 
431     const { options, xref } = evaluator;
432     const promises = [];
433     for (const annotation of annotations) {
434       if (annotation.deleted) {
435         continue;
436       }
437       switch (annotation.annotationType) {
438         case AnnotationEditorType.FREETEXT:
439           promises.push(
440             FreeTextAnnotation.createNewPrintAnnotation(
441               annotationGlobals,
442               xref,
443               annotation,
444               {
445                 evaluator,
446                 task,
447                 evaluatorOptions: options,
448               }
449             )
450           );
451           break;
452         case AnnotationEditorType.HIGHLIGHT:
453           if (annotation.quadPoints) {
454             promises.push(
455               HighlightAnnotation.createNewPrintAnnotation(
456                 annotationGlobals,
457                 xref,
458                 annotation,
459                 {
460                   evaluatorOptions: options,
461                 }
462               )
463             );
464           } else {
465             promises.push(
466               InkAnnotation.createNewPrintAnnotation(
467                 annotationGlobals,
468                 xref,
469                 annotation,
470                 {
471                   evaluatorOptions: options,
472                 }
473               )
474             );
475           }
476           break;
477         case AnnotationEditorType.INK:
478           promises.push(
479             InkAnnotation.createNewPrintAnnotation(
480               annotationGlobals,
481               xref,
482               annotation,
483               {
484                 evaluatorOptions: options,
485               }
486             )
487           );
488           break;
489         case AnnotationEditorType.STAMP:
490           if (!options.isOffscreenCanvasSupported) {
491             break;
492           }
493           const image = await imagePromises.get(annotation.bitmapId);
494           if (image.imageStream) {
495             const { imageStream, smaskStream } = image;
496             if (smaskStream) {
497               imageStream.dict.set("SMask", smaskStream);
498             }
499             image.imageRef = new JpegStream(imageStream, imageStream.length);
500             image.imageStream = image.smaskStream = null;
501           }
502           promises.push(
503             StampAnnotation.createNewPrintAnnotation(
504               annotationGlobals,
505               xref,
506               annotation,
507               {
508                 image,
509                 evaluatorOptions: options,
510               }
511             )
512           );
513           break;
514       }
515     }
516 
517     return Promise.all(promises);
518   }
519 }
520 
521 function getRgbColor(color, defaultColor = new Uint8ClampedArray(3)) {
522   if (!Array.isArray(color)) {
523     return defaultColor;
524   }
525 
526   const rgbColor = defaultColor || new Uint8ClampedArray(3);
527   switch (color.length) {
528     case 0: // Transparent, which we indicate with a null value
529       return null;
530 
531     case 1: // Convert grayscale to RGB
532       ColorSpace.singletons.gray.getRgbItem(color, 0, rgbColor, 0);
533       return rgbColor;
534 
535     case 3: // Convert RGB percentages to RGB
536       ColorSpace.singletons.rgb.getRgbItem(color, 0, rgbColor, 0);
537       return rgbColor;
538 
539     case 4: // Convert CMYK to RGB
540       ColorSpace.singletons.cmyk.getRgbItem(color, 0, rgbColor, 0);
541       return rgbColor;
542 
543     default:
544       return defaultColor;
545   }
546 }
547 
548 function getPdfColorArray(color) {
549   return Array.from(color, c => c / 255);
550 }
551 
552 function getQuadPoints(dict, rect) {
553   // The region is described as a number of quadrilaterals.
554   // Each quadrilateral must consist of eight coordinates.
555   const quadPoints = dict.getArray("QuadPoints");
556   if (
557     !isNumberArray(quadPoints, null) ||
558     quadPoints.length === 0 ||
559     quadPoints.length % 8 > 0
560   ) {
561     return null;
562   }
563 
564   const newQuadPoints = new Float32Array(quadPoints.length);
565   for (let i = 0, ii = quadPoints.length; i < ii; i += 8) {
566     // Each series of eight numbers represents the coordinates for one
567     // quadrilateral in the order [x1, y1, x2, y2, x3, y3, x4, y4].
568     // Convert this to an array of objects with x and y coordinates.
569     const [x1, y1, x2, y2, x3, y3, x4, y4] = quadPoints.slice(i, i + 8);
570     const minX = Math.min(x1, x2, x3, x4);
571     const maxX = Math.max(x1, x2, x3, x4);
572     const minY = Math.min(y1, y2, y3, y4);
573     const maxY = Math.max(y1, y2, y3, y4);
574     // The quadpoints should be ignored if any coordinate in the array
575     // lies outside the region specified by the rectangle. The rectangle
576     // can be `null` for markup annotations since their rectangle may be
577     // incorrect (fixes bug 1538111).
578     if (
579       rect !== null &&
580       (minX < rect[0] || maxX > rect[2] || minY < rect[1] || maxY > rect[3])
581     ) {
582       return null;
583     }
584     // The PDF specification states in section 12.5.6.10 (figure 64) that the
585     // order of the quadpoints should be bottom left, bottom right, top right
586     // and top left. However, in practice PDF files use a different order,
587     // namely bottom left, bottom right, top left and top right (this is also
588     // mentioned on https://github.com/highkite/pdfAnnotate#QuadPoints), so
589     // this is the actual order we should work with. However, the situation is
590     // even worse since Adobe's own applications and other applications violate
591     // the specification and create annotations with other orders, namely top
592     // left, top right, bottom left and bottom right or even top left,
593     // top right, bottom right and bottom left. To avoid inconsistency and
594     // broken rendering, we normalize all lists to put the quadpoints in the
595     // same standard order (see https://stackoverflow.com/a/10729881).
596     newQuadPoints.set([minX, maxY, maxX, maxY, minX, minY, maxX, minY], i);
597   }
598   return newQuadPoints;
599 }
600 
601 function getTransformMatrix(rect, bbox, matrix) {
602   // 12.5.5: Algorithm: Appearance streams
603   const [minX, minY, maxX, maxY] = Util.getAxialAlignedBoundingBox(
604     bbox,
605     matrix
606   );
607   if (minX === maxX || minY === maxY) {
608     // From real-life file, bbox was [0, 0, 0, 0]. In this case,
609     // just apply the transform for rect
610     return [1, 0, 0, 1, rect[0], rect[1]];
611   }
612 
613   const xRatio = (rect[2] - rect[0]) / (maxX - minX);
614   const yRatio = (rect[3] - rect[1]) / (maxY - minY);
615   return [
616     xRatio,
617     0,
618     0,
619     yRatio,
620     rect[0] - minX * xRatio,
621     rect[1] - minY * yRatio,
622   ];
623 }
624 
625 class Annotation {
626   constructor(params) {
627     const { dict, xref, annotationGlobals } = params;
628 
629     this.setTitle(dict.get("T"));
630     this.setContents(dict.get("Contents"));
631     this.setModificationDate(dict.get("M"));
632     this.setFlags(dict.get("F"));
633     this.setRectangle(dict.getArray("Rect"));
634     this.setColor(dict.getArray("C"));
635     this.setBorderStyle(dict);
636     this.setAppearance(dict);
637     this.setOptionalContent(dict);
638 
639     const MK = dict.get("MK");
640     this.setBorderAndBackgroundColors(MK);
641     this.setRotation(MK, dict);
642     this.ref = params.ref instanceof Ref ? params.ref : null;
643 
644     this._streams = [];
645     if (this.appearance) {
646       this._streams.push(this.appearance);
647     }
648 
649     // The annotation cannot be changed (neither its position/visibility nor its
650     // contents), hence we can just display its appearance and don't generate
651     // a HTML element for it.
652     const isLocked = !!(this.flags & AnnotationFlag.LOCKED);
653     const isContentLocked = !!(this.flags & AnnotationFlag.LOCKEDCONTENTS);
654 
655     if (annotationGlobals.structTreeRoot) {
656       let structParent = dict.get("StructParent");
657       structParent =
658         Number.isInteger(structParent) && structParent >= 0 ? structParent : -1;
659 
660       annotationGlobals.structTreeRoot.addAnnotationIdToPage(
661         params.pageRef,
662         structParent
663       );
664     }
665 
666     // Expose public properties using a data object.
667     this.data = {
668       annotationFlags: this.flags,
669       borderStyle: this.borderStyle,
670       color: this.color,
671       backgroundColor: this.backgroundColor,
672       borderColor: this.borderColor,
673       rotation: this.rotation,
674       contentsObj: this._contents,
675       hasAppearance: !!this.appearance,
676       id: params.id,
677       modificationDate: this.modificationDate,
678       rect: this.rectangle,
679       subtype: params.subtype,
680       hasOwnCanvas: false,
681       noRotate: !!(this.flags & AnnotationFlag.NOROTATE),
682       noHTML: isLocked && isContentLocked,
683       isEditable: false,
684     };
685 
686     if (params.collectFields) {
687       // Fields can act as container for other fields and have
688       // some actions even if no Annotation inherit from them.
689       // Those fields can be referenced by CO (calculation order).
690       const kids = dict.get("Kids");
691       if (Array.isArray(kids)) {
692         const kidIds = [];
693         for (const kid of kids) {
694           if (kid instanceof Ref) {
695             kidIds.push(kid.toString());
696           }
697         }
698         if (kidIds.length !== 0) {
699           this.data.kidIds = kidIds;
700         }
701       }
702 
703       this.data.actions = collectActions(xref, dict, AnnotationActionEventType);
704       this.data.fieldName = this._constructFieldName(dict);
705       this.data.pageIndex = params.pageIndex;
706     }
707 
708     const it = dict.get("IT");
709     if (it instanceof Name) {
710       this.data.it = it.name;
711     }
712 
713     this._isOffscreenCanvasSupported =
714       params.evaluatorOptions.isOffscreenCanvasSupported;
715     this._fallbackFontDict = null;
716     this._needAppearances = false;
717   }
718 
719   /**
720    * @private
721    */
722   _hasFlag(flags, flag) {
723     return !!(flags & flag);
724   }
725 
726   /**
727    * @private
728    */
729   _isViewable(flags) {
730     return (
731       !this._hasFlag(flags, AnnotationFlag.INVISIBLE) &&
732       !this._hasFlag(flags, AnnotationFlag.NOVIEW)
733     );
734   }
735 
736   /**
737    * @private
738    */
739   _isPrintable(flags) {
740     // In Acrobat, hidden flag cancels the print one
741     // (see annotation_hidden_print.pdf).
742     return (
743       this._hasFlag(flags, AnnotationFlag.PRINT) &&
744       !this._hasFlag(flags, AnnotationFlag.HIDDEN) &&
745       !this._hasFlag(flags, AnnotationFlag.INVISIBLE)
746     );
747   }
748 
749   /**
750    * Check if the annotation must be displayed by taking into account
751    * the value found in the annotationStorage which may have been set
752    * through JS.
753    *
754    * @public
755    * @memberof Annotation
756    * @param {AnnotationStorage} [annotationStorage] - Storage for annotation
757    * @param {boolean} [_renderForms] - if true widgets are rendered thanks to
758    *                                   the annotation layer.
759    */
760   mustBeViewed(annotationStorage, _renderForms) {
761     const noView = annotationStorage?.get(this.data.id)?.noView;
762     if (noView !== undefined) {
763       return !noView;
764     }
765     return this.viewable && !this._hasFlag(this.flags, AnnotationFlag.HIDDEN);
766   }
767 
768   /**
769    * Check if the annotation must be printed by taking into account
770    * the value found in the annotationStorage which may have been set
771    * through JS.
772    *
773    * @public
774    * @memberof Annotation
775    * @param {AnnotationStorage} [annotationStorage] - Storage for annotation
776    */
777   mustBePrinted(annotationStorage) {
778     const noPrint = annotationStorage?.get(this.data.id)?.noPrint;
779     if (noPrint !== undefined) {
780       return !noPrint;
781     }
782     return this.printable;
783   }
784 
785   mustBeViewedWhenEditing(isEditing, modifiedIds = null) {
786     return isEditing ? !this.data.isEditable : !modifiedIds?.has(this.data.id);
787   }
788 
789   /**
790    * @type {boolean}
791    */
792   get viewable() {
793     if (this.data.quadPoints === null) {
794       return false;
795     }
796     if (this.flags === 0) {
797       return true;
798     }
799     return this._isViewable(this.flags);
800   }
801 
802   /**
803    * @type {boolean}
804    */
805   get printable() {
806     if (this.data.quadPoints === null) {
807       return false;
808     }
809     if (this.flags === 0) {
810       return false;
811     }
812     return this._isPrintable(this.flags);
813   }
814 
815   /**
816    * @private
817    */
818   _parseStringHelper(data) {
819     const str = typeof data === "string" ? stringToPDFString(data) : "";
820     const dir = str && bidi(str).dir === "rtl" ? "rtl" : "ltr";
821 
822     return { str, dir };
823   }
824 
825   setDefaultAppearance(params) {
826     const { dict, annotationGlobals } = params;
827 
828     const defaultAppearance =
829       getInheritableProperty({ dict, key: "DA" }) ||
830       annotationGlobals.acroForm.get("DA");
831     this._defaultAppearance =
832       typeof defaultAppearance === "string" ? defaultAppearance : "";
833     this.data.defaultAppearanceData = parseDefaultAppearance(
834       this._defaultAppearance
835     );
836   }
837 
838   /**
839    * Set the title.
840    *
841    * @param {string} title - The title of the annotation, used e.g. with
842    *   PopupAnnotations.
843    */
844   setTitle(title) {
845     this._title = this._parseStringHelper(title);
846   }
847 
848   /**
849    * Set the contents.
850    *
851    * @param {string} contents - Text to display for the annotation or, if the
852    *                            type of annotation does not display text, a
853    *                            description of the annotation's contents
854    */
855   setContents(contents) {
856     this._contents = this._parseStringHelper(contents);
857   }
858 
859   /**
860    * Set the modification date.
861    *
862    * @public
863    * @memberof Annotation
864    * @param {string} modificationDate - PDF date string that indicates when the
865    *                                    annotation was last modified
866    */
867   setModificationDate(modificationDate) {
868     this.modificationDate =
869       typeof modificationDate === "string" ? modificationDate : null;
870   }
871 
872   /**
873    * Set the flags.
874    *
875    * @public
876    * @memberof Annotation
877    * @param {number} flags - Unsigned 32-bit integer specifying annotation
878    *                         characteristics
879    * @see {@link shared/util.js}
880    */
881   setFlags(flags) {
882     this.flags = Number.isInteger(flags) && flags > 0 ? flags : 0;
883     if (
884       this.flags & AnnotationFlag.INVISIBLE &&
885       this.constructor.name !== "Annotation"
886     ) {
887       // From the pdf spec v1.7, section 12.5.3 (Annotation Flags):
888       //   If set, do not display the annotation if it does not belong to one of
889       //   the standard annotation types and no annotation handler is available.
890       //
891       // So we can remove the flag in case we have a known annotation type.
892       this.flags ^= AnnotationFlag.INVISIBLE;
893     }
894   }
895 
896   /**
897    * Check if a provided flag is set.
898    *
899    * @public
900    * @memberof Annotation
901    * @param {number} flag - Hexadecimal representation for an annotation
902    *                        characteristic
903    * @returns {boolean}
904    * @see {@link shared/util.js}
905    */
906   hasFlag(flag) {
907     return this._hasFlag(this.flags, flag);
908   }
909 
910   /**
911    * Set the rectangle.
912    *
913    * @public
914    * @memberof Annotation
915    * @param {Array} rectangle - The rectangle array with exactly four entries
916    */
917   setRectangle(rectangle) {
918     this.rectangle = lookupNormalRect(rectangle, [0, 0, 0, 0]);
919   }
920 
921   /**
922    * Set the color and take care of color space conversion.
923    * The default value is black, in RGB color space.
924    *
925    * @public
926    * @memberof Annotation
927    * @param {Array} color - The color array containing either 0
928    *                        (transparent), 1 (grayscale), 3 (RGB) or
929    *                        4 (CMYK) elements
930    */
931   setColor(color) {
932     this.color = getRgbColor(color);
933   }
934 
935   /**
936    * Set the line endings; should only be used with specific annotation types.
937    * @param {Array} lineEndings - The line endings array.
938    */
939   setLineEndings(lineEndings) {
940     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) {
941       throw new Error("Not implemented: setLineEndings");
942     }
943     this.lineEndings = ["None", "None"]; // The default values.
944 
945     if (Array.isArray(lineEndings) && lineEndings.length === 2) {
946       for (let i = 0; i < 2; i++) {
947         const obj = lineEndings[i];
948 
949         if (obj instanceof Name) {
950           switch (obj.name) {
951             case "None":
952               continue;
953             case "Square":
954             case "Circle":
955             case "Diamond":
956             case "OpenArrow":
957             case "ClosedArrow":
958             case "Butt":
959             case "ROpenArrow":
960             case "RClosedArrow":
961             case "Slash":
962               this.lineEndings[i] = obj.name;
963               continue;
964           }
965         }
966         warn(`Ignoring invalid lineEnding: ${obj}`);
967       }
968     }
969   }
970 
971   setRotation(mk, dict) {
972     this.rotation = 0;
973     let angle = mk instanceof Dict ? mk.get("R") || 0 : dict.get("Rotate") || 0;
974     if (Number.isInteger(angle) && angle !== 0) {
975       angle %= 360;
976       if (angle < 0) {
977         angle += 360;
978       }
979       if (angle % 90 === 0) {
980         this.rotation = angle;
981       }
982     }
983   }
984 
985   /**
986    * Set the color for background and border if any.
987    * The default values are transparent.
988    *
989    * @public
990    * @memberof Annotation
991    * @param {Dict} mk - The MK dictionary
992    */
993   setBorderAndBackgroundColors(mk) {
994     if (mk instanceof Dict) {
995       this.borderColor = getRgbColor(mk.getArray("BC"), null);
996       this.backgroundColor = getRgbColor(mk.getArray("BG"), null);
997     } else {
998       this.borderColor = this.backgroundColor = null;
999     }
1000   }
1001 
1002   /**
1003    * Set the border style (as AnnotationBorderStyle object).
1004    *
1005    * @public
1006    * @memberof Annotation
1007    * @param {Dict} borderStyle - The border style dictionary
1008    */
1009   setBorderStyle(borderStyle) {
1010     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1011       assert(this.rectangle, "setRectangle must have been called previously.");
1012     }
1013 
1014     this.borderStyle = new AnnotationBorderStyle();
1015     if (!(borderStyle instanceof Dict)) {
1016       return;
1017     }
1018     if (borderStyle.has("BS")) {
1019       const dict = borderStyle.get("BS");
1020 
1021       if (dict instanceof Dict) {
1022         const dictType = dict.get("Type");
1023 
1024         if (!dictType || isName(dictType, "Border")) {
1025           this.borderStyle.setWidth(dict.get("W"), this.rectangle);
1026           this.borderStyle.setStyle(dict.get("S"));
1027           this.borderStyle.setDashArray(dict.getArray("D"));
1028         }
1029       }
1030     } else if (borderStyle.has("Border")) {
1031       const array = borderStyle.getArray("Border");
1032       if (Array.isArray(array) && array.length >= 3) {
1033         this.borderStyle.setHorizontalCornerRadius(array[0]);
1034         this.borderStyle.setVerticalCornerRadius(array[1]);
1035         this.borderStyle.setWidth(array[2], this.rectangle);
1036 
1037         if (array.length === 4) {
1038           // Dash array available
1039           this.borderStyle.setDashArray(array[3], /* forceStyle = */ true);
1040         }
1041       }
1042     } else {
1043       // There are no border entries in the dictionary. According to the
1044       // specification, we should draw a solid border of width 1 in that
1045       // case, but Adobe Reader did not implement that part of the
1046       // specification and instead draws no border at all, so we do the same.
1047       // See also https://github.com/mozilla/pdf.js/issues/6179.
1048       this.borderStyle.setWidth(0);
1049     }
1050   }
1051 
1052   /**
1053    * Set the (normal) appearance.
1054    *
1055    * @public
1056    * @memberof Annotation
1057    * @param {Dict} dict - The annotation's data dictionary
1058    */
1059   setAppearance(dict) {
1060     this.appearance = null;
1061 
1062     const appearanceStates = dict.get("AP");
1063     if (!(appearanceStates instanceof Dict)) {
1064       return;
1065     }
1066 
1067     // In case the normal appearance is a stream, then it is used directly.
1068     const normalAppearanceState = appearanceStates.get("N");
1069     if (normalAppearanceState instanceof BaseStream) {
1070       this.appearance = normalAppearanceState;
1071       return;
1072     }
1073     if (!(normalAppearanceState instanceof Dict)) {
1074       return;
1075     }
1076 
1077     // In case the normal appearance is a dictionary, the `AS` entry provides
1078     // the key of the stream in this dictionary.
1079     const as = dict.get("AS");
1080     if (!(as instanceof Name) || !normalAppearanceState.has(as.name)) {
1081       return;
1082     }
1083     const appearance = normalAppearanceState.get(as.name);
1084     if (appearance instanceof BaseStream) {
1085       this.appearance = appearance;
1086     }
1087   }
1088 
1089   setOptionalContent(dict) {
1090     this.oc = null;
1091 
1092     const oc = dict.get("OC");
1093     if (oc instanceof Name) {
1094       warn("setOptionalContent: Support for /Name-entry is not implemented.");
1095     } else if (oc instanceof Dict) {
1096       this.oc = oc;
1097     }
1098   }
1099 
1100   loadResources(keys, appearance) {
1101     return appearance.dict.getAsync("Resources").then(resources => {
1102       if (!resources) {
1103         return undefined;
1104       }
1105 
1106       const objectLoader = new ObjectLoader(resources, keys, resources.xref);
1107       return objectLoader.load().then(function () {
1108         return resources;
1109       });
1110     });
1111   }
1112 
1113   async getOperatorList(evaluator, task, intent, annotationStorage) {
1114     const { hasOwnCanvas, id, rect } = this.data;
1115     let appearance = this.appearance;
1116     const isUsingOwnCanvas = !!(
1117       hasOwnCanvas && intent & RenderingIntentFlag.DISPLAY
1118     );
1119     if (isUsingOwnCanvas && (rect[0] === rect[2] || rect[1] === rect[3])) {
1120       // Empty annotation, don't draw anything.
1121       this.data.hasOwnCanvas = false;
1122       return {
1123         opList: new OperatorList(),
1124         separateForm: false,
1125         separateCanvas: false,
1126       };
1127     }
1128     if (!appearance) {
1129       if (!isUsingOwnCanvas) {
1130         return {
1131           opList: new OperatorList(),
1132           separateForm: false,
1133           separateCanvas: false,
1134         };
1135       }
1136       appearance = new StringStream("");
1137       appearance.dict = new Dict();
1138     }
1139 
1140     const appearanceDict = appearance.dict;
1141     const resources = await this.loadResources(
1142       ["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"],
1143       appearance
1144     );
1145     const bbox = lookupRect(appearanceDict.getArray("BBox"), [0, 0, 1, 1]);
1146     const matrix = lookupMatrix(
1147       appearanceDict.getArray("Matrix"),
1148       IDENTITY_MATRIX
1149     );
1150     const transform = getTransformMatrix(rect, bbox, matrix);
1151 
1152     const opList = new OperatorList();
1153 
1154     let optionalContent;
1155     if (this.oc) {
1156       optionalContent = await evaluator.parseMarkedContentProps(
1157         this.oc,
1158         /* resources = */ null
1159       );
1160     }
1161     if (optionalContent !== undefined) {
1162       opList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
1163     }
1164 
1165     opList.addOp(OPS.beginAnnotation, [
1166       id,
1167       rect,
1168       transform,
1169       matrix,
1170       isUsingOwnCanvas,
1171     ]);
1172 
1173     await evaluator.getOperatorList({
1174       stream: appearance,
1175       task,
1176       resources,
1177       operatorList: opList,
1178       fallbackFontDict: this._fallbackFontDict,
1179     });
1180     opList.addOp(OPS.endAnnotation, []);
1181 
1182     if (optionalContent !== undefined) {
1183       opList.addOp(OPS.endMarkedContent, []);
1184     }
1185     this.reset();
1186     return { opList, separateForm: false, separateCanvas: isUsingOwnCanvas };
1187   }
1188 
1189   async save(evaluator, task, annotationStorage) {
1190     return null;
1191   }
1192 
1193   get hasTextContent() {
1194     return false;
1195   }
1196 
1197   async extractTextContent(evaluator, task, viewBox) {
1198     if (!this.appearance) {
1199       return;
1200     }
1201 
1202     const resources = await this.loadResources(
1203       ["ExtGState", "Font", "Properties", "XObject"],
1204       this.appearance
1205     );
1206 
1207     const text = [];
1208     const buffer = [];
1209     let firstPosition = null;
1210     const sink = {
1211       desiredSize: Math.Infinity,
1212       ready: true,
1213 
1214       enqueue(chunk, size) {
1215         for (const item of chunk.items) {
1216           if (item.str === undefined) {
1217             continue;
1218           }
1219           firstPosition ||= item.transform.slice(-2);
1220           buffer.push(item.str);
1221           if (item.hasEOL) {
1222             text.push(buffer.join("").trimEnd());
1223             buffer.length = 0;
1224           }
1225         }
1226       },
1227     };
1228 
1229     await evaluator.getTextContent({
1230       stream: this.appearance,
1231       task,
1232       resources,
1233       includeMarkedContent: true,
1234       keepWhiteSpace: true,
1235       sink,
1236       viewBox,
1237     });
1238     this.reset();
1239 
1240     if (buffer.length) {
1241       text.push(buffer.join("").trimEnd());
1242     }
1243 
1244     if (text.length > 1 || text[0]) {
1245       const appearanceDict = this.appearance.dict;
1246       const bbox = lookupRect(appearanceDict.getArray("BBox"), null);
1247       const matrix = lookupMatrix(appearanceDict.getArray("Matrix"), null);
1248 
1249       this.data.textPosition = this._transformPoint(
1250         firstPosition,
1251         bbox,
1252         matrix
1253       );
1254       this.data.textContent = text;
1255     }
1256   }
1257 
1258   _transformPoint(coords, bbox, matrix) {
1259     const { rect } = this.data;
1260     bbox ||= [0, 0, 1, 1];
1261     matrix ||= [1, 0, 0, 1, 0, 0];
1262     const transform = getTransformMatrix(rect, bbox, matrix);
1263     transform[4] -= rect[0];
1264     transform[5] -= rect[1];
1265     coords = Util.applyTransform(coords, transform);
1266     return Util.applyTransform(coords, matrix);
1267   }
1268 
1269   /**
1270    * Get field data for usage in JS sandbox.
1271    *
1272    * Field object is defined here:
1273    * https://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/js_api_reference.pdf#page=16
1274    *
1275    * @public
1276    * @memberof Annotation
1277    * @returns {Object | null}
1278    */
1279   getFieldObject() {
1280     if (this.data.kidIds) {
1281       return {
1282         id: this.data.id,
1283         actions: this.data.actions,
1284         name: this.data.fieldName,
1285         strokeColor: this.data.borderColor,
1286         fillColor: this.data.backgroundColor,
1287         type: "",
1288         kidIds: this.data.kidIds,
1289         page: this.data.pageIndex,
1290         rotation: this.rotation,
1291       };
1292     }
1293     return null;
1294   }
1295 
1296   /**
1297    * Reset the annotation.
1298    *
1299    * This involves resetting the various streams that are either cached on the
1300    * annotation instance or created during its construction.
1301    *
1302    * @public
1303    * @memberof Annotation
1304    */
1305   reset() {
1306     if (
1307       (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) &&
1308       this.appearance &&
1309       !this._streams.includes(this.appearance)
1310     ) {
1311       unreachable("The appearance stream should always be reset.");
1312     }
1313 
1314     for (const stream of this._streams) {
1315       stream.reset();
1316     }
1317   }
1318 
1319   /**
1320    * Construct the (fully qualified) field name from the (partial) field
1321    * names of the field and its ancestors.
1322    *
1323    * @private
1324    * @memberof Annotation
1325    * @param {Dict} dict - Complete widget annotation dictionary
1326    * @returns {string}
1327    */
1328   _constructFieldName(dict) {
1329     // Both the `Parent` and `T` fields are optional. While at least one of
1330     // them should be provided, bad PDF generators may fail to do so.
1331     if (!dict.has("T") && !dict.has("Parent")) {
1332       warn("Unknown field name, falling back to empty field name.");
1333       return "";
1334     }
1335 
1336     // If no parent exists, the partial and fully qualified names are equal.
1337     if (!dict.has("Parent")) {
1338       return stringToPDFString(dict.get("T"));
1339     }
1340 
1341     // Form the fully qualified field name by appending the partial name to
1342     // the parent's fully qualified name, separated by a period.
1343     const fieldName = [];
1344     if (dict.has("T")) {
1345       fieldName.unshift(stringToPDFString(dict.get("T")));
1346     }
1347 
1348     let loopDict = dict;
1349     const visited = new RefSet();
1350     if (dict.objId) {
1351       visited.put(dict.objId);
1352     }
1353     while (loopDict.has("Parent")) {
1354       loopDict = loopDict.get("Parent");
1355       if (
1356         !(loopDict instanceof Dict) ||
1357         (loopDict.objId && visited.has(loopDict.objId))
1358       ) {
1359         // Even though it is not allowed according to the PDF specification,
1360         // bad PDF generators may provide a `Parent` entry that is not a
1361         // dictionary, but `null` for example (issue 8143).
1362         //
1363         // If parent has been already visited, it means that we're
1364         // in an infinite loop.
1365         break;
1366       }
1367       if (loopDict.objId) {
1368         visited.put(loopDict.objId);
1369       }
1370 
1371       if (loopDict.has("T")) {
1372         fieldName.unshift(stringToPDFString(loopDict.get("T")));
1373       }
1374     }
1375     return fieldName.join(".");
1376   }
1377 }
1378 
1379 /**
1380  * Contains all data regarding an annotation's border style.
1381  */
1382 class AnnotationBorderStyle {
1383   constructor() {
1384     this.width = 1;
1385     this.rawWidth = 1;
1386     this.style = AnnotationBorderStyleType.SOLID;
1387     this.dashArray = [3];
1388     this.horizontalCornerRadius = 0;
1389     this.verticalCornerRadius = 0;
1390   }
1391 
1392   /**
1393    * Set the width.
1394    *
1395    * @public
1396    * @memberof AnnotationBorderStyle
1397    * @param {number} width - The width.
1398    * @param {Array} rect - The annotation `Rect` entry.
1399    */
1400   setWidth(width, rect = [0, 0, 0, 0]) {
1401     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1402       assert(
1403         isNumberArray(rect, 4),
1404         "A valid `rect` parameter must be provided."
1405       );
1406     }
1407 
1408     // Some corrupt PDF generators may provide the width as a `Name`,
1409     // rather than as a number (fixes issue 10385).
1410     if (width instanceof Name) {
1411       this.width = 0; // This is consistent with the behaviour in Adobe Reader.
1412       return;
1413     }
1414     if (typeof width === "number") {
1415       if (width > 0) {
1416         this.rawWidth = width;
1417         const maxWidth = (rect[2] - rect[0]) / 2;
1418         const maxHeight = (rect[3] - rect[1]) / 2;
1419 
1420         // Ignore large `width`s, since they lead to the Annotation overflowing
1421         // the size set by the `Rect` entry thus causing the `annotationLayer`
1422         // to render it over the surrounding document (fixes bug1552113.pdf).
1423         if (
1424           maxWidth > 0 &&
1425           maxHeight > 0 &&
1426           (width > maxWidth || width > maxHeight)
1427         ) {
1428           warn(`AnnotationBorderStyle.setWidth - ignoring width: ${width}`);
1429           width = 1;
1430         }
1431       }
1432       this.width = width;
1433     }
1434   }
1435 
1436   /**
1437    * Set the style.
1438    *
1439    * @public
1440    * @memberof AnnotationBorderStyle
1441    * @param {Name} style - The annotation style.
1442    * @see {@link shared/util.js}
1443    */
1444   setStyle(style) {
1445     if (!(style instanceof Name)) {
1446       return;
1447     }
1448     switch (style.name) {
1449       case "S":
1450         this.style = AnnotationBorderStyleType.SOLID;
1451         break;
1452 
1453       case "D":
1454         this.style = AnnotationBorderStyleType.DASHED;
1455         break;
1456 
1457       case "B":
1458         this.style = AnnotationBorderStyleType.BEVELED;
1459         break;
1460 
1461       case "I":
1462         this.style = AnnotationBorderStyleType.INSET;
1463         break;
1464 
1465       case "U":
1466         this.style = AnnotationBorderStyleType.UNDERLINE;
1467         break;
1468 
1469       default:
1470         break;
1471     }
1472   }
1473 
1474   /**
1475    * Set the dash array.
1476    *
1477    * @public
1478    * @memberof AnnotationBorderStyle
1479    * @param {Array} dashArray - The dash array with at least one element
1480    * @param {boolean} [forceStyle]
1481    */
1482   setDashArray(dashArray, forceStyle = false) {
1483     // We validate the dash array, but we do not use it because CSS does not
1484     // allow us to change spacing of dashes. For more information, visit
1485     // http://www.w3.org/TR/css3-background/#the-border-style.
1486     if (Array.isArray(dashArray)) {
1487       // The PDF specification states that elements in the dash array, if
1488       // present, must be non-negative numbers and must not all equal zero.
1489       let isValid = true;
1490       let allZeros = true;
1491       for (const element of dashArray) {
1492         const validNumber = +element >= 0;
1493         if (!validNumber) {
1494           isValid = false;
1495           break;
1496         } else if (element > 0) {
1497           allZeros = false;
1498         }
1499       }
1500       if (dashArray.length === 0 || (isValid && !allZeros)) {
1501         this.dashArray = dashArray;
1502 
1503         if (forceStyle) {
1504           // Even though we cannot use the dash array in the display layer,
1505           // at least ensure that we use the correct border-style.
1506           this.setStyle(Name.get("D"));
1507         }
1508       } else {
1509         this.width = 0; // Adobe behavior when the array is invalid.
1510       }
1511     } else if (dashArray) {
1512       this.width = 0; // Adobe behavior when the array is invalid.
1513     }
1514   }
1515 
1516   /**
1517    * Set the horizontal corner radius (from a Border dictionary).
1518    *
1519    * @public
1520    * @memberof AnnotationBorderStyle
1521    * @param {number} radius - The horizontal corner radius.
1522    */
1523   setHorizontalCornerRadius(radius) {
1524     if (Number.isInteger(radius)) {
1525       this.horizontalCornerRadius = radius;
1526     }
1527   }
1528 
1529   /**
1530    * Set the vertical corner radius (from a Border dictionary).
1531    *
1532    * @public
1533    * @memberof AnnotationBorderStyle
1534    * @param {number} radius - The vertical corner radius.
1535    */
1536   setVerticalCornerRadius(radius) {
1537     if (Number.isInteger(radius)) {
1538       this.verticalCornerRadius = radius;
1539     }
1540   }
1541 }
1542 
1543 class MarkupAnnotation extends Annotation {
1544   constructor(params) {
1545     super(params);
1546 
1547     const { dict } = params;
1548 
1549     if (dict.has("IRT")) {
1550       const rawIRT = dict.getRaw("IRT");
1551       this.data.inReplyTo = rawIRT instanceof Ref ? rawIRT.toString() : null;
1552 
1553       const rt = dict.get("RT");
1554       this.data.replyType =
1555         rt instanceof Name ? rt.name : AnnotationReplyType.REPLY;
1556     }
1557     let popupRef = null;
1558 
1559     if (this.data.replyType === AnnotationReplyType.GROUP) {
1560       // Subordinate annotations in a group should inherit
1561       // the group attributes from the primary annotation.
1562       const parent = dict.get("IRT");
1563 
1564       this.setTitle(parent.get("T"));
1565       this.data.titleObj = this._title;
1566 
1567       this.setContents(parent.get("Contents"));
1568       this.data.contentsObj = this._contents;
1569 
1570       if (!parent.has("CreationDate")) {
1571         this.data.creationDate = null;
1572       } else {
1573         this.setCreationDate(parent.get("CreationDate"));
1574         this.data.creationDate = this.creationDate;
1575       }
1576 
1577       if (!parent.has("M")) {
1578         this.data.modificationDate = null;
1579       } else {
1580         this.setModificationDate(parent.get("M"));
1581         this.data.modificationDate = this.modificationDate;
1582       }
1583 
1584       popupRef = parent.getRaw("Popup");
1585 
1586       if (!parent.has("C")) {
1587         // Fall back to the default background color.
1588         this.data.color = null;
1589       } else {
1590         this.setColor(parent.getArray("C"));
1591         this.data.color = this.color;
1592       }
1593     } else {
1594       this.data.titleObj = this._title;
1595 
1596       this.setCreationDate(dict.get("CreationDate"));
1597       this.data.creationDate = this.creationDate;
1598 
1599       popupRef = dict.getRaw("Popup");
1600 
1601       if (!dict.has("C")) {
1602         // Fall back to the default background color.
1603         this.data.color = null;
1604       }
1605     }
1606 
1607     this.data.popupRef = popupRef instanceof Ref ? popupRef.toString() : null;
1608 
1609     if (dict.has("RC")) {
1610       this.data.richText = XFAFactory.getRichTextAsHtml(dict.get("RC"));
1611     }
1612   }
1613 
1614   /**
1615    * Set the creation date.
1616    *
1617    * @public
1618    * @memberof MarkupAnnotation
1619    * @param {string} creationDate - PDF date string that indicates when the
1620    *                                annotation was originally created
1621    */
1622   setCreationDate(creationDate) {
1623     this.creationDate = typeof creationDate === "string" ? creationDate : null;
1624   }
1625 
1626   _setDefaultAppearance({
1627     xref,
1628     extra,
1629     strokeColor,
1630     fillColor,
1631     blendMode,
1632     strokeAlpha,
1633     fillAlpha,
1634     pointsCallback,
1635   }) {
1636     let minX = Number.MAX_VALUE;
1637     let minY = Number.MAX_VALUE;
1638     let maxX = Number.MIN_VALUE;
1639     let maxY = Number.MIN_VALUE;
1640 
1641     const buffer = ["q"];
1642     if (extra) {
1643       buffer.push(extra);
1644     }
1645     if (strokeColor) {
1646       buffer.push(`${strokeColor[0]} ${strokeColor[1]} ${strokeColor[2]} RG`);
1647     }
1648     if (fillColor) {
1649       buffer.push(`${fillColor[0]} ${fillColor[1]} ${fillColor[2]} rg`);
1650     }
1651 
1652     let pointsArray = this.data.quadPoints;
1653     if (!pointsArray) {
1654       // If there are no quadpoints, the rectangle should be used instead.
1655       // Convert the rectangle definition to a points array similar to how the
1656       // quadpoints are defined.
1657       pointsArray = Float32Array.from([
1658         this.rectangle[0],
1659         this.rectangle[3],
1660         this.rectangle[2],
1661         this.rectangle[3],
1662         this.rectangle[0],
1663         this.rectangle[1],
1664         this.rectangle[2],
1665         this.rectangle[1],
1666       ]);
1667     }
1668 
1669     for (let i = 0, ii = pointsArray.length; i < ii; i += 8) {
1670       const [mX, MX, mY, MY] = pointsCallback(
1671         buffer,
1672         pointsArray.subarray(i, i + 8)
1673       );
1674       minX = Math.min(minX, mX);
1675       maxX = Math.max(maxX, MX);
1676       minY = Math.min(minY, mY);
1677       maxY = Math.max(maxY, MY);
1678     }
1679     buffer.push("Q");
1680 
1681     const formDict = new Dict(xref);
1682     const appearanceStreamDict = new Dict(xref);
1683     appearanceStreamDict.set("Subtype", Name.get("Form"));
1684 
1685     const appearanceStream = new StringStream(buffer.join(" "));
1686     appearanceStream.dict = appearanceStreamDict;
1687     formDict.set("Fm0", appearanceStream);
1688 
1689     const gsDict = new Dict(xref);
1690     if (blendMode) {
1691       gsDict.set("BM", Name.get(blendMode));
1692     }
1693     if (typeof strokeAlpha === "number") {
1694       gsDict.set("CA", strokeAlpha);
1695     }
1696     if (typeof fillAlpha === "number") {
1697       gsDict.set("ca", fillAlpha);
1698     }
1699 
1700     const stateDict = new Dict(xref);
1701     stateDict.set("GS0", gsDict);
1702 
1703     const resources = new Dict(xref);
1704     resources.set("ExtGState", stateDict);
1705     resources.set("XObject", formDict);
1706 
1707     const appearanceDict = new Dict(xref);
1708     appearanceDict.set("Resources", resources);
1709     const bbox = (this.data.rect = [minX, minY, maxX, maxY]);
1710     appearanceDict.set("BBox", bbox);
1711 
1712     this.appearance = new StringStream("/GS0 gs /Fm0 Do");
1713     this.appearance.dict = appearanceDict;
1714 
1715     // This method is only called if there is no appearance for the annotation,
1716     // so `this.appearance` is not pushed yet in the `Annotation` constructor.
1717     this._streams.push(this.appearance, appearanceStream);
1718   }
1719 
1720   static async createNewAnnotation(xref, annotation, dependencies, params) {
1721     let oldAnnotation;
1722     if (annotation.ref) {
1723       oldAnnotation = (await xref.fetchIfRefAsync(annotation.ref)).clone();
1724     } else {
1725       annotation.ref = xref.getNewTemporaryRef();
1726     }
1727 
1728     const annotationRef = annotation.ref;
1729     const ap = await this.createNewAppearanceStream(annotation, xref, params);
1730     const buffer = [];
1731     let annotationDict;
1732 
1733     if (ap) {
1734       const apRef = xref.getNewTemporaryRef();
1735       annotationDict = this.createNewDict(annotation, xref, {
1736         apRef,
1737         oldAnnotation,
1738       });
1739       await writeObject(apRef, ap, buffer, xref);
1740       dependencies.push({ ref: apRef, data: buffer.join("") });
1741     } else {
1742       annotationDict = this.createNewDict(annotation, xref, { oldAnnotation });
1743     }
1744     if (Number.isInteger(annotation.parentTreeId)) {
1745       annotationDict.set("StructParent", annotation.parentTreeId);
1746     }
1747 
1748     buffer.length = 0;
1749     await writeObject(annotationRef, annotationDict, buffer, xref);
1750 
1751     return { ref: annotationRef, data: buffer.join("") };
1752   }
1753 
1754   static async createNewPrintAnnotation(
1755     annotationGlobals,
1756     xref,
1757     annotation,
1758     params
1759   ) {
1760     const ap = await this.createNewAppearanceStream(annotation, xref, params);
1761     const annotationDict = this.createNewDict(annotation, xref, { ap });
1762 
1763     const newAnnotation = new this.prototype.constructor({
1764       dict: annotationDict,
1765       xref,
1766       annotationGlobals,
1767       evaluatorOptions: params.evaluatorOptions,
1768     });
1769 
1770     if (annotation.ref) {
1771       newAnnotation.ref = newAnnotation.refToReplace = annotation.ref;
1772     }
1773 
1774     return newAnnotation;
1775   }
1776 }
1777 
1778 class WidgetAnnotation extends Annotation {
1779   constructor(params) {
1780     super(params);
1781 
1782     const { dict, xref, annotationGlobals } = params;
1783     const data = this.data;
1784     this._needAppearances = params.needAppearances;
1785 
1786     data.annotationType = AnnotationType.WIDGET;
1787     if (data.fieldName === undefined) {
1788       data.fieldName = this._constructFieldName(dict);
1789     }
1790 
1791     if (data.actions === undefined) {
1792       data.actions = collectActions(xref, dict, AnnotationActionEventType);
1793     }
1794 
1795     let fieldValue = getInheritableProperty({
1796       dict,
1797       key: "V",
1798       getArray: true,
1799     });
1800     data.fieldValue = this._decodeFormValue(fieldValue);
1801 
1802     const defaultFieldValue = getInheritableProperty({
1803       dict,
1804       key: "DV",
1805       getArray: true,
1806     });
1807     data.defaultFieldValue = this._decodeFormValue(defaultFieldValue);
1808 
1809     if (fieldValue === undefined && annotationGlobals.xfaDatasets) {
1810       // Try to figure out if we have something in the xfa dataset.
1811       const path = this._title.str;
1812       if (path) {
1813         this._hasValueFromXFA = true;
1814         data.fieldValue = fieldValue =
1815           annotationGlobals.xfaDatasets.getValue(path);
1816       }
1817     }
1818 
1819     // When no "V" entry exists, let the fieldValue fallback to the "DV" entry
1820     // (fixes issue13823.pdf).
1821     if (fieldValue === undefined && data.defaultFieldValue !== null) {
1822       data.fieldValue = data.defaultFieldValue;
1823     }
1824 
1825     data.alternativeText = stringToPDFString(dict.get("TU") || "");
1826 
1827     this.setDefaultAppearance(params);
1828 
1829     data.hasAppearance ||=
1830       this._needAppearances &&
1831       data.fieldValue !== undefined &&
1832       data.fieldValue !== null;
1833 
1834     const fieldType = getInheritableProperty({ dict, key: "FT" });
1835     data.fieldType = fieldType instanceof Name ? fieldType.name : null;
1836 
1837     const localResources = getInheritableProperty({ dict, key: "DR" });
1838     const acroFormResources = annotationGlobals.acroForm.get("DR");
1839     const appearanceResources = this.appearance?.dict.get("Resources");
1840 
1841     this._fieldResources = {
1842       localResources,
1843       acroFormResources,
1844       appearanceResources,
1845       mergedResources: Dict.merge({
1846         xref,
1847         dictArray: [localResources, appearanceResources, acroFormResources],
1848         mergeSubDicts: true,
1849       }),
1850     };
1851 
1852     data.fieldFlags = getInheritableProperty({ dict, key: "Ff" });
1853     if (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) {
1854       data.fieldFlags = 0;
1855     }
1856 
1857     data.readOnly = this.hasFieldFlag(AnnotationFieldFlag.READONLY);
1858     data.required = this.hasFieldFlag(AnnotationFieldFlag.REQUIRED);
1859     data.hidden =
1860       this._hasFlag(data.annotationFlags, AnnotationFlag.HIDDEN) ||
1861       this._hasFlag(data.annotationFlags, AnnotationFlag.NOVIEW);
1862   }
1863 
1864   /**
1865    * Decode the given form value.
1866    *
1867    * @private
1868    * @memberof WidgetAnnotation
1869    * @param {Array<string>|Name|string} formValue - The (possibly encoded)
1870    *   form value.
1871    * @returns {Array<string>|string|null}
1872    */
1873   _decodeFormValue(formValue) {
1874     if (Array.isArray(formValue)) {
1875       return formValue
1876         .filter(item => typeof item === "string")
1877         .map(item => stringToPDFString(item));
1878     } else if (formValue instanceof Name) {
1879       return stringToPDFString(formValue.name);
1880     } else if (typeof formValue === "string") {
1881       return stringToPDFString(formValue);
1882     }
1883     return null;
1884   }
1885 
1886   /**
1887    * Check if a provided field flag is set.
1888    *
1889    * @public
1890    * @memberof WidgetAnnotation
1891    * @param {number} flag - Hexadecimal representation for an annotation
1892    *                        field characteristic
1893    * @returns {boolean}
1894    * @see {@link shared/util.js}
1895    */
1896   hasFieldFlag(flag) {
1897     return !!(this.data.fieldFlags & flag);
1898   }
1899 
1900   /** @inheritdoc */
1901   _isViewable(flags) {
1902     // We don't take into account the `NOVIEW` or `HIDDEN` flags here,
1903     // since the visibility can be changed by js code, hence in case
1904     // it's made viewable, we should render it (with visibility set to
1905     // hidden).
1906     // We don't take into account the `INVISIBLE` flag here, since we've a known
1907     // annotation type.
1908     return true;
1909   }
1910 
1911   /** @inheritdoc */
1912   mustBeViewed(annotationStorage, renderForms) {
1913     if (renderForms) {
1914       return this.viewable;
1915     }
1916     return (
1917       super.mustBeViewed(annotationStorage, renderForms) &&
1918       !this._hasFlag(this.flags, AnnotationFlag.NOVIEW)
1919     );
1920   }
1921 
1922   getRotationMatrix(annotationStorage) {
1923     let rotation = annotationStorage?.get(this.data.id)?.rotation;
1924     if (rotation === undefined) {
1925       rotation = this.rotation;
1926     }
1927 
1928     if (rotation === 0) {
1929       return IDENTITY_MATRIX;
1930     }
1931 
1932     const width = this.data.rect[2] - this.data.rect[0];
1933     const height = this.data.rect[3] - this.data.rect[1];
1934 
1935     return getRotationMatrix(rotation, width, height);
1936   }
1937 
1938   getBorderAndBackgroundAppearances(annotationStorage) {
1939     let rotation = annotationStorage?.get(this.data.id)?.rotation;
1940     if (rotation === undefined) {
1941       rotation = this.rotation;
1942     }
1943 
1944     if (!this.backgroundColor && !this.borderColor) {
1945       return "";
1946     }
1947     const width = this.data.rect[2] - this.data.rect[0];
1948     const height = this.data.rect[3] - this.data.rect[1];
1949     const rect =
1950       rotation === 0 || rotation === 180
1951         ? `0 0 ${width} ${height} re`
1952         : `0 0 ${height} ${width} re`;
1953 
1954     let str = "";
1955     if (this.backgroundColor) {
1956       str = `${getPdfColor(
1957         this.backgroundColor,
1958         /* isFill */ true
1959       )} ${rect} f `;
1960     }
1961 
1962     if (this.borderColor) {
1963       const borderWidth = this.borderStyle.width || 1;
1964       str += `${borderWidth} w ${getPdfColor(
1965         this.borderColor,
1966         /* isFill */ false
1967       )} ${rect} S `;
1968     }
1969 
1970     return str;
1971   }
1972 
1973   async getOperatorList(evaluator, task, intent, annotationStorage) {
1974     // Do not render form elements on the canvas when interactive forms are
1975     // enabled. The display layer is responsible for rendering them instead.
1976     if (
1977       intent & RenderingIntentFlag.ANNOTATIONS_FORMS &&
1978       !(this instanceof SignatureWidgetAnnotation) &&
1979       !this.data.noHTML &&
1980       !this.data.hasOwnCanvas
1981     ) {
1982       return {
1983         opList: new OperatorList(),
1984         separateForm: true,
1985         separateCanvas: false,
1986       };
1987     }
1988 
1989     if (!this._hasText) {
1990       return super.getOperatorList(evaluator, task, intent, annotationStorage);
1991     }
1992 
1993     const content = await this._getAppearance(
1994       evaluator,
1995       task,
1996       intent,
1997       annotationStorage
1998     );
1999     if (this.appearance && content === null) {
2000       return super.getOperatorList(evaluator, task, intent, annotationStorage);
2001     }
2002 
2003     const opList = new OperatorList();
2004 
2005     // Even if there is an appearance stream, ignore it. This is the
2006     // behaviour used by Adobe Reader.
2007     if (!this._defaultAppearance || content === null) {
2008       return { opList, separateForm: false, separateCanvas: false };
2009     }
2010 
2011     const isUsingOwnCanvas = !!(
2012       this.data.hasOwnCanvas && intent & RenderingIntentFlag.DISPLAY
2013     );
2014 
2015     const matrix = [1, 0, 0, 1, 0, 0];
2016     const bbox = [
2017       0,
2018       0,
2019       this.data.rect[2] - this.data.rect[0],
2020       this.data.rect[3] - this.data.rect[1],
2021     ];
2022     const transform = getTransformMatrix(this.data.rect, bbox, matrix);
2023 
2024     let optionalContent;
2025     if (this.oc) {
2026       optionalContent = await evaluator.parseMarkedContentProps(
2027         this.oc,
2028         /* resources = */ null
2029       );
2030     }
2031     if (optionalContent !== undefined) {
2032       opList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
2033     }
2034 
2035     opList.addOp(OPS.beginAnnotation, [
2036       this.data.id,
2037       this.data.rect,
2038       transform,
2039       this.getRotationMatrix(annotationStorage),
2040       isUsingOwnCanvas,
2041     ]);
2042 
2043     const stream = new StringStream(content);
2044     await evaluator.getOperatorList({
2045       stream,
2046       task,
2047       resources: this._fieldResources.mergedResources,
2048       operatorList: opList,
2049     });
2050     opList.addOp(OPS.endAnnotation, []);
2051 
2052     if (optionalContent !== undefined) {
2053       opList.addOp(OPS.endMarkedContent, []);
2054     }
2055     return { opList, separateForm: false, separateCanvas: isUsingOwnCanvas };
2056   }
2057 
2058   _getMKDict(rotation) {
2059     const mk = new Dict(null);
2060     if (rotation) {
2061       mk.set("R", rotation);
2062     }
2063     if (this.borderColor) {
2064       mk.set("BC", getPdfColorArray(this.borderColor));
2065     }
2066     if (this.backgroundColor) {
2067       mk.set("BG", getPdfColorArray(this.backgroundColor));
2068     }
2069     return mk.size > 0 ? mk : null;
2070   }
2071 
2072   amendSavedDict(annotationStorage, dict) {}
2073 
2074   async save(evaluator, task, annotationStorage) {
2075     const storageEntry = annotationStorage?.get(this.data.id);
2076     let value = storageEntry?.value,
2077       rotation = storageEntry?.rotation;
2078     if (value === this.data.fieldValue || value === undefined) {
2079       if (!this._hasValueFromXFA && rotation === undefined) {
2080         return null;
2081       }
2082       value ||= this.data.fieldValue;
2083     }
2084 
2085     // Value can be an array (with choice list and multiple selections)
2086     if (
2087       rotation === undefined &&
2088       !this._hasValueFromXFA &&
2089       Array.isArray(value) &&
2090       Array.isArray(this.data.fieldValue) &&
2091       value.length === this.data.fieldValue.length &&
2092       value.every((x, i) => x === this.data.fieldValue[i])
2093     ) {
2094       return null;
2095     }
2096 
2097     if (rotation === undefined) {
2098       rotation = this.rotation;
2099     }
2100 
2101     let appearance = null;
2102     if (!this._needAppearances) {
2103       appearance = await this._getAppearance(
2104         evaluator,
2105         task,
2106         RenderingIntentFlag.SAVE,
2107         annotationStorage
2108       );
2109       if (appearance === null) {
2110         // Appearance didn't change.
2111         return null;
2112       }
2113     } else {
2114       // No need to create an appearance: the pdf has the flag /NeedAppearances
2115       // which means that it's up to the reader to produce an appearance.
2116     }
2117 
2118     let needAppearances = false;
2119     if (appearance?.needAppearances) {
2120       needAppearances = true;
2121       appearance = null;
2122     }
2123 
2124     const { xref } = evaluator;
2125 
2126     const originalDict = xref.fetchIfRef(this.ref);
2127     if (!(originalDict instanceof Dict)) {
2128       return null;
2129     }
2130 
2131     const dict = new Dict(xref);
2132     for (const key of originalDict.getKeys()) {
2133       if (key !== "AP") {
2134         dict.set(key, originalDict.getRaw(key));
2135       }
2136     }
2137 
2138     const xfa = {
2139       path: this.data.fieldName,
2140       value,
2141     };
2142 
2143     dict.set(
2144       "V",
2145       Array.isArray(value)
2146         ? value.map(stringToAsciiOrUTF16BE)
2147         : stringToAsciiOrUTF16BE(value)
2148     );
2149     this.amendSavedDict(annotationStorage, dict);
2150 
2151     const maybeMK = this._getMKDict(rotation);
2152     if (maybeMK) {
2153       dict.set("MK", maybeMK);
2154     }
2155 
2156     const buffer = [];
2157     const changes = [
2158       // data for the original object
2159       // V field changed + reference for new AP
2160       { ref: this.ref, data: "", xfa, needAppearances },
2161     ];
2162     if (appearance !== null) {
2163       const newRef = xref.getNewTemporaryRef();
2164       const AP = new Dict(xref);
2165       dict.set("AP", AP);
2166       AP.set("N", newRef);
2167 
2168       const resources = this._getSaveFieldResources(xref);
2169       const appearanceStream = new StringStream(appearance);
2170       const appearanceDict = (appearanceStream.dict = new Dict(xref));
2171       appearanceDict.set("Subtype", Name.get("Form"));
2172       appearanceDict.set("Resources", resources);
2173       appearanceDict.set("BBox", [
2174         0,
2175         0,
2176         this.data.rect[2] - this.data.rect[0],
2177         this.data.rect[3] - this.data.rect[1],
2178       ]);
2179 
2180       const rotationMatrix = this.getRotationMatrix(annotationStorage);
2181       if (rotationMatrix !== IDENTITY_MATRIX) {
2182         // The matrix isn't the identity one.
2183         appearanceDict.set("Matrix", rotationMatrix);
2184       }
2185 
2186       await writeObject(newRef, appearanceStream, buffer, xref);
2187 
2188       changes.push(
2189         // data for the new AP
2190         {
2191           ref: newRef,
2192           data: buffer.join(""),
2193           xfa: null,
2194           needAppearances: false,
2195         }
2196       );
2197       buffer.length = 0;
2198     }
2199 
2200     dict.set("M", `D:${getModificationDate()}`);
2201     await writeObject(this.ref, dict, buffer, xref);
2202 
2203     changes[0].data = buffer.join("");
2204 
2205     return changes;
2206   }
2207 
2208   async _getAppearance(evaluator, task, intent, annotationStorage) {
2209     const isPassword = this.hasFieldFlag(AnnotationFieldFlag.PASSWORD);
2210     if (isPassword) {
2211       return null;
2212     }
2213     const storageEntry = annotationStorage?.get(this.data.id);
2214     let value, rotation;
2215     if (storageEntry) {
2216       value = storageEntry.formattedValue || storageEntry.value;
2217       rotation = storageEntry.rotation;
2218     }
2219 
2220     if (
2221       rotation === undefined &&
2222       value === undefined &&
2223       !this._needAppearances
2224     ) {
2225       if (!this._hasValueFromXFA || this.appearance) {
2226         // The annotation hasn't been rendered so use the appearance.
2227         return null;
2228       }
2229     }
2230 
2231     // Empty or it has a trailing whitespace.
2232     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2233 
2234     if (value === undefined) {
2235       // The annotation has its value in XFA datasets but not in the V field.
2236       value = this.data.fieldValue;
2237       if (!value) {
2238         return `/Tx BMC q ${colors}Q EMC`;
2239       }
2240     }
2241 
2242     if (Array.isArray(value) && value.length === 1) {
2243       value = value[0];
2244     }
2245 
2246     assert(typeof value === "string", "Expected `value` to be a string.");
2247     value = value.trim();
2248 
2249     if (this.data.combo) {
2250       // The value can be one of the exportValue or any other values.
2251       const option = this.data.options.find(
2252         ({ exportValue }) => value === exportValue
2253       );
2254       value = option?.displayValue || value;
2255     }
2256 
2257     if (value === "") {
2258       // the field is empty: nothing to render
2259       return `/Tx BMC q ${colors}Q EMC`;
2260     }
2261 
2262     if (rotation === undefined) {
2263       rotation = this.rotation;
2264     }
2265 
2266     let lineCount = -1;
2267     let lines;
2268 
2269     // We could have a text containing for example some sequences of chars and
2270     // their diacritics (e.g. "é".normalize("NFKD") shows 1 char when it's 2).
2271     // Positioning diacritics is really something we don't want to do here.
2272     // So if a font has a glyph for a acute accent and one for "e" then we won't
2273     // get any encoding issues but we'll render "e" and then "´".
2274     // It's why we normalize the string. We use NFC to preserve the initial
2275     // string, (e.g. "²".normalize("NFC") === "²"
2276     // but "²".normalize("NFKC") === "2").
2277     //
2278     // TODO: it isn't a perfect solution, some chars like "ẹ́" will be
2279     // decomposed into two chars ("ẹ" and "´"), so we should detect such
2280     // situations and then use either FakeUnicodeFont or set the
2281     // /NeedAppearances flag.
2282     if (this.data.multiLine) {
2283       lines = value.split(/\r\n?|\n/).map(line => line.normalize("NFC"));
2284       lineCount = lines.length;
2285     } else {
2286       lines = [value.replace(/\r\n?|\n/, "").normalize("NFC")];
2287     }
2288 
2289     const defaultPadding = 1;
2290     const defaultHPadding = 2;
2291     let totalHeight = this.data.rect[3] - this.data.rect[1];
2292     let totalWidth = this.data.rect[2] - this.data.rect[0];
2293 
2294     if (rotation === 90 || rotation === 270) {
2295       [totalWidth, totalHeight] = [totalHeight, totalWidth];
2296     }
2297 
2298     if (!this._defaultAppearance) {
2299       // The DA is required and must be a string.
2300       // If there is no font named Helvetica in the resource dictionary,
2301       // the evaluator will fall back to a default font.
2302       // Doing so prevents exceptions and allows saving/printing
2303       // the file as expected.
2304       this.data.defaultAppearanceData = parseDefaultAppearance(
2305         (this._defaultAppearance = "/Helvetica 0 Tf 0 g")
2306       );
2307     }
2308 
2309     let font = await WidgetAnnotation._getFontData(
2310       evaluator,
2311       task,
2312       this.data.defaultAppearanceData,
2313       this._fieldResources.mergedResources
2314     );
2315 
2316     let defaultAppearance, fontSize, lineHeight;
2317     const encodedLines = [];
2318     let encodingError = false;
2319     for (const line of lines) {
2320       const encodedString = font.encodeString(line);
2321       if (encodedString.length > 1) {
2322         encodingError = true;
2323       }
2324       encodedLines.push(encodedString.join(""));
2325     }
2326 
2327     if (encodingError && intent & RenderingIntentFlag.SAVE) {
2328       // We don't have a way to render the field, so we just rely on the
2329       // /NeedAppearances trick to let the different sofware correctly render
2330       // this pdf.
2331       return { needAppearances: true };
2332     }
2333 
2334     // We check that the font is able to encode the string.
2335     if (encodingError && this._isOffscreenCanvasSupported) {
2336       // If it can't then we fallback on fake unicode font (mapped to sans-serif
2337       // for the rendering).
2338       // It means that a printed form can be rendered differently (it depends on
2339       // the sans-serif font) but at least we've something to render.
2340       // In an ideal world the associated font should correctly handle the
2341       // possible chars but a user can add a smiley or whatever.
2342       // We could try to embed a font but it means that we must have access
2343       // to the raw font file.
2344       const fontFamily = this.data.comb ? "monospace" : "sans-serif";
2345       const fakeUnicodeFont = new FakeUnicodeFont(evaluator.xref, fontFamily);
2346       const resources = fakeUnicodeFont.createFontResources(lines.join(""));
2347       const newFont = resources.getRaw("Font");
2348 
2349       if (this._fieldResources.mergedResources.has("Font")) {
2350         const oldFont = this._fieldResources.mergedResources.get("Font");
2351         for (const key of newFont.getKeys()) {
2352           oldFont.set(key, newFont.getRaw(key));
2353         }
2354       } else {
2355         this._fieldResources.mergedResources.set("Font", newFont);
2356       }
2357 
2358       const fontName = fakeUnicodeFont.fontName.name;
2359       font = await WidgetAnnotation._getFontData(
2360         evaluator,
2361         task,
2362         { fontName, fontSize: 0 },
2363         resources
2364       );
2365 
2366       for (let i = 0, ii = encodedLines.length; i < ii; i++) {
2367         encodedLines[i] = stringToUTF16String(lines[i]);
2368       }
2369 
2370       const savedDefaultAppearance = Object.assign(
2371         Object.create(null),
2372         this.data.defaultAppearanceData
2373       );
2374       this.data.defaultAppearanceData.fontSize = 0;
2375       this.data.defaultAppearanceData.fontName = fontName;
2376 
2377       [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(
2378         totalHeight - 2 * defaultPadding,
2379         totalWidth - 2 * defaultHPadding,
2380         value,
2381         font,
2382         lineCount
2383       );
2384 
2385       this.data.defaultAppearanceData = savedDefaultAppearance;
2386     } else {
2387       if (!this._isOffscreenCanvasSupported) {
2388         warn(
2389           "_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly."
2390         );
2391       }
2392 
2393       [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(
2394         totalHeight - 2 * defaultPadding,
2395         totalWidth - 2 * defaultHPadding,
2396         value,
2397         font,
2398         lineCount
2399       );
2400     }
2401 
2402     let descent = font.descent;
2403     if (isNaN(descent)) {
2404       descent = BASELINE_FACTOR * lineHeight;
2405     } else {
2406       descent = Math.max(
2407         BASELINE_FACTOR * lineHeight,
2408         Math.abs(descent) * fontSize
2409       );
2410     }
2411 
2412     // Take into account the space we have to compute the default vertical
2413     // padding.
2414     const defaultVPadding = Math.min(
2415       Math.floor((totalHeight - fontSize) / 2),
2416       defaultPadding
2417     );
2418     const alignment = this.data.textAlignment;
2419 
2420     if (this.data.multiLine) {
2421       return this._getMultilineAppearance(
2422         defaultAppearance,
2423         encodedLines,
2424         font,
2425         fontSize,
2426         totalWidth,
2427         totalHeight,
2428         alignment,
2429         defaultHPadding,
2430         defaultVPadding,
2431         descent,
2432         lineHeight,
2433         annotationStorage
2434       );
2435     }
2436 
2437     if (this.data.comb) {
2438       return this._getCombAppearance(
2439         defaultAppearance,
2440         font,
2441         encodedLines[0],
2442         fontSize,
2443         totalWidth,
2444         totalHeight,
2445         defaultHPadding,
2446         defaultVPadding,
2447         descent,
2448         lineHeight,
2449         annotationStorage
2450       );
2451     }
2452 
2453     const bottomPadding = defaultVPadding + descent;
2454     if (alignment === 0 || alignment > 2) {
2455       // Left alignment: nothing to do
2456       return (
2457         `/Tx BMC q ${colors}BT ` +
2458         defaultAppearance +
2459         ` 1 0 0 1 ${numberToString(defaultHPadding)} ${numberToString(
2460           bottomPadding
2461         )} Tm (${escapeString(encodedLines[0])}) Tj` +
2462         " ET Q EMC"
2463       );
2464     }
2465 
2466     const prevInfo = { shift: 0 };
2467     const renderedText = this._renderText(
2468       encodedLines[0],
2469       font,
2470       fontSize,
2471       totalWidth,
2472       alignment,
2473       prevInfo,
2474       defaultHPadding,
2475       bottomPadding
2476     );
2477     return (
2478       `/Tx BMC q ${colors}BT ` +
2479       defaultAppearance +
2480       ` 1 0 0 1 0 0 Tm ${renderedText}` +
2481       " ET Q EMC"
2482     );
2483   }
2484 
2485   static async _getFontData(evaluator, task, appearanceData, resources) {
2486     const operatorList = new OperatorList();
2487     const initialState = {
2488       font: null,
2489       clone() {
2490         return this;
2491       },
2492     };
2493 
2494     const { fontName, fontSize } = appearanceData;
2495     await evaluator.handleSetFont(
2496       resources,
2497       [fontName && Name.get(fontName), fontSize],
2498       /* fontRef = */ null,
2499       operatorList,
2500       task,
2501       initialState,
2502       /* fallbackFontDict = */ null
2503     );
2504 
2505     return initialState.font;
2506   }
2507 
2508   _getTextWidth(text, font) {
2509     return (
2510       font
2511         .charsToGlyphs(text)
2512         .reduce((width, glyph) => width + glyph.width, 0) / 1000
2513     );
2514   }
2515 
2516   _computeFontSize(height, width, text, font, lineCount) {
2517     let { fontSize } = this.data.defaultAppearanceData;
2518     let lineHeight = (fontSize || 12) * LINE_FACTOR,
2519       numberOfLines = Math.round(height / lineHeight);
2520 
2521     if (!fontSize) {
2522       // A zero value for size means that the font shall be auto-sized:
2523       // its size shall be computed as a function of the height of the
2524       // annotation rectangle (see 12.7.3.3).
2525 
2526       const roundWithTwoDigits = x => Math.floor(x * 100) / 100;
2527 
2528       if (lineCount === -1) {
2529         // Get the text width for a font size of 1.
2530         const textWidth = this._getTextWidth(text, font);
2531 
2532         // width / textWidth is the max font size to fit the width.
2533         // height / LINE_FACTOR is the max font size to fit the height.
2534         fontSize = roundWithTwoDigits(
2535           Math.min(height / LINE_FACTOR, width / textWidth)
2536         );
2537         numberOfLines = 1;
2538       } else {
2539         const lines = text.split(/\r\n?|\n/);
2540         const cachedLines = [];
2541         for (const line of lines) {
2542           const encoded = font.encodeString(line).join("");
2543           const glyphs = font.charsToGlyphs(encoded);
2544           const positions = font.getCharPositions(encoded);
2545           cachedLines.push({
2546             line: encoded,
2547             glyphs,
2548             positions,
2549           });
2550         }
2551 
2552         const isTooBig = fsize => {
2553           // Return true when the text doesn't fit the given height.
2554           let totalHeight = 0;
2555           for (const cache of cachedLines) {
2556             const chunks = this._splitLine(null, font, fsize, width, cache);
2557             totalHeight += chunks.length * fsize;
2558             if (totalHeight > height) {
2559               return true;
2560             }
2561           }
2562           return false;
2563         };
2564 
2565         // Hard to guess how many lines there are.
2566         // The field may have been sized to have 10 lines
2567         // and the user entered only 1 so if we get font size from
2568         // height and number of lines then we'll get something too big.
2569         // So we compute a fake number of lines based on height and
2570         // a font size equal to 12 (this is the default font size in
2571         // Acrobat).
2572         // Then we'll adjust font size to what we have really.
2573         numberOfLines = Math.max(numberOfLines, lineCount);
2574 
2575         while (true) {
2576           lineHeight = height / numberOfLines;
2577           fontSize = roundWithTwoDigits(lineHeight / LINE_FACTOR);
2578 
2579           if (isTooBig(fontSize)) {
2580             numberOfLines++;
2581             continue;
2582           }
2583 
2584           break;
2585         }
2586       }
2587 
2588       const { fontName, fontColor } = this.data.defaultAppearanceData;
2589       this._defaultAppearance = createDefaultAppearance({
2590         fontSize,
2591         fontName,
2592         fontColor,
2593       });
2594     }
2595 
2596     return [this._defaultAppearance, fontSize, height / numberOfLines];
2597   }
2598 
2599   _renderText(
2600     text,
2601     font,
2602     fontSize,
2603     totalWidth,
2604     alignment,
2605     prevInfo,
2606     hPadding,
2607     vPadding
2608   ) {
2609     // TODO: we need to take into account (if possible) how the text
2610     // is rendered. For example in arabic, the cumulated width of some
2611     // glyphs isn't equal to the width of the rendered glyphs because
2612     // of ligatures.
2613     let shift;
2614     if (alignment === 1) {
2615       // Center
2616       const width = this._getTextWidth(text, font) * fontSize;
2617       shift = (totalWidth - width) / 2;
2618     } else if (alignment === 2) {
2619       // Right
2620       const width = this._getTextWidth(text, font) * fontSize;
2621       shift = totalWidth - width - hPadding;
2622     } else {
2623       shift = hPadding;
2624     }
2625     const shiftStr = numberToString(shift - prevInfo.shift);
2626     prevInfo.shift = shift;
2627     vPadding = numberToString(vPadding);
2628 
2629     return `${shiftStr} ${vPadding} Td (${escapeString(text)}) Tj`;
2630   }
2631 
2632   /**
2633    * @private
2634    */
2635   _getSaveFieldResources(xref) {
2636     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
2637       assert(
2638         this.data.defaultAppearanceData,
2639         "Expected `_defaultAppearanceData` to have been set."
2640       );
2641     }
2642     const { localResources, appearanceResources, acroFormResources } =
2643       this._fieldResources;
2644 
2645     const fontName = this.data.defaultAppearanceData?.fontName;
2646     if (!fontName) {
2647       return localResources || Dict.empty;
2648     }
2649 
2650     for (const resources of [localResources, appearanceResources]) {
2651       if (resources instanceof Dict) {
2652         const localFont = resources.get("Font");
2653         if (localFont instanceof Dict && localFont.has(fontName)) {
2654           return resources;
2655         }
2656       }
2657     }
2658     if (acroFormResources instanceof Dict) {
2659       const acroFormFont = acroFormResources.get("Font");
2660       if (acroFormFont instanceof Dict && acroFormFont.has(fontName)) {
2661         const subFontDict = new Dict(xref);
2662         subFontDict.set(fontName, acroFormFont.getRaw(fontName));
2663 
2664         const subResourcesDict = new Dict(xref);
2665         subResourcesDict.set("Font", subFontDict);
2666 
2667         return Dict.merge({
2668           xref,
2669           dictArray: [subResourcesDict, localResources],
2670           mergeSubDicts: true,
2671         });
2672       }
2673     }
2674     return localResources || Dict.empty;
2675   }
2676 
2677   getFieldObject() {
2678     return null;
2679   }
2680 }
2681 
2682 class TextWidgetAnnotation extends WidgetAnnotation {
2683   constructor(params) {
2684     super(params);
2685 
2686     const { dict } = params;
2687 
2688     if (dict.has("PMD")) {
2689       // It's used to display a barcode but it isn't specified so we just hide
2690       // it to avoid any confusion.
2691       this.flags |= AnnotationFlag.HIDDEN;
2692       this.data.hidden = true;
2693       warn("Barcodes are not supported");
2694     }
2695 
2696     this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML;
2697     this._hasText = true;
2698 
2699     // The field value is always a string.
2700     if (typeof this.data.fieldValue !== "string") {
2701       this.data.fieldValue = "";
2702     }
2703 
2704     // Determine the alignment of text in the field.
2705     let alignment = getInheritableProperty({ dict, key: "Q" });
2706     if (!Number.isInteger(alignment) || alignment < 0 || alignment > 2) {
2707       alignment = null;
2708     }
2709     this.data.textAlignment = alignment;
2710 
2711     // Determine the maximum length of text in the field.
2712     let maximumLength = getInheritableProperty({ dict, key: "MaxLen" });
2713     if (!Number.isInteger(maximumLength) || maximumLength < 0) {
2714       maximumLength = 0;
2715     }
2716     this.data.maxLen = maximumLength;
2717 
2718     // Process field flags for the display layer.
2719     this.data.multiLine = this.hasFieldFlag(AnnotationFieldFlag.MULTILINE);
2720     this.data.comb =
2721       this.hasFieldFlag(AnnotationFieldFlag.COMB) &&
2722       !this.hasFieldFlag(AnnotationFieldFlag.MULTILINE) &&
2723       !this.hasFieldFlag(AnnotationFieldFlag.PASSWORD) &&
2724       !this.hasFieldFlag(AnnotationFieldFlag.FILESELECT) &&
2725       this.data.maxLen !== 0;
2726     this.data.doNotScroll = this.hasFieldFlag(AnnotationFieldFlag.DONOTSCROLL);
2727   }
2728 
2729   get hasTextContent() {
2730     return !!this.appearance && !this._needAppearances;
2731   }
2732 
2733   _getCombAppearance(
2734     defaultAppearance,
2735     font,
2736     text,
2737     fontSize,
2738     width,
2739     height,
2740     hPadding,
2741     vPadding,
2742     descent,
2743     lineHeight,
2744     annotationStorage
2745   ) {
2746     const combWidth = width / this.data.maxLen;
2747     // Empty or it has a trailing whitespace.
2748     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2749 
2750     const buf = [];
2751     const positions = font.getCharPositions(text);
2752     for (const [start, end] of positions) {
2753       buf.push(`(${escapeString(text.substring(start, end))}) Tj`);
2754     }
2755 
2756     const renderedComb = buf.join(` ${numberToString(combWidth)} 0 Td `);
2757     return (
2758       `/Tx BMC q ${colors}BT ` +
2759       defaultAppearance +
2760       ` 1 0 0 1 ${numberToString(hPadding)} ${numberToString(
2761         vPadding + descent
2762       )} Tm ${renderedComb}` +
2763       " ET Q EMC"
2764     );
2765   }
2766 
2767   _getMultilineAppearance(
2768     defaultAppearance,
2769     lines,
2770     font,
2771     fontSize,
2772     width,
2773     height,
2774     alignment,
2775     hPadding,
2776     vPadding,
2777     descent,
2778     lineHeight,
2779     annotationStorage
2780   ) {
2781     const buf = [];
2782     const totalWidth = width - 2 * hPadding;
2783     const prevInfo = { shift: 0 };
2784     for (let i = 0, ii = lines.length; i < ii; i++) {
2785       const line = lines[i];
2786       const chunks = this._splitLine(line, font, fontSize, totalWidth);
2787       for (let j = 0, jj = chunks.length; j < jj; j++) {
2788         const chunk = chunks[j];
2789         const vShift =
2790           i === 0 && j === 0 ? -vPadding - (lineHeight - descent) : -lineHeight;
2791         buf.push(
2792           this._renderText(
2793             chunk,
2794             font,
2795             fontSize,
2796             width,
2797             alignment,
2798             prevInfo,
2799             hPadding,
2800             vShift
2801           )
2802         );
2803       }
2804     }
2805 
2806     // Empty or it has a trailing whitespace.
2807     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2808     const renderedText = buf.join("\n");
2809 
2810     return (
2811       `/Tx BMC q ${colors}BT ` +
2812       defaultAppearance +
2813       ` 1 0 0 1 0 ${numberToString(height)} Tm ${renderedText}` +
2814       " ET Q EMC"
2815     );
2816   }
2817 
2818   _splitLine(line, font, fontSize, width, cache = {}) {
2819     line = cache.line || line;
2820 
2821     const glyphs = cache.glyphs || font.charsToGlyphs(line);
2822 
2823     if (glyphs.length <= 1) {
2824       // Nothing to split
2825       return [line];
2826     }
2827 
2828     const positions = cache.positions || font.getCharPositions(line);
2829     const scale = fontSize / 1000;
2830     const chunks = [];
2831 
2832     let lastSpacePosInStringStart = -1,
2833       lastSpacePosInStringEnd = -1,
2834       lastSpacePos = -1,
2835       startChunk = 0,
2836       currentWidth = 0;
2837 
2838     for (let i = 0, ii = glyphs.length; i < ii; i++) {
2839       const [start, end] = positions[i];
2840       const glyph = glyphs[i];
2841       const glyphWidth = glyph.width * scale;
2842       if (glyph.unicode === " ") {
2843         if (currentWidth + glyphWidth > width) {
2844           // We can break here
2845           chunks.push(line.substring(startChunk, start));
2846           startChunk = start;
2847           currentWidth = glyphWidth;
2848           lastSpacePosInStringStart = -1;
2849           lastSpacePos = -1;
2850         } else {
2851           currentWidth += glyphWidth;
2852           lastSpacePosInStringStart = start;
2853           lastSpacePosInStringEnd = end;
2854           lastSpacePos = i;
2855         }
2856       } else if (currentWidth + glyphWidth > width) {
2857         // We must break to the last white position (if available)
2858         if (lastSpacePosInStringStart !== -1) {
2859           chunks.push(line.substring(startChunk, lastSpacePosInStringEnd));
2860           startChunk = lastSpacePosInStringEnd;
2861           i = lastSpacePos + 1;
2862           lastSpacePosInStringStart = -1;
2863           currentWidth = 0;
2864         } else {
2865           // Just break in the middle of the word
2866           chunks.push(line.substring(startChunk, start));
2867           startChunk = start;
2868           currentWidth = glyphWidth;
2869         }
2870       } else {
2871         currentWidth += glyphWidth;
2872       }
2873     }
2874 
2875     if (startChunk < line.length) {
2876       chunks.push(line.substring(startChunk, line.length));
2877     }
2878 
2879     return chunks;
2880   }
2881 
2882   getFieldObject() {
2883     return {
2884       id: this.data.id,
2885       value: this.data.fieldValue,
2886       defaultValue: this.data.defaultFieldValue || "",
2887       multiline: this.data.multiLine,
2888       password: this.hasFieldFlag(AnnotationFieldFlag.PASSWORD),
2889       charLimit: this.data.maxLen,
2890       comb: this.data.comb,
2891       editable: !this.data.readOnly,
2892       hidden: this.data.hidden,
2893       name: this.data.fieldName,
2894       rect: this.data.rect,
2895       actions: this.data.actions,
2896       page: this.data.pageIndex,
2897       strokeColor: this.data.borderColor,
2898       fillColor: this.data.backgroundColor,
2899       rotation: this.rotation,
2900       type: "text",
2901     };
2902   }
2903 }
2904 
2905 class ButtonWidgetAnnotation extends WidgetAnnotation {
2906   constructor(params) {
2907     super(params);
2908 
2909     this.checkedAppearance = null;
2910     this.uncheckedAppearance = null;
2911 
2912     this.data.checkBox =
2913       !this.hasFieldFlag(AnnotationFieldFlag.RADIO) &&
2914       !this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2915     this.data.radioButton =
2916       this.hasFieldFlag(AnnotationFieldFlag.RADIO) &&
2917       !this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2918     this.data.pushButton = this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2919     this.data.isTooltipOnly = false;
2920 
2921     if (this.data.checkBox) {
2922       this._processCheckBox(params);
2923     } else if (this.data.radioButton) {
2924       this._processRadioButton(params);
2925     } else if (this.data.pushButton) {
2926       this.data.hasOwnCanvas = true;
2927       this.data.noHTML = false;
2928       this._processPushButton(params);
2929     } else {
2930       warn("Invalid field flags for button widget annotation");
2931     }
2932   }
2933 
2934   async getOperatorList(evaluator, task, intent, annotationStorage) {
2935     if (this.data.pushButton) {
2936       return super.getOperatorList(
2937         evaluator,
2938         task,
2939         intent,
2940         false, // we use normalAppearance to render the button
2941         annotationStorage
2942       );
2943     }
2944 
2945     let value = null;
2946     let rotation = null;
2947     if (annotationStorage) {
2948       const storageEntry = annotationStorage.get(this.data.id);
2949       value = storageEntry ? storageEntry.value : null;
2950       rotation = storageEntry ? storageEntry.rotation : null;
2951     }
2952 
2953     if (value === null && this.appearance) {
2954       // Nothing in the annotationStorage.
2955       // But we've a default appearance so use it.
2956       return super.getOperatorList(evaluator, task, intent, annotationStorage);
2957     }
2958 
2959     if (value === null || value === undefined) {
2960       // There is no default appearance so use the one derived
2961       // from the field value.
2962       value = this.data.checkBox
2963         ? this.data.fieldValue === this.data.exportValue
2964         : this.data.fieldValue === this.data.buttonValue;
2965     }
2966 
2967     const appearance = value
2968       ? this.checkedAppearance
2969       : this.uncheckedAppearance;
2970     if (appearance) {
2971       const savedAppearance = this.appearance;
2972       const savedMatrix = lookupMatrix(
2973         appearance.dict.getArray("Matrix"),
2974         IDENTITY_MATRIX
2975       );
2976 
2977       if (rotation) {
2978         appearance.dict.set(
2979           "Matrix",
2980           this.getRotationMatrix(annotationStorage)
2981         );
2982       }
2983 
2984       this.appearance = appearance;
2985       const operatorList = super.getOperatorList(
2986         evaluator,
2987         task,
2988         intent,
2989         annotationStorage
2990       );
2991       this.appearance = savedAppearance;
2992       appearance.dict.set("Matrix", savedMatrix);
2993       return operatorList;
2994     }
2995 
2996     // No appearance
2997     return {
2998       opList: new OperatorList(),
2999       separateForm: false,
3000       separateCanvas: false,
3001     };
3002   }
3003 
3004   async save(evaluator, task, annotationStorage) {
3005     if (this.data.checkBox) {
3006       return this._saveCheckbox(evaluator, task, annotationStorage);
3007     }
3008 
3009     if (this.data.radioButton) {
3010       return this._saveRadioButton(evaluator, task, annotationStorage);
3011     }
3012 
3013     // Nothing to save
3014     return null;
3015   }
3016 
3017   async _saveCheckbox(evaluator, task, annotationStorage) {
3018     if (!annotationStorage) {
3019       return null;
3020     }
3021     const storageEntry = annotationStorage.get(this.data.id);
3022     let rotation = storageEntry?.rotation,
3023       value = storageEntry?.value;
3024 
3025     if (rotation === undefined) {
3026       if (value === undefined) {
3027         return null;
3028       }
3029 
3030       const defaultValue = this.data.fieldValue === this.data.exportValue;
3031       if (defaultValue === value) {
3032         return null;
3033       }
3034     }
3035 
3036     const dict = evaluator.xref.fetchIfRef(this.ref);
3037     if (!(dict instanceof Dict)) {
3038       return null;
3039     }
3040 
3041     if (rotation === undefined) {
3042       rotation = this.rotation;
3043     }
3044     if (value === undefined) {
3045       value = this.data.fieldValue === this.data.exportValue;
3046     }
3047 
3048     const xfa = {
3049       path: this.data.fieldName,
3050       value: value ? this.data.exportValue : "",
3051     };
3052 
3053     const name = Name.get(value ? this.data.exportValue : "Off");
3054     dict.set("V", name);
3055     dict.set("AS", name);
3056     dict.set("M", `D:${getModificationDate()}`);
3057 
3058     const maybeMK = this._getMKDict(rotation);
3059     if (maybeMK) {
3060       dict.set("MK", maybeMK);
3061     }
3062 
3063     const buffer = [];
3064     await writeObject(this.ref, dict, buffer, evaluator.xref);
3065 
3066     return [{ ref: this.ref, data: buffer.join(""), xfa }];
3067   }
3068 
3069   async _saveRadioButton(evaluator, task, annotationStorage) {
3070     if (!annotationStorage) {
3071       return null;
3072     }
3073     const storageEntry = annotationStorage.get(this.data.id);
3074     let rotation = storageEntry?.rotation,
3075       value = storageEntry?.value;
3076 
3077     if (rotation === undefined) {
3078       if (value === undefined) {
3079         return null;
3080       }
3081 
3082       const defaultValue = this.data.fieldValue === this.data.buttonValue;
3083       if (defaultValue === value) {
3084         return null;
3085       }
3086     }
3087 
3088     const dict = evaluator.xref.fetchIfRef(this.ref);
3089     if (!(dict instanceof Dict)) {
3090       return null;
3091     }
3092 
3093     if (value === undefined) {
3094       value = this.data.fieldValue === this.data.buttonValue;
3095     }
3096 
3097     if (rotation === undefined) {
3098       rotation = this.rotation;
3099     }
3100 
3101     const xfa = {
3102       path: this.data.fieldName,
3103       value: value ? this.data.buttonValue : "",
3104     };
3105 
3106     const name = Name.get(value ? this.data.buttonValue : "Off");
3107     const buffer = [];
3108     let parentData = null;
3109 
3110     if (value) {
3111       if (this.parent instanceof Ref) {
3112         const parent = evaluator.xref.fetch(this.parent);
3113         parent.set("V", name);
3114         await writeObject(this.parent, parent, buffer, evaluator.xref);
3115         parentData = buffer.join("");
3116         buffer.length = 0;
3117       } else if (this.parent instanceof Dict) {
3118         this.parent.set("V", name);
3119       }
3120     }
3121 
3122     dict.set("AS", name);
3123     dict.set("M", `D:${getModificationDate()}`);
3124 
3125     const maybeMK = this._getMKDict(rotation);
3126     if (maybeMK) {
3127       dict.set("MK", maybeMK);
3128     }
3129 
3130     await writeObject(this.ref, dict, buffer, evaluator.xref);
3131     const newRefs = [{ ref: this.ref, data: buffer.join(""), xfa }];
3132     if (parentData) {
3133       newRefs.push({ ref: this.parent, data: parentData, xfa: null });
3134     }
3135 
3136     return newRefs;
3137   }
3138 
3139   _getDefaultCheckedAppearance(params, type) {
3140     const width = this.data.rect[2] - this.data.rect[0];
3141     const height = this.data.rect[3] - this.data.rect[1];
3142     const bbox = [0, 0, width, height];
3143 
3144     // Ratio used to have a mark slightly smaller than the bbox.
3145     const FONT_RATIO = 0.8;
3146     const fontSize = Math.min(width, height) * FONT_RATIO;
3147 
3148     // Char Metrics
3149     // Widths came from widths for ZapfDingbats.
3150     // Heights are guessed with Fontforge and FoxitDingbats.pfb.
3151     let metrics, char;
3152     if (type === "check") {
3153       // Char 33 (2713 in unicode)
3154       metrics = {
3155         width: 0.755 * fontSize,
3156         height: 0.705 * fontSize,
3157       };
3158       char = "\x33";
3159     } else if (type === "disc") {
3160       // Char 6C (25CF in unicode)
3161       metrics = {
3162         width: 0.791 * fontSize,
3163         height: 0.705 * fontSize,
3164       };
3165       char = "\x6C";
3166     } else {
3167       unreachable(`_getDefaultCheckedAppearance - unsupported type: ${type}`);
3168     }
3169 
3170     // Values to center the glyph in the bbox.
3171     const xShift = numberToString((width - metrics.width) / 2);
3172     const yShift = numberToString((height - metrics.height) / 2);
3173 
3174     const appearance = `q BT /PdfJsZaDb ${fontSize} Tf 0 g ${xShift} ${yShift} Td (${char}) Tj ET Q`;
3175 
3176     const appearanceStreamDict = new Dict(params.xref);
3177     appearanceStreamDict.set("FormType", 1);
3178     appearanceStreamDict.set("Subtype", Name.get("Form"));
3179     appearanceStreamDict.set("Type", Name.get("XObject"));
3180     appearanceStreamDict.set("BBox", bbox);
3181     appearanceStreamDict.set("Matrix", [1, 0, 0, 1, 0, 0]);
3182     appearanceStreamDict.set("Length", appearance.length);
3183 
3184     const resources = new Dict(params.xref);
3185     const font = new Dict(params.xref);
3186     font.set("PdfJsZaDb", this.fallbackFontDict);
3187     resources.set("Font", font);
3188 
3189     appearanceStreamDict.set("Resources", resources);
3190 
3191     this.checkedAppearance = new StringStream(appearance);
3192     this.checkedAppearance.dict = appearanceStreamDict;
3193 
3194     this._streams.push(this.checkedAppearance);
3195   }
3196 
3197   _processCheckBox(params) {
3198     const customAppearance = params.dict.get("AP");
3199     if (!(customAppearance instanceof Dict)) {
3200       return;
3201     }
3202 
3203     const normalAppearance = customAppearance.get("N");
3204     if (!(normalAppearance instanceof Dict)) {
3205       return;
3206     }
3207 
3208     // See https://bugzilla.mozilla.org/show_bug.cgi?id=1722036.
3209     // If we've an AS and a V then take AS.
3210     const asValue = this._decodeFormValue(params.dict.get("AS"));
3211     if (typeof asValue === "string") {
3212       this.data.fieldValue = asValue;
3213     }
3214 
3215     const yes =
3216       this.data.fieldValue !== null && this.data.fieldValue !== "Off"
3217         ? this.data.fieldValue
3218         : "Yes";
3219 
3220     const exportValues = normalAppearance.getKeys();
3221     if (exportValues.length === 0) {
3222       exportValues.push("Off", yes);
3223     } else if (exportValues.length === 1) {
3224       if (exportValues[0] === "Off") {
3225         exportValues.push(yes);
3226       } else {
3227         exportValues.unshift("Off");
3228       }
3229     } else if (exportValues.includes(yes)) {
3230       exportValues.length = 0;
3231       exportValues.push("Off", yes);
3232     } else {
3233       const otherYes = exportValues.find(v => v !== "Off");
3234       exportValues.length = 0;
3235       exportValues.push("Off", otherYes);
3236     }
3237 
3238     // Don't use a "V" entry pointing to a non-existent appearance state,
3239     // see e.g. bug1720411.pdf where it's an *empty* Name-instance.
3240     if (!exportValues.includes(this.data.fieldValue)) {
3241       this.data.fieldValue = "Off";
3242     }
3243 
3244     this.data.exportValue = exportValues[1];
3245 
3246     const checkedAppearance = normalAppearance.get(this.data.exportValue);
3247     this.checkedAppearance =
3248       checkedAppearance instanceof BaseStream ? checkedAppearance : null;
3249     const uncheckedAppearance = normalAppearance.get("Off");
3250     this.uncheckedAppearance =
3251       uncheckedAppearance instanceof BaseStream ? uncheckedAppearance : null;
3252 
3253     if (this.checkedAppearance) {
3254       this._streams.push(this.checkedAppearance);
3255     } else {
3256       this._getDefaultCheckedAppearance(params, "check");
3257     }
3258     if (this.uncheckedAppearance) {
3259       this._streams.push(this.uncheckedAppearance);
3260     }
3261     this._fallbackFontDict = this.fallbackFontDict;
3262     if (this.data.defaultFieldValue === null) {
3263       this.data.defaultFieldValue = "Off";
3264     }
3265   }
3266 
3267   _processRadioButton(params) {
3268     this.data.buttonValue = null;
3269 
3270     // The parent field's `V` entry holds a `Name` object with the appearance
3271     // state of whichever child field is currently in the "on" state.
3272     const fieldParent = params.dict.get("Parent");
3273     if (fieldParent instanceof Dict) {
3274       this.parent = params.dict.getRaw("Parent");
3275       const fieldParentValue = fieldParent.get("V");
3276       if (fieldParentValue instanceof Name) {
3277         this.data.fieldValue = this._decodeFormValue(fieldParentValue);
3278       }
3279     }
3280 
3281     // The button's value corresponds to its appearance state.
3282     const appearanceStates = params.dict.get("AP");
3283     if (!(appearanceStates instanceof Dict)) {
3284       return;
3285     }
3286     const normalAppearance = appearanceStates.get("N");
3287     if (!(normalAppearance instanceof Dict)) {
3288       return;
3289     }
3290     for (const key of normalAppearance.getKeys()) {
3291       if (key !== "Off") {
3292         this.data.buttonValue = this._decodeFormValue(key);
3293         break;
3294       }
3295     }
3296 
3297     const checkedAppearance = normalAppearance.get(this.data.buttonValue);
3298     this.checkedAppearance =
3299       checkedAppearance instanceof BaseStream ? checkedAppearance : null;
3300     const uncheckedAppearance = normalAppearance.get("Off");
3301     this.uncheckedAppearance =
3302       uncheckedAppearance instanceof BaseStream ? uncheckedAppearance : null;
3303 
3304     if (this.checkedAppearance) {
3305       this._streams.push(this.checkedAppearance);
3306     } else {
3307       this._getDefaultCheckedAppearance(params, "disc");
3308     }
3309     if (this.uncheckedAppearance) {
3310       this._streams.push(this.uncheckedAppearance);
3311     }
3312     this._fallbackFontDict = this.fallbackFontDict;
3313     if (this.data.defaultFieldValue === null) {
3314       this.data.defaultFieldValue = "Off";
3315     }
3316   }
3317 
3318   _processPushButton(params) {
3319     const { dict, annotationGlobals } = params;
3320 
3321     if (!dict.has("A") && !dict.has("AA") && !this.data.alternativeText) {
3322       warn("Push buttons without action dictionaries are not supported");
3323       return;
3324     }
3325 
3326     this.data.isTooltipOnly = !dict.has("A") && !dict.has("AA");
3327 
3328     Catalog.parseDestDictionary({
3329       destDict: dict,
3330       resultObj: this.data,
3331       docBaseUrl: annotationGlobals.baseUrl,
3332       docAttachments: annotationGlobals.attachments,
3333     });
3334   }
3335 
3336   getFieldObject() {
3337     let type = "button";
3338     let exportValues;
3339     if (this.data.checkBox) {
3340       type = "checkbox";
3341       exportValues = this.data.exportValue;
3342     } else if (this.data.radioButton) {
3343       type = "radiobutton";
3344       exportValues = this.data.buttonValue;
3345     }
3346     return {
3347       id: this.data.id,
3348       value: this.data.fieldValue || "Off",
3349       defaultValue: this.data.defaultFieldValue,
3350       exportValues,
3351       editable: !this.data.readOnly,
3352       name: this.data.fieldName,
3353       rect: this.data.rect,
3354       hidden: this.data.hidden,
3355       actions: this.data.actions,
3356       page: this.data.pageIndex,
3357       strokeColor: this.data.borderColor,
3358       fillColor: this.data.backgroundColor,
3359       rotation: this.rotation,
3360       type,
3361     };
3362   }
3363 
3364   get fallbackFontDict() {
3365     const dict = new Dict();
3366     dict.set("BaseFont", Name.get("ZapfDingbats"));
3367     dict.set("Type", Name.get("FallbackType"));
3368     dict.set("Subtype", Name.get("FallbackType"));
3369     dict.set("Encoding", Name.get("ZapfDingbatsEncoding"));
3370 
3371     return shadow(this, "fallbackFontDict", dict);
3372   }
3373 }
3374 
3375 class ChoiceWidgetAnnotation extends WidgetAnnotation {
3376   constructor(params) {
3377     super(params);
3378 
3379     const { dict, xref } = params;
3380 
3381     this.indices = dict.getArray("I");
3382     this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0;
3383 
3384     // Determine the options. The options array may consist of strings or
3385     // arrays. If the array consists of arrays, then the first element of
3386     // each array is the export value and the second element of each array is
3387     // the display value. If the array consists of strings, then these
3388     // represent both the export and display value. In this case, we convert
3389     // it to an array of arrays as well for convenience in the display layer.
3390     // Note that the specification does not state that the `Opt` field is
3391     // inheritable, but in practice PDF generators do make annotations
3392     // inherit the options from a parent annotation (issue 8094).
3393     this.data.options = [];
3394 
3395     const options = getInheritableProperty({ dict, key: "Opt" });
3396     if (Array.isArray(options)) {
3397       for (let i = 0, ii = options.length; i < ii; i++) {
3398         const option = xref.fetchIfRef(options[i]);
3399         const isOptionArray = Array.isArray(option);
3400 
3401         this.data.options[i] = {
3402           exportValue: this._decodeFormValue(
3403             isOptionArray ? xref.fetchIfRef(option[0]) : option
3404           ),
3405           displayValue: this._decodeFormValue(
3406             isOptionArray ? xref.fetchIfRef(option[1]) : option
3407           ),
3408         };
3409       }
3410     }
3411 
3412     if (!this.hasIndices) {
3413       // The field value can be `null` if no item is selected, a string if one
3414       // item is selected or an array of strings if multiple items are selected.
3415       // For consistency in the API and convenience in the display layer, we
3416       // always make the field value an array with zero, one or multiple items.
3417       if (typeof this.data.fieldValue === "string") {
3418         this.data.fieldValue = [this.data.fieldValue];
3419       } else if (!this.data.fieldValue) {
3420         this.data.fieldValue = [];
3421       }
3422     } else {
3423       // The specs say that we should have an indices array only with
3424       // multiselectable Choice and the "V" entry should have the
3425       // precedence, but Acrobat itself is using it whatever the
3426       // the "V" entry is (see bug 1770750).
3427       this.data.fieldValue = [];
3428       const ii = this.data.options.length;
3429       for (const i of this.indices) {
3430         if (Number.isInteger(i) && i >= 0 && i < ii) {
3431           this.data.fieldValue.push(this.data.options[i].exportValue);
3432         }
3433       }
3434     }
3435 
3436     // Process field flags for the display layer.
3437     this.data.combo = this.hasFieldFlag(AnnotationFieldFlag.COMBO);
3438     this.data.multiSelect = this.hasFieldFlag(AnnotationFieldFlag.MULTISELECT);
3439     this._hasText = true;
3440   }
3441 
3442   getFieldObject() {
3443     const type = this.data.combo ? "combobox" : "listbox";
3444     const value =
3445       this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
3446     return {
3447       id: this.data.id,
3448       value,
3449       defaultValue: this.data.defaultFieldValue,
3450       editable: !this.data.readOnly,
3451       name: this.data.fieldName,
3452       rect: this.data.rect,
3453       numItems: this.data.fieldValue.length,
3454       multipleSelection: this.data.multiSelect,
3455       hidden: this.data.hidden,
3456       actions: this.data.actions,
3457       items: this.data.options,
3458       page: this.data.pageIndex,
3459       strokeColor: this.data.borderColor,
3460       fillColor: this.data.backgroundColor,
3461       rotation: this.rotation,
3462       type,
3463     };
3464   }
3465 
3466   amendSavedDict(annotationStorage, dict) {
3467     if (!this.hasIndices) {
3468       return;
3469     }
3470     let values = annotationStorage?.get(this.data.id)?.value;
3471     if (!Array.isArray(values)) {
3472       values = [values];
3473     }
3474     const indices = [];
3475     const { options } = this.data;
3476     for (let i = 0, j = 0, ii = options.length; i < ii; i++) {
3477       if (options[i].exportValue === values[j]) {
3478         indices.push(i);
3479         j += 1;
3480       }
3481     }
3482     dict.set("I", indices);
3483   }
3484 
3485   async _getAppearance(evaluator, task, intent, annotationStorage) {
3486     if (this.data.combo) {
3487       return super._getAppearance(evaluator, task, intent, annotationStorage);
3488     }
3489 
3490     let exportedValue, rotation;
3491     const storageEntry = annotationStorage?.get(this.data.id);
3492     if (storageEntry) {
3493       rotation = storageEntry.rotation;
3494       exportedValue = storageEntry.value;
3495     }
3496 
3497     if (
3498       rotation === undefined &&
3499       exportedValue === undefined &&
3500       !this._needAppearances
3501     ) {
3502       // The annotation hasn't been rendered so use the appearance
3503       return null;
3504     }
3505 
3506     if (exportedValue === undefined) {
3507       exportedValue = this.data.fieldValue;
3508     } else if (!Array.isArray(exportedValue)) {
3509       exportedValue = [exportedValue];
3510     }
3511 
3512     const defaultPadding = 1;
3513     const defaultHPadding = 2;
3514     let totalHeight = this.data.rect[3] - this.data.rect[1];
3515     let totalWidth = this.data.rect[2] - this.data.rect[0];
3516 
3517     if (rotation === 90 || rotation === 270) {
3518       [totalWidth, totalHeight] = [totalHeight, totalWidth];
3519     }
3520 
3521     const lineCount = this.data.options.length;
3522     const valueIndices = [];
3523     for (let i = 0; i < lineCount; i++) {
3524       const { exportValue } = this.data.options[i];
3525       if (exportedValue.includes(exportValue)) {
3526         valueIndices.push(i);
3527       }
3528     }
3529 
3530     if (!this._defaultAppearance) {
3531       // The DA is required and must be a string.
3532       // If there is no font named Helvetica in the resource dictionary,
3533       // the evaluator will fall back to a default font.
3534       // Doing so prevents exceptions and allows saving/printing
3535       // the file as expected.
3536       this.data.defaultAppearanceData = parseDefaultAppearance(
3537         (this._defaultAppearance = "/Helvetica 0 Tf 0 g")
3538       );
3539     }
3540 
3541     const font = await WidgetAnnotation._getFontData(
3542       evaluator,
3543       task,
3544       this.data.defaultAppearanceData,
3545       this._fieldResources.mergedResources
3546     );
3547 
3548     let defaultAppearance;
3549     let { fontSize } = this.data.defaultAppearanceData;
3550     if (!fontSize) {
3551       const lineHeight = (totalHeight - defaultPadding) / lineCount;
3552       let lineWidth = -1;
3553       let value;
3554       for (const { displayValue } of this.data.options) {
3555         const width = this._getTextWidth(displayValue, font);
3556         if (width > lineWidth) {
3557           lineWidth = width;
3558           value = displayValue;
3559         }
3560       }
3561 
3562       [defaultAppearance, fontSize] = this._computeFontSize(
3563         lineHeight,
3564         totalWidth - 2 * defaultHPadding,
3565         value,
3566         font,
3567         -1
3568       );
3569     } else {
3570       defaultAppearance = this._defaultAppearance;
3571     }
3572 
3573     const lineHeight = fontSize * LINE_FACTOR;
3574     const vPadding = (lineHeight - fontSize) / 2;
3575     const numberOfVisibleLines = Math.floor(totalHeight / lineHeight);
3576 
3577     let firstIndex = 0;
3578     if (valueIndices.length > 0) {
3579       const minIndex = Math.min(...valueIndices);
3580       const maxIndex = Math.max(...valueIndices);
3581 
3582       firstIndex = Math.max(0, maxIndex - numberOfVisibleLines + 1);
3583       if (firstIndex > minIndex) {
3584         firstIndex = minIndex;
3585       }
3586     }
3587     const end = Math.min(firstIndex + numberOfVisibleLines + 1, lineCount);
3588 
3589     const buf = ["/Tx BMC q", `1 1 ${totalWidth} ${totalHeight} re W n`];
3590 
3591     if (valueIndices.length) {
3592       // This value has been copied/pasted from annotation-choice-widget.pdf.
3593       // It corresponds to rgb(153, 193, 218).
3594       buf.push("0.600006 0.756866 0.854904 rg");
3595 
3596       // Highlight the lines in filling a blue rectangle at the selected
3597       // positions.
3598       for (const index of valueIndices) {
3599         if (firstIndex <= index && index < end) {
3600           buf.push(
3601             `1 ${
3602               totalHeight - (index - firstIndex + 1) * lineHeight
3603             } ${totalWidth} ${lineHeight} re f`
3604           );
3605         }
3606       }
3607     }
3608     buf.push("BT", defaultAppearance, `1 0 0 1 0 ${totalHeight} Tm`);
3609 
3610     const prevInfo = { shift: 0 };
3611     for (let i = firstIndex; i < end; i++) {
3612       const { displayValue } = this.data.options[i];
3613       const vpadding = i === firstIndex ? vPadding : 0;
3614       buf.push(
3615         this._renderText(
3616           displayValue,
3617           font,
3618           fontSize,
3619           totalWidth,
3620           0,
3621           prevInfo,
3622           defaultHPadding,
3623           -lineHeight + vpadding
3624         )
3625       );
3626     }
3627 
3628     buf.push("ET Q EMC");
3629 
3630     return buf.join("\n");
3631   }
3632 }
3633 
3634 class SignatureWidgetAnnotation extends WidgetAnnotation {
3635   constructor(params) {
3636     super(params);
3637 
3638     // Unset the fieldValue since it's (most likely) a `Dict` which is
3639     // non-serializable and will thus cause errors when sending annotations
3640     // to the main-thread (issue 10347).
3641     this.data.fieldValue = null;
3642     this.data.hasOwnCanvas = this.data.noRotate;
3643     this.data.noHTML = !this.data.hasOwnCanvas;
3644   }
3645 
3646   getFieldObject() {
3647     return {
3648       id: this.data.id,
3649       value: null,
3650       page: this.data.pageIndex,
3651       type: "signature",
3652     };
3653   }
3654 }
3655 
3656 class TextAnnotation extends MarkupAnnotation {
3657   constructor(params) {
3658     const DEFAULT_ICON_SIZE = 22; // px
3659 
3660     super(params);
3661 
3662     // No rotation for Text (see 12.5.6.4).
3663     this.data.noRotate = true;
3664     this.data.hasOwnCanvas = this.data.noRotate;
3665     this.data.noHTML = false;
3666 
3667     const { dict } = params;
3668     this.data.annotationType = AnnotationType.TEXT;
3669 
3670     if (this.data.hasAppearance) {
3671       this.data.name = "NoIcon";
3672     } else {
3673       this.data.rect[1] = this.data.rect[3] - DEFAULT_ICON_SIZE;
3674       this.data.rect[2] = this.data.rect[0] + DEFAULT_ICON_SIZE;
3675       this.data.name = dict.has("Name") ? dict.get("Name").name : "Note";
3676     }
3677 
3678     if (dict.has("State")) {
3679       this.data.state = dict.get("State") || null;
3680       this.data.stateModel = dict.get("StateModel") || null;
3681     } else {
3682       this.data.state = null;
3683       this.data.stateModel = null;
3684     }
3685   }
3686 }
3687 
3688 class LinkAnnotation extends Annotation {
3689   constructor(params) {
3690     super(params);
3691 
3692     const { dict, annotationGlobals } = params;
3693     this.data.annotationType = AnnotationType.LINK;
3694 
3695     // A link is never rendered on the main canvas so we must render its HTML
3696     // version.
3697     this.data.noHTML = false;
3698 
3699     const quadPoints = getQuadPoints(dict, this.rectangle);
3700     if (quadPoints) {
3701       this.data.quadPoints = quadPoints;
3702     }
3703 
3704     // The color entry for a link annotation is the color of the border.
3705     this.data.borderColor ||= this.data.color;
3706 
3707     Catalog.parseDestDictionary({
3708       destDict: dict,
3709       resultObj: this.data,
3710       docBaseUrl: annotationGlobals.baseUrl,
3711       docAttachments: annotationGlobals.attachments,
3712     });
3713   }
3714 }
3715 
3716 class PopupAnnotation extends Annotation {
3717   constructor(params) {
3718     super(params);
3719 
3720     const { dict } = params;
3721     this.data.annotationType = AnnotationType.POPUP;
3722 
3723     // A pop-up is never rendered on the main canvas so we must render its HTML
3724     // version.
3725     this.data.noHTML = false;
3726 
3727     if (
3728       this.data.rect[0] === this.data.rect[2] ||
3729       this.data.rect[1] === this.data.rect[3]
3730     ) {
3731       this.data.rect = null;
3732     }
3733 
3734     let parentItem = dict.get("Parent");
3735     if (!parentItem) {
3736       warn("Popup annotation has a missing or invalid parent annotation.");
3737       return;
3738     }
3739     this.data.parentRect = lookupNormalRect(parentItem.getArray("Rect"), null);
3740 
3741     const rt = parentItem.get("RT");
3742     if (isName(rt, AnnotationReplyType.GROUP)) {
3743       // Subordinate annotations in a group should inherit
3744       // the group attributes from the primary annotation.
3745       parentItem = parentItem.get("IRT");
3746     }
3747 
3748     if (!parentItem.has("M")) {
3749       this.data.modificationDate = null;
3750     } else {
3751       this.setModificationDate(parentItem.get("M"));
3752       this.data.modificationDate = this.modificationDate;
3753     }
3754 
3755     if (!parentItem.has("C")) {
3756       // Fall back to the default background color.
3757       this.data.color = null;
3758     } else {
3759       this.setColor(parentItem.getArray("C"));
3760       this.data.color = this.color;
3761     }
3762 
3763     // If the Popup annotation is not viewable, but the parent annotation is,
3764     // that is most likely a bug. Fallback to inherit the flags from the parent
3765     // annotation (this is consistent with the behaviour in Adobe Reader).
3766     if (!this.viewable) {
3767       const parentFlags = parentItem.get("F");
3768       if (this._isViewable(parentFlags)) {
3769         this.setFlags(parentFlags);
3770       }
3771     }
3772 
3773     this.setTitle(parentItem.get("T"));
3774     this.data.titleObj = this._title;
3775 
3776     this.setContents(parentItem.get("Contents"));
3777     this.data.contentsObj = this._contents;
3778 
3779     if (parentItem.has("RC")) {
3780       this.data.richText = XFAFactory.getRichTextAsHtml(parentItem.get("RC"));
3781     }
3782 
3783     this.data.open = !!dict.get("Open");
3784   }
3785 }
3786 
3787 class FreeTextAnnotation extends MarkupAnnotation {
3788   constructor(params) {
3789     super(params);
3790 
3791     // It uses its own canvas in order to be hidden if edited.
3792     // But if it has the noHTML flag, it means that we don't want to be able
3793     // to modify it so we can just draw it on the main canvas.
3794     this.data.hasOwnCanvas = this.data.noRotate;
3795     this.data.isEditable = !this.data.noHTML;
3796     // We want to be able to add mouse listeners to the annotation.
3797     this.data.noHTML = false;
3798 
3799     const { evaluatorOptions, xref } = params;
3800     this.data.annotationType = AnnotationType.FREETEXT;
3801     this.setDefaultAppearance(params);
3802     this._hasAppearance = !!this.appearance;
3803 
3804     if (this._hasAppearance) {
3805       const { fontColor, fontSize } = parseAppearanceStream(
3806         this.appearance,
3807         evaluatorOptions,
3808         xref
3809       );
3810       this.data.defaultAppearanceData.fontColor = fontColor;
3811       this.data.defaultAppearanceData.fontSize = fontSize || 10;
3812     } else {
3813       this.data.defaultAppearanceData.fontSize ||= 10;
3814       const { fontColor, fontSize } = this.data.defaultAppearanceData;
3815       if (this._contents.str) {
3816         this.data.textContent = this._contents.str
3817           .split(/\r\n?|\n/)
3818           .map(line => line.trimEnd());
3819         const { coords, bbox, matrix } = FakeUnicodeFont.getFirstPositionInfo(
3820           this.rectangle,
3821           this.rotation,
3822           fontSize
3823         );
3824         this.data.textPosition = this._transformPoint(coords, bbox, matrix);
3825       }
3826       if (this._isOffscreenCanvasSupported) {
3827         const strokeAlpha = params.dict.get("CA");
3828         const fakeUnicodeFont = new FakeUnicodeFont(xref, "sans-serif");
3829         this.appearance = fakeUnicodeFont.createAppearance(
3830           this._contents.str,
3831           this.rectangle,
3832           this.rotation,
3833           fontSize,
3834           fontColor,
3835           strokeAlpha
3836         );
3837         this._streams.push(this.appearance);
3838       } else {
3839         warn(
3840           "FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly."
3841         );
3842       }
3843     }
3844   }
3845 
3846   get hasTextContent() {
3847     return this._hasAppearance;
3848   }
3849 
3850   static createNewDict(annotation, xref, { apRef, ap, oldAnnotation }) {
3851     const { color, fontSize, rect, rotation, user, value } = annotation;
3852     const freetext = oldAnnotation || new Dict(xref);
3853     freetext.set("Type", Name.get("Annot"));
3854     freetext.set("Subtype", Name.get("FreeText"));
3855     if (oldAnnotation) {
3856       freetext.set("M", `D:${getModificationDate()}`);
3857       // TODO: We should try to generate a new RC from the content we've.
3858       // For now we can just remove it to avoid any issues.
3859       freetext.delete("RC");
3860     } else {
3861       freetext.set("CreationDate", `D:${getModificationDate()}`);
3862     }
3863     freetext.set("Rect", rect);
3864     const da = `/Helv ${fontSize} Tf ${getPdfColor(color, /* isFill */ true)}`;
3865     freetext.set("DA", da);
3866     freetext.set("Contents", stringToAsciiOrUTF16BE(value));
3867     freetext.set("F", 4);
3868     freetext.set("Border", [0, 0, 0]);
3869     freetext.set("Rotate", rotation);
3870 
3871     if (user) {
3872       freetext.set("T", stringToAsciiOrUTF16BE(user));
3873     }
3874 
3875     if (apRef || ap) {
3876       const n = new Dict(xref);
3877       freetext.set("AP", n);
3878 
3879       if (apRef) {
3880         n.set("N", apRef);
3881       } else {
3882         n.set("N", ap);
3883       }
3884     }
3885 
3886     return freetext;
3887   }
3888 
3889   static async createNewAppearanceStream(annotation, xref, params) {
3890     const { baseFontRef, evaluator, task } = params;
3891     const { color, fontSize, rect, rotation, value } = annotation;
3892 
3893     const resources = new Dict(xref);
3894     const font = new Dict(xref);
3895 
3896     if (baseFontRef) {
3897       font.set("Helv", baseFontRef);
3898     } else {
3899       const baseFont = new Dict(xref);
3900       baseFont.set("BaseFont", Name.get("Helvetica"));
3901       baseFont.set("Type", Name.get("Font"));
3902       baseFont.set("Subtype", Name.get("Type1"));
3903       baseFont.set("Encoding", Name.get("WinAnsiEncoding"));
3904       font.set("Helv", baseFont);
3905     }
3906     resources.set("Font", font);
3907 
3908     const helv = await WidgetAnnotation._getFontData(
3909       evaluator,
3910       task,
3911       {
3912         fontName: "Helv",
3913         fontSize,
3914       },
3915       resources
3916     );
3917 
3918     const [x1, y1, x2, y2] = rect;
3919     let w = x2 - x1;
3920     let h = y2 - y1;
3921 
3922     if (rotation % 180 !== 0) {
3923       [w, h] = [h, w];
3924     }
3925 
3926     const lines = value.split("\n");
3927     const scale = fontSize / 1000;
3928     let totalWidth = -Infinity;
3929     const encodedLines = [];
3930     for (let line of lines) {
3931       const encoded = helv.encodeString(line);
3932       if (encoded.length > 1) {
3933         // The font doesn't contain all the chars.
3934         return null;
3935       }
3936       line = encoded.join("");
3937       encodedLines.push(line);
3938       let lineWidth = 0;
3939       const glyphs = helv.charsToGlyphs(line);
3940       for (const glyph of glyphs) {
3941         lineWidth += glyph.width * scale;
3942       }
3943       totalWidth = Math.max(totalWidth, lineWidth);
3944     }
3945 
3946     let hscale = 1;
3947     if (totalWidth > w) {
3948       hscale = w / totalWidth;
3949     }
3950     let vscale = 1;
3951     const lineHeight = LINE_FACTOR * fontSize;
3952     const lineAscent = (LINE_FACTOR - LINE_DESCENT_FACTOR) * fontSize;
3953     const totalHeight = lineHeight * lines.length;
3954     if (totalHeight > h) {
3955       vscale = h / totalHeight;
3956     }
3957     const fscale = Math.min(hscale, vscale);
3958     const newFontSize = fontSize * fscale;
3959     let firstPoint, clipBox, matrix;
3960     switch (rotation) {
3961       case 0:
3962         matrix = [1, 0, 0, 1];
3963         clipBox = [rect[0], rect[1], w, h];
3964         firstPoint = [rect[0], rect[3] - lineAscent];
3965         break;
3966       case 90:
3967         matrix = [0, 1, -1, 0];
3968         clipBox = [rect[1], -rect[2], w, h];
3969         firstPoint = [rect[1], -rect[0] - lineAscent];
3970         break;
3971       case 180:
3972         matrix = [-1, 0, 0, -1];
3973         clipBox = [-rect[2], -rect[3], w, h];
3974         firstPoint = [-rect[2], -rect[1] - lineAscent];
3975         break;
3976       case 270:
3977         matrix = [0, -1, 1, 0];
3978         clipBox = [-rect[3], rect[0], w, h];
3979         firstPoint = [-rect[3], rect[2] - lineAscent];
3980         break;
3981     }
3982 
3983     const buffer = [
3984       "q",
3985       `${matrix.join(" ")} 0 0 cm`,
3986       `${clipBox.join(" ")} re W n`,
3987       `BT`,
3988       `${getPdfColor(color, /* isFill */ true)}`,
3989       `0 Tc /Helv ${numberToString(newFontSize)} Tf`,
3990     ];
3991 
3992     buffer.push(
3993       `${firstPoint.join(" ")} Td (${escapeString(encodedLines[0])}) Tj`
3994     );
3995     const vShift = numberToString(lineHeight);
3996     for (let i = 1, ii = encodedLines.length; i < ii; i++) {
3997       const line = encodedLines[i];
3998       buffer.push(`0 -${vShift} Td (${escapeString(line)}) Tj`);
3999     }
4000     buffer.push("ET", "Q");
4001     const appearance = buffer.join("\n");
4002 
4003     const appearanceStreamDict = new Dict(xref);
4004     appearanceStreamDict.set("FormType", 1);
4005     appearanceStreamDict.set("Subtype", Name.get("Form"));
4006     appearanceStreamDict.set("Type", Name.get("XObject"));
4007     appearanceStreamDict.set("BBox", rect);
4008     appearanceStreamDict.set("Resources", resources);
4009     appearanceStreamDict.set("Matrix", [1, 0, 0, 1, -rect[0], -rect[1]]);
4010 
4011     const ap = new StringStream(appearance);
4012     ap.dict = appearanceStreamDict;
4013 
4014     return ap;
4015   }
4016 }
4017 
4018 class LineAnnotation extends MarkupAnnotation {
4019   constructor(params) {
4020     super(params);
4021 
4022     const { dict, xref } = params;
4023     this.data.annotationType = AnnotationType.LINE;
4024     this.data.hasOwnCanvas = this.data.noRotate;
4025     this.data.noHTML = false;
4026 
4027     const lineCoordinates = lookupRect(dict.getArray("L"), [0, 0, 0, 0]);
4028     this.data.lineCoordinates = Util.normalizeRect(lineCoordinates);
4029 
4030     if (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) {
4031       this.setLineEndings(dict.getArray("LE"));
4032       this.data.lineEndings = this.lineEndings;
4033     }
4034 
4035     if (!this.appearance) {
4036       // The default stroke color is black.
4037       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4038       const strokeAlpha = dict.get("CA");
4039 
4040       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4041       // The default fill color is transparent. Setting the fill colour is
4042       // necessary if/when we want to add support for non-default line endings.
4043       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4044       const fillAlpha = fillColor ? strokeAlpha : null;
4045 
4046       const borderWidth = this.borderStyle.width || 1,
4047         borderAdjust = 2 * borderWidth;
4048 
4049       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4050       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4051       const bbox = [
4052         this.data.lineCoordinates[0] - borderAdjust,
4053         this.data.lineCoordinates[1] - borderAdjust,
4054         this.data.lineCoordinates[2] + borderAdjust,
4055         this.data.lineCoordinates[3] + borderAdjust,
4056       ];
4057       if (!Util.intersect(this.rectangle, bbox)) {
4058         this.rectangle = bbox;
4059       }
4060 
4061       this._setDefaultAppearance({
4062         xref,
4063         extra: `${borderWidth} w`,
4064         strokeColor,
4065         fillColor,
4066         strokeAlpha,
4067         fillAlpha,
4068         pointsCallback: (buffer, points) => {
4069           buffer.push(
4070             `${lineCoordinates[0]} ${lineCoordinates[1]} m`,
4071             `${lineCoordinates[2]} ${lineCoordinates[3]} l`,
4072             "S"
4073           );
4074           return [
4075             points[0] - borderWidth,
4076             points[2] + borderWidth,
4077             points[7] - borderWidth,
4078             points[3] + borderWidth,
4079           ];
4080         },
4081       });
4082     }
4083   }
4084 }
4085 
4086 class SquareAnnotation extends MarkupAnnotation {
4087   constructor(params) {
4088     super(params);
4089 
4090     const { dict, xref } = params;
4091     this.data.annotationType = AnnotationType.SQUARE;
4092     this.data.hasOwnCanvas = this.data.noRotate;
4093     this.data.noHTML = false;
4094 
4095     if (!this.appearance) {
4096       // The default stroke color is black.
4097       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4098       const strokeAlpha = dict.get("CA");
4099 
4100       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4101       // The default fill color is transparent.
4102       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4103       const fillAlpha = fillColor ? strokeAlpha : null;
4104 
4105       if (this.borderStyle.width === 0 && !fillColor) {
4106         // Prevent rendering a "hairline" border (fixes issue14164.pdf).
4107         return;
4108       }
4109 
4110       this._setDefaultAppearance({
4111         xref,
4112         extra: `${this.borderStyle.width} w`,
4113         strokeColor,
4114         fillColor,
4115         strokeAlpha,
4116         fillAlpha,
4117         pointsCallback: (buffer, points) => {
4118           const x = points[4] + this.borderStyle.width / 2;
4119           const y = points[5] + this.borderStyle.width / 2;
4120           const width = points[6] - points[4] - this.borderStyle.width;
4121           const height = points[3] - points[7] - this.borderStyle.width;
4122           buffer.push(`${x} ${y} ${width} ${height} re`);
4123           if (fillColor) {
4124             buffer.push("B");
4125           } else {
4126             buffer.push("S");
4127           }
4128           return [points[0], points[2], points[7], points[3]];
4129         },
4130       });
4131     }
4132   }
4133 }
4134 
4135 class CircleAnnotation extends MarkupAnnotation {
4136   constructor(params) {
4137     super(params);
4138 
4139     const { dict, xref } = params;
4140     this.data.annotationType = AnnotationType.CIRCLE;
4141 
4142     if (!this.appearance) {
4143       // The default stroke color is black.
4144       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4145       const strokeAlpha = dict.get("CA");
4146 
4147       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4148       // The default fill color is transparent.
4149       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4150       const fillAlpha = fillColor ? strokeAlpha : null;
4151 
4152       if (this.borderStyle.width === 0 && !fillColor) {
4153         // Prevent rendering a "hairline" border (fixes issue14164.pdf).
4154         return;
4155       }
4156 
4157       // Circles are approximated by Bézier curves with four segments since
4158       // there is no circle primitive in the PDF specification. For the control
4159       // points distance, see https://stackoverflow.com/a/27863181.
4160       const controlPointsDistance = (4 / 3) * Math.tan(Math.PI / (2 * 4));
4161 
4162       this._setDefaultAppearance({
4163         xref,
4164         extra: `${this.borderStyle.width} w`,
4165         strokeColor,
4166         fillColor,
4167         strokeAlpha,
4168         fillAlpha,
4169         pointsCallback: (buffer, points) => {
4170           const x0 = points[0] + this.borderStyle.width / 2;
4171           const y0 = points[1] - this.borderStyle.width / 2;
4172           const x1 = points[6] - this.borderStyle.width / 2;
4173           const y1 = points[7] + this.borderStyle.width / 2;
4174           const xMid = x0 + (x1 - x0) / 2;
4175           const yMid = y0 + (y1 - y0) / 2;
4176           const xOffset = ((x1 - x0) / 2) * controlPointsDistance;
4177           const yOffset = ((y1 - y0) / 2) * controlPointsDistance;
4178 
4179           buffer.push(
4180             `${xMid} ${y1} m`,
4181             `${xMid + xOffset} ${y1} ${x1} ${yMid + yOffset} ${x1} ${yMid} c`,
4182             `${x1} ${yMid - yOffset} ${xMid + xOffset} ${y0} ${xMid} ${y0} c`,
4183             `${xMid - xOffset} ${y0} ${x0} ${yMid - yOffset} ${x0} ${yMid} c`,
4184             `${x0} ${yMid + yOffset} ${xMid - xOffset} ${y1} ${xMid} ${y1} c`,
4185             "h"
4186           );
4187           if (fillColor) {
4188             buffer.push("B");
4189           } else {
4190             buffer.push("S");
4191           }
4192           return [points[0], points[2], points[7], points[3]];
4193         },
4194       });
4195     }
4196   }
4197 }
4198 
4199 class PolylineAnnotation extends MarkupAnnotation {
4200   constructor(params) {
4201     super(params);
4202 
4203     const { dict, xref } = params;
4204     this.data.annotationType = AnnotationType.POLYLINE;
4205     this.data.hasOwnCanvas = this.data.noRotate;
4206     this.data.noHTML = false;
4207     this.data.vertices = null;
4208 
4209     if (
4210       (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) &&
4211       !(this instanceof PolygonAnnotation)
4212     ) {
4213       // Only meaningful for polyline annotations.
4214       this.setLineEndings(dict.getArray("LE"));
4215       this.data.lineEndings = this.lineEndings;
4216     }
4217 
4218     // The vertices array is an array of numbers representing the alternating
4219     // horizontal and vertical coordinates, respectively, of each vertex.
4220     // Convert this to an array of objects with x and y coordinates.
4221     const rawVertices = dict.getArray("Vertices");
4222     if (!isNumberArray(rawVertices, null)) {
4223       return;
4224     }
4225     const vertices = (this.data.vertices = Float32Array.from(rawVertices));
4226 
4227     if (!this.appearance) {
4228       // The default stroke color is black.
4229       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4230       const strokeAlpha = dict.get("CA");
4231 
4232       const borderWidth = this.borderStyle.width || 1,
4233         borderAdjust = 2 * borderWidth;
4234 
4235       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4236       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4237       const bbox = [Infinity, Infinity, -Infinity, -Infinity];
4238       for (let i = 0, ii = vertices.length; i < ii; i += 2) {
4239         bbox[0] = Math.min(bbox[0], vertices[i] - borderAdjust);
4240         bbox[1] = Math.min(bbox[1], vertices[i + 1] - borderAdjust);
4241         bbox[2] = Math.max(bbox[2], vertices[i] + borderAdjust);
4242         bbox[3] = Math.max(bbox[3], vertices[i + 1] + borderAdjust);
4243       }
4244       if (!Util.intersect(this.rectangle, bbox)) {
4245         this.rectangle = bbox;
4246       }
4247 
4248       this._setDefaultAppearance({
4249         xref,
4250         extra: `${borderWidth} w`,
4251         strokeColor,
4252         strokeAlpha,
4253         pointsCallback: (buffer, points) => {
4254           for (let i = 0, ii = vertices.length; i < ii; i += 2) {
4255             buffer.push(
4256               `${vertices[i]} ${vertices[i + 1]} ${i === 0 ? "m" : "l"}`
4257             );
4258           }
4259           buffer.push("S");
4260           return [points[0], points[2], points[7], points[3]];
4261         },
4262       });
4263     }
4264   }
4265 }
4266 
4267 class PolygonAnnotation extends PolylineAnnotation {
4268   constructor(params) {
4269     // Polygons are specific forms of polylines, so reuse their logic.
4270     super(params);
4271 
4272     this.data.annotationType = AnnotationType.POLYGON;
4273   }
4274 }
4275 
4276 class CaretAnnotation extends MarkupAnnotation {
4277   constructor(params) {
4278     super(params);
4279 
4280     this.data.annotationType = AnnotationType.CARET;
4281   }
4282 }
4283 
4284 class InkAnnotation extends MarkupAnnotation {
4285   constructor(params) {
4286     super(params);
4287 
4288     this.data.hasOwnCanvas = this.data.noRotate;
4289     this.data.noHTML = false;
4290 
4291     const { dict, xref } = params;
4292     this.data.annotationType = AnnotationType.INK;
4293     this.data.inkLists = [];
4294     this.data.isEditable = !this.data.noHTML && this.data.it === "InkHighlight";
4295     // We want to be able to add mouse listeners to the annotation.
4296     this.data.noHTML = false;
4297     this.data.opacity = dict.get("CA") || 1;
4298 
4299     const rawInkLists = dict.getArray("InkList");
4300     if (!Array.isArray(rawInkLists)) {
4301       return;
4302     }
4303     for (let i = 0, ii = rawInkLists.length; i < ii; ++i) {
4304       // The raw ink lists array contains arrays of numbers representing
4305       // the alternating horizontal and vertical coordinates, respectively,
4306       // of each vertex. Convert this to an array of objects with x and y
4307       // coordinates.
4308       if (!Array.isArray(rawInkLists[i])) {
4309         continue;
4310       }
4311       const inkList = new Float32Array(rawInkLists[i].length);
4312       this.data.inkLists.push(inkList);
4313       for (let j = 0, jj = rawInkLists[i].length; j < jj; j += 2) {
4314         const x = xref.fetchIfRef(rawInkLists[i][j]),
4315           y = xref.fetchIfRef(rawInkLists[i][j + 1]);
4316         if (typeof x === "number" && typeof y === "number") {
4317           inkList[j] = x;
4318           inkList[j + 1] = y;
4319         }
4320       }
4321     }
4322 
4323     if (!this.appearance) {
4324       // The default stroke color is black.
4325       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4326       const strokeAlpha = dict.get("CA");
4327 
4328       const borderWidth = this.borderStyle.width || 1,
4329         borderAdjust = 2 * borderWidth;
4330 
4331       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4332       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4333       const bbox = [Infinity, Infinity, -Infinity, -Infinity];
4334       for (const inkList of this.data.inkLists) {
4335         for (let i = 0, ii = inkList.length; i < ii; i += 2) {
4336           bbox[0] = Math.min(bbox[0], inkList[i] - borderAdjust);
4337           bbox[1] = Math.min(bbox[1], inkList[i + 1] - borderAdjust);
4338           bbox[2] = Math.max(bbox[2], inkList[i] + borderAdjust);
4339           bbox[3] = Math.max(bbox[3], inkList[i + 1] + borderAdjust);
4340         }
4341       }
4342       if (!Util.intersect(this.rectangle, bbox)) {
4343         this.rectangle = bbox;
4344       }
4345 
4346       this._setDefaultAppearance({
4347         xref,
4348         extra: `${borderWidth} w`,
4349         strokeColor,
4350         strokeAlpha,
4351         pointsCallback: (buffer, points) => {
4352           // According to the specification, see "12.5.6.13 Ink Annotations":
4353           //   When drawn, the points shall be connected by straight lines or
4354           //   curves in an implementation-dependent way.
4355           // In order to simplify things, we utilize straight lines for now.
4356           for (const inkList of this.data.inkLists) {
4357             for (let i = 0, ii = inkList.length; i < ii; i += 2) {
4358               buffer.push(
4359                 `${inkList[i]} ${inkList[i + 1]} ${i === 0 ? "m" : "l"}`
4360               );
4361             }
4362             buffer.push("S");
4363           }
4364           return [points[0], points[2], points[7], points[3]];
4365         },
4366       });
4367     }
4368   }
4369 
4370   static createNewDict(annotation, xref, { apRef, ap }) {
4371     const { color, opacity, paths, outlines, rect, rotation, thickness } =
4372       annotation;
4373     const ink = new Dict(xref);
4374     ink.set("Type", Name.get("Annot"));
4375     ink.set("Subtype", Name.get("Ink"));
4376     ink.set("CreationDate", `D:${getModificationDate()}`);
4377     ink.set("Rect", rect);
4378     ink.set("InkList", outlines?.points || paths.map(p => p.points));
4379     ink.set("F", 4);
4380     ink.set("Rotate", rotation);
4381 
4382     if (outlines) {
4383       // Free highlight.
4384       // There's nothing about this in the spec, but it's used when highlighting
4385       // in Edge's viewer. Acrobat takes into account this parameter to indicate
4386       // that the Ink is used for highlighting.
4387       ink.set("IT", Name.get("InkHighlight"));
4388     }
4389 
4390     // Line thickness.
4391     const bs = new Dict(xref);
4392     ink.set("BS", bs);
4393     bs.set("W", thickness);
4394 
4395     // Color.
4396     ink.set(
4397       "C",
4398       Array.from(color, c => c / 255)
4399     );
4400 
4401     // Opacity.
4402     ink.set("CA", opacity);
4403 
4404     const n = new Dict(xref);
4405     ink.set("AP", n);
4406 
4407     if (apRef) {
4408       n.set("N", apRef);
4409     } else {
4410       n.set("N", ap);
4411     }
4412 
4413     return ink;
4414   }
4415 
4416   static async createNewAppearanceStream(annotation, xref, params) {
4417     if (annotation.outlines) {
4418       return this.createNewAppearanceStreamForHighlight(
4419         annotation,
4420         xref,
4421         params
4422       );
4423     }
4424     const { color, rect, paths, thickness, opacity } = annotation;
4425 
4426     const appearanceBuffer = [
4427       `${thickness} w 1 J 1 j`,
4428       `${getPdfColor(color, /* isFill */ false)}`,
4429     ];
4430 
4431     if (opacity !== 1) {
4432       appearanceBuffer.push("/R0 gs");
4433     }
4434 
4435     const buffer = [];
4436     for (const { bezier } of paths) {
4437       buffer.length = 0;
4438       buffer.push(
4439         `${numberToString(bezier[0])} ${numberToString(bezier[1])} m`
4440       );
4441       if (bezier.length === 2) {
4442         buffer.push(
4443           `${numberToString(bezier[0])} ${numberToString(bezier[1])} l S`
4444         );
4445       } else {
4446         for (let i = 2, ii = bezier.length; i < ii; i += 6) {
4447           const curve = bezier
4448             .slice(i, i + 6)
4449             .map(numberToString)
4450             .join(" ");
4451           buffer.push(`${curve} c`);
4452         }
4453         buffer.push("S");
4454       }
4455       appearanceBuffer.push(buffer.join("\n"));
4456     }
4457     const appearance = appearanceBuffer.join("\n");
4458 
4459     const appearanceStreamDict = new Dict(xref);
4460     appearanceStreamDict.set("FormType", 1);
4461     appearanceStreamDict.set("Subtype", Name.get("Form"));
4462     appearanceStreamDict.set("Type", Name.get("XObject"));
4463     appearanceStreamDict.set("BBox", rect);
4464     appearanceStreamDict.set("Length", appearance.length);
4465 
4466     if (opacity !== 1) {
4467       const resources = new Dict(xref);
4468       const extGState = new Dict(xref);
4469       const r0 = new Dict(xref);
4470       r0.set("CA", opacity);
4471       r0.set("Type", Name.get("ExtGState"));
4472       extGState.set("R0", r0);
4473       resources.set("ExtGState", extGState);
4474       appearanceStreamDict.set("Resources", resources);
4475     }
4476 
4477     const ap = new StringStream(appearance);
4478     ap.dict = appearanceStreamDict;
4479 
4480     return ap;
4481   }
4482 
4483   static async createNewAppearanceStreamForHighlight(annotation, xref, params) {
4484     const {
4485       color,
4486       rect,
4487       outlines: { outline },
4488       opacity,
4489     } = annotation;
4490     const appearanceBuffer = [
4491       `${getPdfColor(color, /* isFill */ true)}`,
4492       "/R0 gs",
4493     ];
4494 
4495     appearanceBuffer.push(
4496       `${numberToString(outline[4])} ${numberToString(outline[5])} m`
4497     );
4498     for (let i = 6, ii = outline.length; i < ii; i += 6) {
4499       if (isNaN(outline[i]) || outline[i] === null) {
4500         appearanceBuffer.push(
4501           `${numberToString(outline[i + 4])} ${numberToString(
4502             outline[i + 5]
4503           )} l`
4504         );
4505       } else {
4506         const curve = outline
4507           .slice(i, i + 6)
4508           .map(numberToString)
4509           .join(" ");
4510         appearanceBuffer.push(`${curve} c`);
4511       }
4512     }
4513     appearanceBuffer.push("h f");
4514     const appearance = appearanceBuffer.join("\n");
4515 
4516     const appearanceStreamDict = new Dict(xref);
4517     appearanceStreamDict.set("FormType", 1);
4518     appearanceStreamDict.set("Subtype", Name.get("Form"));
4519     appearanceStreamDict.set("Type", Name.get("XObject"));
4520     appearanceStreamDict.set("BBox", rect);
4521     appearanceStreamDict.set("Length", appearance.length);
4522 
4523     const resources = new Dict(xref);
4524     const extGState = new Dict(xref);
4525     resources.set("ExtGState", extGState);
4526     appearanceStreamDict.set("Resources", resources);
4527     const r0 = new Dict(xref);
4528     extGState.set("R0", r0);
4529     r0.set("BM", Name.get("Multiply"));
4530 
4531     if (opacity !== 1) {
4532       r0.set("ca", opacity);
4533       r0.set("Type", Name.get("ExtGState"));
4534     }
4535 
4536     const ap = new StringStream(appearance);
4537     ap.dict = appearanceStreamDict;
4538 
4539     return ap;
4540   }
4541 }
4542 
4543 class HighlightAnnotation extends MarkupAnnotation {
4544   constructor(params) {
4545     super(params);
4546 
4547     const { dict, xref } = params;
4548     this.data.annotationType = AnnotationType.HIGHLIGHT;
4549     this.data.isEditable = !this.data.noHTML;
4550     // We want to be able to add mouse listeners to the annotation.
4551     this.data.noHTML = false;
4552     this.data.opacity = dict.get("CA") || 1;
4553 
4554     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4555     if (quadPoints) {
4556       const resources = this.appearance?.dict.get("Resources");
4557 
4558       if (!this.appearance || !resources?.has("ExtGState")) {
4559         if (this.appearance) {
4560           // Workaround for cases where there's no /ExtGState-entry directly
4561           // available, e.g. when the appearance stream contains a /XObject of
4562           // the /Form-type, since that causes the highlighting to completely
4563           // obscure the PDF content below it (fixes issue13242.pdf).
4564           warn("HighlightAnnotation - ignoring built-in appearance stream.");
4565         }
4566         // Default color is yellow in Acrobat Reader
4567         const fillColor = this.color ? getPdfColorArray(this.color) : [1, 1, 0];
4568         const fillAlpha = dict.get("CA");
4569 
4570         this._setDefaultAppearance({
4571           xref,
4572           fillColor,
4573           blendMode: "Multiply",
4574           fillAlpha,
4575           pointsCallback: (buffer, points) => {
4576             buffer.push(
4577               `${points[0]} ${points[1]} m`,
4578               `${points[2]} ${points[3]} l`,
4579               `${points[6]} ${points[7]} l`,
4580               `${points[4]} ${points[5]} l`,
4581               "f"
4582             );
4583             return [points[0], points[2], points[7], points[3]];
4584           },
4585         });
4586       }
4587     } else {
4588       this.data.popupRef = null;
4589     }
4590   }
4591 
4592   static createNewDict(annotation, xref, { apRef, ap, oldAnnotation }) {
4593     const { color, opacity, rect, rotation, user, quadPoints } = annotation;
4594     const highlight = oldAnnotation || new Dict(xref);
4595     highlight.set("Type", Name.get("Annot"));
4596     highlight.set("Subtype", Name.get("Highlight"));
4597     highlight.set(
4598       oldAnnotation ? "M" : "CreationDate",
4599       `D:${getModificationDate()}`
4600     );
4601     highlight.set("CreationDate", `D:${getModificationDate()}`);
4602     highlight.set("Rect", rect);
4603     highlight.set("F", 4);
4604     highlight.set("Border", [0, 0, 0]);
4605     highlight.set("Rotate", rotation);
4606     highlight.set("QuadPoints", quadPoints);
4607 
4608     // Color.
4609     highlight.set(
4610       "C",
4611       Array.from(color, c => c / 255)
4612     );
4613 
4614     // Opacity.
4615     highlight.set("CA", opacity);
4616 
4617     if (user) {
4618       highlight.set("T", stringToAsciiOrUTF16BE(user));
4619     }
4620 
4621     if (apRef || ap) {
4622       const n = new Dict(xref);
4623       highlight.set("AP", n);
4624       n.set("N", apRef || ap);
4625     }
4626 
4627     return highlight;
4628   }
4629 
4630   static async createNewAppearanceStream(annotation, xref, params) {
4631     const { color, rect, outlines, opacity } = annotation;
4632 
4633     const appearanceBuffer = [
4634       `${getPdfColor(color, /* isFill */ true)}`,
4635       "/R0 gs",
4636     ];
4637 
4638     const buffer = [];
4639     for (const outline of outlines) {
4640       buffer.length = 0;
4641       buffer.push(
4642         `${numberToString(outline[0])} ${numberToString(outline[1])} m`
4643       );
4644       for (let i = 2, ii = outline.length; i < ii; i += 2) {
4645         buffer.push(
4646           `${numberToString(outline[i])} ${numberToString(outline[i + 1])} l`
4647         );
4648       }
4649       buffer.push("h");
4650       appearanceBuffer.push(buffer.join("\n"));
4651     }
4652     appearanceBuffer.push("f*");
4653     const appearance = appearanceBuffer.join("\n");
4654 
4655     const appearanceStreamDict = new Dict(xref);
4656     appearanceStreamDict.set("FormType", 1);
4657     appearanceStreamDict.set("Subtype", Name.get("Form"));
4658     appearanceStreamDict.set("Type", Name.get("XObject"));
4659     appearanceStreamDict.set("BBox", rect);
4660     appearanceStreamDict.set("Length", appearance.length);
4661 
4662     const resources = new Dict(xref);
4663     const extGState = new Dict(xref);
4664     resources.set("ExtGState", extGState);
4665     appearanceStreamDict.set("Resources", resources);
4666     const r0 = new Dict(xref);
4667     extGState.set("R0", r0);
4668     r0.set("BM", Name.get("Multiply"));
4669 
4670     if (opacity !== 1) {
4671       r0.set("ca", opacity);
4672       r0.set("Type", Name.get("ExtGState"));
4673     }
4674 
4675     const ap = new StringStream(appearance);
4676     ap.dict = appearanceStreamDict;
4677 
4678     return ap;
4679   }
4680 }
4681 
4682 class UnderlineAnnotation extends MarkupAnnotation {
4683   constructor(params) {
4684     super(params);
4685 
4686     const { dict, xref } = params;
4687     this.data.annotationType = AnnotationType.UNDERLINE;
4688 
4689     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4690     if (quadPoints) {
4691       if (!this.appearance) {
4692         // Default color is black
4693         const strokeColor = this.color
4694           ? getPdfColorArray(this.color)
4695           : [0, 0, 0];
4696         const strokeAlpha = dict.get("CA");
4697 
4698         // The values 0.571 and 1.3 below corresponds to what Acrobat is doing.
4699         this._setDefaultAppearance({
4700           xref,
4701           extra: "[] 0 d 0.571 w",
4702           strokeColor,
4703           strokeAlpha,
4704           pointsCallback: (buffer, points) => {
4705             buffer.push(
4706               `${points[4]} ${points[5] + 1.3} m`,
4707               `${points[6]} ${points[7] + 1.3} l`,
4708               "S"
4709             );
4710             return [points[0], points[2], points[7], points[3]];
4711           },
4712         });
4713       }
4714     } else {
4715       this.data.popupRef = null;
4716     }
4717   }
4718 }
4719 
4720 class SquigglyAnnotation extends MarkupAnnotation {
4721   constructor(params) {
4722     super(params);
4723 
4724     const { dict, xref } = params;
4725     this.data.annotationType = AnnotationType.SQUIGGLY;
4726 
4727     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4728     if (quadPoints) {
4729       if (!this.appearance) {
4730         // Default color is black
4731         const strokeColor = this.color
4732           ? getPdfColorArray(this.color)
4733           : [0, 0, 0];
4734         const strokeAlpha = dict.get("CA");
4735 
4736         this._setDefaultAppearance({
4737           xref,
4738           extra: "[] 0 d 1 w",
4739           strokeColor,
4740           strokeAlpha,
4741           pointsCallback: (buffer, points) => {
4742             const dy = (points[1] - points[5]) / 6;
4743             let shift = dy;
4744             let x = points[4];
4745             const y = points[5];
4746             const xEnd = points[6];
4747             buffer.push(`${x} ${y + shift} m`);
4748             do {
4749               x += 2;
4750               shift = shift === 0 ? dy : 0;
4751               buffer.push(`${x} ${y + shift} l`);
4752             } while (x < xEnd);
4753             buffer.push("S");
4754             return [points[4], xEnd, y - 2 * dy, y + 2 * dy];
4755           },
4756         });
4757       }
4758     } else {
4759       this.data.popupRef = null;
4760     }
4761   }
4762 }
4763 
4764 class StrikeOutAnnotation extends MarkupAnnotation {
4765   constructor(params) {
4766     super(params);
4767 
4768     const { dict, xref } = params;
4769     this.data.annotationType = AnnotationType.STRIKEOUT;
4770 
4771     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4772     if (quadPoints) {
4773       if (!this.appearance) {
4774         // Default color is black
4775         const strokeColor = this.color
4776           ? getPdfColorArray(this.color)
4777           : [0, 0, 0];
4778         const strokeAlpha = dict.get("CA");
4779 
4780         this._setDefaultAppearance({
4781           xref,
4782           extra: "[] 0 d 1 w",
4783           strokeColor,
4784           strokeAlpha,
4785           pointsCallback: (buffer, points) => {
4786             buffer.push(
4787               `${(points[0] + points[4]) / 2} ` +
4788                 `${(points[1] + points[5]) / 2} m`,
4789               `${(points[2] + points[6]) / 2} ` +
4790                 `${(points[3] + points[7]) / 2} l`,
4791               "S"
4792             );
4793             return [points[0], points[2], points[7], points[3]];
4794           },
4795         });
4796       }
4797     } else {
4798       this.data.popupRef = null;
4799     }
4800   }
4801 }
4802 
4803 class StampAnnotation extends MarkupAnnotation {
4804   constructor(params) {
4805     super(params);
4806 
4807     this.data.annotationType = AnnotationType.STAMP;
4808     this.data.hasOwnCanvas = this.data.noRotate;
4809     this.data.noHTML = false;
4810   }
4811 
4812   static async createImage(bitmap, xref) {
4813     // TODO: when printing, we could have a specific internal colorspace
4814     // (e.g. something like DeviceRGBA) in order avoid any conversion (i.e. no
4815     // jpeg, no rgba to rgb conversion, etc...)
4816 
4817     const { width, height } = bitmap;
4818     const canvas = new OffscreenCanvas(width, height);
4819     const ctx = canvas.getContext("2d", { alpha: true });
4820 
4821     // Draw the image and get the data in order to extract the transparency.
4822     ctx.drawImage(bitmap, 0, 0);
4823     const data = ctx.getImageData(0, 0, width, height).data;
4824     const buf32 = new Uint32Array(data.buffer);
4825     const hasAlpha = buf32.some(
4826       FeatureTest.isLittleEndian
4827         ? x => x >>> 24 !== 0xff
4828         : x => (x & 0xff) !== 0xff
4829     );
4830 
4831     if (hasAlpha) {
4832       // Redraw the image on a white background in order to remove the thin gray
4833       // line which can appear when exporting to jpeg.
4834       ctx.fillStyle = "white";
4835       ctx.fillRect(0, 0, width, height);
4836       ctx.drawImage(bitmap, 0, 0);
4837     }
4838 
4839     const jpegBufferPromise = canvas
4840       .convertToBlob({ type: "image/jpeg", quality: 1 })
4841       .then(blob => blob.arrayBuffer());
4842 
4843     const xobjectName = Name.get("XObject");
4844     const imageName = Name.get("Image");
4845     const image = new Dict(xref);
4846     image.set("Type", xobjectName);
4847     image.set("Subtype", imageName);
4848     image.set("BitsPerComponent", 8);
4849     image.set("ColorSpace", Name.get("DeviceRGB"));
4850     image.set("Filter", Name.get("DCTDecode"));
4851     image.set("BBox", [0, 0, width, height]);
4852     image.set("Width", width);
4853     image.set("Height", height);
4854 
4855     let smaskStream = null;
4856     if (hasAlpha) {
4857       const alphaBuffer = new Uint8Array(buf32.length);
4858       if (FeatureTest.isLittleEndian) {
4859         for (let i = 0, ii = buf32.length; i < ii; i++) {
4860           alphaBuffer[i] = buf32[i] >>> 24;
4861         }
4862       } else {
4863         for (let i = 0, ii = buf32.length; i < ii; i++) {
4864           alphaBuffer[i] = buf32[i] & 0xff;
4865         }
4866       }
4867 
4868       const smask = new Dict(xref);
4869       smask.set("Type", xobjectName);
4870       smask.set("Subtype", imageName);
4871       smask.set("BitsPerComponent", 8);
4872       smask.set("ColorSpace", Name.get("DeviceGray"));
4873       smask.set("Width", width);
4874       smask.set("Height", height);
4875 
4876       smaskStream = new Stream(alphaBuffer, 0, 0, smask);
4877     }
4878     const imageStream = new Stream(await jpegBufferPromise, 0, 0, image);
4879 
4880     return {
4881       imageStream,
4882       smaskStream,
4883       width,
4884       height,
4885     };
4886   }
4887 
4888   static createNewDict(annotation, xref, { apRef, ap }) {
4889     const { rect, rotation, user } = annotation;
4890     const stamp = new Dict(xref);
4891     stamp.set("Type", Name.get("Annot"));
4892     stamp.set("Subtype", Name.get("Stamp"));
4893     stamp.set("CreationDate", `D:${getModificationDate()}`);
4894     stamp.set("Rect", rect);
4895     stamp.set("F", 4);
4896     stamp.set("Border", [0, 0, 0]);
4897     stamp.set("Rotate", rotation);
4898 
4899     if (user) {
4900       stamp.set("T", stringToAsciiOrUTF16BE(user));
4901     }
4902 
4903     if (apRef || ap) {
4904       const n = new Dict(xref);
4905       stamp.set("AP", n);
4906 
4907       if (apRef) {
4908         n.set("N", apRef);
4909       } else {
4910         n.set("N", ap);
4911       }
4912     }
4913 
4914     return stamp;
4915   }
4916 
4917   static async createNewAppearanceStream(annotation, xref, params) {
4918     const { rotation } = annotation;
4919     const { imageRef, width, height } = params.image;
4920     const resources = new Dict(xref);
4921     const xobject = new Dict(xref);
4922     resources.set("XObject", xobject);
4923     xobject.set("Im0", imageRef);
4924     const appearance = `q ${width} 0 0 ${height} 0 0 cm /Im0 Do Q`;
4925 
4926     const appearanceStreamDict = new Dict(xref);
4927     appearanceStreamDict.set("FormType", 1);
4928     appearanceStreamDict.set("Subtype", Name.get("Form"));
4929     appearanceStreamDict.set("Type", Name.get("XObject"));
4930     appearanceStreamDict.set("BBox", [0, 0, width, height]);
4931     appearanceStreamDict.set("Resources", resources);
4932 
4933     if (rotation) {
4934       const matrix = getRotationMatrix(rotation, width, height);
4935       appearanceStreamDict.set("Matrix", matrix);
4936     }
4937 
4938     const ap = new StringStream(appearance);
4939     ap.dict = appearanceStreamDict;
4940 
4941     return ap;
4942   }
4943 }
4944 
4945 class FileAttachmentAnnotation extends MarkupAnnotation {
4946   constructor(params) {
4947     super(params);
4948 
4949     const { dict, xref } = params;
4950     const file = new FileSpec(dict.get("FS"), xref);
4951 
4952     this.data.annotationType = AnnotationType.FILEATTACHMENT;
4953     this.data.hasOwnCanvas = this.data.noRotate;
4954     this.data.noHTML = false;
4955     this.data.file = file.serializable;
4956 
4957     const name = dict.get("Name");
4958     this.data.name =
4959       name instanceof Name ? stringToPDFString(name.name) : "PushPin";
4960 
4961     const fillAlpha = dict.get("ca");
4962     this.data.fillAlpha =
4963       typeof fillAlpha === "number" && fillAlpha >= 0 && fillAlpha <= 1
4964         ? fillAlpha
4965         : null;
4966   }
4967 }
4968 
4969 export {
4970   Annotation,
4971   AnnotationBorderStyle,
4972   AnnotationFactory,
4973   getQuadPoints,
4974   MarkupAnnotation,
4975   PopupAnnotation,
4976   WidgetAnnotation,
4977 };
File:
src/core/document.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AnnotationEditorPrefix,
18   assert,
19   FormatError,
20   info,
21   InvalidPDFException,
22   isArrayEqual,
23   PageActionEventType,
24   RenderingIntentFlag,
25   shadow,
26   stringToBytes,
27   stringToPDFString,
28   stringToUTF8String,
29   unreachable,
30   Util,
31   warn,
32 } from "../shared/util.js";
33 import {
34   AnnotationFactory,
35   PopupAnnotation,
36   WidgetAnnotation,
37 } from "./annotation.js";
38 import {
39   collectActions,
40   getInheritableProperty,
41   getNewAnnotationsMap,
42   isWhiteSpace,
43   lookupNormalRect,
44   MissingDataException,
45   PDF_VERSION_REGEXP,
46   validateCSSFont,
47   XRefEntryException,
48   XRefParseException,
49 } from "./core_utils.js";
50 import {
51   Dict,
52   isName,
53   isRefsEqual,
54   Name,
55   Ref,
56   RefSet,
57   RefSetCache,
58 } from "./primitives.js";
59 import { getXfaFontDict, getXfaFontName } from "./xfa_fonts.js";
60 import { BaseStream } from "./base_stream.js";
61 import { calculateMD5 } from "./crypto.js";
62 import { Catalog } from "./catalog.js";
63 import { clearGlobalCaches } from "./cleanup_helper.js";
64 import { DatasetReader } from "./dataset_reader.js";
65 import { Linearization } from "./parser.js";
66 import { NullStream } from "./stream.js";
67 import { ObjectLoader } from "./object_loader.js";
68 import { OperatorList } from "./operator_list.js";
69 import { PartialEvaluator } from "./evaluator.js";
70 import { StreamsSequenceStream } from "./decode_stream.js";
71 import { StructTreePage } from "./struct_tree.js";
72 import { writeObject } from "./writer.js";
73 import { XFAFactory } from "./xfa/factory.js";
74 import { XRef } from "./xref.js";
75 
76 const DEFAULT_USER_UNIT = 1.0;
77 const LETTER_SIZE_MEDIABOX = [0, 0, 612, 792];
78 
79 class Page {
80   constructor({
81     pdfManager,
82     xref,
83     pageIndex,
84     pageDict,
85     ref,
86     globalIdFactory,
87     fontCache,
88     builtInCMapCache,
89     standardFontDataCache,
90     globalImageCache,
91     systemFontCache,
92     nonBlendModesSet,
93     xfaFactory,
94   }) {
95     this.pdfManager = pdfManager;
96     this.pageIndex = pageIndex;
97     this.pageDict = pageDict;
98     this.xref = xref;
99     this.ref = ref;
100     this.fontCache = fontCache;
101     this.builtInCMapCache = builtInCMapCache;
102     this.standardFontDataCache = standardFontDataCache;
103     this.globalImageCache = globalImageCache;
104     this.systemFontCache = systemFontCache;
105     this.nonBlendModesSet = nonBlendModesSet;
106     this.evaluatorOptions = pdfManager.evaluatorOptions;
107     this.resourcesPromise = null;
108     this.xfaFactory = xfaFactory;
109 
110     const idCounters = {
111       obj: 0,
112     };
113     this._localIdFactory = class extends globalIdFactory {
114       static createObjId() {
115         return `p${pageIndex}_${++idCounters.obj}`;
116       }
117 
118       static getPageObjId() {
119         return `p${ref.toString()}`;
120       }
121     };
122   }
123 
124   /**
125    * @private
126    */
127   _getInheritableProperty(key, getArray = false) {
128     const value = getInheritableProperty({
129       dict: this.pageDict,
130       key,
131       getArray,
132       stopWhenFound: false,
133     });
134     if (!Array.isArray(value)) {
135       return value;
136     }
137     if (value.length === 1 || !(value[0] instanceof Dict)) {
138       return value[0];
139     }
140     return Dict.merge({ xref: this.xref, dictArray: value });
141   }
142 
143   get content() {
144     return this.pageDict.getArray("Contents");
145   }
146 
147   get resources() {
148     // For robustness: The spec states that a \Resources entry has to be
149     // present, but can be empty. Some documents still omit it; in this case
150     // we return an empty dictionary.
151     const resources = this._getInheritableProperty("Resources");
152 
153     return shadow(
154       this,
155       "resources",
156       resources instanceof Dict ? resources : Dict.empty
157     );
158   }
159 
160   _getBoundingBox(name) {
161     if (this.xfaData) {
162       return this.xfaData.bbox;
163     }
164     const box = lookupNormalRect(
165       this._getInheritableProperty(name, /* getArray = */ true),
166       null
167     );
168 
169     if (box) {
170       if (box[2] - box[0] > 0 && box[3] - box[1] > 0) {
171         return box;
172       }
173       warn(`Empty, or invalid, /${name} entry.`);
174     }
175     return null;
176   }
177 
178   get mediaBox() {
179     // Reset invalid media box to letter size.
180     return shadow(
181       this,
182       "mediaBox",
183       this._getBoundingBox("MediaBox") || LETTER_SIZE_MEDIABOX
184     );
185   }
186 
187   get cropBox() {
188     // Reset invalid crop box to media box.
189     return shadow(
190       this,
191       "cropBox",
192       this._getBoundingBox("CropBox") || this.mediaBox
193     );
194   }
195 
196   get userUnit() {
197     let obj = this.pageDict.get("UserUnit");
198     if (typeof obj !== "number" || obj <= 0) {
199       obj = DEFAULT_USER_UNIT;
200     }
201     return shadow(this, "userUnit", obj);
202   }
203 
204   get view() {
205     // From the spec, 6th ed., p.963:
206     // "The crop, bleed, trim, and art boxes should not ordinarily
207     // extend beyond the boundaries of the media box. If they do, they are
208     // effectively reduced to their intersection with the media box."
209     const { cropBox, mediaBox } = this;
210 
211     if (cropBox !== mediaBox && !isArrayEqual(cropBox, mediaBox)) {
212       const box = Util.intersect(cropBox, mediaBox);
213       if (box && box[2] - box[0] > 0 && box[3] - box[1] > 0) {
214         return shadow(this, "view", box);
215       }
216       warn("Empty /CropBox and /MediaBox intersection.");
217     }
218     return shadow(this, "view", mediaBox);
219   }
220 
221   get rotate() {
222     let rotate = this._getInheritableProperty("Rotate") || 0;
223 
224     // Normalize rotation so it's a multiple of 90 and between 0 and 270.
225     if (rotate % 90 !== 0) {
226       rotate = 0;
227     } else if (rotate >= 360) {
228       rotate %= 360;
229     } else if (rotate < 0) {
230       // The spec doesn't cover negatives. Assume it's counterclockwise
231       // rotation. The following is the other implementation of modulo.
232       rotate = ((rotate % 360) + 360) % 360;
233     }
234     return shadow(this, "rotate", rotate);
235   }
236 
237   /**
238    * @private
239    */
240   _onSubStreamError(reason, objId) {
241     if (this.evaluatorOptions.ignoreErrors) {
242       warn(`getContentStream - ignoring sub-stream (${objId}): "${reason}".`);
243       return;
244     }
245     throw reason;
246   }
247 
248   /**
249    * @returns {Promise<BaseStream>}
250    */
251   getContentStream() {
252     return this.pdfManager.ensure(this, "content").then(content => {
253       if (content instanceof BaseStream) {
254         return content;
255       }
256       if (Array.isArray(content)) {
257         return new StreamsSequenceStream(
258           content,
259           this._onSubStreamError.bind(this)
260         );
261       }
262       // Replace non-existent page content with empty content.
263       return new NullStream();
264     });
265   }
266 
267   get xfaData() {
268     return shadow(
269       this,
270       "xfaData",
271       this.xfaFactory
272         ? { bbox: this.xfaFactory.getBoundingBox(this.pageIndex) }
273         : null
274     );
275   }
276 
277   #replaceIdByRef(annotations, deletedAnnotations, existingAnnotations) {
278     for (const annotation of annotations) {
279       if (annotation.id) {
280         const ref = Ref.fromString(annotation.id);
281         if (!ref) {
282           warn(`A non-linked annotation cannot be modified: ${annotation.id}`);
283           continue;
284         }
285         if (annotation.deleted) {
286           deletedAnnotations.put(ref, ref);
287           if (annotation.popupRef) {
288             const popupRef = Ref.fromString(annotation.popupRef);
289             if (popupRef) {
290               deletedAnnotations.put(popupRef, popupRef);
291             }
292           }
293           continue;
294         }
295         existingAnnotations?.put(ref);
296         annotation.ref = ref;
297         delete annotation.id;
298       }
299     }
300   }
301 
302   async saveNewAnnotations(handler, task, annotations, imagePromises) {
303     if (this.xfaFactory) {
304       throw new Error("XFA: Cannot save new annotations.");
305     }
306 
307     const partialEvaluator = new PartialEvaluator({
308       xref: this.xref,
309       handler,
310       pageIndex: this.pageIndex,
311       idFactory: this._localIdFactory,
312       fontCache: this.fontCache,
313       builtInCMapCache: this.builtInCMapCache,
314       standardFontDataCache: this.standardFontDataCache,
315       globalImageCache: this.globalImageCache,
316       systemFontCache: this.systemFontCache,
317       options: this.evaluatorOptions,
318     });
319 
320     const deletedAnnotations = new RefSetCache();
321     const existingAnnotations = new RefSet();
322     this.#replaceIdByRef(annotations, deletedAnnotations, existingAnnotations);
323 
324     const pageDict = this.pageDict;
325     const annotationsArray = this.annotations.filter(
326       a => !(a instanceof Ref && deletedAnnotations.has(a))
327     );
328     const newData = await AnnotationFactory.saveNewAnnotations(
329       partialEvaluator,
330       task,
331       annotations,
332       imagePromises
333     );
334 
335     for (const { ref } of newData.annotations) {
336       // Don't add an existing annotation ref to the annotations array.
337       if (ref instanceof Ref && !existingAnnotations.has(ref)) {
338         annotationsArray.push(ref);
339       }
340     }
341 
342     const savedDict = pageDict.get("Annots");
343     pageDict.set("Annots", annotationsArray);
344     const buffer = [];
345     await writeObject(this.ref, pageDict, buffer, this.xref);
346     if (savedDict) {
347       pageDict.set("Annots", savedDict);
348     }
349 
350     const objects = newData.dependencies;
351     objects.push(
352       { ref: this.ref, data: buffer.join("") },
353       ...newData.annotations
354     );
355     for (const deletedRef of deletedAnnotations) {
356       objects.push({ ref: deletedRef, data: null });
357     }
358 
359     return objects;
360   }
361 
362   save(handler, task, annotationStorage) {
363     const partialEvaluator = new PartialEvaluator({
364       xref: this.xref,
365       handler,
366       pageIndex: this.pageIndex,
367       idFactory: this._localIdFactory,
368       fontCache: this.fontCache,
369       builtInCMapCache: this.builtInCMapCache,
370       standardFontDataCache: this.standardFontDataCache,
371       globalImageCache: this.globalImageCache,
372       systemFontCache: this.systemFontCache,
373       options: this.evaluatorOptions,
374     });
375 
376     // Fetch the page's annotations and save the content
377     // in case of interactive form fields.
378     return this._parsedAnnotations.then(function (annotations) {
379       const newRefsPromises = [];
380       for (const annotation of annotations) {
381         if (!annotation.mustBePrinted(annotationStorage)) {
382           continue;
383         }
384         newRefsPromises.push(
385           annotation
386             .save(partialEvaluator, task, annotationStorage)
387             .catch(function (reason) {
388               warn(
389                 "save - ignoring annotation data during " +
390                   `"${task.name}" task: "${reason}".`
391               );
392               return null;
393             })
394         );
395       }
396 
397       return Promise.all(newRefsPromises).then(function (newRefs) {
398         return newRefs.filter(newRef => !!newRef);
399       });
400     });
401   }
402 
403   loadResources(keys) {
404     // TODO: add async `_getInheritableProperty` and remove this.
405     this.resourcesPromise ||= this.pdfManager.ensure(this, "resources");
406 
407     return this.resourcesPromise.then(() => {
408       const objectLoader = new ObjectLoader(this.resources, keys, this.xref);
409       return objectLoader.load();
410     });
411   }
412 
413   getOperatorList({
414     handler,
415     sink,
416     task,
417     intent,
418     cacheKey,
419     annotationStorage = null,
420     modifiedIds = null,
421   }) {
422     const contentStreamPromise = this.getContentStream();
423     const resourcesPromise = this.loadResources([
424       "ColorSpace",
425       "ExtGState",
426       "Font",
427       "Pattern",
428       "Properties",
429       "Shading",
430       "XObject",
431     ]);
432 
433     const partialEvaluator = new PartialEvaluator({
434       xref: this.xref,
435       handler,
436       pageIndex: this.pageIndex,
437       idFactory: this._localIdFactory,
438       fontCache: this.fontCache,
439       builtInCMapCache: this.builtInCMapCache,
440       standardFontDataCache: this.standardFontDataCache,
441       globalImageCache: this.globalImageCache,
442       systemFontCache: this.systemFontCache,
443       options: this.evaluatorOptions,
444     });
445 
446     const newAnnotsByPage = !this.xfaFactory
447       ? getNewAnnotationsMap(annotationStorage)
448       : null;
449     const newAnnots = newAnnotsByPage?.get(this.pageIndex);
450     let newAnnotationsPromise = Promise.resolve(null);
451     let deletedAnnotations = null;
452 
453     if (newAnnots) {
454       const annotationGlobalsPromise =
455         this.pdfManager.ensureDoc("annotationGlobals");
456       let imagePromises;
457 
458       // An annotation can contain a reference to a bitmap, but this bitmap
459       // is defined in another annotation. So we need to find this annotation
460       // and generate the bitmap.
461       const missingBitmaps = new Set();
462       for (const { bitmapId, bitmap } of newAnnots) {
463         if (bitmapId && !bitmap && !missingBitmaps.has(bitmapId)) {
464           missingBitmaps.add(bitmapId);
465         }
466       }
467 
468       const { isOffscreenCanvasSupported } = this.evaluatorOptions;
469       if (missingBitmaps.size > 0) {
470         const annotationWithBitmaps = newAnnots.slice();
471         for (const [key, annotation] of annotationStorage) {
472           if (!key.startsWith(AnnotationEditorPrefix)) {
473             continue;
474           }
475           if (annotation.bitmap && missingBitmaps.has(annotation.bitmapId)) {
476             annotationWithBitmaps.push(annotation);
477           }
478         }
479         // The array annotationWithBitmaps cannot be empty: the check above
480         // makes sure to have at least one annotation containing the bitmap.
481         imagePromises = AnnotationFactory.generateImages(
482           annotationWithBitmaps,
483           this.xref,
484           isOffscreenCanvasSupported
485         );
486       } else {
487         imagePromises = AnnotationFactory.generateImages(
488           newAnnots,
489           this.xref,
490           isOffscreenCanvasSupported
491         );
492       }
493 
494       deletedAnnotations = new RefSet();
495       this.#replaceIdByRef(newAnnots, deletedAnnotations, null);
496 
497       newAnnotationsPromise = annotationGlobalsPromise.then(
498         annotationGlobals => {
499           if (!annotationGlobals) {
500             return null;
501           }
502 
503           return AnnotationFactory.printNewAnnotations(
504             annotationGlobals,
505             partialEvaluator,
506             task,
507             newAnnots,
508             imagePromises
509           );
510         }
511       );
512     }
513 
514     const pageListPromise = Promise.all([
515       contentStreamPromise,
516       resourcesPromise,
517     ]).then(([contentStream]) => {
518       const opList = new OperatorList(intent, sink);
519 
520       handler.send("StartRenderPage", {
521         transparency: partialEvaluator.hasBlendModes(
522           this.resources,
523           this.nonBlendModesSet
524         ),
525         pageIndex: this.pageIndex,
526         cacheKey,
527       });
528 
529       return partialEvaluator
530         .getOperatorList({
531           stream: contentStream,
532           task,
533           resources: this.resources,
534           operatorList: opList,
535         })
536         .then(function () {
537           return opList;
538         });
539     });
540 
541     // Fetch the page's annotations and add their operator lists to the
542     // page's operator list to render them.
543     return Promise.all([
544       pageListPromise,
545       this._parsedAnnotations,
546       newAnnotationsPromise,
547     ]).then(function ([pageOpList, annotations, newAnnotations]) {
548       if (newAnnotations) {
549         // Some annotations can already exist (if it has the refToReplace
550         // property). In this case, we replace the old annotation by the new
551         // one.
552         annotations = annotations.filter(
553           a => !(a.ref && deletedAnnotations.has(a.ref))
554         );
555         for (let i = 0, ii = newAnnotations.length; i < ii; i++) {
556           const newAnnotation = newAnnotations[i];
557           if (newAnnotation.refToReplace) {
558             const j = annotations.findIndex(
559               a => a.ref && isRefsEqual(a.ref, newAnnotation.refToReplace)
560             );
561             if (j >= 0) {
562               annotations.splice(j, 1, newAnnotation);
563               newAnnotations.splice(i--, 1);
564               ii--;
565             }
566           }
567         }
568         annotations = annotations.concat(newAnnotations);
569       }
570       if (
571         annotations.length === 0 ||
572         intent & RenderingIntentFlag.ANNOTATIONS_DISABLE
573       ) {
574         pageOpList.flush(/* lastChunk = */ true);
575         return { length: pageOpList.totalLength };
576       }
577       const renderForms = !!(intent & RenderingIntentFlag.ANNOTATIONS_FORMS),
578         isEditing = !!(intent & RenderingIntentFlag.IS_EDITING),
579         intentAny = !!(intent & RenderingIntentFlag.ANY),
580         intentDisplay = !!(intent & RenderingIntentFlag.DISPLAY),
581         intentPrint = !!(intent & RenderingIntentFlag.PRINT);
582 
583       // Collect the operator list promises for the annotations. Each promise
584       // is resolved with the complete operator list for a single annotation.
585       const opListPromises = [];
586       for (const annotation of annotations) {
587         if (
588           intentAny ||
589           (intentDisplay &&
590             annotation.mustBeViewed(annotationStorage, renderForms) &&
591             annotation.mustBeViewedWhenEditing(isEditing, modifiedIds)) ||
592           (intentPrint && annotation.mustBePrinted(annotationStorage))
593         ) {
594           opListPromises.push(
595             annotation
596               .getOperatorList(
597                 partialEvaluator,
598                 task,
599                 intent,
600                 annotationStorage
601               )
602               .catch(function (reason) {
603                 warn(
604                   "getOperatorList - ignoring annotation data during " +
605                     `"${task.name}" task: "${reason}".`
606                 );
607                 return {
608                   opList: null,
609                   separateForm: false,
610                   separateCanvas: false,
611                 };
612               })
613           );
614         }
615       }
616 
617       return Promise.all(opListPromises).then(function (opLists) {
618         let form = false,
619           canvas = false;
620 
621         for (const { opList, separateForm, separateCanvas } of opLists) {
622           pageOpList.addOpList(opList);
623 
624           form ||= separateForm;
625           canvas ||= separateCanvas;
626         }
627         pageOpList.flush(
628           /* lastChunk = */ true,
629           /* separateAnnots = */ { form, canvas }
630         );
631         return { length: pageOpList.totalLength };
632       });
633     });
634   }
635 
636   async extractTextContent({
637     handler,
638     task,
639     includeMarkedContent,
640     disableNormalization,
641     sink,
642   }) {
643     const contentStreamPromise = this.getContentStream();
644     const resourcesPromise = this.loadResources([
645       "ExtGState",
646       "Font",
647       "Properties",
648       "XObject",
649     ]);
650     const langPromise = this.pdfManager.ensureCatalog("lang");
651 
652     const [contentStream, , lang] = await Promise.all([
653       contentStreamPromise,
654       resourcesPromise,
655       langPromise,
656     ]);
657     const partialEvaluator = new PartialEvaluator({
658       xref: this.xref,
659       handler,
660       pageIndex: this.pageIndex,
661       idFactory: this._localIdFactory,
662       fontCache: this.fontCache,
663       builtInCMapCache: this.builtInCMapCache,
664       standardFontDataCache: this.standardFontDataCache,
665       globalImageCache: this.globalImageCache,
666       systemFontCache: this.systemFontCache,
667       options: this.evaluatorOptions,
668     });
669 
670     return partialEvaluator.getTextContent({
671       stream: contentStream,
672       task,
673       resources: this.resources,
674       includeMarkedContent,
675       disableNormalization,
676       sink,
677       viewBox: this.view,
678       lang,
679     });
680   }
681 
682   async getStructTree() {
683     const structTreeRoot =
684       await this.pdfManager.ensureCatalog("structTreeRoot");
685     if (!structTreeRoot) {
686       return null;
687     }
688     // Ensure that the structTree will contain the page's annotations.
689     await this._parsedAnnotations;
690 
691     const structTree = await this.pdfManager.ensure(this, "_parseStructTree", [
692       structTreeRoot,
693     ]);
694     return structTree.serializable;
695   }
696 
697   /**
698    * @private
699    */
700   _parseStructTree(structTreeRoot) {
701     const tree = new StructTreePage(structTreeRoot, this.pageDict);
702     tree.parse(this.ref);
703     return tree;
704   }
705 
706   async getAnnotationsData(handler, task, intent) {
707     const annotations = await this._parsedAnnotations;
708     if (annotations.length === 0) {
709       return annotations;
710     }
711 
712     const annotationsData = [],
713       textContentPromises = [];
714     let partialEvaluator;
715 
716     const intentAny = !!(intent & RenderingIntentFlag.ANY),
717       intentDisplay = !!(intent & RenderingIntentFlag.DISPLAY),
718       intentPrint = !!(intent & RenderingIntentFlag.PRINT);
719 
720     for (const annotation of annotations) {
721       // Get the annotation even if it's hidden because
722       // JS can change its display.
723       const isVisible = intentAny || (intentDisplay && annotation.viewable);
724       if (isVisible || (intentPrint && annotation.printable)) {
725         annotationsData.push(annotation.data);
726       }
727 
728       if (annotation.hasTextContent && isVisible) {
729         partialEvaluator ||= new PartialEvaluator({
730           xref: this.xref,
731           handler,
732           pageIndex: this.pageIndex,
733           idFactory: this._localIdFactory,
734           fontCache: this.fontCache,
735           builtInCMapCache: this.builtInCMapCache,
736           standardFontDataCache: this.standardFontDataCache,
737           globalImageCache: this.globalImageCache,
738           systemFontCache: this.systemFontCache,
739           options: this.evaluatorOptions,
740         });
741 
742         textContentPromises.push(
743           annotation
744             .extractTextContent(partialEvaluator, task, [
745               -Infinity,
746               -Infinity,
747               Infinity,
748               Infinity,
749             ])
750             .catch(function (reason) {
751               warn(
752                 `getAnnotationsData - ignoring textContent during "${task.name}" task: "${reason}".`
753               );
754             })
755         );
756       }
757     }
758 
759     await Promise.all(textContentPromises);
760     return annotationsData;
761   }
762 
763   get annotations() {
764     const annots = this._getInheritableProperty("Annots");
765     return shadow(this, "annotations", Array.isArray(annots) ? annots : []);
766   }
767 
768   get _parsedAnnotations() {
769     const promise = this.pdfManager
770       .ensure(this, "annotations")
771       .then(async annots => {
772         if (annots.length === 0) {
773           return annots;
774         }
775         const annotationGlobals =
776           await this.pdfManager.ensureDoc("annotationGlobals");
777         if (!annotationGlobals) {
778           return [];
779         }
780 
781         const annotationPromises = [];
782         for (const annotationRef of annots) {
783           annotationPromises.push(
784             AnnotationFactory.create(
785               this.xref,
786               annotationRef,
787               annotationGlobals,
788               this._localIdFactory,
789               /* collectFields */ false,
790               this.ref
791             ).catch(function (reason) {
792               warn(`_parsedAnnotations: "${reason}".`);
793               return null;
794             })
795           );
796         }
797 
798         const sortedAnnotations = [];
799         let popupAnnotations, widgetAnnotations;
800         // Ensure that PopupAnnotations are handled last, since they depend on
801         // their parent Annotation in the display layer; fixes issue 11362.
802         for (const annotation of await Promise.all(annotationPromises)) {
803           if (!annotation) {
804             continue;
805           }
806           if (annotation instanceof WidgetAnnotation) {
807             (widgetAnnotations ||= []).push(annotation);
808             continue;
809           }
810           if (annotation instanceof PopupAnnotation) {
811             (popupAnnotations ||= []).push(annotation);
812             continue;
813           }
814           sortedAnnotations.push(annotation);
815         }
816         if (widgetAnnotations) {
817           sortedAnnotations.push(...widgetAnnotations);
818         }
819         if (popupAnnotations) {
820           sortedAnnotations.push(...popupAnnotations);
821         }
822 
823         return sortedAnnotations;
824       });
825 
826     return shadow(this, "_parsedAnnotations", promise);
827   }
828 
829   get jsActions() {
830     const actions = collectActions(
831       this.xref,
832       this.pageDict,
833       PageActionEventType
834     );
835     return shadow(this, "jsActions", actions);
836   }
837 }
838 
839 const PDF_HEADER_SIGNATURE = new Uint8Array([0x25, 0x50, 0x44, 0x46, 0x2d]);
840 const STARTXREF_SIGNATURE = new Uint8Array([
841   0x73, 0x74, 0x61, 0x72, 0x74, 0x78, 0x72, 0x65, 0x66,
842 ]);
843 const ENDOBJ_SIGNATURE = new Uint8Array([0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a]);
844 
845 const FINGERPRINT_FIRST_BYTES = 1024;
846 const EMPTY_FINGERPRINT =
847   "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";
848 
849 function find(stream, signature, limit = 1024, backwards = false) {
850   if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
851     assert(limit > 0, 'The "limit" must be a positive integer.');
852   }
853   const signatureLength = signature.length;
854 
855   const scanBytes = stream.peekBytes(limit);
856   const scanLength = scanBytes.length - signatureLength;
857 
858   if (scanLength <= 0) {
859     return false;
860   }
861   if (backwards) {
862     const signatureEnd = signatureLength - 1;
863 
864     let pos = scanBytes.length - 1;
865     while (pos >= signatureEnd) {
866       let j = 0;
867       while (
868         j < signatureLength &&
869         scanBytes[pos - j] === signature[signatureEnd - j]
870       ) {
871         j++;
872       }
873       if (j >= signatureLength) {
874         // `signature` found.
875         stream.pos += pos - signatureEnd;
876         return true;
877       }
878       pos--;
879     }
880   } else {
881     // forwards
882     let pos = 0;
883     while (pos <= scanLength) {
884       let j = 0;
885       while (j < signatureLength && scanBytes[pos + j] === signature[j]) {
886         j++;
887       }
888       if (j >= signatureLength) {
889         // `signature` found.
890         stream.pos += pos;
891         return true;
892       }
893       pos++;
894     }
895   }
896   return false;
897 }
898 
899 /**
900  * The `PDFDocument` class holds all the (worker-thread) data of the PDF file.
901  */
902 class PDFDocument {
903   constructor(pdfManager, stream) {
904     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
905       assert(
906         stream instanceof BaseStream,
907         'PDFDocument: Invalid "stream" argument.'
908       );
909     }
910     if (stream.length <= 0) {
911       throw new InvalidPDFException(
912         "The PDF file is empty, i.e. its size is zero bytes."
913       );
914     }
915 
916     this.pdfManager = pdfManager;
917     this.stream = stream;
918     this.xref = new XRef(stream, pdfManager);
919     this._pagePromises = new Map();
920     this._version = null;
921 
922     const idCounters = {
923       font: 0,
924     };
925     this._globalIdFactory = class {
926       static getDocId() {
927         return `g_${pdfManager.docId}`;
928       }
929 
930       static createFontId() {
931         return `f${++idCounters.font}`;
932       }
933 
934       static createObjId() {
935         unreachable("Abstract method `createObjId` called.");
936       }
937 
938       static getPageObjId() {
939         unreachable("Abstract method `getPageObjId` called.");
940       }
941     };
942   }
943 
944   parse(recoveryMode) {
945     this.xref.parse(recoveryMode);
946     this.catalog = new Catalog(this.pdfManager, this.xref);
947   }
948 
949   get linearization() {
950     let linearization = null;
951     try {
952       linearization = Linearization.create(this.stream);
953     } catch (err) {
954       if (err instanceof MissingDataException) {
955         throw err;
956       }
957       info(err);
958     }
959     return shadow(this, "linearization", linearization);
960   }
961 
962   get startXRef() {
963     const stream = this.stream;
964     let startXRef = 0;
965 
966     if (this.linearization) {
967       // Find the end of the first object.
968       stream.reset();
969       if (find(stream, ENDOBJ_SIGNATURE)) {
970         stream.skip(6);
971 
972         let ch = stream.peekByte();
973         while (isWhiteSpace(ch)) {
974           stream.pos++;
975           ch = stream.peekByte();
976         }
977         startXRef = stream.pos - stream.start;
978       }
979     } else {
980       // Find `startxref` by checking backwards from the end of the file.
981       const step = 1024;
982       const startXRefLength = STARTXREF_SIGNATURE.length;
983       let found = false,
984         pos = stream.end;
985 
986       while (!found && pos > 0) {
987         pos -= step - startXRefLength;
988         if (pos < 0) {
989           pos = 0;
990         }
991         stream.pos = pos;
992         found = find(stream, STARTXREF_SIGNATURE, step, true);
993       }
994 
995       if (found) {
996         stream.skip(9);
997         let ch;
998         do {
999           ch = stream.getByte();
1000         } while (isWhiteSpace(ch));
1001         let str = "";
1002         while (ch >= /* Space = */ 0x20 && ch <= /* '9' = */ 0x39) {
1003           str += String.fromCharCode(ch);
1004           ch = stream.getByte();
1005         }
1006         startXRef = parseInt(str, 10);
1007         if (isNaN(startXRef)) {
1008           startXRef = 0;
1009         }
1010       }
1011     }
1012     return shadow(this, "startXRef", startXRef);
1013   }
1014 
1015   // Find the header, get the PDF format version and setup the
1016   // stream to start from the header.
1017   checkHeader() {
1018     const stream = this.stream;
1019     stream.reset();
1020 
1021     if (!find(stream, PDF_HEADER_SIGNATURE)) {
1022       // May not be a PDF file, but don't throw an error and let
1023       // parsing continue.
1024       return;
1025     }
1026     stream.moveStart();
1027 
1028     // Skip over the "%PDF-" prefix, since it was found above.
1029     stream.skip(PDF_HEADER_SIGNATURE.length);
1030     // Read the PDF format version.
1031     let version = "",
1032       ch;
1033     while (
1034       (ch = stream.getByte()) > /* Space = */ 0x20 &&
1035       version.length < /* MAX_PDF_VERSION_LENGTH = */ 7
1036     ) {
1037       version += String.fromCharCode(ch);
1038     }
1039 
1040     if (PDF_VERSION_REGEXP.test(version)) {
1041       this._version = version;
1042     } else {
1043       warn(`Invalid PDF header version: ${version}`);
1044     }
1045   }
1046 
1047   parseStartXRef() {
1048     this.xref.setStartXRef(this.startXRef);
1049   }
1050 
1051   get numPages() {
1052     let num = 0;
1053     if (this.catalog.hasActualNumPages) {
1054       num = this.catalog.numPages;
1055     } else if (this.xfaFactory) {
1056       // num is a Promise.
1057       num = this.xfaFactory.getNumPages();
1058     } else if (this.linearization) {
1059       num = this.linearization.numPages;
1060     } else {
1061       num = this.catalog.numPages;
1062     }
1063     return shadow(this, "numPages", num);
1064   }
1065 
1066   /**
1067    * @private
1068    */
1069   _hasOnlyDocumentSignatures(fields, recursionDepth = 0) {
1070     const RECURSION_LIMIT = 10;
1071 
1072     if (!Array.isArray(fields)) {
1073       return false;
1074     }
1075     return fields.every(field => {
1076       field = this.xref.fetchIfRef(field);
1077       if (!(field instanceof Dict)) {
1078         return false;
1079       }
1080       if (field.has("Kids")) {
1081         if (++recursionDepth > RECURSION_LIMIT) {
1082           warn("_hasOnlyDocumentSignatures: maximum recursion depth reached");
1083           return false;
1084         }
1085         return this._hasOnlyDocumentSignatures(
1086           field.get("Kids"),
1087           recursionDepth
1088         );
1089       }
1090       const isSignature = isName(field.get("FT"), "Sig");
1091       const rectangle = field.get("Rect");
1092       const isInvisible =
1093         Array.isArray(rectangle) && rectangle.every(value => value === 0);
1094       return isSignature && isInvisible;
1095     });
1096   }
1097 
1098   get _xfaStreams() {
1099     const acroForm = this.catalog.acroForm;
1100     if (!acroForm) {
1101       return null;
1102     }
1103 
1104     const xfa = acroForm.get("XFA");
1105     const entries = {
1106       "xdp:xdp": "",
1107       template: "",
1108       datasets: "",
1109       config: "",
1110       connectionSet: "",
1111       localeSet: "",
1112       stylesheet: "",
1113       "/xdp:xdp": "",
1114     };
1115     if (xfa instanceof BaseStream && !xfa.isEmpty) {
1116       entries["xdp:xdp"] = xfa;
1117       return entries;
1118     }
1119 
1120     if (!Array.isArray(xfa) || xfa.length === 0) {
1121       return null;
1122     }
1123 
1124     for (let i = 0, ii = xfa.length; i < ii; i += 2) {
1125       let name;
1126       if (i === 0) {
1127         name = "xdp:xdp";
1128       } else if (i === ii - 2) {
1129         name = "/xdp:xdp";
1130       } else {
1131         name = xfa[i];
1132       }
1133 
1134       if (!entries.hasOwnProperty(name)) {
1135         continue;
1136       }
1137       const data = this.xref.fetchIfRef(xfa[i + 1]);
1138       if (!(data instanceof BaseStream) || data.isEmpty) {
1139         continue;
1140       }
1141       entries[name] = data;
1142     }
1143     return entries;
1144   }
1145 
1146   get xfaDatasets() {
1147     const streams = this._xfaStreams;
1148     if (!streams) {
1149       return shadow(this, "xfaDatasets", null);
1150     }
1151     for (const key of ["datasets", "xdp:xdp"]) {
1152       const stream = streams[key];
1153       if (!stream) {
1154         continue;
1155       }
1156       try {
1157         const str = stringToUTF8String(stream.getString());
1158         const data = { [key]: str };
1159         return shadow(this, "xfaDatasets", new DatasetReader(data));
1160       } catch {
1161         warn("XFA - Invalid utf-8 string.");
1162         break;
1163       }
1164     }
1165     return shadow(this, "xfaDatasets", null);
1166   }
1167 
1168   get xfaData() {
1169     const streams = this._xfaStreams;
1170     if (!streams) {
1171       return null;
1172     }
1173     const data = Object.create(null);
1174     for (const [key, stream] of Object.entries(streams)) {
1175       if (!stream) {
1176         continue;
1177       }
1178       try {
1179         data[key] = stringToUTF8String(stream.getString());
1180       } catch {
1181         warn("XFA - Invalid utf-8 string.");
1182         return null;
1183       }
1184     }
1185     return data;
1186   }
1187 
1188   get xfaFactory() {
1189     let data;
1190     if (
1191       this.pdfManager.enableXfa &&
1192       this.catalog.needsRendering &&
1193       this.formInfo.hasXfa &&
1194       !this.formInfo.hasAcroForm
1195     ) {
1196       data = this.xfaData;
1197     }
1198     return shadow(this, "xfaFactory", data ? new XFAFactory(data) : null);
1199   }
1200 
1201   get isPureXfa() {
1202     return this.xfaFactory ? this.xfaFactory.isValid() : false;
1203   }
1204 
1205   get htmlForXfa() {
1206     return this.xfaFactory ? this.xfaFactory.getPages() : null;
1207   }
1208 
1209   async loadXfaImages() {
1210     const xfaImagesDict = await this.pdfManager.ensureCatalog("xfaImages");
1211     if (!xfaImagesDict) {
1212       return;
1213     }
1214 
1215     const keys = xfaImagesDict.getKeys();
1216     const objectLoader = new ObjectLoader(xfaImagesDict, keys, this.xref);
1217     await objectLoader.load();
1218 
1219     const xfaImages = new Map();
1220     for (const key of keys) {
1221       const stream = xfaImagesDict.get(key);
1222       if (stream instanceof BaseStream) {
1223         xfaImages.set(key, stream.getBytes());
1224       }
1225     }
1226 
1227     this.xfaFactory.setImages(xfaImages);
1228   }
1229 
1230   async loadXfaFonts(handler, task) {
1231     const acroForm = await this.pdfManager.ensureCatalog("acroForm");
1232     if (!acroForm) {
1233       return;
1234     }
1235     const resources = await acroForm.getAsync("DR");
1236     if (!(resources instanceof Dict)) {
1237       return;
1238     }
1239     const objectLoader = new ObjectLoader(resources, ["Font"], this.xref);
1240     await objectLoader.load();
1241 
1242     const fontRes = resources.get("Font");
1243     if (!(fontRes instanceof Dict)) {
1244       return;
1245     }
1246 
1247     const options = Object.assign(
1248       Object.create(null),
1249       this.pdfManager.evaluatorOptions
1250     );
1251     options.useSystemFonts = false;
1252 
1253     const partialEvaluator = new PartialEvaluator({
1254       xref: this.xref,
1255       handler,
1256       pageIndex: -1,
1257       idFactory: this._globalIdFactory,
1258       fontCache: this.catalog.fontCache,
1259       builtInCMapCache: this.catalog.builtInCMapCache,
1260       standardFontDataCache: this.catalog.standardFontDataCache,
1261       options,
1262     });
1263     const operatorList = new OperatorList();
1264     const pdfFonts = [];
1265     const initialState = {
1266       get font() {
1267         return pdfFonts.at(-1);
1268       },
1269       set font(font) {
1270         pdfFonts.push(font);
1271       },
1272       clone() {
1273         return this;
1274       },
1275     };
1276 
1277     const fonts = new Map();
1278     fontRes.forEach((fontName, font) => {
1279       fonts.set(fontName, font);
1280     });
1281     const promises = [];
1282 
1283     for (const [fontName, font] of fonts) {
1284       const descriptor = font.get("FontDescriptor");
1285       if (!(descriptor instanceof Dict)) {
1286         continue;
1287       }
1288       let fontFamily = descriptor.get("FontFamily");
1289       // For example, "Wingdings 3" is not a valid font name in the css specs.
1290       fontFamily = fontFamily.replaceAll(/[ ]+(\d)/g, "$1");
1291       const fontWeight = descriptor.get("FontWeight");
1292 
1293       // Angle is expressed in degrees counterclockwise in PDF
1294       // when it's clockwise in CSS
1295       // (see https://drafts.csswg.org/css-fonts-4/#valdef-font-style-oblique-angle)
1296       const italicAngle = -descriptor.get("ItalicAngle");
1297       const cssFontInfo = { fontFamily, fontWeight, italicAngle };
1298 
1299       if (!validateCSSFont(cssFontInfo)) {
1300         continue;
1301       }
1302       promises.push(
1303         partialEvaluator
1304           .handleSetFont(
1305             resources,
1306             [Name.get(fontName), 1],
1307             /* fontRef = */ null,
1308             operatorList,
1309             task,
1310             initialState,
1311             /* fallbackFontDict = */ null,
1312             /* cssFontInfo = */ cssFontInfo
1313           )
1314           .catch(function (reason) {
1315             warn(`loadXfaFonts: "${reason}".`);
1316             return null;
1317           })
1318       );
1319     }
1320 
1321     await Promise.all(promises);
1322     const missingFonts = this.xfaFactory.setFonts(pdfFonts);
1323 
1324     if (!missingFonts) {
1325       return;
1326     }
1327 
1328     options.ignoreErrors = true;
1329     promises.length = 0;
1330     pdfFonts.length = 0;
1331 
1332     const reallyMissingFonts = new Set();
1333     for (const missing of missingFonts) {
1334       if (!getXfaFontName(`${missing}-Regular`)) {
1335         // No substitution available: we'll fallback on Myriad.
1336         reallyMissingFonts.add(missing);
1337       }
1338     }
1339 
1340     if (reallyMissingFonts.size) {
1341       missingFonts.push("PdfJS-Fallback");
1342     }
1343 
1344     for (const missing of missingFonts) {
1345       if (reallyMissingFonts.has(missing)) {
1346         continue;
1347       }
1348       for (const fontInfo of [
1349         { name: "Regular", fontWeight: 400, italicAngle: 0 },
1350         { name: "Bold", fontWeight: 700, italicAngle: 0 },
1351         { name: "Italic", fontWeight: 400, italicAngle: 12 },
1352         { name: "BoldItalic", fontWeight: 700, italicAngle: 12 },
1353       ]) {
1354         const name = `${missing}-${fontInfo.name}`;
1355         const dict = getXfaFontDict(name);
1356 
1357         promises.push(
1358           partialEvaluator
1359             .handleSetFont(
1360               resources,
1361               [Name.get(name), 1],
1362               /* fontRef = */ null,
1363               operatorList,
1364               task,
1365               initialState,
1366               /* fallbackFontDict = */ dict,
1367               /* cssFontInfo = */ {
1368                 fontFamily: missing,
1369                 fontWeight: fontInfo.fontWeight,
1370                 italicAngle: fontInfo.italicAngle,
1371               }
1372             )
1373             .catch(function (reason) {
1374               warn(`loadXfaFonts: "${reason}".`);
1375               return null;
1376             })
1377         );
1378       }
1379     }
1380 
1381     await Promise.all(promises);
1382     this.xfaFactory.appendFonts(pdfFonts, reallyMissingFonts);
1383   }
1384 
1385   async serializeXfaData(annotationStorage) {
1386     return this.xfaFactory
1387       ? this.xfaFactory.serializeData(annotationStorage)
1388       : null;
1389   }
1390 
1391   /**
1392    * The specification states in section 7.5.2 that the version from
1393    * the catalog, if present, should overwrite the version from the header.
1394    */
1395   get version() {
1396     return this.catalog.version || this._version;
1397   }
1398 
1399   get formInfo() {
1400     const formInfo = {
1401       hasFields: false,
1402       hasAcroForm: false,
1403       hasXfa: false,
1404       hasSignatures: false,
1405     };
1406     const acroForm = this.catalog.acroForm;
1407     if (!acroForm) {
1408       return shadow(this, "formInfo", formInfo);
1409     }
1410 
1411     try {
1412       const fields = acroForm.get("Fields");
1413       const hasFields = Array.isArray(fields) && fields.length > 0;
1414       formInfo.hasFields = hasFields; // Used by the `fieldObjects` getter.
1415 
1416       // The document contains XFA data if the `XFA` entry is a non-empty
1417       // array or stream.
1418       const xfa = acroForm.get("XFA");
1419       formInfo.hasXfa =
1420         (Array.isArray(xfa) && xfa.length > 0) ||
1421         (xfa instanceof BaseStream && !xfa.isEmpty);
1422 
1423       // The document contains AcroForm data if the `Fields` entry is a
1424       // non-empty array and it doesn't consist of only document signatures.
1425       // This second check is required for files that don't actually contain
1426       // AcroForm data (only XFA data), but that use the `Fields` entry to
1427       // store (invisible) document signatures. This can be detected using
1428       // the first bit of the `SigFlags` integer (see Table 219 in the
1429       // specification).
1430       const sigFlags = acroForm.get("SigFlags");
1431       const hasSignatures = !!(sigFlags & 0x1);
1432       const hasOnlyDocumentSignatures =
1433         hasSignatures && this._hasOnlyDocumentSignatures(fields);
1434       formInfo.hasAcroForm = hasFields && !hasOnlyDocumentSignatures;
1435       formInfo.hasSignatures = hasSignatures;
1436     } catch (ex) {
1437       if (ex instanceof MissingDataException) {
1438         throw ex;
1439       }
1440       warn(`Cannot fetch form information: "${ex}".`);
1441     }
1442     return shadow(this, "formInfo", formInfo);
1443   }
1444 
1445   get documentInfo() {
1446     const docInfo = {
1447       PDFFormatVersion: this.version,
1448       Language: this.catalog.lang,
1449       EncryptFilterName: this.xref.encrypt
1450         ? this.xref.encrypt.filterName
1451         : null,
1452       IsLinearized: !!this.linearization,
1453       IsAcroFormPresent: this.formInfo.hasAcroForm,
1454       IsXFAPresent: this.formInfo.hasXfa,
1455       IsCollectionPresent: !!this.catalog.collection,
1456       IsSignaturesPresent: this.formInfo.hasSignatures,
1457     };
1458 
1459     let infoDict;
1460     try {
1461       infoDict = this.xref.trailer.get("Info");
1462     } catch (err) {
1463       if (err instanceof MissingDataException) {
1464         throw err;
1465       }
1466       info("The document information dictionary is invalid.");
1467     }
1468     if (!(infoDict instanceof Dict)) {
1469       return shadow(this, "documentInfo", docInfo);
1470     }
1471 
1472     for (const key of infoDict.getKeys()) {
1473       const value = infoDict.get(key);
1474 
1475       switch (key) {
1476         case "Title":
1477         case "Author":
1478         case "Subject":
1479         case "Keywords":
1480         case "Creator":
1481         case "Producer":
1482         case "CreationDate":
1483         case "ModDate":
1484           if (typeof value === "string") {
1485             docInfo[key] = stringToPDFString(value);
1486             continue;
1487           }
1488           break;
1489         case "Trapped":
1490           if (value instanceof Name) {
1491             docInfo[key] = value;
1492             continue;
1493           }
1494           break;
1495         default:
1496           // For custom values, only accept white-listed types to prevent
1497           // errors that would occur when trying to send non-serializable
1498           // objects to the main-thread (for example `Dict` or `Stream`).
1499           let customValue;
1500           switch (typeof value) {
1501             case "string":
1502               customValue = stringToPDFString(value);
1503               break;
1504             case "number":
1505             case "boolean":
1506               customValue = value;
1507               break;
1508             default:
1509               if (value instanceof Name) {
1510                 customValue = value;
1511               }
1512               break;
1513           }
1514 
1515           if (customValue === undefined) {
1516             warn(`Bad value, for custom key "${key}", in Info: ${value}.`);
1517             continue;
1518           }
1519           if (!docInfo.Custom) {
1520             docInfo.Custom = Object.create(null);
1521           }
1522           docInfo.Custom[key] = customValue;
1523           continue;
1524       }
1525       warn(`Bad value, for key "${key}", in Info: ${value}.`);
1526     }
1527     return shadow(this, "documentInfo", docInfo);
1528   }
1529 
1530   get fingerprints() {
1531     function validate(data) {
1532       return (
1533         typeof data === "string" &&
1534         data.length > 0 &&
1535         data !== EMPTY_FINGERPRINT
1536       );
1537     }
1538 
1539     function hexString(hash) {
1540       const buf = [];
1541       for (const num of hash) {
1542         const hex = num.toString(16);
1543         buf.push(hex.padStart(2, "0"));
1544       }
1545       return buf.join("");
1546     }
1547 
1548     const idArray = this.xref.trailer.get("ID");
1549     let hashOriginal, hashModified;
1550     if (Array.isArray(idArray) && validate(idArray[0])) {
1551       hashOriginal = stringToBytes(idArray[0]);
1552 
1553       if (idArray[1] !== idArray[0] && validate(idArray[1])) {
1554         hashModified = stringToBytes(idArray[1]);
1555       }
1556     } else {
1557       hashOriginal = calculateMD5(
1558         this.stream.getByteRange(0, FINGERPRINT_FIRST_BYTES),
1559         0,
1560         FINGERPRINT_FIRST_BYTES
1561       );
1562     }
1563 
1564     return shadow(this, "fingerprints", [
1565       hexString(hashOriginal),
1566       hashModified ? hexString(hashModified) : null,
1567     ]);
1568   }
1569 
1570   async _getLinearizationPage(pageIndex) {
1571     const { catalog, linearization, xref } = this;
1572     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1573       assert(
1574         linearization?.pageFirst === pageIndex,
1575         "_getLinearizationPage - invalid pageIndex argument."
1576       );
1577     }
1578 
1579     const ref = Ref.get(linearization.objectNumberFirst, 0);
1580     try {
1581       const obj = await xref.fetchAsync(ref);
1582       // Ensure that the object that was found is actually a Page dictionary.
1583       if (obj instanceof Dict) {
1584         let type = obj.getRaw("Type");
1585         if (type instanceof Ref) {
1586           type = await xref.fetchAsync(type);
1587         }
1588         if (
1589           isName(type, "Page") ||
1590           (!obj.has("Type") && !obj.has("Kids") && obj.has("Contents"))
1591         ) {
1592           if (!catalog.pageKidsCountCache.has(ref)) {
1593             catalog.pageKidsCountCache.put(ref, 1); // Cache the Page reference.
1594           }
1595           // Help improve performance of the `Catalog.getPageIndex` method.
1596           if (!catalog.pageIndexCache.has(ref)) {
1597             catalog.pageIndexCache.put(ref, 0);
1598           }
1599 
1600           return [obj, ref];
1601         }
1602       }
1603       throw new FormatError(
1604         "The Linearization dictionary doesn't point to a valid Page dictionary."
1605       );
1606     } catch (reason) {
1607       warn(`_getLinearizationPage: "${reason.message}".`);
1608       return catalog.getPageDict(pageIndex);
1609     }
1610   }
1611 
1612   getPage(pageIndex) {
1613     const cachedPromise = this._pagePromises.get(pageIndex);
1614     if (cachedPromise) {
1615       return cachedPromise;
1616     }
1617     const { catalog, linearization, xfaFactory } = this;
1618 
1619     let promise;
1620     if (xfaFactory) {
1621       promise = Promise.resolve([Dict.empty, null]);
1622     } else if (linearization?.pageFirst === pageIndex) {
1623       promise = this._getLinearizationPage(pageIndex);
1624     } else {
1625       promise = catalog.getPageDict(pageIndex);
1626     }
1627     // eslint-disable-next-line arrow-body-style
1628     promise = promise.then(([pageDict, ref]) => {
1629       return new Page({
1630         pdfManager: this.pdfManager,
1631         xref: this.xref,
1632         pageIndex,
1633         pageDict,
1634         ref,
1635         globalIdFactory: this._globalIdFactory,
1636         fontCache: catalog.fontCache,
1637         builtInCMapCache: catalog.builtInCMapCache,
1638         standardFontDataCache: catalog.standardFontDataCache,
1639         globalImageCache: catalog.globalImageCache,
1640         systemFontCache: catalog.systemFontCache,
1641         nonBlendModesSet: catalog.nonBlendModesSet,
1642         xfaFactory,
1643       });
1644     });
1645 
1646     this._pagePromises.set(pageIndex, promise);
1647     return promise;
1648   }
1649 
1650   async checkFirstPage(recoveryMode = false) {
1651     if (recoveryMode) {
1652       return;
1653     }
1654     try {
1655       await this.getPage(0);
1656     } catch (reason) {
1657       if (reason instanceof XRefEntryException) {
1658         // Clear out the various caches to ensure that we haven't stored any
1659         // inconsistent and/or incorrect state, since that could easily break
1660         // subsequent `this.getPage` calls.
1661         this._pagePromises.delete(0);
1662         await this.cleanup();
1663 
1664         throw new XRefParseException();
1665       }
1666     }
1667   }
1668 
1669   async checkLastPage(recoveryMode = false) {
1670     const { catalog, pdfManager } = this;
1671 
1672     catalog.setActualNumPages(); // Ensure that it's always reset.
1673     let numPages;
1674 
1675     try {
1676       await Promise.all([
1677         pdfManager.ensureDoc("xfaFactory"),
1678         pdfManager.ensureDoc("linearization"),
1679         pdfManager.ensureCatalog("numPages"),
1680       ]);
1681 
1682       if (this.xfaFactory) {
1683         return; // The Page count is always calculated for XFA-documents.
1684       } else if (this.linearization) {
1685         numPages = this.linearization.numPages;
1686       } else {
1687         numPages = catalog.numPages;
1688       }
1689 
1690       if (!Number.isInteger(numPages)) {
1691         throw new FormatError("Page count is not an integer.");
1692       } else if (numPages <= 1) {
1693         return;
1694       }
1695       await this.getPage(numPages - 1);
1696     } catch (reason) {
1697       // Clear out the various caches to ensure that we haven't stored any
1698       // inconsistent and/or incorrect state, since that could easily break
1699       // subsequent `this.getPage` calls.
1700       this._pagePromises.delete(numPages - 1);
1701       await this.cleanup();
1702 
1703       if (reason instanceof XRefEntryException && !recoveryMode) {
1704         throw new XRefParseException();
1705       }
1706       warn(`checkLastPage - invalid /Pages tree /Count: ${numPages}.`);
1707 
1708       let pagesTree;
1709       try {
1710         pagesTree = await catalog.getAllPageDicts(recoveryMode);
1711       } catch (reasonAll) {
1712         if (reasonAll instanceof XRefEntryException && !recoveryMode) {
1713           throw new XRefParseException();
1714         }
1715         catalog.setActualNumPages(1);
1716         return;
1717       }
1718 
1719       for (const [pageIndex, [pageDict, ref]] of pagesTree) {
1720         let promise;
1721         if (pageDict instanceof Error) {
1722           promise = Promise.reject(pageDict);
1723 
1724           // Prevent "uncaught exception: Object"-messages in the console.
1725           promise.catch(() => {});
1726         } else {
1727           promise = Promise.resolve(
1728             new Page({
1729               pdfManager,
1730               xref: this.xref,
1731               pageIndex,
1732               pageDict,
1733               ref,
1734               globalIdFactory: this._globalIdFactory,
1735               fontCache: catalog.fontCache,
1736               builtInCMapCache: catalog.builtInCMapCache,
1737               standardFontDataCache: catalog.standardFontDataCache,
1738               globalImageCache: catalog.globalImageCache,
1739               systemFontCache: catalog.systemFontCache,
1740               nonBlendModesSet: catalog.nonBlendModesSet,
1741               xfaFactory: null,
1742             })
1743           );
1744         }
1745 
1746         this._pagePromises.set(pageIndex, promise);
1747       }
1748       catalog.setActualNumPages(pagesTree.size);
1749     }
1750   }
1751 
1752   fontFallback(id, handler) {
1753     return this.catalog.fontFallback(id, handler);
1754   }
1755 
1756   async cleanup(manuallyTriggered = false) {
1757     return this.catalog
1758       ? this.catalog.cleanup(manuallyTriggered)
1759       : clearGlobalCaches();
1760   }
1761 
1762   async #collectFieldObjects(
1763     name,
1764     fieldRef,
1765     promises,
1766     annotationGlobals,
1767     visitedRefs
1768   ) {
1769     const { xref } = this;
1770 
1771     if (!(fieldRef instanceof Ref) || visitedRefs.has(fieldRef)) {
1772       return;
1773     }
1774     visitedRefs.put(fieldRef);
1775     const field = await xref.fetchAsync(fieldRef);
1776     if (!(field instanceof Dict)) {
1777       return;
1778     }
1779     if (field.has("T")) {
1780       const partName = stringToPDFString(await field.getAsync("T"));
1781       name = name === "" ? partName : `${name}.${partName}`;
1782     } else {
1783       let obj = field;
1784       while (true) {
1785         obj = obj.getRaw("Parent");
1786         if (obj instanceof Ref) {
1787           if (visitedRefs.has(obj)) {
1788             break;
1789           }
1790           obj = await xref.fetchAsync(obj);
1791         }
1792         if (!(obj instanceof Dict)) {
1793           break;
1794         }
1795         if (obj.has("T")) {
1796           const partName = stringToPDFString(await obj.getAsync("T"));
1797           name = name === "" ? partName : `${name}.${partName}`;
1798           break;
1799         }
1800       }
1801     }
1802 
1803     if (!promises.has(name)) {
1804       promises.set(name, []);
1805     }
1806     promises.get(name).push(
1807       AnnotationFactory.create(
1808         xref,
1809         fieldRef,
1810         annotationGlobals,
1811         /* idFactory = */ null,
1812         /* collectFields */ true,
1813         /* pageRef */ null
1814       )
1815         .then(annotation => annotation?.getFieldObject())
1816         .catch(function (reason) {
1817           warn(`#collectFieldObjects: "${reason}".`);
1818           return null;
1819         })
1820     );
1821 
1822     if (!field.has("Kids")) {
1823       return;
1824     }
1825     const kids = await field.getAsync("Kids");
1826     if (Array.isArray(kids)) {
1827       for (const kid of kids) {
1828         await this.#collectFieldObjects(
1829           name,
1830           kid,
1831           promises,
1832           annotationGlobals,
1833           visitedRefs
1834         );
1835       }
1836     }
1837   }
1838 
1839   get fieldObjects() {
1840     if (!this.formInfo.hasFields) {
1841       return shadow(this, "fieldObjects", Promise.resolve(null));
1842     }
1843 
1844     const promise = Promise.all([
1845       this.pdfManager.ensureDoc("annotationGlobals"),
1846       this.pdfManager.ensureCatalog("acroForm"),
1847     ]).then(async ([annotationGlobals, acroForm]) => {
1848       if (!annotationGlobals) {
1849         return null;
1850       }
1851 
1852       const visitedRefs = new RefSet();
1853       const allFields = Object.create(null);
1854       const fieldPromises = new Map();
1855       for (const fieldRef of await acroForm.getAsync("Fields")) {
1856         await this.#collectFieldObjects(
1857           "",
1858           fieldRef,
1859           fieldPromises,
1860           annotationGlobals,
1861           visitedRefs
1862         );
1863       }
1864 
1865       const allPromises = [];
1866       for (const [name, promises] of fieldPromises) {
1867         allPromises.push(
1868           Promise.all(promises).then(fields => {
1869             fields = fields.filter(field => !!field);
1870             if (fields.length > 0) {
1871               allFields[name] = fields;
1872             }
1873           })
1874         );
1875       }
1876 
1877       await Promise.all(allPromises);
1878       return allFields;
1879     });
1880 
1881     return shadow(this, "fieldObjects", promise);
1882   }
1883 
1884   get hasJSActions() {
1885     const promise = this.pdfManager.ensureDoc("_parseHasJSActions");
1886     return shadow(this, "hasJSActions", promise);
1887   }
1888 
1889   /**
1890    * @private
1891    */
1892   async _parseHasJSActions() {
1893     const [catalogJsActions, fieldObjects] = await Promise.all([
1894       this.pdfManager.ensureCatalog("jsActions"),
1895       this.pdfManager.ensureDoc("fieldObjects"),
1896     ]);
1897 
1898     if (catalogJsActions) {
1899       return true;
1900     }
1901     if (fieldObjects) {
1902       return Object.values(fieldObjects).some(fieldObject =>
1903         fieldObject.some(object => object.actions !== null)
1904       );
1905     }
1906     return false;
1907   }
1908 
1909   get calculationOrderIds() {
1910     const acroForm = this.catalog.acroForm;
1911     if (!acroForm?.has("CO")) {
1912       return shadow(this, "calculationOrderIds", null);
1913     }
1914 
1915     const calculationOrder = acroForm.get("CO");
1916     if (!Array.isArray(calculationOrder) || calculationOrder.length === 0) {
1917       return shadow(this, "calculationOrderIds", null);
1918     }
1919 
1920     const ids = [];
1921     for (const id of calculationOrder) {
1922       if (id instanceof Ref) {
1923         ids.push(id.toString());
1924       }
1925     }
1926     if (ids.length === 0) {
1927       return shadow(this, "calculationOrderIds", null);
1928     }
1929     return shadow(this, "calculationOrderIds", ids);
1930   }
1931 
1932   get annotationGlobals() {
1933     return shadow(
1934       this,
1935       "annotationGlobals",
1936       AnnotationFactory.createGlobals(this.pdfManager)
1937     );
1938   }
1939 }
1940 
1941 export { Page, PDFDocument };
</code>

Test file:
<test_file>
File:
test/unit/annotation_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  Annotation,
  AnnotationBorderStyle,
  AnnotationFactory,
  getQuadPoints,
  MarkupAnnotation,
} from "../../src/core/annotation.js";
import {
  AnnotationBorderStyleType,
  AnnotationEditorType,
  AnnotationFieldFlag,
  AnnotationFlag,
  AnnotationType,
  OPS,
  RenderingIntentFlag,
  stringToBytes,
  stringToUTF8String,
} from "../../src/shared/util.js";
import {
  CMAP_URL,
  createIdFactory,
  STANDARD_FONT_DATA_URL,
  XRefMock,
} from "./test_utils.js";
import {
  DefaultCMapReaderFactory,
  DefaultStandardFontDataFactory,
} from "../../src/display/api.js";
import { Dict, Name, Ref, RefSetCache } from "../../src/core/primitives.js";
import { Lexer, Parser } from "../../src/core/parser.js";
import { FlateStream } from "../../src/core/flate_stream.js";
import { PartialEvaluator } from "../../src/core/evaluator.js";
import { StringStream } from "../../src/core/stream.js";
import { WorkerTask } from "../../src/core/worker.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

