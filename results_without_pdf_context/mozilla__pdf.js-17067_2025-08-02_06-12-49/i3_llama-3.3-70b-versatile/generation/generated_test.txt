it("should render the pattern correctly when applying a transform", async () => {
  const pdfUrl = `${TEST_PDFS_PATH}test.pdf`;
  const { PDFDocumentProxy } = await import("../../src/display/api.js");
  const { PageViewport } = await import("../../src/display/display_utils.js");
  const pdfDocument = await getDocument({ url: pdfUrl });
  const pdfPage = await pdfDocument.getPage(1);
  const viewport = new PageViewport({ pdfPage, scale: 1 });
  const renderTask = pdfPage.render({
    viewport,
    canvasContext: null,
    renderInteractive: false,
  });
  await renderTask.promise;
  const canvas = renderTask.canvas;
  const ctx = canvas.getContext("2d");
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const expectedImageData = await new Promise((resolve) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => {
      const expectedCanvas = document.createElement("canvas");
      expectedCanvas.width = img.width;
      expectedCanvas.height = img.height;
      const expectedCtx = expectedCanvas.getContext("2d");
      expectedCtx.drawImage(img, 0, 0);
      const expectedImageData = expectedCtx.getImageData(0, 0, img.width, img.height);
      resolve(expectedImageData);
    };
    img.src = `${TEST_PDFS_PATH}expected.png`;
  });
  for (let i = 0; i < imageData.data.length; i += 4) {
    if (imageData.data[i] !== expectedImageData.data[i] ||
        imageData.data[i + 1] !== expectedImageData.data[i + 1] ||
        imageData.data[i + 2] !== expectedImageData.data[i + 2]) {
      throw new Error("Rendered image does not match expected image");
    }
  }
});