<think>
Okay, I need to write a regression test for the patch that fixes the slow rendering of poster PDFs in Firefox. The patch modifies the canvas.js file to avoid unnecessarily setting the filter to "none" when it's already in that state. 

First, I should understand what the patch does. It looks like in two places, the code was setting ctx.filter = "none" unconditionally. The patch changes this to check if the filter is already "none" or an empty string before making any changes. This should reduce the number of filter operations, which was causing performance issues.

Now, I need to create a test that fails before the patch and passes after. The test should measure the time it takes to render a PDF with many pages or complex content where the filter is set multiple times.

I'll use the test framework provided by pdf.js. I'll import the necessary modules like PDFDocument, PDFPage, and measure the rendering time. I'll create a test PDF with multiple pages, each triggering the filter operation.

In the test, I'll load the test PDF, iterate through each page, render them, and measure the time taken. I'll set a threshold for the maximum allowed time. If the rendering time exceeds this threshold, the test fails.

Before the patch, the test should fail because the excessive filter operations slow down rendering. After applying the patch, the test should pass as the filter is only set when necessary, improving performance.

I need to ensure the test is self-contained, uses only the provided imports, and doesn't add new dependencies. I'll structure the test using async/await for loading the PDF and measuring performance.

I'll write the test using Jest syntax, importing the required modules dynamically. I'll set up the PDF, loop through pages, render each, and measure the time. If the time is within the expected range, the test passes.

Finally, I'll make sure the test only returns the JavaScript code without any extra comments or explanations, as per the instructions.
</think>

```javascript
it("should improve rendering performance by avoiding unnecessary filter operations", async () => {
  const { PDFDocument } = await import("../../src/core/document.js");
  const { PDFPage } = await import("../../src/core/document.js");
  const { getBlob } = await import("../../src/shared/util.js");
  const { createIdFactory } = await import("../../src/display/canvas.js");
  
  // Create a test PDF with multiple pages to trigger the rendering path
  const pdfBytes = new Uint8Array([
    0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x30, 0x0a, 0x25, 0xe2, 0xe3, 0xcf, 0xd3, 0x0a, 0x31, 0x30, 0x20, 0x41, 0x5f, 0x53, 0x50, 0x4f, 0x52, 0x54, 0x0a,
    0x25, 0xe2, 0xe3, 0xcf, 0xd3, 0x0a, 0x31, 0x30, 0x20, 0x4a, 0x41, 0x53, 0x30, 0x0a, 0x0a, 0x28, 0x0a, 0x46, 0x49, 0x4c, 0x45, 0x0a,
    0x32, 0x30, 0x20, 0x4f, 0x62, 0x6a, 0x0a, 0x3c, 0x0a, 0x78, 0x0a, 0x32, 0x30, 0x20, 0x52, 0x45, 0x44, 0x0a, 0x3e, 0x0a, 0x0a,
    0x74, 0x72, 0x61, 0x69, 0x6c, 0x65, 0x72, 0x0a, 0x3c, 0x0a, 0x78, 0x0a, 0x32, 0x30, 0x20, 0x55, 0x49, 0x44, 0x0a,
    0x3e, 0x0a
  ]);
  
  // Load the test PDF
  const pdf = await PDFDocument.load(getBlob(pdfBytes), { createIdFactory });
  
  // Measure rendering time
  const startTime = performance.now();
  const numPages = pdf.numPages;
  
  for (let i = 0; i < numPages; i++) {
    const page = await pdf.getPage(i + 1);
    await page.render({
      canvasContext: new Canvas(),
      viewport: page.getViewport({ scale: 1 })
    });
  }
  
  const endTime = performance.now();
  const renderTime = endTime - startTime;
  
  // The threshold is set to 500ms - adjust based on expected performance gains
  expect(renderTime).toBeLessThan(500);
});
```