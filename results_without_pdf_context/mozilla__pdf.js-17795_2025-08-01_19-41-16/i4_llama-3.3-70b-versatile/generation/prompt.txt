Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Incorrect rendering with some inlined images
Attach (recommended) or Link to PDF file here:
[image1.pdf](https://github.com/mozilla/pdf.js/files/14607428/image1.pdf)

For context, the pdf has been found on the PDFBox bug tracker:
https://issues.apache.org/jira/projects/PDFBOX/issues/PDFBOX-5776

Configuration:
- Web browser and its version: Firefox nightly
- Operating system and its version: Mac

Steps to reproduce the problem:
1. Open the pdf
2. only one image is rendered

What is the expected behavior? (add screenshot)
From Preview
<img width="573" alt="image" src="https://github.com/mozilla/pdf.js/assets/5641725/a9be4615-60f8-440e-890c-3ab6f0ea18b7">

The file contains some inlined images without the closing `EI`.

</issue>

Patch:
<patch>
diff --git a/src/core/evaluator.js b/src/core/evaluator.js
--- a/src/core/evaluator.js
+++ b/src/core/evaluator.js
@@ -739,27 +739,36 @@ class PartialEvaluator {
       !dict.has("Mask") &&
       w + h < SMALL_IMAGE_DIMENSIONS
     ) {
-      const imageObj = new PDFImage({
-        xref: this.xref,
-        res: resources,
-        image,
-        isInline,
-        pdfFunctionFactory: this._pdfFunctionFactory,
-        localColorSpaceCache,
-      });
-      // We force the use of RGBA_32BPP images here, because we can't handle
-      // any other kind.
-      imgData = await imageObj.createImageData(
-        /* forceRGBA = */ true,
-        /* isOffscreenCanvasSupported = */ false
-      );
-      operatorList.isOffscreenCanvasSupported =
-        this.options.isOffscreenCanvasSupported;
-      operatorList.addImageOps(
-        OPS.paintInlineImageXObject,
-        [imgData],
-        optionalContent
-      );
+      try {
+        const imageObj = new PDFImage({
+          xref: this.xref,
+          res: resources,
+          image,
+          isInline,
+          pdfFunctionFactory: this._pdfFunctionFactory,
+          localColorSpaceCache,
+        });
+        // We force the use of RGBA_32BPP images here, because we can't handle
+        // any other kind.
+        imgData = await imageObj.createImageData(
+          /* forceRGBA = */ true,
+          /* isOffscreenCanvasSupported = */ false
+        );
+        operatorList.isOffscreenCanvasSupported =
+          this.options.isOffscreenCanvasSupported;
+        operatorList.addImageOps(
+          OPS.paintInlineImageXObject,
+          [imgData],
+          optionalContent
+        );
+      } catch (reason) {
+        const msg = `Unable to decode inline image: "${reason}".`;
+
+        if (!this.options.ignoreErrors) {
+          throw new Error(msg);
+        }
+        warn(msg);
+      }
       return;
     }


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.23.9
- @babel/preset-env: ^7.23.9
- @babel/runtime: ^7.23.9
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.9.0
- @jazzer.js/core: ^2.1.0
- autoprefixer: ^10.4.17
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001587
- canvas: ^2.11.2
- core-js: ^3.36.0
- cross-env: ^7.0.3
- eslint: ^8.56.0
- eslint-config-prettier: ^8.10.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.29.1
- eslint-plugin-jasmine: ^4.1.3
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.3.2
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.1.3
- eslint-plugin-sort-exports: ^0.9.1
- eslint-plugin-unicorn: ^51.0.1
- globals: ^14.0.0
- gulp: ^4.0.2
- gulp-cli: ^2.3.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.3.1
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.35
- postcss-dark-theme-class: ^1.2.1
- postcss-dir-pseudo-class: ^8.0.1
- postcss-discard-comments: ^6.0.1
- postcss-nesting: ^12.0.2
- prettier: ^3.2.5
- puppeteer: ^22.3.0
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^16.2.1
- stylelint-prettier: ^5.0.0
- terser-webpack-plugin: ^5.3.10
- through2: ^4.0.2
- tsc-alias: ^1.8.8
- ttest: ^4.0.0
- typescript: ^5.3.3
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.90.2
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/outliner.js`: Outliner
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/evaluator.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 /* eslint-disable no-var */
16 
17 import {
18   AbortException,
19   assert,
20   CMapCompressionType,
21   FONT_IDENTITY_MATRIX,
22   FormatError,
23   IDENTITY_MATRIX,
24   info,
25   isArrayEqual,
26   normalizeUnicode,
27   OPS,
28   PromiseCapability,
29   shadow,
30   stringToPDFString,
31   TextRenderingMode,
32   Util,
33   warn,
34 } from "../shared/util.js";
35 import { CMapFactory, IdentityCMap } from "./cmap.js";
36 import { Cmd, Dict, EOF, isName, Name, Ref, RefSet } from "./primitives.js";
37 import { ErrorFont, Font } from "./fonts.js";
38 import {
39   getEncoding,
40   MacRomanEncoding,
41   StandardEncoding,
42   SymbolSetEncoding,
43   WinAnsiEncoding,
44   ZapfDingbatsEncoding,
45 } from "./encodings.js";
46 import {
47   getFontNameToFileMap,
48   getSerifFonts,
49   getStandardFontName,
50   getStdFontMap,
51   getSymbolsFonts,
52   isKnownFontName,
53 } from "./standard_fonts.js";
54 import { getTilingPatternIR, Pattern } from "./pattern.js";
55 import { getXfaFontDict, getXfaFontName } from "./xfa_fonts.js";
56 import { IdentityToUnicodeMap, ToUnicodeMap } from "./to_unicode_map.js";
57 import { isPDFFunction, PDFFunctionFactory } from "./function.js";
58 import { Lexer, Parser } from "./parser.js";
59 import {
60   LocalColorSpaceCache,
61   LocalGStateCache,
62   LocalImageCache,
63   LocalTilingPatternCache,
64   RegionalImageCache,
65 } from "./image_utils.js";
66 import { NullStream, Stream } from "./stream.js";
67 import { BaseStream } from "./base_stream.js";
68 import { bidi } from "./bidi.js";
69 import { ColorSpace } from "./colorspace.js";
70 import { DecodeStream } from "./decode_stream.js";
71 import { FontFlags } from "./fonts_utils.js";
72 import { getFontSubstitution } from "./font_substitutions.js";
73 import { getGlyphsUnicode } from "./glyphlist.js";
74 import { getMetrics } from "./metrics.js";
75 import { getUnicodeForGlyph } from "./unicode.js";
76 import { ImageResizer } from "./image_resizer.js";
77 import { MurmurHash3_64 } from "../shared/murmurhash3.js";
78 import { OperatorList } from "./operator_list.js";
79 import { PDFImage } from "./image.js";
80 
81 const DefaultPartialEvaluatorOptions = Object.freeze({
82   maxImageSize: -1,
83   disableFontFace: false,
84   ignoreErrors: false,
85   isEvalSupported: true,
86   isOffscreenCanvasSupported: false,
87   canvasMaxAreaInBytes: -1,
88   fontExtraProperties: false,
89   useSystemFonts: true,
90   cMapUrl: null,
91   standardFontDataUrl: null,
92 });
93 
94 const PatternType = {
95   TILING: 1,
96   SHADING: 2,
97 };
98 
99 // Optionally avoid sending individual, or very few, text chunks to reduce
100 // `postMessage` overhead with ReadableStream (see issue 13962).
101 //
102 // PLEASE NOTE: This value should *not* be too large (it's used as a lower limit
103 // in `enqueueChunk`), since that would cause streaming of textContent to become
104 // essentially useless in practice by sending all (or most) chunks at once.
105 // Also, a too large value would (indirectly) affect the main-thread `textLayer`
106 // building negatively by forcing all textContent to be handled at once, which
107 // could easily end up hurting *overall* performance (e.g. rendering as well).
108 const TEXT_CHUNK_BATCH_SIZE = 10;
109 
110 const deferred = Promise.resolve();
111 
112 // Convert PDF blend mode names to HTML5 blend mode names.
113 function normalizeBlendMode(value, parsingArray = false) {
114   if (Array.isArray(value)) {
115     // Use the first *supported* BM value in the Array (fixes issue11279.pdf).
116     for (const val of value) {
117       const maybeBM = normalizeBlendMode(val, /* parsingArray = */ true);
118       if (maybeBM) {
119         return maybeBM;
120       }
121     }
122     warn(`Unsupported blend mode Array: ${value}`);
123     return "source-over";
124   }
125 
126   if (!(value instanceof Name)) {
127     if (parsingArray) {
128       return null;
129     }
130     return "source-over";
131   }
132   switch (value.name) {
133     case "Normal":
134     case "Compatible":
135       return "source-over";
136     case "Multiply":
137       return "multiply";
138     case "Screen":
139       return "screen";
140     case "Overlay":
141       return "overlay";
142     case "Darken":
143       return "darken";
144     case "Lighten":
145       return "lighten";
146     case "ColorDodge":
147       return "color-dodge";
148     case "ColorBurn":
149       return "color-burn";
150     case "HardLight":
151       return "hard-light";
152     case "SoftLight":
153       return "soft-light";
154     case "Difference":
155       return "difference";
156     case "Exclusion":
157       return "exclusion";
158     case "Hue":
159       return "hue";
160     case "Saturation":
161       return "saturation";
162     case "Color":
163       return "color";
164     case "Luminosity":
165       return "luminosity";
166   }
167   if (parsingArray) {
168     return null;
169   }
170   warn(`Unsupported blend mode: ${value.name}`);
171   return "source-over";
172 }
173 
174 function incrementCachedImageMaskCount(data) {
175   if (data.fn === OPS.paintImageMaskXObject && data.args[0]?.count > 0) {
176     data.args[0].count++;
177   }
178 }
179 
180 // Trying to minimize Date.now() usage and check every 100 time.
181 class TimeSlotManager {
182   static TIME_SLOT_DURATION_MS = 20;
183 
184   static CHECK_TIME_EVERY = 100;
185 
186   constructor() {
187     this.reset();
188   }
189 
190   check() {
191     if (++this.checked < TimeSlotManager.CHECK_TIME_EVERY) {
192       return false;
193     }
194     this.checked = 0;
195     return this.endTime <= Date.now();
196   }
197 
198   reset() {
199     this.endTime = Date.now() + TimeSlotManager.TIME_SLOT_DURATION_MS;
200     this.checked = 0;
201   }
202 }
203 
204 class PartialEvaluator {
205   constructor({
206     xref,
207     handler,
208     pageIndex,
209     idFactory,
210     fontCache,
211     builtInCMapCache,
212     standardFontDataCache,
213     globalImageCache,
214     systemFontCache,
215     options = null,
216   }) {
217     this.xref = xref;
218     this.handler = handler;
219     this.pageIndex = pageIndex;
220     this.idFactory = idFactory;
221     this.fontCache = fontCache;
222     this.builtInCMapCache = builtInCMapCache;
223     this.standardFontDataCache = standardFontDataCache;
224     this.globalImageCache = globalImageCache;
225     this.systemFontCache = systemFontCache;
226     this.options = options || DefaultPartialEvaluatorOptions;
227     this.parsingType3Font = false;
228 
229     this._regionalImageCache = new RegionalImageCache();
230     this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
231     ImageResizer.setMaxArea(this.options.canvasMaxAreaInBytes);
232   }
233 
234   /**
235    * Since Functions are only cached (locally) by reference, we can share one
236    * `PDFFunctionFactory` instance within this `PartialEvaluator` instance.
237    */
238   get _pdfFunctionFactory() {
239     const pdfFunctionFactory = new PDFFunctionFactory({
240       xref: this.xref,
241       isEvalSupported: this.options.isEvalSupported,
242     });
243     return shadow(this, "_pdfFunctionFactory", pdfFunctionFactory);
244   }
245 
246   clone(newOptions = null) {
247     const newEvaluator = Object.create(this);
248     newEvaluator.options = Object.assign(
249       Object.create(null),
250       this.options,
251       newOptions
252     );
253     return newEvaluator;
254   }
255 
256   hasBlendModes(resources, nonBlendModesSet) {
257     if (!(resources instanceof Dict)) {
258       return false;
259     }
260     if (resources.objId && nonBlendModesSet.has(resources.objId)) {
261       return false;
262     }
263 
264     const processed = new RefSet(nonBlendModesSet);
265     if (resources.objId) {
266       processed.put(resources.objId);
267     }
268 
269     const nodes = [resources],
270       xref = this.xref;
271     while (nodes.length) {
272       const node = nodes.shift();
273       // First check the current resources for blend modes.
274       const graphicStates = node.get("ExtGState");
275       if (graphicStates instanceof Dict) {
276         for (let graphicState of graphicStates.getRawValues()) {
277           if (graphicState instanceof Ref) {
278             if (processed.has(graphicState)) {
279               continue; // The ExtGState has already been processed.
280             }
281             try {
282               graphicState = xref.fetch(graphicState);
283             } catch (ex) {
284               // Avoid parsing a corrupt ExtGState more than once.
285               processed.put(graphicState);
286 
287               info(`hasBlendModes - ignoring ExtGState: "${ex}".`);
288               continue;
289             }
290           }
291           if (!(graphicState instanceof Dict)) {
292             continue;
293           }
294           if (graphicState.objId) {
295             processed.put(graphicState.objId);
296           }
297 
298           const bm = graphicState.get("BM");
299           if (bm instanceof Name) {
300             if (bm.name !== "Normal") {
301               return true;
302             }
303             continue;
304           }
305           if (bm !== undefined && Array.isArray(bm)) {
306             for (const element of bm) {
307               if (element instanceof Name && element.name !== "Normal") {
308                 return true;
309               }
310             }
311           }
312         }
313       }
314       // Descend into the XObjects to look for more resources and blend modes.
315       const xObjects = node.get("XObject");
316       if (!(xObjects instanceof Dict)) {
317         continue;
318       }
319       for (let xObject of xObjects.getRawValues()) {
320         if (xObject instanceof Ref) {
321           if (processed.has(xObject)) {
322             // The XObject has already been processed, and by avoiding a
323             // redundant `xref.fetch` we can *significantly* reduce the load
324             // time for badly generated PDF files (fixes issue6961.pdf).
325             continue;
326           }
327           try {
328             xObject = xref.fetch(xObject);
329           } catch (ex) {
330             // Avoid parsing a corrupt XObject more than once.
331             processed.put(xObject);
332 
333             info(`hasBlendModes - ignoring XObject: "${ex}".`);
334             continue;
335           }
336         }
337         if (!(xObject instanceof BaseStream)) {
338           continue;
339         }
340         if (xObject.dict.objId) {
341           processed.put(xObject.dict.objId);
342         }
343         const xResources = xObject.dict.get("Resources");
344         if (!(xResources instanceof Dict)) {
345           continue;
346         }
347         // Checking objId to detect an infinite loop.
348         if (xResources.objId && processed.has(xResources.objId)) {
349           continue;
350         }
351 
352         nodes.push(xResources);
353         if (xResources.objId) {
354           processed.put(xResources.objId);
355         }
356       }
357     }
358 
359     // When no blend modes exist, there's no need re-fetch/re-parse any of the
360     // processed `Ref`s again for subsequent pages. This helps reduce redundant
361     // `XRef.fetch` calls for some documents (e.g. issue6961.pdf).
362     for (const ref of processed) {
363       nonBlendModesSet.put(ref);
364     }
365     return false;
366   }
367 
368   async fetchBuiltInCMap(name) {
369     const cachedData = this.builtInCMapCache.get(name);
370     if (cachedData) {
371       return cachedData;
372     }
373     let data;
374 
375     if (this.options.cMapUrl !== null) {
376       // Only compressed CMaps are (currently) supported here.
377       const url = `${this.options.cMapUrl}${name}.bcmap`;
378       const response = await fetch(url);
379       if (!response.ok) {
380         throw new Error(
381           `fetchBuiltInCMap: failed to fetch file "${url}" with "${response.statusText}".`
382         );
383       }
384       data = {
385         cMapData: new Uint8Array(await response.arrayBuffer()),
386         compressionType: CMapCompressionType.BINARY,
387       };
388     } else {
389       // Get the data on the main-thread instead.
390       data = await this.handler.sendWithPromise("FetchBuiltInCMap", { name });
391     }
392 
393     if (data.compressionType !== CMapCompressionType.NONE) {
394       // Given the size of uncompressed CMaps, only cache compressed ones.
395       this.builtInCMapCache.set(name, data);
396     }
397     return data;
398   }
399 
400   async fetchStandardFontData(name) {
401     const cachedData = this.standardFontDataCache.get(name);
402     if (cachedData) {
403       return new Stream(cachedData);
404     }
405 
406     // The symbol fonts are not consistent across platforms, always load the
407     // standard font data for them.
408     if (
409       this.options.useSystemFonts &&
410       name !== "Symbol" &&
411       name !== "ZapfDingbats"
412     ) {
413       return null;
414     }
415 
416     const standardFontNameToFileName = getFontNameToFileMap(),
417       filename = standardFontNameToFileName[name];
418     let data;
419 
420     if (this.options.standardFontDataUrl !== null) {
421       const url = `${this.options.standardFontDataUrl}${filename}`;
422       const response = await fetch(url);
423       if (!response.ok) {
424         warn(
425           `fetchStandardFontData: failed to fetch file "${url}" with "${response.statusText}".`
426         );
427       } else {
428         data = new Uint8Array(await response.arrayBuffer());
429       }
430     } else {
431       // Get the data on the main-thread instead.
432       try {
433         data = await this.handler.sendWithPromise("FetchStandardFontData", {
434           filename,
435         });
436       } catch (e) {
437         warn(
438           `fetchStandardFontData: failed to fetch file "${filename}" with "${e}".`
439         );
440       }
441     }
442 
443     if (!data) {
444       return null;
445     }
446     // Cache the "raw" standard font data, to avoid fetching it repeatedly
447     // (see e.g. issue 11399).
448     this.standardFontDataCache.set(name, data);
449 
450     return new Stream(data);
451   }
452 
453   async buildFormXObject(
454     resources,
455     xobj,
456     smask,
457     operatorList,
458     task,
459     initialState,
460     localColorSpaceCache
461   ) {
462     const dict = xobj.dict;
463     const matrix = dict.getArray("Matrix");
464     let bbox = dict.getArray("BBox");
465     bbox =
466       Array.isArray(bbox) && bbox.length === 4
467         ? Util.normalizeRect(bbox)
468         : null;
469 
470     let optionalContent, groupOptions;
471     if (dict.has("OC")) {
472       optionalContent = await this.parseMarkedContentProps(
473         dict.get("OC"),
474         resources
475       );
476     }
477     if (optionalContent !== undefined) {
478       operatorList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
479     }
480     const group = dict.get("Group");
481     if (group) {
482       groupOptions = {
483         matrix,
484         bbox,
485         smask,
486         isolated: false,
487         knockout: false,
488       };
489 
490       const groupSubtype = group.get("S");
491       let colorSpace = null;
492       if (isName(groupSubtype, "Transparency")) {
493         groupOptions.isolated = group.get("I") || false;
494         groupOptions.knockout = group.get("K") || false;
495         if (group.has("CS")) {
496           const cs = group.getRaw("CS");
497 
498           const cachedColorSpace = ColorSpace.getCached(
499             cs,
500             this.xref,
501             localColorSpaceCache
502           );
503           if (cachedColorSpace) {
504             colorSpace = cachedColorSpace;
505           } else {
506             colorSpace = await this.parseColorSpace({
507               cs,
508               resources,
509               localColorSpaceCache,
510             });
511           }
512         }
513       }
514 
515       if (smask?.backdrop) {
516         colorSpace ||= ColorSpace.singletons.rgb;
517         smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
518       }
519 
520       operatorList.addOp(OPS.beginGroup, [groupOptions]);
521     }
522 
523     // If it's a group, a new canvas will be created that is the size of the
524     // bounding box and translated to the correct position so we don't need to
525     // apply the bounding box to it.
526     const args = group ? [matrix, null] : [matrix, bbox];
527     operatorList.addOp(OPS.paintFormXObjectBegin, args);
528 
529     await this.getOperatorList({
530       stream: xobj,
531       task,
532       resources: dict.get("Resources") || resources,
533       operatorList,
534       initialState,
535     });
536     operatorList.addOp(OPS.paintFormXObjectEnd, []);
537 
538     if (group) {
539       operatorList.addOp(OPS.endGroup, [groupOptions]);
540     }
541 
542     if (optionalContent !== undefined) {
543       operatorList.addOp(OPS.endMarkedContent, []);
544     }
545   }
546 
547   _sendImgData(objId, imgData, cacheGlobally = false) {
548     if (
549       (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) &&
550       imgData
551     ) {
552       assert(Number.isInteger(imgData.dataLen), "Expected dataLen to be set.");
553     }
554     const transfers = imgData ? [imgData.bitmap || imgData.data.buffer] : null;
555 
556     if (this.parsingType3Font || cacheGlobally) {
557       return this.handler.send(
558         "commonobj",
559         [objId, "Image", imgData],
560         transfers
561       );
562     }
563     return this.handler.send(
564       "obj",
565       [objId, this.pageIndex, "Image", imgData],
566       transfers
567     );
568   }
569 
570   async buildPaintImageXObject({
571     resources,
572     image,
573     isInline = false,
574     operatorList,
575     cacheKey,
576     localImageCache,
577     localColorSpaceCache,
578   }) {
579     const dict = image.dict;
580     const imageRef = dict.objId;
581     const w = dict.get("W", "Width");
582     const h = dict.get("H", "Height");
583 
584     if (!(w && typeof w === "number") || !(h && typeof h === "number")) {
585       warn("Image dimensions are missing, or not numbers.");
586       return;
587     }
588     const maxImageSize = this.options.maxImageSize;
589     if (maxImageSize !== -1 && w * h > maxImageSize) {
590       const msg = "Image exceeded maximum allowed size and was removed.";
591 
592       if (this.options.ignoreErrors) {
593         warn(msg);
594         return;
595       }
596       throw new Error(msg);
597     }
598 
599     let optionalContent;
600     if (dict.has("OC")) {
601       optionalContent = await this.parseMarkedContentProps(
602         dict.get("OC"),
603         resources
604       );
605     }
606 
607     const imageMask = dict.get("IM", "ImageMask") || false;
608     let imgData, args;
609     if (imageMask) {
610       // This depends on a tmpCanvas being filled with the
611       // current fillStyle, such that processing the pixel
612       // data can't be done here. Instead of creating a
613       // complete PDFImage, only read the information needed
614       // for later.
615       const interpolate = dict.get("I", "Interpolate");
616       const bitStrideLength = (w + 7) >> 3;
617       const imgArray = image.getBytes(bitStrideLength * h);
618       const decode = dict.getArray("D", "Decode");
619 
620       if (this.parsingType3Font) {
621         imgData = PDFImage.createRawMask({
622           imgArray,
623           width: w,
624           height: h,
625           imageIsFromDecodeStream: image instanceof DecodeStream,
626           inverseDecode: decode?.[0] > 0,
627           interpolate,
628         });
629 
630         imgData.cached = !!cacheKey;
631         args = [imgData];
632 
633         operatorList.addImageOps(
634           OPS.paintImageMaskXObject,
635           args,
636           optionalContent
637         );
638 
639         if (cacheKey) {
640           const cacheData = {
641             fn: OPS.paintImageMaskXObject,
642             args,
643             optionalContent,
644           };
645           localImageCache.set(cacheKey, imageRef, cacheData);
646 
647           if (imageRef) {
648             this._regionalImageCache.set(
649               /* name = */ null,
650               imageRef,
651               cacheData
652             );
653           }
654         }
655         return;
656       }
657 
658       imgData = await PDFImage.createMask({
659         imgArray,
660         width: w,
661         height: h,
662         imageIsFromDecodeStream: image instanceof DecodeStream,
663         inverseDecode: decode?.[0] > 0,
664         interpolate,
665         isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported,
666       });
667 
668       if (imgData.isSingleOpaquePixel) {
669         // Handles special case of mainly LaTeX documents which use image
670         // masks to draw lines with the current fill style.
671         operatorList.addImageOps(
672           OPS.paintSolidColorImageMask,
673           [],
674           optionalContent
675         );
676 
677         if (cacheKey) {
678           const cacheData = {
679             fn: OPS.paintSolidColorImageMask,
680             args: [],
681             optionalContent,
682           };
683           localImageCache.set(cacheKey, imageRef, cacheData);
684 
685           if (imageRef) {
686             this._regionalImageCache.set(
687               /* name = */ null,
688               imageRef,
689               cacheData
690             );
691           }
692         }
693         return;
694       }
695 
696       const objId = `mask_${this.idFactory.createObjId()}`;
697       operatorList.addDependency(objId);
698 
699       imgData.dataLen = imgData.bitmap
700         ? imgData.width * imgData.height * 4
701         : imgData.data.length;
702       this._sendImgData(objId, imgData);
703 
704       args = [
705         {
706           data: objId,
707           width: imgData.width,
708           height: imgData.height,
709           interpolate: imgData.interpolate,
710           count: 1,
711         },
712       ];
713       operatorList.addImageOps(
714         OPS.paintImageMaskXObject,
715         args,
716         optionalContent
717       );
718 
719       if (cacheKey) {
720         const cacheData = {
721           fn: OPS.paintImageMaskXObject,
722           args,
723           optionalContent,
724         };
725         localImageCache.set(cacheKey, imageRef, cacheData);
726 
727         if (imageRef) {
728           this._regionalImageCache.set(/* name = */ null, imageRef, cacheData);
729         }
730       }
731       return;
732     }
733 
734     const SMALL_IMAGE_DIMENSIONS = 200;
735     // Inlining small images into the queue as RGB data
736     if (
737       isInline &&
738       !dict.has("SMask") &&
739       !dict.has("Mask") &&
740       w + h < SMALL_IMAGE_DIMENSIONS
741     ) {
742       const imageObj = new PDFImage({
743         xref: this.xref,
744         res: resources,
745         image,
746         isInline,
747         pdfFunctionFactory: this._pdfFunctionFactory,
748         localColorSpaceCache,
749       });
750       // We force the use of RGBA_32BPP images here, because we can't handle
751       // any other kind.
752       imgData = await imageObj.createImageData(
753         /* forceRGBA = */ true,
754         /* isOffscreenCanvasSupported = */ false
755       );
756       operatorList.isOffscreenCanvasSupported =
757         this.options.isOffscreenCanvasSupported;
758       operatorList.addImageOps(
759         OPS.paintInlineImageXObject,
760         [imgData],
761         optionalContent
762       );
763       return;
764     }
765 
766     // If there is no imageMask, create the PDFImage and a lot
767     // of image processing can be done here.
768     let objId = `img_${this.idFactory.createObjId()}`,
769       cacheGlobally = false;
770 
771     if (this.parsingType3Font) {
772       objId = `${this.idFactory.getDocId()}_type3_${objId}`;
773     } else if (cacheKey && imageRef) {
774       cacheGlobally = this.globalImageCache.shouldCache(
775         imageRef,
776         this.pageIndex
777       );
778 
779       if (cacheGlobally) {
780         assert(!isInline, "Cannot cache an inline image globally.");
781 
782         objId = `${this.idFactory.getDocId()}_${objId}`;
783       }
784     }
785 
786     // Ensure that the dependency is added before the image is decoded.
787     operatorList.addDependency(objId);
788     args = [objId, w, h];
789     operatorList.addImageOps(OPS.paintImageXObject, args, optionalContent);
790 
791     // For large images, at least 500x500 in size, that we'll cache globally
792     // check if the image is still cached locally on the main-thread to avoid
793     // having to re-parse the image (since that can be slow).
794     if (cacheGlobally && w * h > 250000) {
795       const localLength = await this.handler.sendWithPromise("commonobj", [
796         objId,
797         "CopyLocalImage",
798         { imageRef },
799       ]);
800 
801       if (localLength) {
802         this.globalImageCache.setData(imageRef, {
803           objId,
804           fn: OPS.paintImageXObject,
805           args,
806           optionalContent,
807           byteSize: 0, // Temporary entry, to avoid `setData` returning early.
808         });
809         this.globalImageCache.addByteSize(imageRef, localLength);
810         return;
811       }
812     }
813 
814     PDFImage.buildImage({
815       xref: this.xref,
816       res: resources,
817       image,
818       isInline,
819       pdfFunctionFactory: this._pdfFunctionFactory,
820       localColorSpaceCache,
821     })
822       .then(async imageObj => {
823         imgData = await imageObj.createImageData(
824           /* forceRGBA = */ false,
825           /* isOffscreenCanvasSupported = */ this.options
826             .isOffscreenCanvasSupported
827         );
828         imgData.dataLen = imgData.bitmap
829           ? imgData.width * imgData.height * 4
830           : imgData.data.length;
831         imgData.ref = imageRef;
832 
833         if (cacheGlobally) {
834           this.globalImageCache.addByteSize(imageRef, imgData.dataLen);
835         }
836         return this._sendImgData(objId, imgData, cacheGlobally);
837       })
838       .catch(reason => {
839         warn(`Unable to decode image "${objId}": "${reason}".`);
840 
841         return this._sendImgData(objId, /* imgData = */ null, cacheGlobally);
842       });
843 
844     if (cacheKey) {
845       const cacheData = {
846         fn: OPS.paintImageXObject,
847         args,
848         optionalContent,
849       };
850       localImageCache.set(cacheKey, imageRef, cacheData);
851 
852       if (imageRef) {
853         this._regionalImageCache.set(/* name = */ null, imageRef, cacheData);
854 
855         if (cacheGlobally) {
856           this.globalImageCache.setData(imageRef, {
857             objId,
858             fn: OPS.paintImageXObject,
859             args,
860             optionalContent,
861             byteSize: 0, // Temporary entry, note `addByteSize` above.
862           });
863         }
864       }
865     }
866   }
867 
868   handleSMask(
869     smask,
870     resources,
871     operatorList,
872     task,
873     stateManager,
874     localColorSpaceCache
875   ) {
876     const smaskContent = smask.get("G");
877     const smaskOptions = {
878       subtype: smask.get("S").name,
879       backdrop: smask.get("BC"),
880     };
881 
882     // The SMask might have a alpha/luminosity value transfer function --
883     // we will build a map of integer values in range 0..255 to be fast.
884     const transferObj = smask.get("TR");
885     if (isPDFFunction(transferObj)) {
886       const transferFn = this._pdfFunctionFactory.create(transferObj);
887       const transferMap = new Uint8Array(256);
888       const tmp = new Float32Array(1);
889       for (let i = 0; i < 256; i++) {
890         tmp[0] = i / 255;
891         transferFn(tmp, 0, tmp, 0);
892         transferMap[i] = (tmp[0] * 255) | 0;
893       }
894       smaskOptions.transferMap = transferMap;
895     }
896 
897     return this.buildFormXObject(
898       resources,
899       smaskContent,
900       smaskOptions,
901       operatorList,
902       task,
903       stateManager.state.clone(),
904       localColorSpaceCache
905     );
906   }
907 
908   handleTransferFunction(tr) {
909     let transferArray;
910     if (Array.isArray(tr)) {
911       transferArray = tr;
912     } else if (isPDFFunction(tr)) {
913       transferArray = [tr];
914     } else {
915       return null; // Not a valid transfer function entry.
916     }
917 
918     const transferMaps = [];
919     let numFns = 0,
920       numEffectfulFns = 0;
921     for (const entry of transferArray) {
922       const transferObj = this.xref.fetchIfRef(entry);
923       numFns++;
924 
925       if (isName(transferObj, "Identity")) {
926         transferMaps.push(null);
927         continue;
928       } else if (!isPDFFunction(transferObj)) {
929         return null; // Not a valid transfer function object.
930       }
931 
932       const transferFn = this._pdfFunctionFactory.create(transferObj);
933       const transferMap = new Uint8Array(256),
934         tmp = new Float32Array(1);
935       for (let j = 0; j < 256; j++) {
936         tmp[0] = j / 255;
937         transferFn(tmp, 0, tmp, 0);
938         transferMap[j] = (tmp[0] * 255) | 0;
939       }
940       transferMaps.push(transferMap);
941       numEffectfulFns++;
942     }
943 
944     if (!(numFns === 1 || numFns === 4)) {
945       return null; // Only 1 or 4 functions are supported, by the specification.
946     }
947     if (numEffectfulFns === 0) {
948       return null; // Only /Identity transfer functions found, which are no-ops.
949     }
950     return transferMaps;
951   }
952 
953   handleTilingType(
954     fn,
955     color,
956     resources,
957     pattern,
958     patternDict,
959     operatorList,
960     task,
961     localTilingPatternCache
962   ) {
963     // Create an IR of the pattern code.
964     const tilingOpList = new OperatorList();
965     // Merge the available resources, to prevent issues when the patternDict
966     // is missing some /Resources entries (fixes issue6541.pdf).
967     const patternResources = Dict.merge({
968       xref: this.xref,
969       dictArray: [patternDict.get("Resources"), resources],
970     });
971 
972     return this.getOperatorList({
973       stream: pattern,
974       task,
975       resources: patternResources,
976       operatorList: tilingOpList,
977     })
978       .then(function () {
979         const operatorListIR = tilingOpList.getIR();
980         const tilingPatternIR = getTilingPatternIR(
981           operatorListIR,
982           patternDict,
983           color
984         );
985         // Add the dependencies to the parent operator list so they are
986         // resolved before the sub operator list is executed synchronously.
987         operatorList.addDependencies(tilingOpList.dependencies);
988         operatorList.addOp(fn, tilingPatternIR);
989 
990         if (patternDict.objId) {
991           localTilingPatternCache.set(/* name = */ null, patternDict.objId, {
992             operatorListIR,
993             dict: patternDict,
994           });
995         }
996       })
997       .catch(reason => {
998         if (reason instanceof AbortException) {
999           return;
1000         }
1001         if (this.options.ignoreErrors) {
1002           warn(`handleTilingType - ignoring pattern: "${reason}".`);
1003           return;
1004         }
1005         throw reason;
1006       });
1007   }
1008 
1009   async handleSetFont(
1010     resources,
1011     fontArgs,
1012     fontRef,
1013     operatorList,
1014     task,
1015     state,
1016     fallbackFontDict = null,
1017     cssFontInfo = null
1018   ) {
1019     const fontName = fontArgs?.[0] instanceof Name ? fontArgs[0].name : null;
1020 
1021     let translated = await this.loadFont(
1022       fontName,
1023       fontRef,
1024       resources,
1025       fallbackFontDict,
1026       cssFontInfo
1027     );
1028 
1029     if (translated.font.isType3Font) {
1030       try {
1031         await translated.loadType3Data(this, resources, task);
1032         // Add the dependencies to the parent operatorList so they are
1033         // resolved before Type3 operatorLists are executed synchronously.
1034         operatorList.addDependencies(translated.type3Dependencies);
1035       } catch (reason) {
1036         translated = new TranslatedFont({
1037           loadedName: "g_font_error",
1038           font: new ErrorFont(`Type3 font load error: ${reason}`),
1039           dict: translated.font,
1040           evaluatorOptions: this.options,
1041         });
1042       }
1043     }
1044 
1045     state.font = translated.font;
1046     translated.send(this.handler);
1047     return translated.loadedName;
1048   }
1049 
1050   handleText(chars, state) {
1051     const font = state.font;
1052     const glyphs = font.charsToGlyphs(chars);
1053 
1054     if (font.data) {
1055       const isAddToPathSet = !!(
1056         state.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG
1057       );
1058       if (
1059         isAddToPathSet ||
1060         state.fillColorSpace.name === "Pattern" ||
1061         font.disableFontFace ||
1062         this.options.disableFontFace
1063       ) {
1064         PartialEvaluator.buildFontPaths(
1065           font,
1066           glyphs,
1067           this.handler,
1068           this.options
1069         );
1070       }
1071     }
1072     return glyphs;
1073   }
1074 
1075   ensureStateFont(state) {
1076     if (state.font) {
1077       return;
1078     }
1079     const reason = new FormatError(
1080       "Missing setFont (Tf) operator before text rendering operator."
1081     );
1082 
1083     if (this.options.ignoreErrors) {
1084       warn(`ensureStateFont: "${reason}".`);
1085       return;
1086     }
1087     throw reason;
1088   }
1089 
1090   async setGState({
1091     resources,
1092     gState,
1093     operatorList,
1094     cacheKey,
1095     task,
1096     stateManager,
1097     localGStateCache,
1098     localColorSpaceCache,
1099   }) {
1100     const gStateRef = gState.objId;
1101     let isSimpleGState = true;
1102     // This array holds the converted/processed state data.
1103     const gStateObj = [];
1104     let promise = Promise.resolve();
1105     for (const key of gState.getKeys()) {
1106       const value = gState.get(key);
1107       switch (key) {
1108         case "Type":
1109           break;
1110         case "LW":
1111         case "LC":
1112         case "LJ":
1113         case "ML":
1114         case "D":
1115         case "RI":
1116         case "FL":
1117         case "CA":
1118         case "ca":
1119           gStateObj.push([key, value]);
1120           break;
1121         case "Font":
1122           isSimpleGState = false;
1123 
1124           promise = promise.then(() =>
1125             this.handleSetFont(
1126               resources,
1127               null,
1128               value[0],
1129               operatorList,
1130               task,
1131               stateManager.state
1132             ).then(function (loadedName) {
1133               operatorList.addDependency(loadedName);
1134               gStateObj.push([key, [loadedName, value[1]]]);
1135             })
1136           );
1137           break;
1138         case "BM":
1139           gStateObj.push([key, normalizeBlendMode(value)]);
1140           break;
1141         case "SMask":
1142           if (isName(value, "None")) {
1143             gStateObj.push([key, false]);
1144             break;
1145           }
1146           if (value instanceof Dict) {
1147             isSimpleGState = false;
1148 
1149             promise = promise.then(() =>
1150               this.handleSMask(
1151                 value,
1152                 resources,
1153                 operatorList,
1154                 task,
1155                 stateManager,
1156                 localColorSpaceCache
1157               )
1158             );
1159             gStateObj.push([key, true]);
1160           } else {
1161             warn("Unsupported SMask type");
1162           }
1163           break;
1164         case "TR":
1165           const transferMaps = this.handleTransferFunction(value);
1166           gStateObj.push([key, transferMaps]);
1167           break;
1168         // Only generate info log messages for the following since
1169         // they are unlikely to have a big impact on the rendering.
1170         case "OP":
1171         case "op":
1172         case "OPM":
1173         case "BG":
1174         case "BG2":
1175         case "UCR":
1176         case "UCR2":
1177         case "TR2":
1178         case "HT":
1179         case "SM":
1180         case "SA":
1181         case "AIS":
1182         case "TK":
1183           // TODO implement these operators.
1184           info("graphic state operator " + key);
1185           break;
1186         default:
1187           info("Unknown graphic state operator " + key);
1188           break;
1189       }
1190     }
1191     await promise;
1192 
1193     if (gStateObj.length > 0) {
1194       operatorList.addOp(OPS.setGState, [gStateObj]);
1195     }
1196 
1197     if (isSimpleGState) {
1198       localGStateCache.set(cacheKey, gStateRef, gStateObj);
1199     }
1200   }
1201 
1202   loadFont(
1203     fontName,
1204     font,
1205     resources,
1206     fallbackFontDict = null,
1207     cssFontInfo = null
1208   ) {
1209     // eslint-disable-next-line arrow-body-style
1210     const errorFont = async () => {
1211       return new TranslatedFont({
1212         loadedName: "g_font_error",
1213         font: new ErrorFont(`Font "${fontName}" is not available.`),
1214         dict: font,
1215         evaluatorOptions: this.options,
1216       });
1217     };
1218 
1219     let fontRef;
1220     if (font) {
1221       // Loading by ref.
1222       if (font instanceof Ref) {
1223         fontRef = font;
1224       }
1225     } else {
1226       // Loading by name.
1227       const fontRes = resources.get("Font");
1228       if (fontRes) {
1229         fontRef = fontRes.getRaw(fontName);
1230       }
1231     }
1232     if (fontRef) {
1233       if (this.parsingType3Font && this.type3FontRefs.has(fontRef)) {
1234         return errorFont();
1235       }
1236 
1237       if (this.fontCache.has(fontRef)) {
1238         return this.fontCache.get(fontRef);
1239       }
1240 
1241       font = this.xref.fetchIfRef(fontRef);
1242     }
1243 
1244     if (!(font instanceof Dict)) {
1245       if (!this.options.ignoreErrors && !this.parsingType3Font) {
1246         warn(`Font "${fontName}" is not available.`);
1247         return errorFont();
1248       }
1249       warn(
1250         `Font "${fontName}" is not available -- attempting to fallback to a default font.`
1251       );
1252 
1253       // Falling back to a default font to avoid completely broken rendering,
1254       // but note that there're no guarantees that things will look "correct".
1255       font = fallbackFontDict || PartialEvaluator.fallbackFontDict;
1256     }
1257 
1258     // We are holding `font.cacheKey` references only for `fontRef`s that
1259     // are not actually `Ref`s, but rather `Dict`s. See explanation below.
1260     if (font.cacheKey && this.fontCache.has(font.cacheKey)) {
1261       return this.fontCache.get(font.cacheKey);
1262     }
1263 
1264     const fontCapability = new PromiseCapability();
1265 
1266     let preEvaluatedFont;
1267     try {
1268       preEvaluatedFont = this.preEvaluateFont(font);
1269       preEvaluatedFont.cssFontInfo = cssFontInfo;
1270     } catch (reason) {
1271       warn(`loadFont - preEvaluateFont failed: "${reason}".`);
1272       return errorFont();
1273     }
1274     const { descriptor, hash } = preEvaluatedFont;
1275 
1276     const fontRefIsRef = fontRef instanceof Ref;
1277     let fontID;
1278 
1279     if (hash && descriptor instanceof Dict) {
1280       const fontAliases = (descriptor.fontAliases ||= Object.create(null));
1281 
1282       if (fontAliases[hash]) {
1283         const aliasFontRef = fontAliases[hash].aliasRef;
1284         if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
1285           this.fontCache.putAlias(fontRef, aliasFontRef);
1286           return this.fontCache.get(fontRef);
1287         }
1288       } else {
1289         fontAliases[hash] = {
1290           fontID: this.idFactory.createFontId(),
1291         };
1292       }
1293 
1294       if (fontRefIsRef) {
1295         fontAliases[hash].aliasRef = fontRef;
1296       }
1297       fontID = fontAliases[hash].fontID;
1298     } else {
1299       fontID = this.idFactory.createFontId();
1300     }
1301     assert(
1302       fontID?.startsWith("f"),
1303       'The "fontID" must be (correctly) defined.'
1304     );
1305 
1306     // Workaround for bad PDF generators that reference fonts incorrectly,
1307     // where `fontRef` is a `Dict` rather than a `Ref` (fixes bug946506.pdf).
1308     // In this case we cannot put the font into `this.fontCache` (which is
1309     // a `RefSetCache`), since it's not possible to use a `Dict` as a key.
1310     //
1311     // However, if we don't cache the font it's not possible to remove it
1312     // when `cleanup` is triggered from the API, which causes issues on
1313     // subsequent rendering operations (see issue7403.pdf) and would force us
1314     // to unnecessarily load the same fonts over and over.
1315     //
1316     // Instead, we cheat a bit by using a modified `fontID` as a key in
1317     // `this.fontCache`, to allow the font to be cached.
1318     // NOTE: This works because `RefSetCache` calls `toString()` on provided
1319     //       keys. Also, since `fontRef` is used when getting cached fonts,
1320     //       we'll not accidentally match fonts cached with the `fontID`.
1321     if (fontRefIsRef) {
1322       this.fontCache.put(fontRef, fontCapability.promise);
1323     } else {
1324       font.cacheKey = `cacheKey_${fontID}`;
1325       this.fontCache.put(font.cacheKey, fontCapability.promise);
1326     }
1327 
1328     // Keep track of each font we translated so the caller can
1329     // load them asynchronously before calling display on a page.
1330     font.loadedName = `${this.idFactory.getDocId()}_${fontID}`;
1331 
1332     this.translateFont(preEvaluatedFont)
1333       .then(translatedFont => {
1334         fontCapability.resolve(
1335           new TranslatedFont({
1336             loadedName: font.loadedName,
1337             font: translatedFont,
1338             dict: font,
1339             evaluatorOptions: this.options,
1340           })
1341         );
1342       })
1343       .catch(reason => {
1344         // TODO fontCapability.reject?
1345         warn(`loadFont - translateFont failed: "${reason}".`);
1346 
1347         fontCapability.resolve(
1348           new TranslatedFont({
1349             loadedName: font.loadedName,
1350             font: new ErrorFont(
1351               reason instanceof Error ? reason.message : reason
1352             ),
1353             dict: font,
1354             evaluatorOptions: this.options,
1355           })
1356         );
1357       });
1358     return fontCapability.promise;
1359   }
1360 
1361   buildPath(operatorList, fn, args, parsingText = false) {
1362     const lastIndex = operatorList.length - 1;
1363     if (!args) {
1364       args = [];
1365     }
1366     if (
1367       lastIndex < 0 ||
1368       operatorList.fnArray[lastIndex] !== OPS.constructPath
1369     ) {
1370       // Handle corrupt PDF documents that contains path operators inside of
1371       // text objects, which may shift subsequent text, by enclosing the path
1372       // operator in save/restore operators (fixes issue10542_reduced.pdf).
1373       //
1374       // Note that this will effectively disable the optimization in the
1375       // `else` branch below, but given that this type of corruption is
1376       // *extremely* rare that shouldn't really matter much in practice.
1377       if (parsingText) {
1378         warn(`Encountered path operator "${fn}" inside of a text object.`);
1379         operatorList.addOp(OPS.save, null);
1380       }
1381 
1382       let minMax;
1383       switch (fn) {
1384         case OPS.rectangle:
1385           const x = args[0] + args[2];
1386           const y = args[1] + args[3];
1387           minMax = [
1388             Math.min(args[0], x),
1389             Math.min(args[1], y),
1390             Math.max(args[0], x),
1391             Math.max(args[1], y),
1392           ];
1393           break;
1394         case OPS.moveTo:
1395         case OPS.lineTo:
1396           minMax = [args[0], args[1], args[0], args[1]];
1397           break;
1398         default:
1399           minMax = [Infinity, Infinity, -Infinity, -Infinity];
1400           break;
1401       }
1402       operatorList.addOp(OPS.constructPath, [[fn], args, minMax]);
1403 
1404       if (parsingText) {
1405         operatorList.addOp(OPS.restore, null);
1406       }
1407     } else {
1408       const opArgs = operatorList.argsArray[lastIndex];
1409       opArgs[0].push(fn);
1410       opArgs[1].push(...args);
1411       const minMax = opArgs[2];
1412 
1413       // Compute min/max in the worker instead of the main thread.
1414       // If the current matrix (when drawing) is a scaling one
1415       // then min/max can be easily computed in using those values.
1416       // Only rectangle, lineTo and moveTo are handled here since
1417       // Bezier stuff requires to have the starting point.
1418       switch (fn) {
1419         case OPS.rectangle:
1420           const x = args[0] + args[2];
1421           const y = args[1] + args[3];
1422           minMax[0] = Math.min(minMax[0], args[0], x);
1423           minMax[1] = Math.min(minMax[1], args[1], y);
1424           minMax[2] = Math.max(minMax[2], args[0], x);
1425           minMax[3] = Math.max(minMax[3], args[1], y);
1426           break;
1427         case OPS.moveTo:
1428         case OPS.lineTo:
1429           minMax[0] = Math.min(minMax[0], args[0]);
1430           minMax[1] = Math.min(minMax[1], args[1]);
1431           minMax[2] = Math.max(minMax[2], args[0]);
1432           minMax[3] = Math.max(minMax[3], args[1]);
1433           break;
1434       }
1435     }
1436   }
1437 
1438   parseColorSpace({ cs, resources, localColorSpaceCache }) {
1439     return ColorSpace.parseAsync({
1440       cs,
1441       xref: this.xref,
1442       resources,
1443       pdfFunctionFactory: this._pdfFunctionFactory,
1444       localColorSpaceCache,
1445     }).catch(reason => {
1446       if (reason instanceof AbortException) {
1447         return null;
1448       }
1449       if (this.options.ignoreErrors) {
1450         warn(`parseColorSpace - ignoring ColorSpace: "${reason}".`);
1451         return null;
1452       }
1453       throw reason;
1454     });
1455   }
1456 
1457   parseShading({
1458     shading,
1459     resources,
1460     localColorSpaceCache,
1461     localShadingPatternCache,
1462   }) {
1463     // Shadings and patterns may be referenced by the same name but the resource
1464     // dictionary could be different so we can't use the name for the cache key.
1465     let id = localShadingPatternCache.get(shading);
1466     if (!id) {
1467       var shadingFill = Pattern.parseShading(
1468         shading,
1469         this.xref,
1470         resources,
1471         this._pdfFunctionFactory,
1472         localColorSpaceCache
1473       );
1474       const patternIR = shadingFill.getIR();
1475       id = `pattern_${this.idFactory.createObjId()}`;
1476       if (this.parsingType3Font) {
1477         id = `${this.idFactory.getDocId()}_type3_${id}`;
1478       }
1479       localShadingPatternCache.set(shading, id);
1480 
1481       if (this.parsingType3Font) {
1482         this.handler.send("commonobj", [id, "Pattern", patternIR]);
1483       } else {
1484         this.handler.send("obj", [id, this.pageIndex, "Pattern", patternIR]);
1485       }
1486     }
1487     return id;
1488   }
1489 
1490   handleColorN(
1491     operatorList,
1492     fn,
1493     args,
1494     cs,
1495     patterns,
1496     resources,
1497     task,
1498     localColorSpaceCache,
1499     localTilingPatternCache,
1500     localShadingPatternCache
1501   ) {
1502     // compile tiling patterns
1503     const patternName = args.pop();
1504     // SCN/scn applies patterns along with normal colors
1505     if (patternName instanceof Name) {
1506       const rawPattern = patterns.getRaw(patternName.name);
1507 
1508       const localTilingPattern =
1509         rawPattern instanceof Ref &&
1510         localTilingPatternCache.getByRef(rawPattern);
1511       if (localTilingPattern) {
1512         try {
1513           const color = cs.base ? cs.base.getRgb(args, 0) : null;
1514           const tilingPatternIR = getTilingPatternIR(
1515             localTilingPattern.operatorListIR,
1516             localTilingPattern.dict,
1517             color
1518           );
1519           operatorList.addOp(fn, tilingPatternIR);
1520           return undefined;
1521         } catch {
1522           // Handle any errors during normal TilingPattern parsing.
1523         }
1524       }
1525 
1526       const pattern = this.xref.fetchIfRef(rawPattern);
1527       if (pattern) {
1528         const dict = pattern instanceof BaseStream ? pattern.dict : pattern;
1529         const typeNum = dict.get("PatternType");
1530 
1531         if (typeNum === PatternType.TILING) {
1532           const color = cs.base ? cs.base.getRgb(args, 0) : null;
1533           return this.handleTilingType(
1534             fn,
1535             color,
1536             resources,
1537             pattern,
1538             dict,
1539             operatorList,
1540             task,
1541             localTilingPatternCache
1542           );
1543         } else if (typeNum === PatternType.SHADING) {
1544           const shading = dict.get("Shading");
1545           const matrix = dict.getArray("Matrix");
1546           const objId = this.parseShading({
1547             shading,
1548             resources,
1549             localColorSpaceCache,
1550             localShadingPatternCache,
1551           });
1552           operatorList.addOp(fn, ["Shading", objId, matrix]);
1553           return undefined;
1554         }
1555         throw new FormatError(`Unknown PatternType: ${typeNum}`);
1556       }
1557     }
1558     throw new FormatError(`Unknown PatternName: ${patternName}`);
1559   }
1560 
1561   _parseVisibilityExpression(array, nestingCounter, currentResult) {
1562     const MAX_NESTING = 10;
1563     if (++nestingCounter > MAX_NESTING) {
1564       warn("Visibility expression is too deeply nested");
1565       return;
1566     }
1567     const length = array.length;
1568     const operator = this.xref.fetchIfRef(array[0]);
1569     if (length < 2 || !(operator instanceof Name)) {
1570       warn("Invalid visibility expression");
1571       return;
1572     }
1573     switch (operator.name) {
1574       case "And":
1575       case "Or":
1576       case "Not":
1577         currentResult.push(operator.name);
1578         break;
1579       default:
1580         warn(`Invalid operator ${operator.name} in visibility expression`);
1581         return;
1582     }
1583     for (let i = 1; i < length; i++) {
1584       const raw = array[i];
1585       const object = this.xref.fetchIfRef(raw);
1586       if (Array.isArray(object)) {
1587         const nestedResult = [];
1588         currentResult.push(nestedResult);
1589         // Recursively parse a subarray.
1590         this._parseVisibilityExpression(object, nestingCounter, nestedResult);
1591       } else if (raw instanceof Ref) {
1592         // Reference to an OCG dictionary.
1593         currentResult.push(raw.toString());
1594       }
1595     }
1596   }
1597 
1598   async parseMarkedContentProps(contentProperties, resources) {
1599     let optionalContent;
1600     if (contentProperties instanceof Name) {
1601       const properties = resources.get("Properties");
1602       optionalContent = properties.get(contentProperties.name);
1603     } else if (contentProperties instanceof Dict) {
1604       optionalContent = contentProperties;
1605     } else {
1606       throw new FormatError("Optional content properties malformed.");
1607     }
1608 
1609     const optionalContentType = optionalContent.get("Type")?.name;
1610     if (optionalContentType === "OCG") {
1611       return {
1612         type: optionalContentType,
1613         id: optionalContent.objId,
1614       };
1615     } else if (optionalContentType === "OCMD") {
1616       const expression = optionalContent.get("VE");
1617       if (Array.isArray(expression)) {
1618         const result = [];
1619         this._parseVisibilityExpression(expression, 0, result);
1620         if (result.length > 0) {
1621           return {
1622             type: "OCMD",
1623             expression: result,
1624           };
1625         }
1626       }
1627 
1628       const optionalContentGroups = optionalContent.get("OCGs");
1629       if (
1630         Array.isArray(optionalContentGroups) ||
1631         optionalContentGroups instanceof Dict
1632       ) {
1633         const groupIds = [];
1634         if (Array.isArray(optionalContentGroups)) {
1635           for (const ocg of optionalContentGroups) {
1636             groupIds.push(ocg.toString());
1637           }
1638         } else {
1639           // Dictionary, just use the obj id.
1640           groupIds.push(optionalContentGroups.objId);
1641         }
1642 
1643         return {
1644           type: optionalContentType,
1645           ids: groupIds,
1646           policy:
1647             optionalContent.get("P") instanceof Name
1648               ? optionalContent.get("P").name
1649               : null,
1650           expression: null,
1651         };
1652       } else if (optionalContentGroups instanceof Ref) {
1653         return {
1654           type: optionalContentType,
1655           id: optionalContentGroups.toString(),
1656         };
1657       }
1658     }
1659     return null;
1660   }
1661 
1662   getOperatorList({
1663     stream,
1664     task,
1665     resources,
1666     operatorList,
1667     initialState = null,
1668     fallbackFontDict = null,
1669   }) {
1670     // Ensure that `resources`/`initialState` is correctly initialized,
1671     // even if the provided parameter is e.g. `null`.
1672     resources ||= Dict.empty;
1673     initialState ||= new EvalState();
1674 
1675     if (!operatorList) {
1676       throw new Error('getOperatorList: missing "operatorList" parameter');
1677     }
1678 
1679     const self = this;
1680     const xref = this.xref;
1681     let parsingText = false;
1682     const localImageCache = new LocalImageCache();
1683     const localColorSpaceCache = new LocalColorSpaceCache();
1684     const localGStateCache = new LocalGStateCache();
1685     const localTilingPatternCache = new LocalTilingPatternCache();
1686     const localShadingPatternCache = new Map();
1687 
1688     const xobjs = resources.get("XObject") || Dict.empty;
1689     const patterns = resources.get("Pattern") || Dict.empty;
1690     const stateManager = new StateManager(initialState);
1691     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
1692     const timeSlotManager = new TimeSlotManager();
1693 
1694     function closePendingRestoreOPS(argument) {
1695       for (let i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
1696         operatorList.addOp(OPS.restore, []);
1697       }
1698     }
1699 
1700     return new Promise(function promiseBody(resolve, reject) {
1701       const next = function (promise) {
1702         Promise.all([promise, operatorList.ready]).then(function () {
1703           try {
1704             promiseBody(resolve, reject);
1705           } catch (ex) {
1706             reject(ex);
1707           }
1708         }, reject);
1709       };
1710       task.ensureNotTerminated();
1711       timeSlotManager.reset();
1712 
1713       const operation = {};
1714       let stop, i, ii, cs, name, isValidName;
1715       while (!(stop = timeSlotManager.check())) {
1716         // The arguments parsed by read() are used beyond this loop, so we
1717         // cannot reuse the same array on each iteration. Therefore we pass
1718         // in |null| as the initial value (see the comment on
1719         // EvaluatorPreprocessor_read() for why).
1720         operation.args = null;
1721         if (!preprocessor.read(operation)) {
1722           break;
1723         }
1724         let args = operation.args;
1725         let fn = operation.fn;
1726 
1727         switch (fn | 0) {
1728           case OPS.paintXObject:
1729             // eagerly compile XForm objects
1730             isValidName = args[0] instanceof Name;
1731             name = args[0].name;
1732 
1733             if (isValidName) {
1734               const localImage = localImageCache.getByName(name);
1735               if (localImage) {
1736                 operatorList.addImageOps(
1737                   localImage.fn,
1738                   localImage.args,
1739                   localImage.optionalContent
1740                 );
1741 
1742                 incrementCachedImageMaskCount(localImage);
1743                 args = null;
1744                 continue;
1745               }
1746             }
1747 
1748             next(
1749               new Promise(function (resolveXObject, rejectXObject) {
1750                 if (!isValidName) {
1751                   throw new FormatError("XObject must be referred to by name.");
1752                 }
1753 
1754                 let xobj = xobjs.getRaw(name);
1755                 if (xobj instanceof Ref) {
1756                   const localImage =
1757                     localImageCache.getByRef(xobj) ||
1758                     self._regionalImageCache.getByRef(xobj);
1759                   if (localImage) {
1760                     operatorList.addImageOps(
1761                       localImage.fn,
1762                       localImage.args,
1763                       localImage.optionalContent
1764                     );
1765 
1766                     incrementCachedImageMaskCount(localImage);
1767                     resolveXObject();
1768                     return;
1769                   }
1770 
1771                   const globalImage = self.globalImageCache.getData(
1772                     xobj,
1773                     self.pageIndex
1774                   );
1775                   if (globalImage) {
1776                     operatorList.addDependency(globalImage.objId);
1777                     operatorList.addImageOps(
1778                       globalImage.fn,
1779                       globalImage.args,
1780                       globalImage.optionalContent
1781                     );
1782 
1783                     resolveXObject();
1784                     return;
1785                   }
1786 
1787                   xobj = xref.fetch(xobj);
1788                 }
1789 
1790                 if (!(xobj instanceof BaseStream)) {
1791                   throw new FormatError("XObject should be a stream");
1792                 }
1793 
1794                 const type = xobj.dict.get("Subtype");
1795                 if (!(type instanceof Name)) {
1796                   throw new FormatError("XObject should have a Name subtype");
1797                 }
1798 
1799                 if (type.name === "Form") {
1800                   stateManager.save();
1801                   self
1802                     .buildFormXObject(
1803                       resources,
1804                       xobj,
1805                       null,
1806                       operatorList,
1807                       task,
1808                       stateManager.state.clone(),
1809                       localColorSpaceCache
1810                     )
1811                     .then(function () {
1812                       stateManager.restore();
1813                       resolveXObject();
1814                     }, rejectXObject);
1815                   return;
1816                 } else if (type.name === "Image") {
1817                   self
1818                     .buildPaintImageXObject({
1819                       resources,
1820                       image: xobj,
1821                       operatorList,
1822                       cacheKey: name,
1823                       localImageCache,
1824                       localColorSpaceCache,
1825                     })
1826                     .then(resolveXObject, rejectXObject);
1827                   return;
1828                 } else if (type.name === "PS") {
1829                   // PostScript XObjects are unused when viewing documents.
1830                   // See section 4.7.1 of Adobe's PDF reference.
1831                   info("Ignored XObject subtype PS");
1832                 } else {
1833                   throw new FormatError(
1834                     `Unhandled XObject subtype ${type.name}`
1835                   );
1836                 }
1837                 resolveXObject();
1838               }).catch(function (reason) {
1839                 if (reason instanceof AbortException) {
1840                   return;
1841                 }
1842                 if (self.options.ignoreErrors) {
1843                   warn(`getOperatorList - ignoring XObject: "${reason}".`);
1844                   return;
1845                 }
1846                 throw reason;
1847               })
1848             );
1849             return;
1850           case OPS.setFont:
1851             var fontSize = args[1];
1852             // eagerly collect all fonts
1853             next(
1854               self
1855                 .handleSetFont(
1856                   resources,
1857                   args,
1858                   null,
1859                   operatorList,
1860                   task,
1861                   stateManager.state,
1862                   fallbackFontDict
1863                 )
1864                 .then(function (loadedName) {
1865                   operatorList.addDependency(loadedName);
1866                   operatorList.addOp(OPS.setFont, [loadedName, fontSize]);
1867                 })
1868             );
1869             return;
1870           case OPS.beginText:
1871             parsingText = true;
1872             break;
1873           case OPS.endText:
1874             parsingText = false;
1875             break;
1876           case OPS.endInlineImage:
1877             var cacheKey = args[0].cacheKey;
1878             if (cacheKey) {
1879               const localImage = localImageCache.getByName(cacheKey);
1880               if (localImage) {
1881                 operatorList.addImageOps(
1882                   localImage.fn,
1883                   localImage.args,
1884                   localImage.optionalContent
1885                 );
1886 
1887                 incrementCachedImageMaskCount(localImage);
1888                 args = null;
1889                 continue;
1890               }
1891             }
1892             next(
1893               self.buildPaintImageXObject({
1894                 resources,
1895                 image: args[0],
1896                 isInline: true,
1897                 operatorList,
1898                 cacheKey,
1899                 localImageCache,
1900                 localColorSpaceCache,
1901               })
1902             );
1903             return;
1904           case OPS.showText:
1905             if (!stateManager.state.font) {
1906               self.ensureStateFont(stateManager.state);
1907               continue;
1908             }
1909             args[0] = self.handleText(args[0], stateManager.state);
1910             break;
1911           case OPS.showSpacedText:
1912             if (!stateManager.state.font) {
1913               self.ensureStateFont(stateManager.state);
1914               continue;
1915             }
1916             var combinedGlyphs = [];
1917             var state = stateManager.state;
1918             for (const arrItem of args[0]) {
1919               if (typeof arrItem === "string") {
1920                 combinedGlyphs.push(...self.handleText(arrItem, state));
1921               } else if (typeof arrItem === "number") {
1922                 combinedGlyphs.push(arrItem);
1923               }
1924             }
1925             args[0] = combinedGlyphs;
1926             fn = OPS.showText;
1927             break;
1928           case OPS.nextLineShowText:
1929             if (!stateManager.state.font) {
1930               self.ensureStateFont(stateManager.state);
1931               continue;
1932             }
1933             operatorList.addOp(OPS.nextLine);
1934             args[0] = self.handleText(args[0], stateManager.state);
1935             fn = OPS.showText;
1936             break;
1937           case OPS.nextLineSetSpacingShowText:
1938             if (!stateManager.state.font) {
1939               self.ensureStateFont(stateManager.state);
1940               continue;
1941             }
1942             operatorList.addOp(OPS.nextLine);
1943             operatorList.addOp(OPS.setWordSpacing, [args.shift()]);
1944             operatorList.addOp(OPS.setCharSpacing, [args.shift()]);
1945             args[0] = self.handleText(args[0], stateManager.state);
1946             fn = OPS.showText;
1947             break;
1948           case OPS.setTextRenderingMode:
1949             stateManager.state.textRenderingMode = args[0];
1950             break;
1951 
1952           case OPS.setFillColorSpace: {
1953             const cachedColorSpace = ColorSpace.getCached(
1954               args[0],
1955               xref,
1956               localColorSpaceCache
1957             );
1958             if (cachedColorSpace) {
1959               stateManager.state.fillColorSpace = cachedColorSpace;
1960               continue;
1961             }
1962 
1963             next(
1964               self
1965                 .parseColorSpace({
1966                   cs: args[0],
1967                   resources,
1968                   localColorSpaceCache,
1969                 })
1970                 .then(function (colorSpace) {
1971                   if (colorSpace) {
1972                     stateManager.state.fillColorSpace = colorSpace;
1973                   }
1974                 })
1975             );
1976             return;
1977           }
1978           case OPS.setStrokeColorSpace: {
1979             const cachedColorSpace = ColorSpace.getCached(
1980               args[0],
1981               xref,
1982               localColorSpaceCache
1983             );
1984             if (cachedColorSpace) {
1985               stateManager.state.strokeColorSpace = cachedColorSpace;
1986               continue;
1987             }
1988 
1989             next(
1990               self
1991                 .parseColorSpace({
1992                   cs: args[0],
1993                   resources,
1994                   localColorSpaceCache,
1995                 })
1996                 .then(function (colorSpace) {
1997                   if (colorSpace) {
1998                     stateManager.state.strokeColorSpace = colorSpace;
1999                   }
2000                 })
2001             );
2002             return;
2003           }
2004           case OPS.setFillColor:
2005             cs = stateManager.state.fillColorSpace;
2006             args = cs.getRgb(args, 0);
2007             fn = OPS.setFillRGBColor;
2008             break;
2009           case OPS.setStrokeColor:
2010             cs = stateManager.state.strokeColorSpace;
2011             args = cs.getRgb(args, 0);
2012             fn = OPS.setStrokeRGBColor;
2013             break;
2014           case OPS.setFillGray:
2015             stateManager.state.fillColorSpace = ColorSpace.singletons.gray;
2016             args = ColorSpace.singletons.gray.getRgb(args, 0);
2017             fn = OPS.setFillRGBColor;
2018             break;
2019           case OPS.setStrokeGray:
2020             stateManager.state.strokeColorSpace = ColorSpace.singletons.gray;
2021             args = ColorSpace.singletons.gray.getRgb(args, 0);
2022             fn = OPS.setStrokeRGBColor;
2023             break;
2024           case OPS.setFillCMYKColor:
2025             stateManager.state.fillColorSpace = ColorSpace.singletons.cmyk;
2026             args = ColorSpace.singletons.cmyk.getRgb(args, 0);
2027             fn = OPS.setFillRGBColor;
2028             break;
2029           case OPS.setStrokeCMYKColor:
2030             stateManager.state.strokeColorSpace = ColorSpace.singletons.cmyk;
2031             args = ColorSpace.singletons.cmyk.getRgb(args, 0);
2032             fn = OPS.setStrokeRGBColor;
2033             break;
2034           case OPS.setFillRGBColor:
2035             stateManager.state.fillColorSpace = ColorSpace.singletons.rgb;
2036             args = ColorSpace.singletons.rgb.getRgb(args, 0);
2037             break;
2038           case OPS.setStrokeRGBColor:
2039             stateManager.state.strokeColorSpace = ColorSpace.singletons.rgb;
2040             args = ColorSpace.singletons.rgb.getRgb(args, 0);
2041             break;
2042           case OPS.setFillColorN:
2043             cs = stateManager.state.fillColorSpace;
2044             if (cs.name === "Pattern") {
2045               next(
2046                 self.handleColorN(
2047                   operatorList,
2048                   OPS.setFillColorN,
2049                   args,
2050                   cs,
2051                   patterns,
2052                   resources,
2053                   task,
2054                   localColorSpaceCache,
2055                   localTilingPatternCache,
2056                   localShadingPatternCache
2057                 )
2058               );
2059               return;
2060             }
2061             args = cs.getRgb(args, 0);
2062             fn = OPS.setFillRGBColor;
2063             break;
2064           case OPS.setStrokeColorN:
2065             cs = stateManager.state.strokeColorSpace;
2066             if (cs.name === "Pattern") {
2067               next(
2068                 self.handleColorN(
2069                   operatorList,
2070                   OPS.setStrokeColorN,
2071                   args,
2072                   cs,
2073                   patterns,
2074                   resources,
2075                   task,
2076                   localColorSpaceCache,
2077                   localTilingPatternCache,
2078                   localShadingPatternCache
2079                 )
2080               );
2081               return;
2082             }
2083             args = cs.getRgb(args, 0);
2084             fn = OPS.setStrokeRGBColor;
2085             break;
2086 
2087           case OPS.shadingFill:
2088             var shadingRes = resources.get("Shading");
2089             if (!shadingRes) {
2090               throw new FormatError("No shading resource found");
2091             }
2092 
2093             var shading = shadingRes.get(args[0].name);
2094             if (!shading) {
2095               throw new FormatError("No shading object found");
2096             }
2097             const patternId = self.parseShading({
2098               shading,
2099               resources,
2100               localColorSpaceCache,
2101               localShadingPatternCache,
2102             });
2103             args = [patternId];
2104             fn = OPS.shadingFill;
2105             break;
2106           case OPS.setGState:
2107             isValidName = args[0] instanceof Name;
2108             name = args[0].name;
2109 
2110             if (isValidName) {
2111               const localGStateObj = localGStateCache.getByName(name);
2112               if (localGStateObj) {
2113                 if (localGStateObj.length > 0) {
2114                   operatorList.addOp(OPS.setGState, [localGStateObj]);
2115                 }
2116                 args = null;
2117                 continue;
2118               }
2119             }
2120 
2121             next(
2122               new Promise(function (resolveGState, rejectGState) {
2123                 if (!isValidName) {
2124                   throw new FormatError("GState must be referred to by name.");
2125                 }
2126 
2127                 const extGState = resources.get("ExtGState");
2128                 if (!(extGState instanceof Dict)) {
2129                   throw new FormatError("ExtGState should be a dictionary.");
2130                 }
2131 
2132                 const gState = extGState.get(name);
2133                 // TODO: Attempt to lookup cached GStates by reference as well,
2134                 //       if and only if there are PDF documents where doing so
2135                 //       would significantly improve performance.
2136                 if (!(gState instanceof Dict)) {
2137                   throw new FormatError("GState should be a dictionary.");
2138                 }
2139 
2140                 self
2141                   .setGState({
2142                     resources,
2143                     gState,
2144                     operatorList,
2145                     cacheKey: name,
2146                     task,
2147                     stateManager,
2148                     localGStateCache,
2149                     localColorSpaceCache,
2150                   })
2151                   .then(resolveGState, rejectGState);
2152               }).catch(function (reason) {
2153                 if (reason instanceof AbortException) {
2154                   return;
2155                 }
2156                 if (self.options.ignoreErrors) {
2157                   warn(`getOperatorList - ignoring ExtGState: "${reason}".`);
2158                   return;
2159                 }
2160                 throw reason;
2161               })
2162             );
2163             return;
2164           case OPS.moveTo:
2165           case OPS.lineTo:
2166           case OPS.curveTo:
2167           case OPS.curveTo2:
2168           case OPS.curveTo3:
2169           case OPS.closePath:
2170           case OPS.rectangle:
2171             self.buildPath(operatorList, fn, args, parsingText);
2172             continue;
2173           case OPS.markPoint:
2174           case OPS.markPointProps:
2175           case OPS.beginCompat:
2176           case OPS.endCompat:
2177             // Ignore operators where the corresponding handlers are known to
2178             // be no-op in CanvasGraphics (display/canvas.js). This prevents
2179             // serialization errors and is also a bit more efficient.
2180             // We could also try to serialize all objects in a general way,
2181             // e.g. as done in https://github.com/mozilla/pdf.js/pull/6266,
2182             // but doing so is meaningless without knowing the semantics.
2183             continue;
2184           case OPS.beginMarkedContentProps:
2185             if (!(args[0] instanceof Name)) {
2186               warn(`Expected name for beginMarkedContentProps arg0=${args[0]}`);
2187               operatorList.addOp(OPS.beginMarkedContentProps, ["OC", null]);
2188               continue;
2189             }
2190             if (args[0].name === "OC") {
2191               next(
2192                 self
2193                   .parseMarkedContentProps(args[1], resources)
2194                   .then(data => {
2195                     operatorList.addOp(OPS.beginMarkedContentProps, [
2196                       "OC",
2197                       data,
2198                     ]);
2199                   })
2200                   .catch(reason => {
2201                     if (reason instanceof AbortException) {
2202                       return;
2203                     }
2204                     if (self.options.ignoreErrors) {
2205                       warn(
2206                         `getOperatorList - ignoring beginMarkedContentProps: "${reason}".`
2207                       );
2208                       operatorList.addOp(OPS.beginMarkedContentProps, [
2209                         "OC",
2210                         null,
2211                       ]);
2212                       return;
2213                     }
2214                     throw reason;
2215                   })
2216               );
2217               return;
2218             }
2219             // Other marked content types aren't supported yet.
2220             args = [
2221               args[0].name,
2222               args[1] instanceof Dict ? args[1].get("MCID") : null,
2223             ];
2224 
2225             break;
2226           case OPS.beginMarkedContent:
2227           case OPS.endMarkedContent:
2228           default:
2229             // Note: Ignore the operator if it has `Dict` arguments, since
2230             // those are non-serializable, otherwise postMessage will throw
2231             // "An object could not be cloned.".
2232             if (args !== null) {
2233               for (i = 0, ii = args.length; i < ii; i++) {
2234                 if (args[i] instanceof Dict) {
2235                   break;
2236                 }
2237               }
2238               if (i < ii) {
2239                 warn("getOperatorList - ignoring operator: " + fn);
2240                 continue;
2241               }
2242             }
2243         }
2244         operatorList.addOp(fn, args);
2245       }
2246       if (stop) {
2247         next(deferred);
2248         return;
2249       }
2250       // Some PDFs don't close all restores inside object/form.
2251       // Closing those for them.
2252       closePendingRestoreOPS();
2253       resolve();
2254     }).catch(reason => {
2255       if (reason instanceof AbortException) {
2256         return;
2257       }
2258       if (this.options.ignoreErrors) {
2259         warn(
2260           `getOperatorList - ignoring errors during "${task.name}" ` +
2261             `task: "${reason}".`
2262         );
2263 
2264         closePendingRestoreOPS();
2265         return;
2266       }
2267       throw reason;
2268     });
2269   }
2270 
2271   getTextContent({
2272     stream,
2273     task,
2274     resources,
2275     stateManager = null,
2276     includeMarkedContent = false,
2277     sink,
2278     seenStyles = new Set(),
2279     viewBox,
2280     markedContentData = null,
2281     disableNormalization = false,
2282     keepWhiteSpace = false,
2283   }) {
2284     // Ensure that `resources`/`stateManager` is correctly initialized,
2285     // even if the provided parameter is e.g. `null`.
2286     resources ||= Dict.empty;
2287     stateManager ||= new StateManager(new TextState());
2288 
2289     if (includeMarkedContent) {
2290       markedContentData ||= { level: 0 };
2291     }
2292 
2293     const textContent = {
2294       items: [],
2295       styles: Object.create(null),
2296     };
2297     const textContentItem = {
2298       initialized: false,
2299       str: [],
2300       totalWidth: 0,
2301       totalHeight: 0,
2302       width: 0,
2303       height: 0,
2304       vertical: false,
2305       prevTransform: null,
2306       textAdvanceScale: 0,
2307       spaceInFlowMin: 0,
2308       spaceInFlowMax: 0,
2309       trackingSpaceMin: Infinity,
2310       negativeSpaceMax: -Infinity,
2311       notASpace: -Infinity,
2312       transform: null,
2313       fontName: null,
2314       hasEOL: false,
2315     };
2316 
2317     // Use a circular buffer (length === 2) to save the last chars in the
2318     // text stream.
2319     // This implementation of the circular buffer is using a fixed array
2320     // and the position of the next element:
2321     // function addElement(x) {
2322     //   buffer[pos] = x;
2323     //   pos = (pos + 1) % buffer.length;
2324     // }
2325     // It's a way faster than:
2326     // function addElement(x) {
2327     //   buffer.push(x);
2328     //   buffer.shift();
2329     // }
2330     //
2331     // It's useful to know when we need to add a whitespace in the
2332     // text chunk.
2333     const twoLastChars = [" ", " "];
2334     let twoLastCharsPos = 0;
2335 
2336     /**
2337      * Save the last char.
2338      * @param {string} char
2339      * @returns {boolean} true when the two last chars before adding the new one
2340      * are a non-whitespace followed by a whitespace.
2341      */
2342     function saveLastChar(char) {
2343       const nextPos = (twoLastCharsPos + 1) % 2;
2344       const ret =
2345         twoLastChars[twoLastCharsPos] !== " " && twoLastChars[nextPos] === " ";
2346       twoLastChars[twoLastCharsPos] = char;
2347       twoLastCharsPos = nextPos;
2348 
2349       return !keepWhiteSpace && ret;
2350     }
2351 
2352     function shouldAddWhitepsace() {
2353       return (
2354         !keepWhiteSpace &&
2355         twoLastChars[twoLastCharsPos] !== " " &&
2356         twoLastChars[(twoLastCharsPos + 1) % 2] === " "
2357       );
2358     }
2359 
2360     function resetLastChars() {
2361       twoLastChars[0] = twoLastChars[1] = " ";
2362       twoLastCharsPos = 0;
2363     }
2364 
2365     // Used in addFakeSpaces.
2366 
2367     // A white <= fontSize * TRACKING_SPACE_FACTOR is a tracking space
2368     // so it doesn't count as a space.
2369     const TRACKING_SPACE_FACTOR = 0.102;
2370 
2371     // When a white <= fontSize * NOT_A_SPACE_FACTOR, there is no space
2372     // even if one is present in the text stream.
2373     const NOT_A_SPACE_FACTOR = 0.03;
2374 
2375     // A negative white < fontSize * NEGATIVE_SPACE_FACTOR induces
2376     // a break (a new chunk of text is created).
2377     // It doesn't change anything when the text is copied but
2378     // it improves potential mismatch between text layer and canvas.
2379     const NEGATIVE_SPACE_FACTOR = -0.2;
2380 
2381     // A white with a width in [fontSize * MIN_FACTOR; fontSize * MAX_FACTOR]
2382     // is a space which will be inserted in the current flow of words.
2383     // If the width is outside of this range then the flow is broken
2384     // (which means a new span in the text layer).
2385     // It's useful to adjust the best as possible the span in the layer
2386     // to what is displayed in the canvas.
2387     const SPACE_IN_FLOW_MIN_FACTOR = 0.102;
2388     const SPACE_IN_FLOW_MAX_FACTOR = 0.6;
2389 
2390     // If a char is too high/too low compared to the previous we just create
2391     // a new chunk.
2392     // If the advance isn't in the +/-VERTICAL_SHIFT_RATIO * height range then
2393     // a new chunk is created.
2394     const VERTICAL_SHIFT_RATIO = 0.25;
2395 
2396     const self = this;
2397     const xref = this.xref;
2398     const showSpacedTextBuffer = [];
2399 
2400     // The xobj is parsed iff it's needed, e.g. if there is a `DO` cmd.
2401     let xobjs = null;
2402     const emptyXObjectCache = new LocalImageCache();
2403     const emptyGStateCache = new LocalGStateCache();
2404 
2405     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
2406 
2407     let textState;
2408 
2409     function pushWhitespace({
2410       width = 0,
2411       height = 0,
2412       transform = textContentItem.prevTransform,
2413       fontName = textContentItem.fontName,
2414     }) {
2415       textContent.items.push({
2416         str: " ",
2417         dir: "ltr",
2418         width,
2419         height,
2420         transform,
2421         fontName,
2422         hasEOL: false,
2423       });
2424     }
2425 
2426     function getCurrentTextTransform() {
2427       // 9.4.4 Text Space Details
2428       const font = textState.font;
2429       const tsm = [
2430         textState.fontSize * textState.textHScale,
2431         0,
2432         0,
2433         textState.fontSize,
2434         0,
2435         textState.textRise,
2436       ];
2437 
2438       if (
2439         font.isType3Font &&
2440         (textState.fontSize <= 1 || font.isCharBBox) &&
2441         !isArrayEqual(textState.fontMatrix, FONT_IDENTITY_MATRIX)
2442       ) {
2443         const glyphHeight = font.bbox[3] - font.bbox[1];
2444         if (glyphHeight > 0) {
2445           tsm[3] *= glyphHeight * textState.fontMatrix[3];
2446         }
2447       }
2448 
2449       return Util.transform(
2450         textState.ctm,
2451         Util.transform(textState.textMatrix, tsm)
2452       );
2453     }
2454 
2455     function ensureTextContentItem() {
2456       if (textContentItem.initialized) {
2457         return textContentItem;
2458       }
2459       const { font, loadedName } = textState;
2460       if (!seenStyles.has(loadedName)) {
2461         seenStyles.add(loadedName);
2462         textContent.styles[loadedName] = {
2463           fontFamily: font.fallbackName,
2464           ascent: font.ascent,
2465           descent: font.descent,
2466           vertical: font.vertical,
2467         };
2468         if (self.options.fontExtraProperties && font.systemFontInfo) {
2469           const style = textContent.styles[loadedName];
2470           style.fontSubstitution = font.systemFontInfo.css;
2471           style.fontSubstitutionLoadedName = font.systemFontInfo.loadedName;
2472         }
2473       }
2474       textContentItem.fontName = loadedName;
2475 
2476       const trm = (textContentItem.transform = getCurrentTextTransform());
2477       if (!font.vertical) {
2478         textContentItem.width = textContentItem.totalWidth = 0;
2479         textContentItem.height = textContentItem.totalHeight = Math.hypot(
2480           trm[2],
2481           trm[3]
2482         );
2483         textContentItem.vertical = false;
2484       } else {
2485         textContentItem.width = textContentItem.totalWidth = Math.hypot(
2486           trm[0],
2487           trm[1]
2488         );
2489         textContentItem.height = textContentItem.totalHeight = 0;
2490         textContentItem.vertical = true;
2491       }
2492 
2493       const scaleLineX = Math.hypot(
2494         textState.textLineMatrix[0],
2495         textState.textLineMatrix[1]
2496       );
2497       const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
2498       textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
2499 
2500       const { fontSize } = textState;
2501       textContentItem.trackingSpaceMin = fontSize * TRACKING_SPACE_FACTOR;
2502       textContentItem.notASpace = fontSize * NOT_A_SPACE_FACTOR;
2503       textContentItem.negativeSpaceMax = fontSize * NEGATIVE_SPACE_FACTOR;
2504       textContentItem.spaceInFlowMin = fontSize * SPACE_IN_FLOW_MIN_FACTOR;
2505       textContentItem.spaceInFlowMax = fontSize * SPACE_IN_FLOW_MAX_FACTOR;
2506       textContentItem.hasEOL = false;
2507 
2508       textContentItem.initialized = true;
2509       return textContentItem;
2510     }
2511 
2512     function updateAdvanceScale() {
2513       if (!textContentItem.initialized) {
2514         return;
2515       }
2516 
2517       const scaleLineX = Math.hypot(
2518         textState.textLineMatrix[0],
2519         textState.textLineMatrix[1]
2520       );
2521       const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
2522       const scaleFactor = scaleCtmX * scaleLineX;
2523       if (scaleFactor === textContentItem.textAdvanceScale) {
2524         return;
2525       }
2526 
2527       if (!textContentItem.vertical) {
2528         textContentItem.totalWidth +=
2529           textContentItem.width * textContentItem.textAdvanceScale;
2530         textContentItem.width = 0;
2531       } else {
2532         textContentItem.totalHeight +=
2533           textContentItem.height * textContentItem.textAdvanceScale;
2534         textContentItem.height = 0;
2535       }
2536 
2537       textContentItem.textAdvanceScale = scaleFactor;
2538     }
2539 
2540     function runBidiTransform(textChunk) {
2541       let text = textChunk.str.join("");
2542       if (!disableNormalization) {
2543         text = normalizeUnicode(text);
2544       }
2545       const bidiResult = bidi(text, -1, textChunk.vertical);
2546       return {
2547         str: bidiResult.str,
2548         dir: bidiResult.dir,
2549         width: Math.abs(textChunk.totalWidth),
2550         height: Math.abs(textChunk.totalHeight),
2551         transform: textChunk.transform,
2552         fontName: textChunk.fontName,
2553         hasEOL: textChunk.hasEOL,
2554       };
2555     }
2556 
2557     async function handleSetFont(fontName, fontRef) {
2558       const translated = await self.loadFont(fontName, fontRef, resources);
2559 
2560       if (translated.font.isType3Font) {
2561         try {
2562           await translated.loadType3Data(self, resources, task);
2563         } catch {
2564           // Ignore Type3-parsing errors, since we only use `loadType3Data`
2565           // here to ensure that we'll always obtain a useful /FontBBox.
2566         }
2567       }
2568 
2569       textState.loadedName = translated.loadedName;
2570       textState.font = translated.font;
2571       textState.fontMatrix = translated.font.fontMatrix || FONT_IDENTITY_MATRIX;
2572     }
2573 
2574     function applyInverseRotation(x, y, matrix) {
2575       const scale = Math.hypot(matrix[0], matrix[1]);
2576       return [
2577         (matrix[0] * x + matrix[1] * y) / scale,
2578         (matrix[2] * x + matrix[3] * y) / scale,
2579       ];
2580     }
2581 
2582     function compareWithLastPosition(glyphWidth) {
2583       const currentTransform = getCurrentTextTransform();
2584       let posX = currentTransform[4];
2585       let posY = currentTransform[5];
2586 
2587       // Check if the glyph is in the viewbox.
2588       if (textState.font?.vertical) {
2589         if (
2590           posX < viewBox[0] ||
2591           posX > viewBox[2] ||
2592           posY + glyphWidth < viewBox[1] ||
2593           posY > viewBox[3]
2594         ) {
2595           return false;
2596         }
2597       } else if (
2598         posX + glyphWidth < viewBox[0] ||
2599         posX > viewBox[2] ||
2600         posY < viewBox[1] ||
2601         posY > viewBox[3]
2602       ) {
2603         return false;
2604       }
2605 
2606       if (!textState.font || !textContentItem.prevTransform) {
2607         return true;
2608       }
2609 
2610       let lastPosX = textContentItem.prevTransform[4];
2611       let lastPosY = textContentItem.prevTransform[5];
2612 
2613       if (lastPosX === posX && lastPosY === posY) {
2614         return true;
2615       }
2616 
2617       let rotate = -1;
2618       // Take into account the rotation is the current transform.
2619       if (
2620         currentTransform[0] &&
2621         currentTransform[1] === 0 &&
2622         currentTransform[2] === 0
2623       ) {
2624         rotate = currentTransform[0] > 0 ? 0 : 180;
2625       } else if (
2626         currentTransform[1] &&
2627         currentTransform[0] === 0 &&
2628         currentTransform[3] === 0
2629       ) {
2630         rotate = currentTransform[1] > 0 ? 90 : 270;
2631       }
2632 
2633       switch (rotate) {
2634         case 0:
2635           break;
2636         case 90:
2637           [posX, posY] = [posY, posX];
2638           [lastPosX, lastPosY] = [lastPosY, lastPosX];
2639           break;
2640         case 180:
2641           [posX, posY, lastPosX, lastPosY] = [
2642             -posX,
2643             -posY,
2644             -lastPosX,
2645             -lastPosY,
2646           ];
2647           break;
2648         case 270:
2649           [posX, posY] = [-posY, -posX];
2650           [lastPosX, lastPosY] = [-lastPosY, -lastPosX];
2651           break;
2652         default:
2653           // This is not a 0, 90, 180, 270 rotation so:
2654           //  - remove the scale factor from the matrix to get a rotation matrix
2655           //  - apply the inverse (which is the transposed) to the positions
2656           // and we can then compare positions of the glyphes to detect
2657           // a whitespace.
2658           [posX, posY] = applyInverseRotation(posX, posY, currentTransform);
2659           [lastPosX, lastPosY] = applyInverseRotation(
2660             lastPosX,
2661             lastPosY,
2662             textContentItem.prevTransform
2663           );
2664       }
2665 
2666       if (textState.font.vertical) {
2667         const advanceY = (lastPosY - posY) / textContentItem.textAdvanceScale;
2668         const advanceX = posX - lastPosX;
2669 
2670         // When the total height of the current chunk is negative
2671         // then we're writing from bottom to top.
2672         const textOrientation = Math.sign(textContentItem.height);
2673         if (advanceY < textOrientation * textContentItem.negativeSpaceMax) {
2674           if (
2675             Math.abs(advanceX) >
2676             0.5 * textContentItem.width /* not the same column */
2677           ) {
2678             appendEOL();
2679             return true;
2680           }
2681 
2682           resetLastChars();
2683           flushTextContentItem();
2684           return true;
2685         }
2686 
2687         if (Math.abs(advanceX) > textContentItem.width) {
2688           appendEOL();
2689           return true;
2690         }
2691 
2692         if (advanceY <= textOrientation * textContentItem.notASpace) {
2693           // The real spacing between 2 consecutive chars is thin enough to be
2694           // considered a non-space.
2695           resetLastChars();
2696         }
2697 
2698         if (advanceY <= textOrientation * textContentItem.trackingSpaceMin) {
2699           if (shouldAddWhitepsace()) {
2700             // The space is very thin, hence it deserves to have its own span in
2701             // order to avoid too much shift between the canvas and the text
2702             // layer.
2703             resetLastChars();
2704             flushTextContentItem();
2705             pushWhitespace({ height: Math.abs(advanceY) });
2706           } else {
2707             textContentItem.height += advanceY;
2708           }
2709         } else if (
2710           !addFakeSpaces(
2711             advanceY,
2712             textContentItem.prevTransform,
2713             textOrientation
2714           )
2715         ) {
2716           if (textContentItem.str.length === 0) {
2717             resetLastChars();
2718             pushWhitespace({ height: Math.abs(advanceY) });
2719           } else {
2720             textContentItem.height += advanceY;
2721           }
2722         }
2723 
2724         if (Math.abs(advanceX) > textContentItem.width * VERTICAL_SHIFT_RATIO) {
2725           flushTextContentItem();
2726         }
2727 
2728         return true;
2729       }
2730 
2731       const advanceX = (posX - lastPosX) / textContentItem.textAdvanceScale;
2732       const advanceY = posY - lastPosY;
2733 
2734       // When the total width of the current chunk is negative
2735       // then we're writing from right to left.
2736       const textOrientation = Math.sign(textContentItem.width);
2737       if (advanceX < textOrientation * textContentItem.negativeSpaceMax) {
2738         if (
2739           Math.abs(advanceY) >
2740           0.5 * textContentItem.height /* not the same line */
2741         ) {
2742           appendEOL();
2743           return true;
2744         }
2745 
2746         // We're moving back so in case the last char was a whitespace
2747         // we cancel it: it doesn't make sense to insert it.
2748         resetLastChars();
2749         flushTextContentItem();
2750         return true;
2751       }
2752 
2753       if (Math.abs(advanceY) > textContentItem.height) {
2754         appendEOL();
2755         return true;
2756       }
2757 
2758       if (advanceX <= textOrientation * textContentItem.notASpace) {
2759         // The real spacing between 2 consecutive chars is thin enough to be
2760         // considered a non-space.
2761         resetLastChars();
2762       }
2763 
2764       if (advanceX <= textOrientation * textContentItem.trackingSpaceMin) {
2765         if (shouldAddWhitepsace()) {
2766           // The space is very thin, hence it deserves to have its own span in
2767           // order to avoid too much shift between the canvas and the text
2768           // layer.
2769           resetLastChars();
2770           flushTextContentItem();
2771           pushWhitespace({ width: Math.abs(advanceX) });
2772         } else {
2773           textContentItem.width += advanceX;
2774         }
2775       } else if (
2776         !addFakeSpaces(advanceX, textContentItem.prevTransform, textOrientation)
2777       ) {
2778         if (textContentItem.str.length === 0) {
2779           resetLastChars();
2780           pushWhitespace({ width: Math.abs(advanceX) });
2781         } else {
2782           textContentItem.width += advanceX;
2783         }
2784       }
2785 
2786       if (Math.abs(advanceY) > textContentItem.height * VERTICAL_SHIFT_RATIO) {
2787         flushTextContentItem();
2788       }
2789 
2790       return true;
2791     }
2792 
2793     function buildTextContentItem({ chars, extraSpacing }) {
2794       const font = textState.font;
2795       if (!chars) {
2796         // Just move according to the space we have.
2797         const charSpacing = textState.charSpacing + extraSpacing;
2798         if (charSpacing) {
2799           if (!font.vertical) {
2800             textState.translateTextMatrix(
2801               charSpacing * textState.textHScale,
2802               0
2803             );
2804           } else {
2805             textState.translateTextMatrix(0, -charSpacing);
2806           }
2807         }
2808 
2809         if (keepWhiteSpace) {
2810           compareWithLastPosition(0);
2811         }
2812 
2813         return;
2814       }
2815 
2816       const glyphs = font.charsToGlyphs(chars);
2817       const scale = textState.fontMatrix[0] * textState.fontSize;
2818 
2819       for (let i = 0, ii = glyphs.length; i < ii; i++) {
2820         const glyph = glyphs[i];
2821         const { category } = glyph;
2822 
2823         if (category.isInvisibleFormatMark) {
2824           continue;
2825         }
2826         let charSpacing =
2827           textState.charSpacing + (i + 1 === ii ? extraSpacing : 0);
2828 
2829         let glyphWidth = glyph.width;
2830         if (font.vertical) {
2831           glyphWidth = glyph.vmetric ? glyph.vmetric[0] : -glyphWidth;
2832         }
2833         let scaledDim = glyphWidth * scale;
2834 
2835         if (!keepWhiteSpace && category.isWhitespace) {
2836           // Don't push a " " in the textContentItem
2837           // (except when it's between two non-spaces chars),
2838           // it will be done (if required) in next call to
2839           // compareWithLastPosition.
2840           // This way we can merge real spaces and spaces due to cursor moves.
2841           if (!font.vertical) {
2842             charSpacing += scaledDim + textState.wordSpacing;
2843             textState.translateTextMatrix(
2844               charSpacing * textState.textHScale,
2845               0
2846             );
2847           } else {
2848             charSpacing += -scaledDim + textState.wordSpacing;
2849             textState.translateTextMatrix(0, -charSpacing);
2850           }
2851           saveLastChar(" ");
2852           continue;
2853         }
2854 
2855         if (
2856           !category.isZeroWidthDiacritic &&
2857           !compareWithLastPosition(scaledDim)
2858         ) {
2859           // The glyph is not in page so just skip it but move the cursor.
2860           if (!font.vertical) {
2861             textState.translateTextMatrix(scaledDim * textState.textHScale, 0);
2862           } else {
2863             textState.translateTextMatrix(0, scaledDim);
2864           }
2865           continue;
2866         }
2867 
2868         // Must be called after compareWithLastPosition because
2869         // the textContentItem could have been flushed.
2870         const textChunk = ensureTextContentItem();
2871         if (category.isZeroWidthDiacritic) {
2872           scaledDim = 0;
2873         }
2874 
2875         if (!font.vertical) {
2876           scaledDim *= textState.textHScale;
2877           textState.translateTextMatrix(scaledDim, 0);
2878           textChunk.width += scaledDim;
2879         } else {
2880           textState.translateTextMatrix(0, scaledDim);
2881           scaledDim = Math.abs(scaledDim);
2882           textChunk.height += scaledDim;
2883         }
2884 
2885         if (scaledDim) {
2886           // Save the position of the last visible character.
2887           textChunk.prevTransform = getCurrentTextTransform();
2888         }
2889 
2890         const glyphUnicode = glyph.unicode;
2891         if (saveLastChar(glyphUnicode)) {
2892           // The two last chars are a non-whitespace followed by a whitespace
2893           // and then this non-whitespace, so we insert a whitespace here.
2894           // Replaces all whitespaces with standard spaces (0x20), to avoid
2895           // alignment issues between the textLayer and the canvas if the text
2896           // contains e.g. tabs (fixes issue6612.pdf).
2897           textChunk.str.push(" ");
2898         }
2899         textChunk.str.push(glyphUnicode);
2900 
2901         if (charSpacing) {
2902           if (!font.vertical) {
2903             textState.translateTextMatrix(
2904               charSpacing * textState.textHScale,
2905               0
2906             );
2907           } else {
2908             textState.translateTextMatrix(0, -charSpacing);
2909           }
2910         }
2911       }
2912     }
2913 
2914     function appendEOL() {
2915       resetLastChars();
2916       if (textContentItem.initialized) {
2917         textContentItem.hasEOL = true;
2918         flushTextContentItem();
2919       } else {
2920         textContent.items.push({
2921           str: "",
2922           dir: "ltr",
2923           width: 0,
2924           height: 0,
2925           transform: getCurrentTextTransform(),
2926           fontName: textState.loadedName,
2927           hasEOL: true,
2928         });
2929       }
2930     }
2931 
2932     function addFakeSpaces(width, transf, textOrientation) {
2933       if (
2934         textOrientation * textContentItem.spaceInFlowMin <= width &&
2935         width <= textOrientation * textContentItem.spaceInFlowMax
2936       ) {
2937         if (textContentItem.initialized) {
2938           resetLastChars();
2939           textContentItem.str.push(" ");
2940         }
2941         return false;
2942       }
2943 
2944       const fontName = textContentItem.fontName;
2945 
2946       let height = 0;
2947       if (textContentItem.vertical) {
2948         height = width;
2949         width = 0;
2950       }
2951 
2952       flushTextContentItem();
2953       resetLastChars();
2954       pushWhitespace({
2955         width: Math.abs(width),
2956         height: Math.abs(height),
2957         transform: transf || getCurrentTextTransform(),
2958         fontName,
2959       });
2960 
2961       return true;
2962     }
2963 
2964     function flushTextContentItem() {
2965       if (!textContentItem.initialized || !textContentItem.str) {
2966         return;
2967       }
2968 
2969       // Do final text scaling.
2970       if (!textContentItem.vertical) {
2971         textContentItem.totalWidth +=
2972           textContentItem.width * textContentItem.textAdvanceScale;
2973       } else {
2974         textContentItem.totalHeight +=
2975           textContentItem.height * textContentItem.textAdvanceScale;
2976       }
2977 
2978       textContent.items.push(runBidiTransform(textContentItem));
2979       textContentItem.initialized = false;
2980       textContentItem.str.length = 0;
2981     }
2982 
2983     function enqueueChunk(batch = false) {
2984       const length = textContent.items.length;
2985       if (length === 0) {
2986         return;
2987       }
2988       if (batch && length < TEXT_CHUNK_BATCH_SIZE) {
2989         return;
2990       }
2991       sink.enqueue(textContent, length);
2992       textContent.items = [];
2993       textContent.styles = Object.create(null);
2994     }
2995 
2996     const timeSlotManager = new TimeSlotManager();
2997 
2998     return new Promise(function promiseBody(resolve, reject) {
2999       const next = function (promise) {
3000         enqueueChunk(/* batch = */ true);
3001         Promise.all([promise, sink.ready]).then(function () {
3002           try {
3003             promiseBody(resolve, reject);
3004           } catch (ex) {
3005             reject(ex);
3006           }
3007         }, reject);
3008       };
3009       task.ensureNotTerminated();
3010       timeSlotManager.reset();
3011 
3012       const operation = {};
3013       let stop,
3014         args = [];
3015       while (!(stop = timeSlotManager.check())) {
3016         // The arguments parsed by read() are not used beyond this loop, so
3017         // we can reuse the same array on every iteration, thus avoiding
3018         // unnecessary allocations.
3019         args.length = 0;
3020         operation.args = args;
3021         if (!preprocessor.read(operation)) {
3022           break;
3023         }
3024 
3025         const previousState = textState;
3026         textState = stateManager.state;
3027         const fn = operation.fn;
3028         args = operation.args;
3029 
3030         switch (fn | 0) {
3031           case OPS.setFont:
3032             // Optimization to ignore multiple identical Tf commands.
3033             var fontNameArg = args[0].name,
3034               fontSizeArg = args[1];
3035             if (
3036               textState.font &&
3037               fontNameArg === textState.fontName &&
3038               fontSizeArg === textState.fontSize
3039             ) {
3040               break;
3041             }
3042 
3043             flushTextContentItem();
3044             textState.fontName = fontNameArg;
3045             textState.fontSize = fontSizeArg;
3046             next(handleSetFont(fontNameArg, null));
3047             return;
3048           case OPS.setTextRise:
3049             textState.textRise = args[0];
3050             break;
3051           case OPS.setHScale:
3052             textState.textHScale = args[0] / 100;
3053             break;
3054           case OPS.setLeading:
3055             textState.leading = args[0];
3056             break;
3057           case OPS.moveText:
3058             textState.translateTextLineMatrix(args[0], args[1]);
3059             textState.textMatrix = textState.textLineMatrix.slice();
3060             break;
3061           case OPS.setLeadingMoveText:
3062             textState.leading = -args[1];
3063             textState.translateTextLineMatrix(args[0], args[1]);
3064             textState.textMatrix = textState.textLineMatrix.slice();
3065             break;
3066           case OPS.nextLine:
3067             textState.carriageReturn();
3068             break;
3069           case OPS.setTextMatrix:
3070             textState.setTextMatrix(
3071               args[0],
3072               args[1],
3073               args[2],
3074               args[3],
3075               args[4],
3076               args[5]
3077             );
3078             textState.setTextLineMatrix(
3079               args[0],
3080               args[1],
3081               args[2],
3082               args[3],
3083               args[4],
3084               args[5]
3085             );
3086             updateAdvanceScale();
3087             break;
3088           case OPS.setCharSpacing:
3089             textState.charSpacing = args[0];
3090             break;
3091           case OPS.setWordSpacing:
3092             textState.wordSpacing = args[0];
3093             break;
3094           case OPS.beginText:
3095             textState.textMatrix = IDENTITY_MATRIX.slice();
3096             textState.textLineMatrix = IDENTITY_MATRIX.slice();
3097             break;
3098           case OPS.showSpacedText:
3099             if (!stateManager.state.font) {
3100               self.ensureStateFont(stateManager.state);
3101               continue;
3102             }
3103 
3104             const spaceFactor =
3105               ((textState.font.vertical ? 1 : -1) * textState.fontSize) / 1000;
3106             const elements = args[0];
3107             for (let i = 0, ii = elements.length; i < ii; i++) {
3108               const item = elements[i];
3109               if (typeof item === "string") {
3110                 showSpacedTextBuffer.push(item);
3111               } else if (typeof item === "number" && item !== 0) {
3112                 // PDF Specification 5.3.2 states:
3113                 // The number is expressed in thousandths of a unit of text
3114                 // space.
3115                 // This amount is subtracted from the current horizontal or
3116                 // vertical coordinate, depending on the writing mode.
3117                 // In the default coordinate system, a positive adjustment
3118                 // has the effect of moving the next glyph painted either to
3119                 // the left or down by the given amount.
3120                 const str = showSpacedTextBuffer.join("");
3121                 showSpacedTextBuffer.length = 0;
3122                 buildTextContentItem({
3123                   chars: str,
3124                   extraSpacing: item * spaceFactor,
3125                 });
3126               }
3127             }
3128 
3129             if (showSpacedTextBuffer.length > 0) {
3130               const str = showSpacedTextBuffer.join("");
3131               showSpacedTextBuffer.length = 0;
3132               buildTextContentItem({
3133                 chars: str,
3134                 extraSpacing: 0,
3135               });
3136             }
3137             break;
3138           case OPS.showText:
3139             if (!stateManager.state.font) {
3140               self.ensureStateFont(stateManager.state);
3141               continue;
3142             }
3143             buildTextContentItem({
3144               chars: args[0],
3145               extraSpacing: 0,
3146             });
3147             break;
3148           case OPS.nextLineShowText:
3149             if (!stateManager.state.font) {
3150               self.ensureStateFont(stateManager.state);
3151               continue;
3152             }
3153             textState.carriageReturn();
3154             buildTextContentItem({
3155               chars: args[0],
3156               extraSpacing: 0,
3157             });
3158             break;
3159           case OPS.nextLineSetSpacingShowText:
3160             if (!stateManager.state.font) {
3161               self.ensureStateFont(stateManager.state);
3162               continue;
3163             }
3164             textState.wordSpacing = args[0];
3165             textState.charSpacing = args[1];
3166             textState.carriageReturn();
3167             buildTextContentItem({
3168               chars: args[2],
3169               extraSpacing: 0,
3170             });
3171             break;
3172           case OPS.paintXObject:
3173             flushTextContentItem();
3174             if (!xobjs) {
3175               xobjs = resources.get("XObject") || Dict.empty;
3176             }
3177 
3178             var isValidName = args[0] instanceof Name;
3179             var name = args[0].name;
3180 
3181             if (isValidName && emptyXObjectCache.getByName(name)) {
3182               break;
3183             }
3184 
3185             next(
3186               new Promise(function (resolveXObject, rejectXObject) {
3187                 if (!isValidName) {
3188                   throw new FormatError("XObject must be referred to by name.");
3189                 }
3190 
3191                 let xobj = xobjs.getRaw(name);
3192                 if (xobj instanceof Ref) {
3193                   if (emptyXObjectCache.getByRef(xobj)) {
3194                     resolveXObject();
3195                     return;
3196                   }
3197 
3198                   const globalImage = self.globalImageCache.getData(
3199                     xobj,
3200                     self.pageIndex
3201                   );
3202                   if (globalImage) {
3203                     resolveXObject();
3204                     return;
3205                   }
3206 
3207                   xobj = xref.fetch(xobj);
3208                 }
3209 
3210                 if (!(xobj instanceof BaseStream)) {
3211                   throw new FormatError("XObject should be a stream");
3212                 }
3213 
3214                 const type = xobj.dict.get("Subtype");
3215                 if (!(type instanceof Name)) {
3216                   throw new FormatError("XObject should have a Name subtype");
3217                 }
3218 
3219                 if (type.name !== "Form") {
3220                   emptyXObjectCache.set(name, xobj.dict.objId, true);
3221 
3222                   resolveXObject();
3223                   return;
3224                 }
3225 
3226                 // Use a new `StateManager` to prevent incorrect positioning
3227                 // of textItems *after* the Form XObject, since errors in the
3228                 // data can otherwise prevent `restore` operators from
3229                 // executing.
3230                 // NOTE: Only an issue when `options.ignoreErrors === true`.
3231                 const currentState = stateManager.state.clone();
3232                 const xObjStateManager = new StateManager(currentState);
3233 
3234                 const matrix = xobj.dict.getArray("Matrix");
3235                 if (Array.isArray(matrix) && matrix.length === 6) {
3236                   xObjStateManager.transform(matrix);
3237                 }
3238 
3239                 // Enqueue the `textContent` chunk before parsing the /Form
3240                 // XObject.
3241                 enqueueChunk();
3242                 const sinkWrapper = {
3243                   enqueueInvoked: false,
3244 
3245                   enqueue(chunk, size) {
3246                     this.enqueueInvoked = true;
3247                     sink.enqueue(chunk, size);
3248                   },
3249 
3250                   get desiredSize() {
3251                     return sink.desiredSize;
3252                   },
3253 
3254                   get ready() {
3255                     return sink.ready;
3256                   },
3257                 };
3258 
3259                 self
3260                   .getTextContent({
3261                     stream: xobj,
3262                     task,
3263                     resources: xobj.dict.get("Resources") || resources,
3264                     stateManager: xObjStateManager,
3265                     includeMarkedContent,
3266                     sink: sinkWrapper,
3267                     seenStyles,
3268                     viewBox,
3269                     markedContentData,
3270                     disableNormalization,
3271                     keepWhiteSpace,
3272                   })
3273                   .then(function () {
3274                     if (!sinkWrapper.enqueueInvoked) {
3275                       emptyXObjectCache.set(name, xobj.dict.objId, true);
3276                     }
3277                     resolveXObject();
3278                   }, rejectXObject);
3279               }).catch(function (reason) {
3280                 if (reason instanceof AbortException) {
3281                   return;
3282                 }
3283                 if (self.options.ignoreErrors) {
3284                   // Error(s) in the XObject -- allow text-extraction to
3285                   // continue.
3286                   warn(`getTextContent - ignoring XObject: "${reason}".`);
3287                   return;
3288                 }
3289                 throw reason;
3290               })
3291             );
3292             return;
3293           case OPS.setGState:
3294             isValidName = args[0] instanceof Name;
3295             name = args[0].name;
3296 
3297             if (isValidName && emptyGStateCache.getByName(name)) {
3298               break;
3299             }
3300 
3301             next(
3302               new Promise(function (resolveGState, rejectGState) {
3303                 if (!isValidName) {
3304                   throw new FormatError("GState must be referred to by name.");
3305                 }
3306 
3307                 const extGState = resources.get("ExtGState");
3308                 if (!(extGState instanceof Dict)) {
3309                   throw new FormatError("ExtGState should be a dictionary.");
3310                 }
3311 
3312                 const gState = extGState.get(name);
3313                 // TODO: Attempt to lookup cached GStates by reference as well,
3314                 //       if and only if there are PDF documents where doing so
3315                 //       would significantly improve performance.
3316                 if (!(gState instanceof Dict)) {
3317                   throw new FormatError("GState should be a dictionary.");
3318                 }
3319 
3320                 const gStateFont = gState.get("Font");
3321                 if (!gStateFont) {
3322                   emptyGStateCache.set(name, gState.objId, true);
3323 
3324                   resolveGState();
3325                   return;
3326                 }
3327                 flushTextContentItem();
3328 
3329                 textState.fontName = null;
3330                 textState.fontSize = gStateFont[1];
3331                 handleSetFont(null, gStateFont[0]).then(
3332                   resolveGState,
3333                   rejectGState
3334                 );
3335               }).catch(function (reason) {
3336                 if (reason instanceof AbortException) {
3337                   return;
3338                 }
3339                 if (self.options.ignoreErrors) {
3340                   // Error(s) in the ExtGState -- allow text-extraction to
3341                   // continue.
3342                   warn(`getTextContent - ignoring ExtGState: "${reason}".`);
3343                   return;
3344                 }
3345                 throw reason;
3346               })
3347             );
3348             return;
3349           case OPS.beginMarkedContent:
3350             flushTextContentItem();
3351             if (includeMarkedContent) {
3352               markedContentData.level++;
3353 
3354               textContent.items.push({
3355                 type: "beginMarkedContent",
3356                 tag: args[0] instanceof Name ? args[0].name : null,
3357               });
3358             }
3359             break;
3360           case OPS.beginMarkedContentProps:
3361             flushTextContentItem();
3362             if (includeMarkedContent) {
3363               markedContentData.level++;
3364 
3365               let mcid = null;
3366               if (args[1] instanceof Dict) {
3367                 mcid = args[1].get("MCID");
3368               }
3369               textContent.items.push({
3370                 type: "beginMarkedContentProps",
3371                 id: Number.isInteger(mcid)
3372                   ? `${self.idFactory.getPageObjId()}_mc${mcid}`
3373                   : null,
3374                 tag: args[0] instanceof Name ? args[0].name : null,
3375               });
3376             }
3377             break;
3378           case OPS.endMarkedContent:
3379             flushTextContentItem();
3380             if (includeMarkedContent) {
3381               if (markedContentData.level === 0) {
3382                 // Handle unbalanced beginMarkedContent/endMarkedContent
3383                 // operators (fixes issue15629.pdf).
3384                 break;
3385               }
3386               markedContentData.level--;
3387 
3388               textContent.items.push({
3389                 type: "endMarkedContent",
3390               });
3391             }
3392             break;
3393           case OPS.restore:
3394             if (
3395               previousState &&
3396               (previousState.font !== textState.font ||
3397                 previousState.fontSize !== textState.fontSize ||
3398                 previousState.fontName !== textState.fontName)
3399             ) {
3400               flushTextContentItem();
3401             }
3402             break;
3403         } // switch
3404         if (textContent.items.length >= sink.desiredSize) {
3405           // Wait for ready, if we reach highWaterMark.
3406           stop = true;
3407           break;
3408         }
3409       } // while
3410       if (stop) {
3411         next(deferred);
3412         return;
3413       }
3414       flushTextContentItem();
3415       enqueueChunk();
3416       resolve();
3417     }).catch(reason => {
3418       if (reason instanceof AbortException) {
3419         return;
3420       }
3421       if (this.options.ignoreErrors) {
3422         // Error(s) in the TextContent -- allow text-extraction to continue.
3423         warn(
3424           `getTextContent - ignoring errors during "${task.name}" ` +
3425             `task: "${reason}".`
3426         );
3427 
3428         flushTextContentItem();
3429         enqueueChunk();
3430         return;
3431       }
3432       throw reason;
3433     });
3434   }
3435 
3436   async extractDataStructures(dict, properties) {
3437     const xref = this.xref;
3438     let cidToGidBytes;
3439     // 9.10.2
3440     const toUnicodePromise = this.readToUnicode(properties.toUnicode);
3441 
3442     if (properties.composite) {
3443       // CIDSystemInfo helps to match CID to glyphs
3444       const cidSystemInfo = dict.get("CIDSystemInfo");
3445       if (cidSystemInfo instanceof Dict) {
3446         properties.cidSystemInfo = {
3447           registry: stringToPDFString(cidSystemInfo.get("Registry")),
3448           ordering: stringToPDFString(cidSystemInfo.get("Ordering")),
3449           supplement: cidSystemInfo.get("Supplement"),
3450         };
3451       }
3452 
3453       try {
3454         const cidToGidMap = dict.get("CIDToGIDMap");
3455         if (cidToGidMap instanceof BaseStream) {
3456           cidToGidBytes = cidToGidMap.getBytes();
3457         }
3458       } catch (ex) {
3459         if (!this.options.ignoreErrors) {
3460           throw ex;
3461         }
3462         warn(`extractDataStructures - ignoring CIDToGIDMap data: "${ex}".`);
3463       }
3464     }
3465 
3466     // Based on 9.6.6 of the spec the encoding can come from multiple places
3467     // and depends on the font type. The base encoding and differences are
3468     // read here, but the encoding that is actually used is chosen during
3469     // glyph mapping in the font.
3470     // TODO: Loading the built in encoding in the font would allow the
3471     // differences to be merged in here not require us to hold on to it.
3472     const differences = [];
3473     let baseEncodingName = null;
3474     let encoding;
3475     if (dict.has("Encoding")) {
3476       encoding = dict.get("Encoding");
3477       if (encoding instanceof Dict) {
3478         baseEncodingName = encoding.get("BaseEncoding");
3479         baseEncodingName =
3480           baseEncodingName instanceof Name ? baseEncodingName.name : null;
3481         // Load the differences between the base and original
3482         if (encoding.has("Differences")) {
3483           const diffEncoding = encoding.get("Differences");
3484           let index = 0;
3485           for (const entry of diffEncoding) {
3486             const data = xref.fetchIfRef(entry);
3487             if (typeof data === "number") {
3488               index = data;
3489             } else if (data instanceof Name) {
3490               differences[index++] = data.name;
3491             } else {
3492               throw new FormatError(
3493                 `Invalid entry in 'Differences' array: ${data}`
3494               );
3495             }
3496           }
3497         }
3498       } else if (encoding instanceof Name) {
3499         baseEncodingName = encoding.name;
3500       } else {
3501         const msg = "Encoding is not a Name nor a Dict";
3502 
3503         if (!this.options.ignoreErrors) {
3504           throw new FormatError(msg);
3505         }
3506         warn(msg);
3507       }
3508       // According to table 114 if the encoding is a named encoding it must be
3509       // one of these predefined encodings.
3510       if (
3511         baseEncodingName !== "MacRomanEncoding" &&
3512         baseEncodingName !== "MacExpertEncoding" &&
3513         baseEncodingName !== "WinAnsiEncoding"
3514       ) {
3515         baseEncodingName = null;
3516       }
3517     }
3518 
3519     const nonEmbeddedFont = !properties.file || properties.isInternalFont,
3520       isSymbolsFontName = getSymbolsFonts()[properties.name];
3521     // Ignore an incorrectly specified named encoding for non-embedded
3522     // symbol fonts (fixes issue16464.pdf).
3523     if (baseEncodingName && nonEmbeddedFont && isSymbolsFontName) {
3524       baseEncodingName = null;
3525     }
3526 
3527     if (baseEncodingName) {
3528       properties.defaultEncoding = getEncoding(baseEncodingName);
3529     } else {
3530       const isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
3531       const isNonsymbolicFont = !!(properties.flags & FontFlags.Nonsymbolic);
3532       // According to "Table 114" in section "9.6.6.1 General" (under
3533       // "9.6.6 Character Encoding") of the PDF specification, a Nonsymbolic
3534       // font should use the `StandardEncoding` if no encoding is specified.
3535       encoding = StandardEncoding;
3536       if (properties.type === "TrueType" && !isNonsymbolicFont) {
3537         encoding = WinAnsiEncoding;
3538       }
3539       // The Symbolic attribute can be misused for regular fonts
3540       // Heuristic: we have to check if the font is a standard one also
3541       if (isSymbolicFont || isSymbolsFontName) {
3542         encoding = MacRomanEncoding;
3543         if (nonEmbeddedFont) {
3544           if (/Symbol/i.test(properties.name)) {
3545             encoding = SymbolSetEncoding;
3546           } else if (/Dingbats/i.test(properties.name)) {
3547             encoding = ZapfDingbatsEncoding;
3548           } else if (/Wingdings/i.test(properties.name)) {
3549             encoding = WinAnsiEncoding;
3550           }
3551         }
3552       }
3553       properties.defaultEncoding = encoding;
3554     }
3555 
3556     properties.differences = differences;
3557     properties.baseEncodingName = baseEncodingName;
3558     properties.hasEncoding = !!baseEncodingName || differences.length > 0;
3559     properties.dict = dict;
3560 
3561     properties.toUnicode = await toUnicodePromise;
3562 
3563     const builtToUnicode = await this.buildToUnicode(properties);
3564     properties.toUnicode = builtToUnicode;
3565 
3566     if (cidToGidBytes) {
3567       properties.cidToGidMap = this.readCidToGidMap(
3568         cidToGidBytes,
3569         builtToUnicode
3570       );
3571     }
3572     return properties;
3573   }
3574 
3575   /**
3576    * @returns {Array}
3577    * @private
3578    */
3579   _simpleFontToUnicode(properties, forceGlyphs = false) {
3580     assert(!properties.composite, "Must be a simple font.");
3581 
3582     const toUnicode = [];
3583     const encoding = properties.defaultEncoding.slice();
3584     const baseEncodingName = properties.baseEncodingName;
3585     // Merge in the differences array.
3586     const differences = properties.differences;
3587     for (const charcode in differences) {
3588       const glyphName = differences[charcode];
3589       if (glyphName === ".notdef") {
3590         // Skip .notdef to prevent rendering errors, e.g. boxes appearing
3591         // where there should be spaces (fixes issue5256.pdf).
3592         continue;
3593       }
3594       encoding[charcode] = glyphName;
3595     }
3596     const glyphsUnicodeMap = getGlyphsUnicode();
3597     for (const charcode in encoding) {
3598       // a) Map the character code to a character name.
3599       let glyphName = encoding[charcode];
3600       if (glyphName === "") {
3601         continue;
3602       }
3603       // b) Look up the character name in the Adobe Glyph List (see the
3604       //    Bibliography) to obtain the corresponding Unicode value.
3605       let unicode = glyphsUnicodeMap[glyphName];
3606       if (unicode !== undefined) {
3607         toUnicode[charcode] = String.fromCharCode(unicode);
3608         continue;
3609       }
3610       // (undocumented) c) Few heuristics to recognize unknown glyphs
3611       // NOTE: Adobe Reader does not do this step, but OSX Preview does
3612       let code = 0;
3613       switch (glyphName[0]) {
3614         case "G": // Gxx glyph
3615           if (glyphName.length === 3) {
3616             code = parseInt(glyphName.substring(1), 16);
3617           }
3618           break;
3619         case "g": // g00xx glyph
3620           if (glyphName.length === 5) {
3621             code = parseInt(glyphName.substring(1), 16);
3622           }
3623           break;
3624         case "C": // Cdd{d} glyph
3625         case "c": // cdd{d} glyph
3626           if (glyphName.length >= 3 && glyphName.length <= 4) {
3627             const codeStr = glyphName.substring(1);
3628 
3629             if (forceGlyphs) {
3630               code = parseInt(codeStr, 16);
3631               break;
3632             }
3633             // Normally the Cdd{d}/cdd{d} glyphName format will contain
3634             // regular, i.e. base 10, charCodes (see issue4550.pdf)...
3635             code = +codeStr;
3636 
3637             // ... however some PDF generators violate that assumption by
3638             // containing glyph, i.e. base 16, codes instead.
3639             // In that case we need to re-parse the *entire* encoding to
3640             // prevent broken text-selection (fixes issue9655_reduced.pdf).
3641             if (Number.isNaN(code) && Number.isInteger(parseInt(codeStr, 16))) {
3642               return this._simpleFontToUnicode(
3643                 properties,
3644                 /* forceGlyphs */ true
3645               );
3646             }
3647           }
3648           break;
3649         case "u": // 'uniXXXX'/'uXXXX{XX}' glyphs
3650           unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
3651           if (unicode !== -1) {
3652             code = unicode;
3653           }
3654           break;
3655         default:
3656           // Support (some) non-standard ligatures.
3657           switch (glyphName) {
3658             case "f_h":
3659             case "f_t":
3660             case "T_h":
3661               toUnicode[charcode] = glyphName.replaceAll("_", "");
3662               continue;
3663           }
3664           break;
3665       }
3666       if (code > 0 && code <= 0x10ffff && Number.isInteger(code)) {
3667         // If `baseEncodingName` is one the predefined encodings, and `code`
3668         // equals `charcode`, using the glyph defined in the baseEncoding
3669         // seems to yield a better `toUnicode` mapping (fixes issue 5070).
3670         if (baseEncodingName && code === +charcode) {
3671           const baseEncoding = getEncoding(baseEncodingName);
3672           if (baseEncoding && (glyphName = baseEncoding[charcode])) {
3673             toUnicode[charcode] = String.fromCharCode(
3674               glyphsUnicodeMap[glyphName]
3675             );
3676             continue;
3677           }
3678         }
3679         toUnicode[charcode] = String.fromCodePoint(code);
3680       }
3681     }
3682     return toUnicode;
3683   }
3684 
3685   /**
3686    * Builds a char code to unicode map based on section 9.10 of the spec.
3687    * @param {Object} properties Font properties object.
3688    * @returns {Promise} A Promise that is resolved with a
3689    *   {ToUnicodeMap|IdentityToUnicodeMap} object.
3690    */
3691   async buildToUnicode(properties) {
3692     properties.hasIncludedToUnicodeMap = properties.toUnicode?.length > 0;
3693 
3694     // Section 9.10.2 Mapping Character Codes to Unicode Values
3695     if (properties.hasIncludedToUnicodeMap) {
3696       // Some fonts contain incomplete ToUnicode data, causing issues with
3697       // text-extraction. For simple fonts, containing encoding information,
3698       // use a fallback ToUnicode map to improve this (fixes issue8229.pdf).
3699       if (!properties.composite && properties.hasEncoding) {
3700         properties.fallbackToUnicode = this._simpleFontToUnicode(properties);
3701       }
3702       return properties.toUnicode;
3703     }
3704 
3705     // According to the spec if the font is a simple font we should only map
3706     // to unicode if the base encoding is MacRoman, MacExpert, or WinAnsi or
3707     // the differences array only contains adobe standard or symbol set names,
3708     // in pratice it seems better to always try to create a toUnicode map
3709     // based of the default encoding.
3710     if (!properties.composite /* is simple font */) {
3711       return new ToUnicodeMap(this._simpleFontToUnicode(properties));
3712     }
3713 
3714     // If the font is a composite font that uses one of the predefined CMaps
3715     // listed in Table 118 (except Identity–H and Identity–V) or whose
3716     // descendant CIDFont uses the Adobe-GB1, Adobe-CNS1, Adobe-Japan1, or
3717     // Adobe-Korea1 character collection:
3718     if (
3719       properties.composite &&
3720       ((properties.cMap.builtInCMap &&
3721         !(properties.cMap instanceof IdentityCMap)) ||
3722         // The font is supposed to have a CIDSystemInfo dictionary, but some
3723         // PDFs don't include it (fixes issue 17689), hence the `?'.
3724         (properties.cidSystemInfo?.registry === "Adobe" &&
3725           (properties.cidSystemInfo.ordering === "GB1" ||
3726             properties.cidSystemInfo.ordering === "CNS1" ||
3727             properties.cidSystemInfo.ordering === "Japan1" ||
3728             properties.cidSystemInfo.ordering === "Korea1")))
3729     ) {
3730       // Then:
3731       // a) Map the character code to a character identifier (CID) according
3732       // to the font’s CMap.
3733       // b) Obtain the registry and ordering of the character collection used
3734       // by the font’s CMap (for example, Adobe and Japan1) from its
3735       // CIDSystemInfo dictionary.
3736       const { registry, ordering } = properties.cidSystemInfo;
3737       // c) Construct a second CMap name by concatenating the registry and
3738       // ordering obtained in step (b) in the format registry–ordering–UCS2
3739       // (for example, Adobe–Japan1–UCS2).
3740       const ucs2CMapName = Name.get(`${registry}-${ordering}-UCS2`);
3741       // d) Obtain the CMap with the name constructed in step (c) (available
3742       // from the ASN Web site; see the Bibliography).
3743       const ucs2CMap = await CMapFactory.create({
3744         encoding: ucs2CMapName,
3745         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3746         useCMap: null,
3747       });
3748       const toUnicode = [],
3749         buf = [];
3750       properties.cMap.forEach(function (charcode, cid) {
3751         if (cid > 0xffff) {
3752           throw new FormatError("Max size of CID is 65,535");
3753         }
3754         // e) Map the CID obtained in step (a) according to the CMap
3755         // obtained in step (d), producing a Unicode value.
3756         const ucs2 = ucs2CMap.lookup(cid);
3757         if (ucs2) {
3758           buf.length = 0;
3759           // Support multi-byte entries (fixes issue16176.pdf).
3760           for (let i = 0, ii = ucs2.length; i < ii; i += 2) {
3761             buf.push((ucs2.charCodeAt(i) << 8) + ucs2.charCodeAt(i + 1));
3762           }
3763           toUnicode[charcode] = String.fromCharCode(...buf);
3764         }
3765       });
3766       return new ToUnicodeMap(toUnicode);
3767     }
3768 
3769     // The viewer's choice, just use an identity map.
3770     return new IdentityToUnicodeMap(properties.firstChar, properties.lastChar);
3771   }
3772 
3773   async readToUnicode(cmapObj) {
3774     if (!cmapObj) {
3775       return null;
3776     }
3777     if (cmapObj instanceof Name) {
3778       const cmap = await CMapFactory.create({
3779         encoding: cmapObj,
3780         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3781         useCMap: null,
3782       });
3783 
3784       if (cmap instanceof IdentityCMap) {
3785         return new IdentityToUnicodeMap(0, 0xffff);
3786       }
3787       return new ToUnicodeMap(cmap.getMap());
3788     }
3789     if (cmapObj instanceof BaseStream) {
3790       try {
3791         const cmap = await CMapFactory.create({
3792           encoding: cmapObj,
3793           fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3794           useCMap: null,
3795         });
3796 
3797         if (cmap instanceof IdentityCMap) {
3798           return new IdentityToUnicodeMap(0, 0xffff);
3799         }
3800         const map = new Array(cmap.length);
3801         // Convert UTF-16BE
3802         // NOTE: cmap can be a sparse array, so use forEach instead of
3803         // `for(;;)` to iterate over all keys.
3804         cmap.forEach(function (charCode, token) {
3805           // Some cmaps contain *only* CID characters (fixes issue9367.pdf).
3806           if (typeof token === "number") {
3807             map[charCode] = String.fromCodePoint(token);
3808             return;
3809           }
3810           const str = [];
3811           for (let k = 0; k < token.length; k += 2) {
3812             const w1 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
3813             if ((w1 & 0xf800) !== 0xd800) {
3814               // w1 < 0xD800 || w1 > 0xDFFF
3815               str.push(w1);
3816               continue;
3817             }
3818             k += 2;
3819             const w2 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
3820             str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);
3821           }
3822           map[charCode] = String.fromCodePoint(...str);
3823         });
3824         return new ToUnicodeMap(map);
3825       } catch (reason) {
3826         if (reason instanceof AbortException) {
3827           return null;
3828         }
3829         if (this.options.ignoreErrors) {
3830           warn(`readToUnicode - ignoring ToUnicode data: "${reason}".`);
3831           return null;
3832         }
3833         throw reason;
3834       }
3835     }
3836     return null;
3837   }
3838 
3839   readCidToGidMap(glyphsData, toUnicode) {
3840     // Extract the encoding from the CIDToGIDMap
3841 
3842     // Set encoding 0 to later verify the font has an encoding
3843     const result = [];
3844     for (let j = 0, jj = glyphsData.length; j < jj; j++) {
3845       const glyphID = (glyphsData[j++] << 8) | glyphsData[j];
3846       const code = j >> 1;
3847       if (glyphID === 0 && !toUnicode.has(code)) {
3848         continue;
3849       }
3850       result[code] = glyphID;
3851     }
3852     return result;
3853   }
3854 
3855   extractWidths(dict, descriptor, properties) {
3856     const xref = this.xref;
3857     let glyphsWidths = [];
3858     let defaultWidth = 0;
3859     const glyphsVMetrics = [];
3860     let defaultVMetrics;
3861     let i, ii, j, jj, start, code, widths;
3862     if (properties.composite) {
3863       defaultWidth = dict.has("DW") ? dict.get("DW") : 1000;
3864 
3865       widths = dict.get("W");
3866       if (widths) {
3867         for (i = 0, ii = widths.length; i < ii; i++) {
3868           start = xref.fetchIfRef(widths[i++]);
3869           code = xref.fetchIfRef(widths[i]);
3870           if (Array.isArray(code)) {
3871             for (j = 0, jj = code.length; j < jj; j++) {
3872               glyphsWidths[start++] = xref.fetchIfRef(code[j]);
3873             }
3874           } else {
3875             const width = xref.fetchIfRef(widths[++i]);
3876             for (j = start; j <= code; j++) {
3877               glyphsWidths[j] = width;
3878             }
3879           }
3880         }
3881       }
3882 
3883       if (properties.vertical) {
3884         let vmetrics = dict.getArray("DW2") || [880, -1000];
3885         defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
3886         vmetrics = dict.get("W2");
3887         if (vmetrics) {
3888           for (i = 0, ii = vmetrics.length; i < ii; i++) {
3889             start = xref.fetchIfRef(vmetrics[i++]);
3890             code = xref.fetchIfRef(vmetrics[i]);
3891             if (Array.isArray(code)) {
3892               for (j = 0, jj = code.length; j < jj; j++) {
3893                 glyphsVMetrics[start++] = [
3894                   xref.fetchIfRef(code[j++]),
3895                   xref.fetchIfRef(code[j++]),
3896                   xref.fetchIfRef(code[j]),
3897                 ];
3898               }
3899             } else {
3900               const vmetric = [
3901                 xref.fetchIfRef(vmetrics[++i]),
3902                 xref.fetchIfRef(vmetrics[++i]),
3903                 xref.fetchIfRef(vmetrics[++i]),
3904               ];
3905               for (j = start; j <= code; j++) {
3906                 glyphsVMetrics[j] = vmetric;
3907               }
3908             }
3909           }
3910         }
3911       }
3912     } else {
3913       const firstChar = properties.firstChar;
3914       widths = dict.get("Widths");
3915       if (widths) {
3916         j = firstChar;
3917         for (i = 0, ii = widths.length; i < ii; i++) {
3918           glyphsWidths[j++] = xref.fetchIfRef(widths[i]);
3919         }
3920         defaultWidth = parseFloat(descriptor.get("MissingWidth")) || 0;
3921       } else {
3922         // Trying get the BaseFont metrics (see comment above).
3923         const baseFontName = dict.get("BaseFont");
3924         if (baseFontName instanceof Name) {
3925           const metrics = this.getBaseFontMetrics(baseFontName.name);
3926 
3927           glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
3928           defaultWidth = metrics.defaultWidth;
3929         }
3930       }
3931     }
3932 
3933     // Heuristic: detection of monospace font by checking all non-zero widths
3934     let isMonospace = true;
3935     let firstWidth = defaultWidth;
3936     for (const glyph in glyphsWidths) {
3937       const glyphWidth = glyphsWidths[glyph];
3938       if (!glyphWidth) {
3939         continue;
3940       }
3941       if (!firstWidth) {
3942         firstWidth = glyphWidth;
3943         continue;
3944       }
3945       if (firstWidth !== glyphWidth) {
3946         isMonospace = false;
3947         break;
3948       }
3949     }
3950     if (isMonospace) {
3951       properties.flags |= FontFlags.FixedPitch;
3952     } else {
3953       // Clear the flag.
3954       properties.flags &= ~FontFlags.FixedPitch;
3955     }
3956 
3957     properties.defaultWidth = defaultWidth;
3958     properties.widths = glyphsWidths;
3959     properties.defaultVMetrics = defaultVMetrics;
3960     properties.vmetrics = glyphsVMetrics;
3961   }
3962 
3963   isSerifFont(baseFontName) {
3964     // Simulating descriptor flags attribute
3965     const fontNameWoStyle = baseFontName.split("-", 1)[0];
3966     return (
3967       fontNameWoStyle in getSerifFonts() || /serif/gi.test(fontNameWoStyle)
3968     );
3969   }
3970 
3971   getBaseFontMetrics(name) {
3972     let defaultWidth = 0;
3973     let widths = Object.create(null);
3974     let monospace = false;
3975     const stdFontMap = getStdFontMap();
3976     let lookupName = stdFontMap[name] || name;
3977     const Metrics = getMetrics();
3978 
3979     if (!(lookupName in Metrics)) {
3980       // Use default fonts for looking up font metrics if the passed
3981       // font is not a base font
3982       lookupName = this.isSerifFont(name) ? "Times-Roman" : "Helvetica";
3983     }
3984     const glyphWidths = Metrics[lookupName];
3985 
3986     if (typeof glyphWidths === "number") {
3987       defaultWidth = glyphWidths;
3988       monospace = true;
3989     } else {
3990       widths = glyphWidths(); // expand lazy widths array
3991     }
3992 
3993     return {
3994       defaultWidth,
3995       monospace,
3996       widths,
3997     };
3998   }
3999 
4000   buildCharCodeToWidth(widthsByGlyphName, properties) {
4001     const widths = Object.create(null);
4002     const differences = properties.differences;
4003     const encoding = properties.defaultEncoding;
4004     for (let charCode = 0; charCode < 256; charCode++) {
4005       if (charCode in differences && widthsByGlyphName[differences[charCode]]) {
4006         widths[charCode] = widthsByGlyphName[differences[charCode]];
4007         continue;
4008       }
4009       if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
4010         widths[charCode] = widthsByGlyphName[encoding[charCode]];
4011         continue;
4012       }
4013     }
4014     return widths;
4015   }
4016 
4017   preEvaluateFont(dict) {
4018     const baseDict = dict;
4019     let type = dict.get("Subtype");
4020     if (!(type instanceof Name)) {
4021       throw new FormatError("invalid font Subtype");
4022     }
4023 
4024     let composite = false;
4025     let hash;
4026     if (type.name === "Type0") {
4027       // If font is a composite
4028       //  - get the descendant font
4029       //  - set the type according to the descendant font
4030       //  - get the FontDescriptor from the descendant font
4031       const df = dict.get("DescendantFonts");
4032       if (!df) {
4033         throw new FormatError("Descendant fonts are not specified");
4034       }
4035       dict = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df;
4036 
4037       if (!(dict instanceof Dict)) {
4038         throw new FormatError("Descendant font is not a dictionary.");
4039       }
4040       type = dict.get("Subtype");
4041       if (!(type instanceof Name)) {
4042         throw new FormatError("invalid font Subtype");
4043       }
4044       composite = true;
4045     }
4046 
4047     const firstChar = dict.get("FirstChar") || 0,
4048       lastChar = dict.get("LastChar") || (composite ? 0xffff : 0xff);
4049     const descriptor = dict.get("FontDescriptor");
4050     const toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");
4051 
4052     if (descriptor) {
4053       hash = new MurmurHash3_64();
4054 
4055       const encoding = baseDict.getRaw("Encoding");
4056       if (encoding instanceof Name) {
4057         hash.update(encoding.name);
4058       } else if (encoding instanceof Ref) {
4059         hash.update(encoding.toString());
4060       } else if (encoding instanceof Dict) {
4061         for (const entry of encoding.getRawValues()) {
4062           if (entry instanceof Name) {
4063             hash.update(entry.name);
4064           } else if (entry instanceof Ref) {
4065             hash.update(entry.toString());
4066           } else if (Array.isArray(entry)) {
4067             // 'Differences' array (fixes bug1157493.pdf).
4068             const diffLength = entry.length,
4069               diffBuf = new Array(diffLength);
4070 
4071             for (let j = 0; j < diffLength; j++) {
4072               const diffEntry = entry[j];
4073               if (diffEntry instanceof Name) {
4074                 diffBuf[j] = diffEntry.name;
4075               } else if (
4076                 typeof diffEntry === "number" ||
4077                 diffEntry instanceof Ref
4078               ) {
4079                 diffBuf[j] = diffEntry.toString();
4080               }
4081             }
4082             hash.update(diffBuf.join());
4083           }
4084         }
4085       }
4086 
4087       hash.update(`${firstChar}-${lastChar}`); // Fixes issue10665_reduced.pdf
4088 
4089       if (toUnicode instanceof BaseStream) {
4090         const stream = toUnicode.str || toUnicode;
4091         const uint8array = stream.buffer
4092           ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength)
4093           : new Uint8Array(
4094               stream.bytes.buffer,
4095               stream.start,
4096               stream.end - stream.start
4097             );
4098         hash.update(uint8array);
4099       } else if (toUnicode instanceof Name) {
4100         hash.update(toUnicode.name);
4101       }
4102 
4103       const widths = dict.get("Widths") || baseDict.get("Widths");
4104       if (Array.isArray(widths)) {
4105         const widthsBuf = [];
4106         for (const entry of widths) {
4107           if (typeof entry === "number" || entry instanceof Ref) {
4108             widthsBuf.push(entry.toString());
4109           }
4110         }
4111         hash.update(widthsBuf.join());
4112       }
4113 
4114       if (composite) {
4115         hash.update("compositeFont");
4116 
4117         const compositeWidths = dict.get("W") || baseDict.get("W");
4118         if (Array.isArray(compositeWidths)) {
4119           const widthsBuf = [];
4120           for (const entry of compositeWidths) {
4121             if (typeof entry === "number" || entry instanceof Ref) {
4122               widthsBuf.push(entry.toString());
4123             } else if (Array.isArray(entry)) {
4124               const subWidthsBuf = [];
4125               for (const element of entry) {
4126                 if (typeof element === "number" || element instanceof Ref) {
4127                   subWidthsBuf.push(element.toString());
4128                 }
4129               }
4130               widthsBuf.push(`[${subWidthsBuf.join()}]`);
4131             }
4132           }
4133           hash.update(widthsBuf.join());
4134         }
4135 
4136         const cidToGidMap =
4137           dict.getRaw("CIDToGIDMap") || baseDict.getRaw("CIDToGIDMap");
4138         if (cidToGidMap instanceof Name) {
4139           hash.update(cidToGidMap.name);
4140         } else if (cidToGidMap instanceof Ref) {
4141           hash.update(cidToGidMap.toString());
4142         } else if (cidToGidMap instanceof BaseStream) {
4143           hash.update(cidToGidMap.peekBytes());
4144         }
4145       }
4146     }
4147 
4148     return {
4149       descriptor,
4150       dict,
4151       baseDict,
4152       composite,
4153       type: type.name,
4154       firstChar,
4155       lastChar,
4156       toUnicode,
4157       hash: hash ? hash.hexdigest() : "",
4158     };
4159   }
4160 
4161   async translateFont({
4162     descriptor,
4163     dict,
4164     baseDict,
4165     composite,
4166     type,
4167     firstChar,
4168     lastChar,
4169     toUnicode,
4170     cssFontInfo,
4171   }) {
4172     const isType3Font = type === "Type3";
4173 
4174     if (!descriptor) {
4175       if (isType3Font) {
4176         // FontDescriptor is only required for Type3 fonts when the document
4177         // is a tagged pdf. Create a barbebones one to get by.
4178         descriptor = new Dict(null);
4179         descriptor.set("FontName", Name.get(type));
4180         descriptor.set("FontBBox", dict.getArray("FontBBox") || [0, 0, 0, 0]);
4181       } else {
4182         // Before PDF 1.5 if the font was one of the base 14 fonts, having a
4183         // FontDescriptor was not required.
4184         // This case is here for compatibility.
4185         let baseFontName = dict.get("BaseFont");
4186         if (!(baseFontName instanceof Name)) {
4187           throw new FormatError("Base font is not specified");
4188         }
4189 
4190         // Using base font name as a font name.
4191         baseFontName = baseFontName.name.replaceAll(/[,_]/g, "-");
4192         const metrics = this.getBaseFontMetrics(baseFontName);
4193 
4194         // Simulating descriptor flags attribute
4195         const fontNameWoStyle = baseFontName.split("-", 1)[0];
4196         const flags =
4197           (this.isSerifFont(fontNameWoStyle) ? FontFlags.Serif : 0) |
4198           (metrics.monospace ? FontFlags.FixedPitch : 0) |
4199           (getSymbolsFonts()[fontNameWoStyle]
4200             ? FontFlags.Symbolic
4201             : FontFlags.Nonsymbolic);
4202 
4203         const properties = {
4204           type,
4205           name: baseFontName,
4206           loadedName: baseDict.loadedName,
4207           systemFontInfo: null,
4208           widths: metrics.widths,
4209           defaultWidth: metrics.defaultWidth,
4210           isSimulatedFlags: true,
4211           flags,
4212           firstChar,
4213           lastChar,
4214           toUnicode,
4215           xHeight: 0,
4216           capHeight: 0,
4217           italicAngle: 0,
4218           isType3Font,
4219         };
4220         const widths = dict.get("Widths");
4221 
4222         const standardFontName = getStandardFontName(baseFontName);
4223         let file = null;
4224         if (standardFontName) {
4225           file = await this.fetchStandardFontData(standardFontName);
4226           properties.isInternalFont = !!file;
4227         }
4228         if (!properties.isInternalFont && this.options.useSystemFonts) {
4229           properties.systemFontInfo = getFontSubstitution(
4230             this.systemFontCache,
4231             this.idFactory,
4232             this.options.standardFontDataUrl,
4233             baseFontName,
4234             standardFontName
4235           );
4236         }
4237 
4238         const newProperties = await this.extractDataStructures(
4239           dict,
4240           properties
4241         );
4242         if (widths) {
4243           const glyphWidths = [];
4244           let j = firstChar;
4245           for (const width of widths) {
4246             glyphWidths[j++] = this.xref.fetchIfRef(width);
4247           }
4248           newProperties.widths = glyphWidths;
4249         } else {
4250           newProperties.widths = this.buildCharCodeToWidth(
4251             metrics.widths,
4252             newProperties
4253           );
4254         }
4255         return new Font(baseFontName, file, newProperties);
4256       }
4257     }
4258 
4259     // According to the spec if 'FontDescriptor' is declared, 'FirstChar',
4260     // 'LastChar' and 'Widths' should exist too, but some PDF encoders seem
4261     // to ignore this rule when a variant of a standard font is used.
4262     // TODO Fill the width array depending on which of the base font this is
4263     // a variant.
4264 
4265     let fontName = descriptor.get("FontName");
4266     let baseFont = dict.get("BaseFont");
4267     // Some bad PDFs have a string as the font name.
4268     if (typeof fontName === "string") {
4269       fontName = Name.get(fontName);
4270     }
4271     if (typeof baseFont === "string") {
4272       baseFont = Name.get(baseFont);
4273     }
4274 
4275     const fontNameStr = fontName?.name;
4276     const baseFontStr = baseFont?.name;
4277     if (!isType3Font && fontNameStr !== baseFontStr) {
4278       info(
4279         `The FontDescriptor's FontName is "${fontNameStr}" but ` +
4280           `should be the same as the Font's BaseFont "${baseFontStr}".`
4281       );
4282       // - Workaround for cases where e.g. fontNameStr = 'Arial' and
4283       //   baseFontStr = 'Arial,Bold' (needed when no font file is embedded).
4284       //
4285       // - Workaround for cases where e.g. fontNameStr = 'wg09np' and
4286       //   baseFontStr = 'Wingdings-Regular' (fixes issue7454.pdf).
4287       if (
4288         fontNameStr &&
4289         baseFontStr &&
4290         (baseFontStr.startsWith(fontNameStr) ||
4291           (!isKnownFontName(fontNameStr) && isKnownFontName(baseFontStr)))
4292       ) {
4293         fontName = null;
4294       }
4295     }
4296     fontName ||= baseFont;
4297 
4298     if (!(fontName instanceof Name)) {
4299       throw new FormatError("invalid font name");
4300     }
4301 
4302     let fontFile, subtype, length1, length2, length3;
4303     try {
4304       fontFile = descriptor.get("FontFile", "FontFile2", "FontFile3");
4305     } catch (ex) {
4306       if (!this.options.ignoreErrors) {
4307         throw ex;
4308       }
4309       warn(`translateFont - fetching "${fontName.name}" font file: "${ex}".`);
4310       fontFile = new NullStream();
4311     }
4312     let isInternalFont = false;
4313     let glyphScaleFactors = null;
4314     let systemFontInfo = null;
4315     if (fontFile) {
4316       if (fontFile.dict) {
4317         const subtypeEntry = fontFile.dict.get("Subtype");
4318         if (subtypeEntry instanceof Name) {
4319           subtype = subtypeEntry.name;
4320         }
4321         length1 = fontFile.dict.get("Length1");
4322         length2 = fontFile.dict.get("Length2");
4323         length3 = fontFile.dict.get("Length3");
4324       }
4325     } else if (cssFontInfo) {
4326       // We've a missing XFA font.
4327       const standardFontName = getXfaFontName(fontName.name);
4328       if (standardFontName) {
4329         cssFontInfo.fontFamily = `${cssFontInfo.fontFamily}-PdfJS-XFA`;
4330         cssFontInfo.metrics = standardFontName.metrics || null;
4331         glyphScaleFactors = standardFontName.factors || null;
4332         fontFile = await this.fetchStandardFontData(standardFontName.name);
4333         isInternalFont = !!fontFile;
4334 
4335         // We're using a substitution font but for example widths (if any)
4336         // are related to the glyph positions in the font.
4337         // So we overwrite everything here to be sure that widths are
4338         // correct.
4339         baseDict = dict = getXfaFontDict(fontName.name);
4340         composite = true;
4341       }
4342     } else if (!isType3Font) {
4343       const standardFontName = getStandardFontName(fontName.name);
4344       if (standardFontName) {
4345         fontFile = await this.fetchStandardFontData(standardFontName);
4346         isInternalFont = !!fontFile;
4347       }
4348       if (!isInternalFont && this.options.useSystemFonts) {
4349         systemFontInfo = getFontSubstitution(
4350           this.systemFontCache,
4351           this.idFactory,
4352           this.options.standardFontDataUrl,
4353           fontName.name,
4354           standardFontName
4355         );
4356       }
4357     }
4358 
4359     const properties = {
4360       type,
4361       name: fontName.name,
4362       subtype,
4363       file: fontFile,
4364       length1,
4365       length2,
4366       length3,
4367       isInternalFont,
4368       loadedName: baseDict.loadedName,
4369       composite,
4370       fixedPitch: false,
4371       fontMatrix: dict.getArray("FontMatrix") || FONT_IDENTITY_MATRIX,
4372       firstChar,
4373       lastChar,
4374       toUnicode,
4375       bbox: descriptor.getArray("FontBBox") || dict.getArray("FontBBox"),
4376       ascent: descriptor.get("Ascent"),
4377       descent: descriptor.get("Descent"),
4378       xHeight: descriptor.get("XHeight") || 0,
4379       capHeight: descriptor.get("CapHeight") || 0,
4380       flags: descriptor.get("Flags"),
4381       italicAngle: descriptor.get("ItalicAngle") || 0,
4382       isType3Font,
4383       cssFontInfo,
4384       scaleFactors: glyphScaleFactors,
4385       systemFontInfo,
4386     };
4387 
4388     if (composite) {
4389       const cidEncoding = baseDict.get("Encoding");
4390       if (cidEncoding instanceof Name) {
4391         properties.cidEncoding = cidEncoding.name;
4392       }
4393       const cMap = await CMapFactory.create({
4394         encoding: cidEncoding,
4395         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
4396         useCMap: null,
4397       });
4398       properties.cMap = cMap;
4399       properties.vertical = properties.cMap.vertical;
4400     }
4401 
4402     const newProperties = await this.extractDataStructures(dict, properties);
4403     this.extractWidths(dict, descriptor, newProperties);
4404 
4405     return new Font(fontName.name, fontFile, newProperties);
4406   }
4407 
4408   static buildFontPaths(font, glyphs, handler, evaluatorOptions) {
4409     function buildPath(fontChar) {
4410       const glyphName = `${font.loadedName}_path_${fontChar}`;
4411       try {
4412         if (font.renderer.hasBuiltPath(fontChar)) {
4413           return;
4414         }
4415         handler.send("commonobj", [
4416           glyphName,
4417           "FontPath",
4418           font.renderer.getPathJs(fontChar),
4419         ]);
4420       } catch (reason) {
4421         if (evaluatorOptions.ignoreErrors) {
4422           warn(`buildFontPaths - ignoring ${glyphName} glyph: "${reason}".`);
4423           return;
4424         }
4425         throw reason;
4426       }
4427     }
4428 
4429     for (const glyph of glyphs) {
4430       buildPath(glyph.fontChar);
4431 
4432       // If the glyph has an accent we need to build a path for its
4433       // fontChar too, otherwise CanvasGraphics_paintChar will fail.
4434       const accent = glyph.accent;
4435       if (accent?.fontChar) {
4436         buildPath(accent.fontChar);
4437       }
4438     }
4439   }
4440 
4441   static get fallbackFontDict() {
4442     const dict = new Dict();
4443     dict.set("BaseFont", Name.get("Helvetica"));
4444     dict.set("Type", Name.get("FallbackType"));
4445     dict.set("Subtype", Name.get("FallbackType"));
4446     dict.set("Encoding", Name.get("WinAnsiEncoding"));
4447 
4448     return shadow(this, "fallbackFontDict", dict);
4449   }
4450 }
4451 
4452 class TranslatedFont {
4453   constructor({ loadedName, font, dict, evaluatorOptions }) {
4454     this.loadedName = loadedName;
4455     this.font = font;
4456     this.dict = dict;
4457     this._evaluatorOptions = evaluatorOptions || DefaultPartialEvaluatorOptions;
4458     this.type3Loaded = null;
4459     this.type3Dependencies = font.isType3Font ? new Set() : null;
4460     this.sent = false;
4461   }
4462 
4463   send(handler) {
4464     if (this.sent) {
4465       return;
4466     }
4467     this.sent = true;
4468 
4469     handler.send("commonobj", [
4470       this.loadedName,
4471       "Font",
4472       this.font.exportData(this._evaluatorOptions.fontExtraProperties),
4473     ]);
4474   }
4475 
4476   fallback(handler) {
4477     if (!this.font.data) {
4478       return;
4479     }
4480     // When font loading failed, fall back to the built-in font renderer.
4481     this.font.disableFontFace = true;
4482     // An arbitrary number of text rendering operators could have been
4483     // encountered between the point in time when the 'Font' message was sent
4484     // to the main-thread, and the point in time when the 'FontFallback'
4485     // message was received on the worker-thread.
4486     // To ensure that all 'FontPath's are available on the main-thread, when
4487     // font loading failed, attempt to resend *all* previously parsed glyphs.
4488     PartialEvaluator.buildFontPaths(
4489       this.font,
4490       /* glyphs = */ this.font.glyphCacheValues,
4491       handler,
4492       this._evaluatorOptions
4493     );
4494   }
4495 
4496   loadType3Data(evaluator, resources, task) {
4497     if (this.type3Loaded) {
4498       return this.type3Loaded;
4499     }
4500     if (!this.font.isType3Font) {
4501       throw new Error("Must be a Type3 font.");
4502     }
4503     // When parsing Type3 glyphs, always ignore them if there are errors.
4504     // Compared to the parsing of e.g. an entire page, it doesn't really
4505     // make sense to only be able to render a Type3 glyph partially.
4506     const type3Evaluator = evaluator.clone({ ignoreErrors: false });
4507     type3Evaluator.parsingType3Font = true;
4508     // Prevent circular references in Type3 fonts.
4509     const type3FontRefs = new RefSet(evaluator.type3FontRefs);
4510     if (this.dict.objId && !type3FontRefs.has(this.dict.objId)) {
4511       type3FontRefs.put(this.dict.objId);
4512     }
4513     type3Evaluator.type3FontRefs = type3FontRefs;
4514 
4515     const translatedFont = this.font,
4516       type3Dependencies = this.type3Dependencies;
4517     let loadCharProcsPromise = Promise.resolve();
4518     const charProcs = this.dict.get("CharProcs");
4519     const fontResources = this.dict.get("Resources") || resources;
4520     const charProcOperatorList = Object.create(null);
4521 
4522     const fontBBox = Util.normalizeRect(translatedFont.bbox || [0, 0, 0, 0]),
4523       width = fontBBox[2] - fontBBox[0],
4524       height = fontBBox[3] - fontBBox[1];
4525     const fontBBoxSize = Math.hypot(width, height);
4526 
4527     for (const key of charProcs.getKeys()) {
4528       loadCharProcsPromise = loadCharProcsPromise.then(() => {
4529         const glyphStream = charProcs.get(key);
4530         const operatorList = new OperatorList();
4531         return type3Evaluator
4532           .getOperatorList({
4533             stream: glyphStream,
4534             task,
4535             resources: fontResources,
4536             operatorList,
4537           })
4538           .then(() => {
4539             // According to the PDF specification, section "9.6.5 Type 3 Fonts"
4540             // and "Table 113":
4541             //  "A glyph description that begins with the d1 operator should
4542             //   not execute any operators that set the colour (or other
4543             //   colour-related parameters) in the graphics state;
4544             //   any use of such operators shall be ignored."
4545             if (operatorList.fnArray[0] === OPS.setCharWidthAndBounds) {
4546               this._removeType3ColorOperators(operatorList, fontBBoxSize);
4547             }
4548             charProcOperatorList[key] = operatorList.getIR();
4549 
4550             for (const dependency of operatorList.dependencies) {
4551               type3Dependencies.add(dependency);
4552             }
4553           })
4554           .catch(function (reason) {
4555             warn(`Type3 font resource "${key}" is not available.`);
4556             const dummyOperatorList = new OperatorList();
4557             charProcOperatorList[key] = dummyOperatorList.getIR();
4558           });
4559       });
4560     }
4561     this.type3Loaded = loadCharProcsPromise.then(() => {
4562       translatedFont.charProcOperatorList = charProcOperatorList;
4563       if (this._bbox) {
4564         translatedFont.isCharBBox = true;
4565         translatedFont.bbox = this._bbox;
4566       }
4567     });
4568     return this.type3Loaded;
4569   }
4570 
4571   /**
4572    * @private
4573    */
4574   _removeType3ColorOperators(operatorList, fontBBoxSize = NaN) {
4575     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
4576       assert(
4577         operatorList.fnArray[0] === OPS.setCharWidthAndBounds,
4578         "Type3 glyph shall start with the d1 operator."
4579       );
4580     }
4581     const charBBox = Util.normalizeRect(operatorList.argsArray[0].slice(2)),
4582       width = charBBox[2] - charBBox[0],
4583       height = charBBox[3] - charBBox[1];
4584     const charBBoxSize = Math.hypot(width, height);
4585 
4586     if (width === 0 || height === 0) {
4587       // Skip the d1 operator when its bounds are bogus (fixes issue14953.pdf).
4588       operatorList.fnArray.splice(0, 1);
4589       operatorList.argsArray.splice(0, 1);
4590     } else if (
4591       fontBBoxSize === 0 ||
4592       Math.round(charBBoxSize / fontBBoxSize) >= 10
4593     ) {
4594       // Override the fontBBox when it's undefined/empty, or when it's at least
4595       // (approximately) one order of magnitude smaller than the charBBox
4596       // (fixes issue14999_reduced.pdf).
4597       if (!this._bbox) {
4598         this._bbox = [Infinity, Infinity, -Infinity, -Infinity];
4599       }
4600       this._bbox[0] = Math.min(this._bbox[0], charBBox[0]);
4601       this._bbox[1] = Math.min(this._bbox[1], charBBox[1]);
4602       this._bbox[2] = Math.max(this._bbox[2], charBBox[2]);
4603       this._bbox[3] = Math.max(this._bbox[3], charBBox[3]);
4604     }
4605 
4606     let i = 0,
4607       ii = operatorList.length;
4608     while (i < ii) {
4609       switch (operatorList.fnArray[i]) {
4610         case OPS.setCharWidthAndBounds:
4611           break; // Handled above.
4612         case OPS.setStrokeColorSpace:
4613         case OPS.setFillColorSpace:
4614         case OPS.setStrokeColor:
4615         case OPS.setStrokeColorN:
4616         case OPS.setFillColor:
4617         case OPS.setFillColorN:
4618         case OPS.setStrokeGray:
4619         case OPS.setFillGray:
4620         case OPS.setStrokeRGBColor:
4621         case OPS.setFillRGBColor:
4622         case OPS.setStrokeCMYKColor:
4623         case OPS.setFillCMYKColor:
4624         case OPS.shadingFill:
4625         case OPS.setRenderingIntent:
4626           operatorList.fnArray.splice(i, 1);
4627           operatorList.argsArray.splice(i, 1);
4628           ii--;
4629           continue;
4630 
4631         case OPS.setGState:
4632           const [gStateObj] = operatorList.argsArray[i];
4633           let j = 0,
4634             jj = gStateObj.length;
4635           while (j < jj) {
4636             const [gStateKey] = gStateObj[j];
4637             switch (gStateKey) {
4638               case "TR":
4639               case "TR2":
4640               case "HT":
4641               case "BG":
4642               case "BG2":
4643               case "UCR":
4644               case "UCR2":
4645                 gStateObj.splice(j, 1);
4646                 jj--;
4647                 continue;
4648             }
4649             j++;
4650           }
4651           break;
4652       }
4653       i++;
4654     }
4655   }
4656 }
4657 
4658 class StateManager {
4659   constructor(initialState = new EvalState()) {
4660     this.state = initialState;
4661     this.stateStack = [];
4662   }
4663 
4664   save() {
4665     const old = this.state;
4666     this.stateStack.push(this.state);
4667     this.state = old.clone();
4668   }
4669 
4670   restore() {
4671     const prev = this.stateStack.pop();
4672     if (prev) {
4673       this.state = prev;
4674     }
4675   }
4676 
4677   transform(args) {
4678     this.state.ctm = Util.transform(this.state.ctm, args);
4679   }
4680 }
4681 
4682 class TextState {
4683   constructor() {
4684     this.ctm = new Float32Array(IDENTITY_MATRIX);
4685     this.fontName = null;
4686     this.fontSize = 0;
4687     this.loadedName = null;
4688     this.font = null;
4689     this.fontMatrix = FONT_IDENTITY_MATRIX;
4690     this.textMatrix = IDENTITY_MATRIX.slice();
4691     this.textLineMatrix = IDENTITY_MATRIX.slice();
4692     this.charSpacing = 0;
4693     this.wordSpacing = 0;
4694     this.leading = 0;
4695     this.textHScale = 1;
4696     this.textRise = 0;
4697   }
4698 
4699   setTextMatrix(a, b, c, d, e, f) {
4700     const m = this.textMatrix;
4701     m[0] = a;
4702     m[1] = b;
4703     m[2] = c;
4704     m[3] = d;
4705     m[4] = e;
4706     m[5] = f;
4707   }
4708 
4709   setTextLineMatrix(a, b, c, d, e, f) {
4710     const m = this.textLineMatrix;
4711     m[0] = a;
4712     m[1] = b;
4713     m[2] = c;
4714     m[3] = d;
4715     m[4] = e;
4716     m[5] = f;
4717   }
4718 
4719   translateTextMatrix(x, y) {
4720     const m = this.textMatrix;
4721     m[4] = m[0] * x + m[2] * y + m[4];
4722     m[5] = m[1] * x + m[3] * y + m[5];
4723   }
4724 
4725   translateTextLineMatrix(x, y) {
4726     const m = this.textLineMatrix;
4727     m[4] = m[0] * x + m[2] * y + m[4];
4728     m[5] = m[1] * x + m[3] * y + m[5];
4729   }
4730 
4731   carriageReturn() {
4732     this.translateTextLineMatrix(0, -this.leading);
4733     this.textMatrix = this.textLineMatrix.slice();
4734   }
4735 
4736   clone() {
4737     const clone = Object.create(this);
4738     clone.textMatrix = this.textMatrix.slice();
4739     clone.textLineMatrix = this.textLineMatrix.slice();
4740     clone.fontMatrix = this.fontMatrix.slice();
4741     return clone;
4742   }
4743 }
4744 
4745 class EvalState {
4746   constructor() {
4747     this.ctm = new Float32Array(IDENTITY_MATRIX);
4748     this.font = null;
4749     this.textRenderingMode = TextRenderingMode.FILL;
4750     this.fillColorSpace = ColorSpace.singletons.gray;
4751     this.strokeColorSpace = ColorSpace.singletons.gray;
4752   }
4753 
4754   clone() {
4755     return Object.create(this);
4756   }
4757 }
4758 
4759 class EvaluatorPreprocessor {
4760   static get opMap() {
4761     // Specifies properties for each command
4762     //
4763     // If variableArgs === true: [0, `numArgs`] expected
4764     // If variableArgs === false: exactly `numArgs` expected
4765     return shadow(
4766       this,
4767       "opMap",
4768       Object.assign(Object.create(null), {
4769         // Graphic state
4770         w: { id: OPS.setLineWidth, numArgs: 1, variableArgs: false },
4771         J: { id: OPS.setLineCap, numArgs: 1, variableArgs: false },
4772         j: { id: OPS.setLineJoin, numArgs: 1, variableArgs: false },
4773         M: { id: OPS.setMiterLimit, numArgs: 1, variableArgs: false },
4774         d: { id: OPS.setDash, numArgs: 2, variableArgs: false },
4775         ri: { id: OPS.setRenderingIntent, numArgs: 1, variableArgs: false },
4776         i: { id: OPS.setFlatness, numArgs: 1, variableArgs: false },
4777         gs: { id: OPS.setGState, numArgs: 1, variableArgs: false },
4778         q: { id: OPS.save, numArgs: 0, variableArgs: false },
4779         Q: { id: OPS.restore, numArgs: 0, variableArgs: false },
4780         cm: { id: OPS.transform, numArgs: 6, variableArgs: false },
4781 
4782         // Path
4783         m: { id: OPS.moveTo, numArgs: 2, variableArgs: false },
4784         l: { id: OPS.lineTo, numArgs: 2, variableArgs: false },
4785         c: { id: OPS.curveTo, numArgs: 6, variableArgs: false },
4786         v: { id: OPS.curveTo2, numArgs: 4, variableArgs: false },
4787         y: { id: OPS.curveTo3, numArgs: 4, variableArgs: false },
4788         h: { id: OPS.closePath, numArgs: 0, variableArgs: false },
4789         re: { id: OPS.rectangle, numArgs: 4, variableArgs: false },
4790         S: { id: OPS.stroke, numArgs: 0, variableArgs: false },
4791         s: { id: OPS.closeStroke, numArgs: 0, variableArgs: false },
4792         f: { id: OPS.fill, numArgs: 0, variableArgs: false },
4793         F: { id: OPS.fill, numArgs: 0, variableArgs: false },
4794         "f*": { id: OPS.eoFill, numArgs: 0, variableArgs: false },
4795         B: { id: OPS.fillStroke, numArgs: 0, variableArgs: false },
4796         "B*": { id: OPS.eoFillStroke, numArgs: 0, variableArgs: false },
4797         b: { id: OPS.closeFillStroke, numArgs: 0, variableArgs: false },
4798         "b*": { id: OPS.closeEOFillStroke, numArgs: 0, variableArgs: false },
4799         n: { id: OPS.endPath, numArgs: 0, variableArgs: false },
4800 
4801         // Clipping
4802         W: { id: OPS.clip, numArgs: 0, variableArgs: false },
4803         "W*": { id: OPS.eoClip, numArgs: 0, variableArgs: false },
4804 
4805         // Text
4806         BT: { id: OPS.beginText, numArgs: 0, variableArgs: false },
4807         ET: { id: OPS.endText, numArgs: 0, variableArgs: false },
4808         Tc: { id: OPS.setCharSpacing, numArgs: 1, variableArgs: false },
4809         Tw: { id: OPS.setWordSpacing, numArgs: 1, variableArgs: false },
4810         Tz: { id: OPS.setHScale, numArgs: 1, variableArgs: false },
4811         TL: { id: OPS.setLeading, numArgs: 1, variableArgs: false },
4812         Tf: { id: OPS.setFont, numArgs: 2, variableArgs: false },
4813         Tr: { id: OPS.setTextRenderingMode, numArgs: 1, variableArgs: false },
4814         Ts: { id: OPS.setTextRise, numArgs: 1, variableArgs: false },
4815         Td: { id: OPS.moveText, numArgs: 2, variableArgs: false },
4816         TD: { id: OPS.setLeadingMoveText, numArgs: 2, variableArgs: false },
4817         Tm: { id: OPS.setTextMatrix, numArgs: 6, variableArgs: false },
4818         "T*": { id: OPS.nextLine, numArgs: 0, variableArgs: false },
4819         Tj: { id: OPS.showText, numArgs: 1, variableArgs: false },
4820         TJ: { id: OPS.showSpacedText, numArgs: 1, variableArgs: false },
4821         "'": { id: OPS.nextLineShowText, numArgs: 1, variableArgs: false },
4822         '"': {
4823           id: OPS.nextLineSetSpacingShowText,
4824           numArgs: 3,
4825           variableArgs: false,
4826         },
4827 
4828         // Type3 fonts
4829         d0: { id: OPS.setCharWidth, numArgs: 2, variableArgs: false },
4830         d1: {
4831           id: OPS.setCharWidthAndBounds,
4832           numArgs: 6,
4833           variableArgs: false,
4834         },
4835 
4836         // Color
4837         CS: { id: OPS.setStrokeColorSpace, numArgs: 1, variableArgs: false },
4838         cs: { id: OPS.setFillColorSpace, numArgs: 1, variableArgs: false },
4839         SC: { id: OPS.setStrokeColor, numArgs: 4, variableArgs: true },
4840         SCN: { id: OPS.setStrokeColorN, numArgs: 33, variableArgs: true },
4841         sc: { id: OPS.setFillColor, numArgs: 4, variableArgs: true },
4842         scn: { id: OPS.setFillColorN, numArgs: 33, variableArgs: true },
4843         G: { id: OPS.setStrokeGray, numArgs: 1, variableArgs: false },
4844         g: { id: OPS.setFillGray, numArgs: 1, variableArgs: false },
4845         RG: { id: OPS.setStrokeRGBColor, numArgs: 3, variableArgs: false },
4846         rg: { id: OPS.setFillRGBColor, numArgs: 3, variableArgs: false },
4847         K: { id: OPS.setStrokeCMYKColor, numArgs: 4, variableArgs: false },
4848         k: { id: OPS.setFillCMYKColor, numArgs: 4, variableArgs: false },
4849 
4850         // Shading
4851         sh: { id: OPS.shadingFill, numArgs: 1, variableArgs: false },
4852 
4853         // Images
4854         BI: { id: OPS.beginInlineImage, numArgs: 0, variableArgs: false },
4855         ID: { id: OPS.beginImageData, numArgs: 0, variableArgs: false },
4856         EI: { id: OPS.endInlineImage, numArgs: 1, variableArgs: false },
4857 
4858         // XObjects
4859         Do: { id: OPS.paintXObject, numArgs: 1, variableArgs: false },
4860         MP: { id: OPS.markPoint, numArgs: 1, variableArgs: false },
4861         DP: { id: OPS.markPointProps, numArgs: 2, variableArgs: false },
4862         BMC: { id: OPS.beginMarkedContent, numArgs: 1, variableArgs: false },
4863         BDC: {
4864           id: OPS.beginMarkedContentProps,
4865           numArgs: 2,
4866           variableArgs: false,
4867         },
4868         EMC: { id: OPS.endMarkedContent, numArgs: 0, variableArgs: false },
4869 
4870         // Compatibility
4871         BX: { id: OPS.beginCompat, numArgs: 0, variableArgs: false },
4872         EX: { id: OPS.endCompat, numArgs: 0, variableArgs: false },
4873 
4874         // (reserved partial commands for the lexer)
4875         BM: null,
4876         BD: null,
4877         true: null,
4878         fa: null,
4879         fal: null,
4880         fals: null,
4881         false: null,
4882         nu: null,
4883         nul: null,
4884         null: null,
4885       })
4886     );
4887   }
4888 
4889   static MAX_INVALID_PATH_OPS = 10;
4890 
4891   constructor(stream, xref, stateManager = new StateManager()) {
4892     // TODO(mduan): pass array of knownCommands rather than this.opMap
4893     // dictionary
4894     this.parser = new Parser({
4895       lexer: new Lexer(stream, EvaluatorPreprocessor.opMap),
4896       xref,
4897     });
4898     this.stateManager = stateManager;
4899     this.nonProcessedArgs = [];
4900     this._isPathOp = false;
4901     this._numInvalidPathOPS = 0;
4902   }
4903 
4904   get savedStatesDepth() {
4905     return this.stateManager.stateStack.length;
4906   }
4907 
4908   // |operation| is an object with two fields:
4909   //
4910   // - |fn| is an out param.
4911   //
4912   // - |args| is an inout param. On entry, it should have one of two values.
4913   //
4914   //   - An empty array. This indicates that the caller is providing the
4915   //     array in which the args will be stored in. The caller should use
4916   //     this value if it can reuse a single array for each call to read().
4917   //
4918   //   - |null|. This indicates that the caller needs this function to create
4919   //     the array in which any args are stored in. If there are zero args,
4920   //     this function will leave |operation.args| as |null| (thus avoiding
4921   //     allocations that would occur if we used an empty array to represent
4922   //     zero arguments). Otherwise, it will replace |null| with a new array
4923   //     containing the arguments. The caller should use this value if it
4924   //     cannot reuse an array for each call to read().
4925   //
4926   // These two modes are present because this function is very hot and so
4927   // avoiding allocations where possible is worthwhile.
4928   //
4929   read(operation) {
4930     let args = operation.args;
4931     while (true) {
4932       const obj = this.parser.getObj();
4933       if (obj instanceof Cmd) {
4934         const cmd = obj.cmd;
4935         // Check that the command is valid
4936         const opSpec = EvaluatorPreprocessor.opMap[cmd];
4937         if (!opSpec) {
4938           warn(`Unknown command "${cmd}".`);
4939           continue;
4940         }
4941 
4942         const fn = opSpec.id;
4943         const numArgs = opSpec.numArgs;
4944         let argsLength = args !== null ? args.length : 0;
4945 
4946         // If the *previous* command wasn't a path operator, reset the heuristic
4947         // used with incomplete path operators below (fixes issue14917.pdf).
4948         if (!this._isPathOp) {
4949           this._numInvalidPathOPS = 0;
4950         }
4951         this._isPathOp = fn >= OPS.moveTo && fn <= OPS.endPath;
4952 
4953         if (!opSpec.variableArgs) {
4954           // Postscript commands can be nested, e.g. /F2 /GS2 gs 5.711 Tf
4955           if (argsLength !== numArgs) {
4956             const nonProcessedArgs = this.nonProcessedArgs;
4957             while (argsLength > numArgs) {
4958               nonProcessedArgs.push(args.shift());
4959               argsLength--;
4960             }
4961             while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
4962               if (args === null) {
4963                 args = [];
4964               }
4965               args.unshift(nonProcessedArgs.pop());
4966               argsLength++;
4967             }
4968           }
4969 
4970           if (argsLength < numArgs) {
4971             const partialMsg =
4972               `command ${cmd}: expected ${numArgs} args, ` +
4973               `but received ${argsLength} args.`;
4974 
4975             // Incomplete path operators, in particular, can result in fairly
4976             // chaotic rendering artifacts. Hence the following heuristics is
4977             // used to error, rather than just warn, once a number of invalid
4978             // path operators have been encountered (fixes bug1443140.pdf).
4979             if (
4980               this._isPathOp &&
4981               ++this._numInvalidPathOPS >
4982                 EvaluatorPreprocessor.MAX_INVALID_PATH_OPS
4983             ) {
4984               throw new FormatError(`Invalid ${partialMsg}`);
4985             }
4986             // If we receive too few arguments, it's not possible to execute
4987             // the command, hence we skip the command.
4988             warn(`Skipping ${partialMsg}`);
4989             if (args !== null) {
4990               args.length = 0;
4991             }
4992             continue;
4993           }
4994         } else if (argsLength > numArgs) {
4995           info(
4996             `Command ${cmd}: expected [0, ${numArgs}] args, ` +
4997               `but received ${argsLength} args.`
4998           );
4999         }
5000 
5001         // TODO figure out how to type-check vararg functions
5002         this.preprocessCommand(fn, args);
5003 
5004         operation.fn = fn;
5005         operation.args = args;
5006         return true;
5007       }
5008       if (obj === EOF) {
5009         return false; // no more commands
5010       }
5011       // argument
5012       if (obj !== null) {
5013         if (args === null) {
5014           args = [];
5015         }
5016         args.push(obj);
5017         if (args.length > 33) {
5018           throw new FormatError("Too many arguments");
5019         }
5020       }
5021     }
5022   }
5023 
5024   preprocessCommand(fn, args) {
5025     switch (fn | 0) {
5026       case OPS.save:
5027         this.stateManager.save();
5028         break;
5029       case OPS.restore:
5030         this.stateManager.restore();
5031         break;
5032       case OPS.transform:
5033         this.stateManager.transform(args);
5034         break;
5035     }
5036   }
5037 }
5038 
5039 export { EvaluatorPreprocessor, PartialEvaluator };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

