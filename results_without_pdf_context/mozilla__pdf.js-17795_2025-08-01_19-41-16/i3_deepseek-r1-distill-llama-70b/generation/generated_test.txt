it("should handle inlined images without EI", async () => {
  const xref = new XRefMock();
  const idFactory = createIdFactory();
  const handler = {
    send: jest.fn(),
    sendWithPromise: jest.fn(),
  };
  const evaluator = new PartialEvaluator({
    xref,
    handler,
    pageIndex: 0,
    idFactory,
    options: {
      ignoreErrors: false,
    },
  });

  const dict = new Dict();
  const image = new Stream(new Uint8Array([0, 1, 2, 3, 4, 5]));
  const operatorList = new OperatorList();

  // Mock the image processing to throw an error
  const originalCreateImageData = PartialEvaluator.prototype.createImageData;
  PartialEvaluator.prototype.createImageData = async () => {
    throw new Error("Failed to decode image");
  };

  const consoleSpy = jest.spyOn(console, "warn").mockImplementation(() => {});

  // Add an inlined image without EI
  await evaluator.buildPaintImageXObject({
    resources: dict,
    image,
    isInline: true,
    operatorList,
    cacheKey: null,
    localImageCache: null,
    localColorSpaceCache: null,
  });

  // Verify that the warning was logged
  expect(consoleSpy).toHaveBeenCalledWith("Unable to decode inline image: \"Failed to decode image\".");

  // Restore the original method
  PartialEvaluator.prototype.createImageData = originalCreateImageData;
});