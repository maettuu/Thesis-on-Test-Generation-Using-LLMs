it("should correctly reflect radio button state in print view", async () => {
  const idFactory = createIdFactory();
  const xref = new XRefMock(idFactory);
  const fontData = await fetch(STANDARD_FONT_DATA_URL).then(res => res.arrayBuffer());

  // Create a radio button annotation
  const annotationRef = xref.createRef();
  const dict = new Dict(xref);
  dict.set("Type", Name.get("Annot"));
  dict.set("Subtype", Name.get("Widget"));
  dict.set("FT", Name.get("Btn"));
  dict.set("F", 0);
  dict.set("Rect", [0, 0, 100, 100]);
  dict.set("T", stringToPDFString("Test Radio Button"));
  dict.set("Parent", new Ref(1));

  // Create parent field
  const parentRef = xref.createRef();
  const parentDict = new Dict(xref);
  parentDict.set("V", Name.get("Yes"));
  parentDict.set("Opt", [Name.get("Yes"), Name.get("No")]);

  xref.put(parentRef, parentDict);
  xref.put(annotationRef, dict);

  const annotation = await AnnotationFactory.create(
    xref,
    annotationRef,
    {
      pdfManager: null,
      acroForm: new Dict(),
      xfaDatasets: null,
      structTreeRoot: null,
      baseUrl: null,
      attachments: null
    },
    idFactory,
    true
  );

  const buttonAnnotation = new ButtonWidgetAnnotation({
    dict: annotation.dict,
    xref: xref,
    annotationGlobals: {
      pdfManager: null,
      acroForm: new Dict(),
      xfaDatasets: null,
      structTreeRoot: null,
      baseUrl: null,
      attachments: null
    },
    id: idFactory.createObjId(),
    collectFields: true,
    pageIndex: 0,
    pageRef: null,
    evaluatorOptions: {}
  });

  // The state should be correctly reflected
  expect(buttonAnnotation.data.fieldValue).toBe("Yes");
});