Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
navigator does not contain platform, therefore require('pdfjs-dist/build/pdf') leads to an error
Attach (recommended) or Link to PDF file here:

Configuration:
- Web browser and its version:
Node.js 18 .12.1
- Operating system and its version:
Microsoft Windows 11 Home 10.0.22621
- PDF.js version:
3.0.279
- Is a browser extension:
No
Steps to reproduce the problem:
1.  install node js
2. npm i pdfjs-dist
3. npm i webex
4.  create any node js project and load "const webex = require('webex');" "const pdfjs = require('pdfjs-dist/build/pdf');" 

What is the expected behavior? (add screenshot)
 no error should occur

What went wrong? (add screenshot)
In line 3365 of the pdf.js file the object "navigator" does not contain the attribute "platform", therefore the following .include operations cause an error.

![image](https://user-images.githubusercontent.com/105495892/203373285-be70feb5-4fa3-4110-8372-871c4c82962b.png)


I would suggest changing line 3365 to 'const platform = typeof navigator.platform  !== "undefined" ? navigator.platform : "";'
since not only the navigator object needs to exist.
The same should be done for legacy.
</issue>

Patch:
<patch>
diff --git a/src/display/font_loader.js b/src/display/font_loader.js
--- a/src/display/font_loader.js
+++ b/src/display/font_loader.js
@@ -184,6 +184,7 @@ class FontLoader {
         supported = true;
       } else if (
         typeof navigator !== "undefined" &&
+        typeof navigator?.userAgent === "string" &&
         // User agent string sniffing is bad, but there is no reliable way to
         // tell if the font is fully loaded and ready to be used with canvas.
         /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)

diff --git a/src/shared/util.js b/src/shared/util.js
--- a/src/shared/util.js
+++ b/src/shared/util.js
@@ -616,14 +616,15 @@ class FeatureTest {
 
   static get platform() {
     if (
-      (typeof PDFJSDev === "undefined" || PDFJSDev.test("GENERIC")) &&
-      typeof navigator === "undefined"
+      (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) ||
+      (typeof navigator !== "undefined" &&
+        typeof navigator?.platform === "string")
     ) {
-      return shadow(this, "platform", { isMac: false });
+      return shadow(this, "platform", {
+        isMac: navigator.platform.includes("Mac"),
+      });
     }
-    return shadow(this, "platform", {
-      isMac: navigator.platform.includes("Mac"),
-    });
+    return shadow(this, "platform", { isMac: false });
   }
 
   static get isCSSRoundSupported() {


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.23.2
- @babel/preset-env: ^7.23.2
- @babel/runtime: ^7.23.2
- @javascript-obfuscator/escodegen: 2.3.0
- acorn: ^8.10.0
- autoprefixer: ^10.4.16
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001549
- canvas: ^2.11.2
- core-js: ^3.33.0
- cross-env: ^7.0.3
- eslint: ^8.51.0
- eslint-config-prettier: ^8.10.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.28.1
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.2.0
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.0.1
- eslint-plugin-sort-exports: ^0.8.0
- eslint-plugin-unicorn: ^48.0.1
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.9.0
- globals: ^13.23.0
- gulp: ^4.0.2
- gulp-postcss: ^9.0.1
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^5.1.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.2.0
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.31
- postcss-dir-pseudo-class: ^8.0.0
- postcss-discard-comments: ^6.0.0
- postcss-nesting: ^12.0.1
- prettier: ^3.0.3
- puppeteer: ^21.3.8
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^15.10.3
- stylelint-prettier: ^4.0.2
- terser: ^5.21.0
- through2: ^4.0.2
- tsc-alias: ^1.8.8
- ttest: ^4.0.0
- typescript: ^5.2.2
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.89.0
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isArrayBuffer, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/l10n.js`: L10n
- `../../web/l10n_utils.js`: NullL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/display/font_loader.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   assert,
18   bytesToString,
19   FeatureTest,
20   isNodeJS,
21   shadow,
22   string32,
23   unreachable,
24   warn,
25 } from "../shared/util.js";
26 
27 class FontLoader {
28   #systemFonts = new Set();
29 
30   constructor({
31     ownerDocument = globalThis.document,
32     styleElement = null, // For testing only.
33   }) {
34     this._document = ownerDocument;
35 
36     this.nativeFontFaces = new Set();
37     this.styleElement =
38       typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")
39         ? styleElement
40         : null;
41 
42     if (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) {
43       this.loadingRequests = [];
44       this.loadTestFontId = 0;
45     }
46   }
47 
48   addNativeFontFace(nativeFontFace) {
49     this.nativeFontFaces.add(nativeFontFace);
50     this._document.fonts.add(nativeFontFace);
51   }
52 
53   removeNativeFontFace(nativeFontFace) {
54     this.nativeFontFaces.delete(nativeFontFace);
55     this._document.fonts.delete(nativeFontFace);
56   }
57 
58   insertRule(rule) {
59     if (!this.styleElement) {
60       this.styleElement = this._document.createElement("style");
61       this._document.documentElement
62         .getElementsByTagName("head")[0]
63         .append(this.styleElement);
64     }
65     const styleSheet = this.styleElement.sheet;
66     styleSheet.insertRule(rule, styleSheet.cssRules.length);
67   }
68 
69   clear() {
70     for (const nativeFontFace of this.nativeFontFaces) {
71       this._document.fonts.delete(nativeFontFace);
72     }
73     this.nativeFontFaces.clear();
74     this.#systemFonts.clear();
75 
76     if (this.styleElement) {
77       // Note: ChildNode.remove doesn't throw if the parentNode is undefined.
78       this.styleElement.remove();
79       this.styleElement = null;
80     }
81   }
82 
83   async loadSystemFont({ systemFontInfo: info, _inspectFont }) {
84     if (!info || this.#systemFonts.has(info.loadedName)) {
85       return;
86     }
87     assert(
88       !this.disableFontFace,
89       "loadSystemFont shouldn't be called when `disableFontFace` is set."
90     );
91 
92     if (this.isFontLoadingAPISupported) {
93       const { loadedName, src, style } = info;
94       const fontFace = new FontFace(loadedName, src, style);
95       this.addNativeFontFace(fontFace);
96       try {
97         await fontFace.load();
98         this.#systemFonts.add(loadedName);
99         _inspectFont?.(info);
100       } catch {
101         warn(
102           `Cannot load system font: ${info.baseFontName}, installing it could help to improve PDF rendering.`
103         );
104 
105         this.removeNativeFontFace(fontFace);
106       }
107       return;
108     }
109 
110     unreachable(
111       "Not implemented: loadSystemFont without the Font Loading API."
112     );
113   }
114 
115   async bind(font) {
116     // Add the font to the DOM only once; skip if the font is already loaded.
117     if (font.attached || (font.missingFile && !font.systemFontInfo)) {
118       return;
119     }
120     font.attached = true;
121 
122     if (font.systemFontInfo) {
123       await this.loadSystemFont(font);
124       return;
125     }
126 
127     if (this.isFontLoadingAPISupported) {
128       const nativeFontFace = font.createNativeFontFace();
129       if (nativeFontFace) {
130         this.addNativeFontFace(nativeFontFace);
131         try {
132           await nativeFontFace.loaded;
133         } catch (ex) {
134           warn(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
135 
136           // When font loading failed, fall back to the built-in font renderer.
137           font.disableFontFace = true;
138           throw ex;
139         }
140       }
141       return; // The font was, asynchronously, loaded.
142     }
143 
144     // !this.isFontLoadingAPISupported
145     const rule = font.createFontFaceRule();
146     if (rule) {
147       this.insertRule(rule);
148 
149       if (this.isSyncFontLoadingSupported) {
150         return; // The font was, synchronously, loaded.
151       }
152       if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) {
153         throw new Error("Not implemented: async font loading");
154       }
155       await new Promise(resolve => {
156         const request = this._queueLoadingCallback(resolve);
157         this._prepareFontLoadEvent(font, request);
158       });
159       // The font was, asynchronously, loaded.
160     }
161   }
162 
163   get isFontLoadingAPISupported() {
164     const hasFonts = !!this._document?.fonts;
165     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
166       return shadow(
167         this,
168         "isFontLoadingAPISupported",
169         hasFonts && !this.styleElement
170       );
171     }
172     return shadow(this, "isFontLoadingAPISupported", hasFonts);
173   }
174 
175   get isSyncFontLoadingSupported() {
176     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) {
177       return shadow(this, "isSyncFontLoadingSupported", true);
178     }
179 
180     let supported = false;
181     if (typeof PDFJSDev === "undefined" || !PDFJSDev.test("CHROME")) {
182       if (isNodeJS) {
183         // Node.js - we can pretend that sync font loading is supported.
184         supported = true;
185       } else if (
186         typeof navigator !== "undefined" &&
187         // User agent string sniffing is bad, but there is no reliable way to
188         // tell if the font is fully loaded and ready to be used with canvas.
189         /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)
190       ) {
191         // Firefox, from version 14, supports synchronous font loading.
192         supported = true;
193       }
194     }
195     return shadow(this, "isSyncFontLoadingSupported", supported);
196   }
197 
198   _queueLoadingCallback(callback) {
199     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) {
200       throw new Error("Not implemented: _queueLoadingCallback");
201     }
202 
203     function completeRequest() {
204       assert(!request.done, "completeRequest() cannot be called twice.");
205       request.done = true;
206 
207       // Sending all completed requests in order of how they were queued.
208       while (loadingRequests.length > 0 && loadingRequests[0].done) {
209         const otherRequest = loadingRequests.shift();
210         setTimeout(otherRequest.callback, 0);
211       }
212     }
213 
214     const { loadingRequests } = this;
215     const request = {
216       done: false,
217       complete: completeRequest,
218       callback,
219     };
220     loadingRequests.push(request);
221     return request;
222   }
223 
224   get _loadTestFont() {
225     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) {
226       throw new Error("Not implemented: _loadTestFont");
227     }
228 
229     // This is a CFF font with 1 glyph for '.' that fills its entire width
230     // and height.
231     const testFont = atob(
232       "T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA" +
233         "FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA" +
234         "ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA" +
235         "AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1" +
236         "AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD" +
237         "6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM" +
238         "AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D" +
239         "IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA" +
240         "AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA" +
241         "AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB" +
242         "AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY" +
243         "AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA" +
244         "AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
245         "AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
246         "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
247         "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
248         "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
249         "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA" +
250         "AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC" +
251         "AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3" +
252         "Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj" +
253         "FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA=="
254     );
255     return shadow(this, "_loadTestFont", testFont);
256   }
257 
258   _prepareFontLoadEvent(font, request) {
259     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) {
260       throw new Error("Not implemented: _prepareFontLoadEvent");
261     }
262 
263     /** Hack begin */
264     // There's currently no event when a font has finished downloading so the
265     // following code is a dirty hack to 'guess' when a font is ready.
266     // It's assumed fonts are loaded in order, so add a known test font after
267     // the desired fonts and then test for the loading of that test font.
268 
269     function int32(data, offset) {
270       return (
271         (data.charCodeAt(offset) << 24) |
272         (data.charCodeAt(offset + 1) << 16) |
273         (data.charCodeAt(offset + 2) << 8) |
274         (data.charCodeAt(offset + 3) & 0xff)
275       );
276     }
277     function spliceString(s, offset, remove, insert) {
278       const chunk1 = s.substring(0, offset);
279       const chunk2 = s.substring(offset + remove);
280       return chunk1 + insert + chunk2;
281     }
282     let i, ii;
283 
284     // The temporary canvas is used to determine if fonts are loaded.
285     const canvas = this._document.createElement("canvas");
286     canvas.width = 1;
287     canvas.height = 1;
288     const ctx = canvas.getContext("2d");
289 
290     let called = 0;
291     function isFontReady(name, callback) {
292       // With setTimeout clamping this gives the font ~100ms to load.
293       if (++called > 30) {
294         warn("Load test font never loaded.");
295         callback();
296         return;
297       }
298       ctx.font = "30px " + name;
299       ctx.fillText(".", 0, 20);
300       const imageData = ctx.getImageData(0, 0, 1, 1);
301       if (imageData.data[3] > 0) {
302         callback();
303         return;
304       }
305       setTimeout(isFontReady.bind(null, name, callback));
306     }
307 
308     const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
309     // Chromium seems to cache fonts based on a hash of the actual font data,
310     // so the font must be modified for each load test else it will appear to
311     // be loaded already.
312     // TODO: This could maybe be made faster by avoiding the btoa of the full
313     // font by splitting it in chunks before hand and padding the font id.
314     let data = this._loadTestFont;
315     const COMMENT_OFFSET = 976; // has to be on 4 byte boundary (for checksum)
316     data = spliceString(
317       data,
318       COMMENT_OFFSET,
319       loadTestFontId.length,
320       loadTestFontId
321     );
322     // CFF checksum is important for IE, adjusting it
323     const CFF_CHECKSUM_OFFSET = 16;
324     const XXXX_VALUE = 0x58585858; // the "comment" filled with 'X'
325     let checksum = int32(data, CFF_CHECKSUM_OFFSET);
326     for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
327       checksum = (checksum - XXXX_VALUE + int32(loadTestFontId, i)) | 0;
328     }
329     if (i < loadTestFontId.length) {
330       // align to 4 bytes boundary
331       checksum = (checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i)) | 0;
332     }
333     data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));
334 
335     const url = `url(data:font/opentype;base64,${btoa(data)});`;
336     const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
337     this.insertRule(rule);
338 
339     const div = this._document.createElement("div");
340     div.style.visibility = "hidden";
341     div.style.width = div.style.height = "10px";
342     div.style.position = "absolute";
343     div.style.top = div.style.left = "0px";
344 
345     for (const name of [font.loadedName, loadTestFontId]) {
346       const span = this._document.createElement("span");
347       span.textContent = "Hi";
348       span.style.fontFamily = name;
349       div.append(span);
350     }
351     this._document.body.append(div);
352 
353     isFontReady(loadTestFontId, () => {
354       div.remove();
355       request.complete();
356     });
357     /** Hack end */
358   }
359 }
360 
361 class FontFaceObject {
362   constructor(
363     translatedData,
364     {
365       isEvalSupported = true,
366       disableFontFace = false,
367       ignoreErrors = false,
368       inspectFont = null,
369     }
370   ) {
371     this.compiledGlyphs = Object.create(null);
372     // importing translated data
373     for (const i in translatedData) {
374       this[i] = translatedData[i];
375     }
376     this.isEvalSupported = isEvalSupported !== false;
377     this.disableFontFace = disableFontFace === true;
378     this.ignoreErrors = ignoreErrors === true;
379     this._inspectFont = inspectFont;
380   }
381 
382   createNativeFontFace() {
383     if (!this.data || this.disableFontFace) {
384       return null;
385     }
386     let nativeFontFace;
387     if (!this.cssFontInfo) {
388       nativeFontFace = new FontFace(this.loadedName, this.data, {});
389     } else {
390       const css = {
391         weight: this.cssFontInfo.fontWeight,
392       };
393       if (this.cssFontInfo.italicAngle) {
394         css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
395       }
396       nativeFontFace = new FontFace(
397         this.cssFontInfo.fontFamily,
398         this.data,
399         css
400       );
401     }
402 
403     this._inspectFont?.(this);
404     return nativeFontFace;
405   }
406 
407   createFontFaceRule() {
408     if (!this.data || this.disableFontFace) {
409       return null;
410     }
411     const data = bytesToString(this.data);
412     // Add the @font-face rule to the document.
413     const url = `url(data:${this.mimetype};base64,${btoa(data)});`;
414     let rule;
415     if (!this.cssFontInfo) {
416       rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
417     } else {
418       let css = `font-weight: ${this.cssFontInfo.fontWeight};`;
419       if (this.cssFontInfo.italicAngle) {
420         css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
421       }
422       rule = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url}}`;
423     }
424 
425     this._inspectFont?.(this, url);
426     return rule;
427   }
428 
429   getPathGenerator(objs, character) {
430     if (this.compiledGlyphs[character] !== undefined) {
431       return this.compiledGlyphs[character];
432     }
433 
434     let cmds;
435     try {
436       cmds = objs.get(this.loadedName + "_path_" + character);
437     } catch (ex) {
438       if (!this.ignoreErrors) {
439         throw ex;
440       }
441       warn(`getPathGenerator - ignoring character: "${ex}".`);
442 
443       return (this.compiledGlyphs[character] = function (c, size) {
444         // No-op function, to allow rendering to continue.
445       });
446     }
447 
448     // If we can, compile cmds into JS for MAXIMUM SPEED...
449     if (this.isEvalSupported && FeatureTest.isEvalSupported) {
450       const jsBuf = [];
451       for (const current of cmds) {
452         const args = current.args !== undefined ? current.args.join(",") : "";
453         jsBuf.push("c.", current.cmd, "(", args, ");\n");
454       }
455       // eslint-disable-next-line no-new-func
456       return (this.compiledGlyphs[character] = new Function(
457         "c",
458         "size",
459         jsBuf.join("")
460       ));
461     }
462     // ... but fall back on using Function.prototype.apply() if we're
463     // blocked from using eval() for whatever reason (like CSP policies).
464     return (this.compiledGlyphs[character] = function (c, size) {
465       for (const current of cmds) {
466         if (current.cmd === "scale") {
467           current.args = [size, -size];
468         }
469         // eslint-disable-next-line prefer-spread
470         c[current.cmd].apply(c, current.args);
471       }
472     });
473   }
474 }
475 
476 export { FontFaceObject, FontLoader };
File:
src/shared/util.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 /* globals process */
16 
17 // NW.js / Electron is a browser context, but copies some Node.js objects; see
18 // http://docs.nwjs.io/en/latest/For%20Users/Advanced/JavaScript%20Contexts%20in%20NW.js/#access-nodejs-and-nwjs-api-in-browser-context
19 // https://www.electronjs.org/docs/api/process#processversionselectron-readonly
20 // https://www.electronjs.org/docs/api/process#processtype-readonly
21 const isNodeJS =
22   (typeof PDFJSDev === "undefined" || PDFJSDev.test("GENERIC")) &&
23   typeof process === "object" &&
24   process + "" === "[object process]" &&
25   !process.versions.nw &&
26   !(process.versions.electron && process.type && process.type !== "browser");
27 
28 const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
29 const FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
30 
31 const MAX_IMAGE_SIZE_TO_CACHE = 10e6; // Ten megabytes.
32 
33 // Represent the percentage of the height of a single-line field over
34 // the font size. Acrobat seems to use this value.
35 const LINE_FACTOR = 1.35;
36 const LINE_DESCENT_FACTOR = 0.35;
37 const BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;
38 
39 /**
40  * Refer to the `WorkerTransport.getRenderingIntent`-method in the API, to see
41  * how these flags are being used:
42  *  - ANY, DISPLAY, and PRINT are the normal rendering intents, note the
43  *    `PDFPageProxy.{render, getOperatorList, getAnnotations}`-methods.
44  *  - ANNOTATIONS_FORMS, ANNOTATIONS_STORAGE, ANNOTATIONS_DISABLE control which
45  *    annotations are rendered onto the canvas (i.e. by being included in the
46  *    operatorList), note the `PDFPageProxy.{render, getOperatorList}`-methods
47  *    and their `annotationMode`-option.
48  *  - OPLIST is used with the `PDFPageProxy.getOperatorList`-method, note the
49  *    `OperatorList`-constructor (on the worker-thread).
50  */
51 const RenderingIntentFlag = {
52   ANY: 0x01,
53   DISPLAY: 0x02,
54   PRINT: 0x04,
55   SAVE: 0x08,
56   ANNOTATIONS_FORMS: 0x10,
57   ANNOTATIONS_STORAGE: 0x20,
58   ANNOTATIONS_DISABLE: 0x40,
59   OPLIST: 0x100,
60 };
61 
62 const AnnotationMode = {
63   DISABLE: 0,
64   ENABLE: 1,
65   ENABLE_FORMS: 2,
66   ENABLE_STORAGE: 3,
67 };
68 
69 const AnnotationEditorPrefix = "pdfjs_internal_editor_";
70 
71 const AnnotationEditorType = {
72   DISABLE: -1,
73   NONE: 0,
74   FREETEXT: 3,
75   STAMP: 13,
76   INK: 15,
77 };
78 
79 const AnnotationEditorParamsType = {
80   RESIZE: 1,
81   CREATE: 2,
82   FREETEXT_SIZE: 11,
83   FREETEXT_COLOR: 12,
84   FREETEXT_OPACITY: 13,
85   INK_COLOR: 21,
86   INK_THICKNESS: 22,
87   INK_OPACITY: 23,
88 };
89 
90 // Permission flags from Table 22, Section 7.6.3.2 of the PDF specification.
91 const PermissionFlag = {
92   PRINT: 0x04,
93   MODIFY_CONTENTS: 0x08,
94   COPY: 0x10,
95   MODIFY_ANNOTATIONS: 0x20,
96   FILL_INTERACTIVE_FORMS: 0x100,
97   COPY_FOR_ACCESSIBILITY: 0x200,
98   ASSEMBLE: 0x400,
99   PRINT_HIGH_QUALITY: 0x800,
100 };
101 
102 const TextRenderingMode = {
103   FILL: 0,
104   STROKE: 1,
105   FILL_STROKE: 2,
106   INVISIBLE: 3,
107   FILL_ADD_TO_PATH: 4,
108   STROKE_ADD_TO_PATH: 5,
109   FILL_STROKE_ADD_TO_PATH: 6,
110   ADD_TO_PATH: 7,
111   FILL_STROKE_MASK: 3,
112   ADD_TO_PATH_FLAG: 4,
113 };
114 
115 const ImageKind = {
116   GRAYSCALE_1BPP: 1,
117   RGB_24BPP: 2,
118   RGBA_32BPP: 3,
119 };
120 
121 const AnnotationType = {
122   TEXT: 1,
123   LINK: 2,
124   FREETEXT: 3,
125   LINE: 4,
126   SQUARE: 5,
127   CIRCLE: 6,
128   POLYGON: 7,
129   POLYLINE: 8,
130   HIGHLIGHT: 9,
131   UNDERLINE: 10,
132   SQUIGGLY: 11,
133   STRIKEOUT: 12,
134   STAMP: 13,
135   CARET: 14,
136   INK: 15,
137   POPUP: 16,
138   FILEATTACHMENT: 17,
139   SOUND: 18,
140   MOVIE: 19,
141   WIDGET: 20,
142   SCREEN: 21,
143   PRINTERMARK: 22,
144   TRAPNET: 23,
145   WATERMARK: 24,
146   THREED: 25,
147   REDACT: 26,
148 };
149 
150 const AnnotationReplyType = {
151   GROUP: "Group",
152   REPLY: "R",
153 };
154 
155 const AnnotationFlag = {
156   INVISIBLE: 0x01,
157   HIDDEN: 0x02,
158   PRINT: 0x04,
159   NOZOOM: 0x08,
160   NOROTATE: 0x10,
161   NOVIEW: 0x20,
162   READONLY: 0x40,
163   LOCKED: 0x80,
164   TOGGLENOVIEW: 0x100,
165   LOCKEDCONTENTS: 0x200,
166 };
167 
168 const AnnotationFieldFlag = {
169   READONLY: 0x0000001,
170   REQUIRED: 0x0000002,
171   NOEXPORT: 0x0000004,
172   MULTILINE: 0x0001000,
173   PASSWORD: 0x0002000,
174   NOTOGGLETOOFF: 0x0004000,
175   RADIO: 0x0008000,
176   PUSHBUTTON: 0x0010000,
177   COMBO: 0x0020000,
178   EDIT: 0x0040000,
179   SORT: 0x0080000,
180   FILESELECT: 0x0100000,
181   MULTISELECT: 0x0200000,
182   DONOTSPELLCHECK: 0x0400000,
183   DONOTSCROLL: 0x0800000,
184   COMB: 0x1000000,
185   RICHTEXT: 0x2000000,
186   RADIOSINUNISON: 0x2000000,
187   COMMITONSELCHANGE: 0x4000000,
188 };
189 
190 const AnnotationBorderStyleType = {
191   SOLID: 1,
192   DASHED: 2,
193   BEVELED: 3,
194   INSET: 4,
195   UNDERLINE: 5,
196 };
197 
198 const AnnotationActionEventType = {
199   E: "Mouse Enter",
200   X: "Mouse Exit",
201   D: "Mouse Down",
202   U: "Mouse Up",
203   Fo: "Focus",
204   Bl: "Blur",
205   PO: "PageOpen",
206   PC: "PageClose",
207   PV: "PageVisible",
208   PI: "PageInvisible",
209   K: "Keystroke",
210   F: "Format",
211   V: "Validate",
212   C: "Calculate",
213 };
214 
215 const DocumentActionEventType = {
216   WC: "WillClose",
217   WS: "WillSave",
218   DS: "DidSave",
219   WP: "WillPrint",
220   DP: "DidPrint",
221 };
222 
223 const PageActionEventType = {
224   O: "PageOpen",
225   C: "PageClose",
226 };
227 
228 const VerbosityLevel = {
229   ERRORS: 0,
230   WARNINGS: 1,
231   INFOS: 5,
232 };
233 
234 const CMapCompressionType = {
235   NONE: 0,
236   BINARY: 1,
237 };
238 
239 // All the possible operations for an operator list.
240 const OPS = {
241   // Intentionally start from 1 so it is easy to spot bad operators that will be
242   // 0's.
243   // PLEASE NOTE: We purposely keep any removed operators commented out, since
244   //              re-numbering the list would risk breaking third-party users.
245   dependency: 1,
246   setLineWidth: 2,
247   setLineCap: 3,
248   setLineJoin: 4,
249   setMiterLimit: 5,
250   setDash: 6,
251   setRenderingIntent: 7,
252   setFlatness: 8,
253   setGState: 9,
254   save: 10,
255   restore: 11,
256   transform: 12,
257   moveTo: 13,
258   lineTo: 14,
259   curveTo: 15,
260   curveTo2: 16,
261   curveTo3: 17,
262   closePath: 18,
263   rectangle: 19,
264   stroke: 20,
265   closeStroke: 21,
266   fill: 22,
267   eoFill: 23,
268   fillStroke: 24,
269   eoFillStroke: 25,
270   closeFillStroke: 26,
271   closeEOFillStroke: 27,
272   endPath: 28,
273   clip: 29,
274   eoClip: 30,
275   beginText: 31,
276   endText: 32,
277   setCharSpacing: 33,
278   setWordSpacing: 34,
279   setHScale: 35,
280   setLeading: 36,
281   setFont: 37,
282   setTextRenderingMode: 38,
283   setTextRise: 39,
284   moveText: 40,
285   setLeadingMoveText: 41,
286   setTextMatrix: 42,
287   nextLine: 43,
288   showText: 44,
289   showSpacedText: 45,
290   nextLineShowText: 46,
291   nextLineSetSpacingShowText: 47,
292   setCharWidth: 48,
293   setCharWidthAndBounds: 49,
294   setStrokeColorSpace: 50,
295   setFillColorSpace: 51,
296   setStrokeColor: 52,
297   setStrokeColorN: 53,
298   setFillColor: 54,
299   setFillColorN: 55,
300   setStrokeGray: 56,
301   setFillGray: 57,
302   setStrokeRGBColor: 58,
303   setFillRGBColor: 59,
304   setStrokeCMYKColor: 60,
305   setFillCMYKColor: 61,
306   shadingFill: 62,
307   beginInlineImage: 63,
308   beginImageData: 64,
309   endInlineImage: 65,
310   paintXObject: 66,
311   markPoint: 67,
312   markPointProps: 68,
313   beginMarkedContent: 69,
314   beginMarkedContentProps: 70,
315   endMarkedContent: 71,
316   beginCompat: 72,
317   endCompat: 73,
318   paintFormXObjectBegin: 74,
319   paintFormXObjectEnd: 75,
320   beginGroup: 76,
321   endGroup: 77,
322   // beginAnnotations: 78,
323   // endAnnotations: 79,
324   beginAnnotation: 80,
325   endAnnotation: 81,
326   // paintJpegXObject: 82,
327   paintImageMaskXObject: 83,
328   paintImageMaskXObjectGroup: 84,
329   paintImageXObject: 85,
330   paintInlineImageXObject: 86,
331   paintInlineImageXObjectGroup: 87,
332   paintImageXObjectRepeat: 88,
333   paintImageMaskXObjectRepeat: 89,
334   paintSolidColorImageMask: 90,
335   constructPath: 91,
336 };
337 
338 const PasswordResponses = {
339   NEED_PASSWORD: 1,
340   INCORRECT_PASSWORD: 2,
341 };
342 
343 let verbosity = VerbosityLevel.WARNINGS;
344 
345 function setVerbosityLevel(level) {
346   if (Number.isInteger(level)) {
347     verbosity = level;
348   }
349 }
350 
351 function getVerbosityLevel() {
352   return verbosity;
353 }
354 
355 // A notice for devs. These are good for things that are helpful to devs, such
356 // as warning that Workers were disabled, which is important to devs but not
357 // end users.
358 function info(msg) {
359   if (verbosity >= VerbosityLevel.INFOS) {
360     console.log(`Info: ${msg}`);
361   }
362 }
363 
364 // Non-fatal warnings.
365 function warn(msg) {
366   if (verbosity >= VerbosityLevel.WARNINGS) {
367     console.log(`Warning: ${msg}`);
368   }
369 }
370 
371 function unreachable(msg) {
372   throw new Error(msg);
373 }
374 
375 function assert(cond, msg) {
376   if (!cond) {
377     unreachable(msg);
378   }
379 }
380 
381 // Checks if URLs use one of the allowed protocols, e.g. to avoid XSS.
382 function _isValidProtocol(url) {
383   switch (url?.protocol) {
384     case "http:":
385     case "https:":
386     case "ftp:":
387     case "mailto:":
388     case "tel:":
389       return true;
390     default:
391       return false;
392   }
393 }
394 
395 /**
396  * Attempts to create a valid absolute URL.
397  *
398  * @param {URL|string} url - An absolute, or relative, URL.
399  * @param {URL|string} [baseUrl] - An absolute URL.
400  * @param {Object} [options]
401  * @returns Either a valid {URL}, or `null` otherwise.
402  */
403 function createValidAbsoluteUrl(url, baseUrl = null, options = null) {
404   if (!url) {
405     return null;
406   }
407   try {
408     if (options && typeof url === "string") {
409       // Let URLs beginning with "www." default to using the "http://" protocol.
410       if (options.addDefaultProtocol && url.startsWith("www.")) {
411         const dots = url.match(/\./g);
412         // Avoid accidentally matching a *relative* URL pointing to a file named
413         // e.g. "www.pdf" or similar.
414         if (dots?.length >= 2) {
415           url = `http://${url}`;
416         }
417       }
418 
419       // According to ISO 32000-1:2008, section 12.6.4.7, URIs should be encoded
420       // in 7-bit ASCII. Some bad PDFs use UTF-8 encoding; see bug 1122280.
421       if (options.tryConvertEncoding) {
422         try {
423           url = stringToUTF8String(url);
424         } catch {}
425       }
426     }
427 
428     const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
429     if (_isValidProtocol(absoluteUrl)) {
430       return absoluteUrl;
431     }
432   } catch {
433     /* `new URL()` will throw on incorrect data. */
434   }
435   return null;
436 }
437 
438 function shadow(obj, prop, value, nonSerializable = false) {
439   if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
440     assert(
441       prop in obj,
442       `shadow: Property "${prop && prop.toString()}" not found in object.`
443     );
444   }
445   Object.defineProperty(obj, prop, {
446     value,
447     enumerable: !nonSerializable,
448     configurable: true,
449     writable: false,
450   });
451   return value;
452 }
453 
454 /**
455  * @type {any}
456  */
457 const BaseException = (function BaseExceptionClosure() {
458   // eslint-disable-next-line no-shadow
459   function BaseException(message, name) {
460     if (this.constructor === BaseException) {
461       unreachable("Cannot initialize BaseException.");
462     }
463     this.message = message;
464     this.name = name;
465   }
466   BaseException.prototype = new Error();
467   BaseException.constructor = BaseException;
468 
469   return BaseException;
470 })();
471 
472 class PasswordException extends BaseException {
473   constructor(msg, code) {
474     super(msg, "PasswordException");
475     this.code = code;
476   }
477 }
478 
479 class UnknownErrorException extends BaseException {
480   constructor(msg, details) {
481     super(msg, "UnknownErrorException");
482     this.details = details;
483   }
484 }
485 
486 class InvalidPDFException extends BaseException {
487   constructor(msg) {
488     super(msg, "InvalidPDFException");
489   }
490 }
491 
492 class MissingPDFException extends BaseException {
493   constructor(msg) {
494     super(msg, "MissingPDFException");
495   }
496 }
497 
498 class UnexpectedResponseException extends BaseException {
499   constructor(msg, status) {
500     super(msg, "UnexpectedResponseException");
501     this.status = status;
502   }
503 }
504 
505 /**
506  * Error caused during parsing PDF data.
507  */
508 class FormatError extends BaseException {
509   constructor(msg) {
510     super(msg, "FormatError");
511   }
512 }
513 
514 /**
515  * Error used to indicate task cancellation.
516  */
517 class AbortException extends BaseException {
518   constructor(msg) {
519     super(msg, "AbortException");
520   }
521 }
522 
523 function bytesToString(bytes) {
524   if (typeof bytes !== "object" || bytes?.length === undefined) {
525     unreachable("Invalid argument for bytesToString");
526   }
527   const length = bytes.length;
528   const MAX_ARGUMENT_COUNT = 8192;
529   if (length < MAX_ARGUMENT_COUNT) {
530     return String.fromCharCode.apply(null, bytes);
531   }
532   const strBuf = [];
533   for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
534     const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
535     const chunk = bytes.subarray(i, chunkEnd);
536     strBuf.push(String.fromCharCode.apply(null, chunk));
537   }
538   return strBuf.join("");
539 }
540 
541 function stringToBytes(str) {
542   if (typeof str !== "string") {
543     unreachable("Invalid argument for stringToBytes");
544   }
545   const length = str.length;
546   const bytes = new Uint8Array(length);
547   for (let i = 0; i < length; ++i) {
548     bytes[i] = str.charCodeAt(i) & 0xff;
549   }
550   return bytes;
551 }
552 
553 function string32(value) {
554   if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
555     assert(
556       typeof value === "number" && Math.abs(value) < 2 ** 32,
557       `string32: Unexpected input "${value}".`
558     );
559   }
560   return String.fromCharCode(
561     (value >> 24) & 0xff,
562     (value >> 16) & 0xff,
563     (value >> 8) & 0xff,
564     value & 0xff
565   );
566 }
567 
568 function objectSize(obj) {
569   return Object.keys(obj).length;
570 }
571 
572 // Ensure that the returned Object has a `null` prototype; hence why
573 // `Object.fromEntries(...)` is not used.
574 function objectFromMap(map) {
575   const obj = Object.create(null);
576   for (const [key, value] of map) {
577     obj[key] = value;
578   }
579   return obj;
580 }
581 
582 // Checks the endianness of the platform.
583 function isLittleEndian() {
584   const buffer8 = new Uint8Array(4);
585   buffer8[0] = 1;
586   const view32 = new Uint32Array(buffer8.buffer, 0, 1);
587   return view32[0] === 1;
588 }
589 
590 // Checks if it's possible to eval JS expressions.
591 function isEvalSupported() {
592   try {
593     new Function(""); // eslint-disable-line no-new, no-new-func
594     return true;
595   } catch {
596     return false;
597   }
598 }
599 
600 class FeatureTest {
601   static get isLittleEndian() {
602     return shadow(this, "isLittleEndian", isLittleEndian());
603   }
604 
605   static get isEvalSupported() {
606     return shadow(this, "isEvalSupported", isEvalSupported());
607   }
608 
609   static get isOffscreenCanvasSupported() {
610     return shadow(
611       this,
612       "isOffscreenCanvasSupported",
613       typeof OffscreenCanvas !== "undefined"
614     );
615   }
616 
617   static get platform() {
618     if (
619       (typeof PDFJSDev === "undefined" || PDFJSDev.test("GENERIC")) &&
620       typeof navigator === "undefined"
621     ) {
622       return shadow(this, "platform", { isMac: false });
623     }
624     return shadow(this, "platform", {
625       isMac: navigator.platform.includes("Mac"),
626     });
627   }
628 
629   static get isCSSRoundSupported() {
630     return shadow(
631       this,
632       "isCSSRoundSupported",
633       globalThis.CSS?.supports?.("width: round(1.5px, 1px)")
634     );
635   }
636 }
637 
638 const hexNumbers = [...Array(256).keys()].map(n =>
639   n.toString(16).padStart(2, "0")
640 );
641 
642 class Util {
643   static makeHexColor(r, g, b) {
644     return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
645   }
646 
647   // Apply a scaling matrix to some min/max values.
648   // If a scaling factor is negative then min and max must be
649   // swaped.
650   static scaleMinMax(transform, minMax) {
651     let temp;
652     if (transform[0]) {
653       if (transform[0] < 0) {
654         temp = minMax[0];
655         minMax[0] = minMax[1];
656         minMax[1] = temp;
657       }
658       minMax[0] *= transform[0];
659       minMax[1] *= transform[0];
660 
661       if (transform[3] < 0) {
662         temp = minMax[2];
663         minMax[2] = minMax[3];
664         minMax[3] = temp;
665       }
666       minMax[2] *= transform[3];
667       minMax[3] *= transform[3];
668     } else {
669       temp = minMax[0];
670       minMax[0] = minMax[2];
671       minMax[2] = temp;
672       temp = minMax[1];
673       minMax[1] = minMax[3];
674       minMax[3] = temp;
675 
676       if (transform[1] < 0) {
677         temp = minMax[2];
678         minMax[2] = minMax[3];
679         minMax[3] = temp;
680       }
681       minMax[2] *= transform[1];
682       minMax[3] *= transform[1];
683 
684       if (transform[2] < 0) {
685         temp = minMax[0];
686         minMax[0] = minMax[1];
687         minMax[1] = temp;
688       }
689       minMax[0] *= transform[2];
690       minMax[1] *= transform[2];
691     }
692     minMax[0] += transform[4];
693     minMax[1] += transform[4];
694     minMax[2] += transform[5];
695     minMax[3] += transform[5];
696   }
697 
698   // Concatenates two transformation matrices together and returns the result.
699   static transform(m1, m2) {
700     return [
701       m1[0] * m2[0] + m1[2] * m2[1],
702       m1[1] * m2[0] + m1[3] * m2[1],
703       m1[0] * m2[2] + m1[2] * m2[3],
704       m1[1] * m2[2] + m1[3] * m2[3],
705       m1[0] * m2[4] + m1[2] * m2[5] + m1[4],
706       m1[1] * m2[4] + m1[3] * m2[5] + m1[5],
707     ];
708   }
709 
710   // For 2d affine transforms
711   static applyTransform(p, m) {
712     const xt = p[0] * m[0] + p[1] * m[2] + m[4];
713     const yt = p[0] * m[1] + p[1] * m[3] + m[5];
714     return [xt, yt];
715   }
716 
717   static applyInverseTransform(p, m) {
718     const d = m[0] * m[3] - m[1] * m[2];
719     const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
720     const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
721     return [xt, yt];
722   }
723 
724   // Applies the transform to the rectangle and finds the minimum axially
725   // aligned bounding box.
726   static getAxialAlignedBoundingBox(r, m) {
727     const p1 = this.applyTransform(r, m);
728     const p2 = this.applyTransform(r.slice(2, 4), m);
729     const p3 = this.applyTransform([r[0], r[3]], m);
730     const p4 = this.applyTransform([r[2], r[1]], m);
731     return [
732       Math.min(p1[0], p2[0], p3[0], p4[0]),
733       Math.min(p1[1], p2[1], p3[1], p4[1]),
734       Math.max(p1[0], p2[0], p3[0], p4[0]),
735       Math.max(p1[1], p2[1], p3[1], p4[1]),
736     ];
737   }
738 
739   static inverseTransform(m) {
740     const d = m[0] * m[3] - m[1] * m[2];
741     return [
742       m[3] / d,
743       -m[1] / d,
744       -m[2] / d,
745       m[0] / d,
746       (m[2] * m[5] - m[4] * m[3]) / d,
747       (m[4] * m[1] - m[5] * m[0]) / d,
748     ];
749   }
750 
751   // This calculation uses Singular Value Decomposition.
752   // The SVD can be represented with formula A = USV. We are interested in the
753   // matrix S here because it represents the scale values.
754   static singularValueDecompose2dScale(m) {
755     const transpose = [m[0], m[2], m[1], m[3]];
756 
757     // Multiply matrix m with its transpose.
758     const a = m[0] * transpose[0] + m[1] * transpose[2];
759     const b = m[0] * transpose[1] + m[1] * transpose[3];
760     const c = m[2] * transpose[0] + m[3] * transpose[2];
761     const d = m[2] * transpose[1] + m[3] * transpose[3];
762 
763     // Solve the second degree polynomial to get roots.
764     const first = (a + d) / 2;
765     const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;
766     const sx = first + second || 1;
767     const sy = first - second || 1;
768 
769     // Scale values are the square roots of the eigenvalues.
770     return [Math.sqrt(sx), Math.sqrt(sy)];
771   }
772 
773   // Normalize rectangle rect=[x1, y1, x2, y2] so that (x1,y1) < (x2,y2)
774   // For coordinate systems whose origin lies in the bottom-left, this
775   // means normalization to (BL,TR) ordering. For systems with origin in the
776   // top-left, this means (TL,BR) ordering.
777   static normalizeRect(rect) {
778     const r = rect.slice(0); // clone rect
779     if (rect[0] > rect[2]) {
780       r[0] = rect[2];
781       r[2] = rect[0];
782     }
783     if (rect[1] > rect[3]) {
784       r[1] = rect[3];
785       r[3] = rect[1];
786     }
787     return r;
788   }
789 
790   // Returns a rectangle [x1, y1, x2, y2] corresponding to the
791   // intersection of rect1 and rect2. If no intersection, returns 'null'
792   // The rectangle coordinates of rect1, rect2 should be [x1, y1, x2, y2]
793   static intersect(rect1, rect2) {
794     const xLow = Math.max(
795       Math.min(rect1[0], rect1[2]),
796       Math.min(rect2[0], rect2[2])
797     );
798     const xHigh = Math.min(
799       Math.max(rect1[0], rect1[2]),
800       Math.max(rect2[0], rect2[2])
801     );
802     if (xLow > xHigh) {
803       return null;
804     }
805     const yLow = Math.max(
806       Math.min(rect1[1], rect1[3]),
807       Math.min(rect2[1], rect2[3])
808     );
809     const yHigh = Math.min(
810       Math.max(rect1[1], rect1[3]),
811       Math.max(rect2[1], rect2[3])
812     );
813     if (yLow > yHigh) {
814       return null;
815     }
816 
817     return [xLow, yLow, xHigh, yHigh];
818   }
819 
820   // From https://github.com/adobe-webplatform/Snap.svg/blob/b365287722a72526000ac4bfcf0ce4cac2faa015/src/path.js#L852
821   static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {
822     const tvalues = [],
823       bounds = [[], []];
824     let a, b, c, t, t1, t2, b2ac, sqrtb2ac;
825     for (let i = 0; i < 2; ++i) {
826       if (i === 0) {
827         b = 6 * x0 - 12 * x1 + 6 * x2;
828         a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
829         c = 3 * x1 - 3 * x0;
830       } else {
831         b = 6 * y0 - 12 * y1 + 6 * y2;
832         a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
833         c = 3 * y1 - 3 * y0;
834       }
835       if (Math.abs(a) < 1e-12) {
836         if (Math.abs(b) < 1e-12) {
837           continue;
838         }
839         t = -c / b;
840         if (0 < t && t < 1) {
841           tvalues.push(t);
842         }
843         continue;
844       }
845       b2ac = b * b - 4 * c * a;
846       sqrtb2ac = Math.sqrt(b2ac);
847       if (b2ac < 0) {
848         continue;
849       }
850       t1 = (-b + sqrtb2ac) / (2 * a);
851       if (0 < t1 && t1 < 1) {
852         tvalues.push(t1);
853       }
854       t2 = (-b - sqrtb2ac) / (2 * a);
855       if (0 < t2 && t2 < 1) {
856         tvalues.push(t2);
857       }
858     }
859 
860     let j = tvalues.length,
861       mt;
862     const jlen = j;
863     while (j--) {
864       t = tvalues[j];
865       mt = 1 - t;
866       bounds[0][j] =
867         mt * mt * mt * x0 +
868         3 * mt * mt * t * x1 +
869         3 * mt * t * t * x2 +
870         t * t * t * x3;
871       bounds[1][j] =
872         mt * mt * mt * y0 +
873         3 * mt * mt * t * y1 +
874         3 * mt * t * t * y2 +
875         t * t * t * y3;
876     }
877 
878     bounds[0][jlen] = x0;
879     bounds[1][jlen] = y0;
880     bounds[0][jlen + 1] = x3;
881     bounds[1][jlen + 1] = y3;
882     bounds[0].length = bounds[1].length = jlen + 2;
883 
884     return [
885       Math.min(...bounds[0]),
886       Math.min(...bounds[1]),
887       Math.max(...bounds[0]),
888       Math.max(...bounds[1]),
889     ];
890   }
891 }
892 
893 const PDFStringTranslateTable = [
894   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8,
895   0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
896   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
897   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
898   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
899   0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192,
900   0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018,
901   0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d,
902   0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac,
903 ];
904 
905 function stringToPDFString(str) {
906   if (str[0] >= "\xEF") {
907     let encoding;
908     if (str[0] === "\xFE" && str[1] === "\xFF") {
909       encoding = "utf-16be";
910     } else if (str[0] === "\xFF" && str[1] === "\xFE") {
911       encoding = "utf-16le";
912     } else if (str[0] === "\xEF" && str[1] === "\xBB" && str[2] === "\xBF") {
913       encoding = "utf-8";
914     }
915 
916     if (encoding) {
917       try {
918         const decoder = new TextDecoder(encoding, { fatal: true });
919         const buffer = stringToBytes(str);
920         return decoder.decode(buffer);
921       } catch (ex) {
922         warn(`stringToPDFString: "${ex}".`);
923       }
924     }
925   }
926   // ISO Latin 1
927   const strBuf = [];
928   for (let i = 0, ii = str.length; i < ii; i++) {
929     const code = PDFStringTranslateTable[str.charCodeAt(i)];
930     strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
931   }
932   return strBuf.join("");
933 }
934 
935 function stringToUTF8String(str) {
936   return decodeURIComponent(escape(str));
937 }
938 
939 function utf8StringToString(str) {
940   return unescape(encodeURIComponent(str));
941 }
942 
943 function isArrayBuffer(v) {
944   return typeof v === "object" && v?.byteLength !== undefined;
945 }
946 
947 function isArrayEqual(arr1, arr2) {
948   if (arr1.length !== arr2.length) {
949     return false;
950   }
951   for (let i = 0, ii = arr1.length; i < ii; i++) {
952     if (arr1[i] !== arr2[i]) {
953       return false;
954     }
955   }
956   return true;
957 }
958 
959 function getModificationDate(date = new Date()) {
960   const buffer = [
961     date.getUTCFullYear().toString(),
962     (date.getUTCMonth() + 1).toString().padStart(2, "0"),
963     date.getUTCDate().toString().padStart(2, "0"),
964     date.getUTCHours().toString().padStart(2, "0"),
965     date.getUTCMinutes().toString().padStart(2, "0"),
966     date.getUTCSeconds().toString().padStart(2, "0"),
967   ];
968 
969   return buffer.join("");
970 }
971 
972 class PromiseCapability {
973   #settled = false;
974 
975   constructor() {
976     /**
977      * @type {Promise<any>} The Promise object.
978      */
979     this.promise = new Promise((resolve, reject) => {
980       /**
981        * @type {function} Fulfills the Promise.
982        */
983       this.resolve = data => {
984         this.#settled = true;
985         resolve(data);
986       };
987 
988       /**
989        * @type {function} Rejects the Promise.
990        */
991       this.reject = reason => {
992         if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
993           assert(reason instanceof Error, 'Expected valid "reason" argument.');
994         }
995         this.#settled = true;
996         reject(reason);
997       };
998     });
999   }
1000 
1001   /**
1002    * @type {boolean} If the Promise has been fulfilled/rejected.
1003    */
1004   get settled() {
1005     return this.#settled;
1006   }
1007 }
1008 
1009 let NormalizeRegex = null;
1010 let NormalizationMap = null;
1011 function normalizeUnicode(str) {
1012   if (!NormalizeRegex) {
1013     // In order to generate the following regex:
1014     //  - create a PDF containing all the chars in the range 0000-FFFF with
1015     //    a NFKC which is different of the char.
1016     //  - copy and paste all those chars and get the ones where NFKC is
1017     //    required.
1018     // It appears that most the chars here contain some ligatures.
1019     NormalizeRegex =
1020       /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
1021     NormalizationMap = new Map([["ﬅ", "ſt"]]);
1022   }
1023   return str.replaceAll(NormalizeRegex, (_, p1, p2) => {
1024     return p1 ? p1.normalize("NFKC") : NormalizationMap.get(p2);
1025   });
1026 }
1027 
1028 function getUuid() {
1029   if (
1030     (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) ||
1031     (typeof crypto !== "undefined" && typeof crypto?.randomUUID === "function")
1032   ) {
1033     return crypto.randomUUID();
1034   }
1035   const buf = new Uint8Array(32);
1036   if (
1037     typeof crypto !== "undefined" &&
1038     typeof crypto?.getRandomValues === "function"
1039   ) {
1040     crypto.getRandomValues(buf);
1041   } else {
1042     for (let i = 0; i < 32; i++) {
1043       buf[i] = Math.floor(Math.random() * 255);
1044     }
1045   }
1046   return bytesToString(buf);
1047 }
1048 
1049 const AnnotationPrefix = "pdfjs_internal_id_";
1050 
1051 export {
1052   AbortException,
1053   AnnotationActionEventType,
1054   AnnotationBorderStyleType,
1055   AnnotationEditorParamsType,
1056   AnnotationEditorPrefix,
1057   AnnotationEditorType,
1058   AnnotationFieldFlag,
1059   AnnotationFlag,
1060   AnnotationMode,
1061   AnnotationPrefix,
1062   AnnotationReplyType,
1063   AnnotationType,
1064   assert,
1065   BaseException,
1066   BASELINE_FACTOR,
1067   bytesToString,
1068   CMapCompressionType,
1069   createValidAbsoluteUrl,
1070   DocumentActionEventType,
1071   FeatureTest,
1072   FONT_IDENTITY_MATRIX,
1073   FormatError,
1074   getModificationDate,
1075   getUuid,
1076   getVerbosityLevel,
1077   IDENTITY_MATRIX,
1078   ImageKind,
1079   info,
1080   InvalidPDFException,
1081   isArrayBuffer,
1082   isArrayEqual,
1083   isNodeJS,
1084   LINE_DESCENT_FACTOR,
1085   LINE_FACTOR,
1086   MAX_IMAGE_SIZE_TO_CACHE,
1087   MissingPDFException,
1088   normalizeUnicode,
1089   objectFromMap,
1090   objectSize,
1091   OPS,
1092   PageActionEventType,
1093   PasswordException,
1094   PasswordResponses,
1095   PermissionFlag,
1096   PromiseCapability,
1097   RenderingIntentFlag,
1098   setVerbosityLevel,
1099   shadow,
1100   string32,
1101   stringToBytes,
1102   stringToPDFString,
1103   stringToUTF8String,
1104   TextRenderingMode,
1105   UnexpectedResponseException,
1106   UnknownErrorException,
1107   unreachable,
1108   utf8StringToString,
1109   Util,
1110   VerbosityLevel,
1111   warn,
1112 };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

