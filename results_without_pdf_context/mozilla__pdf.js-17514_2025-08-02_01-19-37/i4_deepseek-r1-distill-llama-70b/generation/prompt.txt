Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Single point ink annotation doesn't show on Chrome pdf viewer
Configuration:
- Web browser and its version: Firefox 115.5.0esr  / Chrome 120.0.6099.71
- Operating system and its version: Ubuntu 22.04
- PDF.js version: 4.0.347
- Is a browser extension: No

Steps to reproduce the problem:
1. Open the [viewer](https://mozilla.github.io/pdf.js/web/viewer.html).
2. Draw a single point annotation (not a line) with the ink tool.
3. Save the pdf.
4. Open the pdf in a Chrome tab.

What is the expected behavior?
The point ink annotation should be visible

What went wrong?
The point ink annotation doesn't show on Chrome.

Is it a bug in the Chrome pdf viewer? Is there a way to draw a circle annotation instead of a single point line?
</issue>

Patch:
<patch>
diff --git a/src/core/annotation.js b/src/core/annotation.js
--- a/src/core/annotation.js
+++ b/src/core/annotation.js
@@ -4397,14 +4397,20 @@ class InkAnnotation extends MarkupAnnotation {
       buffer.push(
         `${numberToString(bezier[0])} ${numberToString(bezier[1])} m`
       );
-      for (let i = 2, ii = bezier.length; i < ii; i += 6) {
-        const curve = bezier
-          .slice(i, i + 6)
-          .map(numberToString)
-          .join(" ");
-        buffer.push(`${curve} c`);
+      if (bezier.length === 2) {
+        buffer.push(
+          `${numberToString(bezier[0])} ${numberToString(bezier[1])} l S`
+        );
+      } else {
+        for (let i = 2, ii = bezier.length; i < ii; i += 6) {
+          const curve = bezier
+            .slice(i, i + 6)
+            .map(numberToString)
+            .join(" ");
+          buffer.push(`${curve} c`);
+        }
+        buffer.push("S");
       }
-      buffer.push("S");
       appearanceBuffer.push(buffer.join("\n"));
     }
     const appearance = appearanceBuffer.join("\n");

diff --git a/src/display/editor/ink.js b/src/display/editor/ink.js
--- a/src/display/editor/ink.js
+++ b/src/display/editor/ink.js
@@ -628,7 +628,7 @@ class InkEditor extends AnnotationEditor {
 
     this.parent.addInkEditorIfNeeded(/* isCommitting = */ true);
 
-    // When commiting, the position of this editor is changed, hence we must
+    // When committing, the position of this editor is changed, hence we must
     // move it to the right position in the DOM.
     this.moveInDOM();
     this.div.focus({
@@ -994,6 +994,14 @@ class InkEditor extends AnnotationEditor {
       const points = [];
       for (let j = 0, jj = bezier.length; j < jj; j++) {
         const [first, control1, control2, second] = bezier[j];
+        if (first[0] === second[0] && first[1] === second[1] && jj === 1) {
+          // We have only one point.
+          const p0 = s * first[0] + shiftX;
+          const p1 = s * first[1] + shiftY;
+          buffer.push(p0, p1);
+          points.push(p0, p1);
+          break;
+        }
         const p10 = s * first[0] + shiftX;
         const p11 = s * first[1] + shiftY;
         const p20 = s * control1[0] + shiftX;


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.23.7
- @babel/preset-env: ^7.23.7
- @babel/runtime: ^7.23.7
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.9.0
- @javascript-obfuscator/escodegen: 2.3.0
- @jazzer.js/core: ^2.1.0
- acorn: ^8.11.3
- autoprefixer: ^10.4.16
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001574
- canvas: ^2.11.2
- core-js: ^3.35.0
- cross-env: ^7.0.3
- eslint: ^8.56.0
- eslint-config-prettier: ^8.10.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.29.1
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.3.2
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.1.2
- eslint-plugin-sort-exports: ^0.8.0
- eslint-plugin-unicorn: ^50.0.1
- globals: ^13.24.0
- gulp: ^4.0.2
- gulp-cli: ^2.3.0
- gulp-postcss: ^9.0.1
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.3.1
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.33
- postcss-dark-theme-class: ^1.1.0
- postcss-dir-pseudo-class: ^8.0.1
- postcss-discard-comments: ^6.0.1
- postcss-nesting: ^12.0.2
- prettier: ^3.1.1
- puppeteer: ^21.7.0
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^16.1.0
- stylelint-prettier: ^5.0.0
- terser: ^5.26.0
- through2: ^4.0.2
- tsc-alias: ^1.8.8
- ttest: ^4.0.0
- typescript: ^5.3.3
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.89.0
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/outliner.js`: Outliner
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isArrayBuffer, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/l10n.js`: L10n
- `../../web/l10n_utils.js`: NullL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/annotation.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AnnotationActionEventType,
18   AnnotationBorderStyleType,
19   AnnotationEditorType,
20   AnnotationFieldFlag,
21   AnnotationFlag,
22   AnnotationReplyType,
23   AnnotationType,
24   assert,
25   BASELINE_FACTOR,
26   FeatureTest,
27   getModificationDate,
28   IDENTITY_MATRIX,
29   info,
30   LINE_DESCENT_FACTOR,
31   LINE_FACTOR,
32   OPS,
33   RenderingIntentFlag,
34   shadow,
35   stringToPDFString,
36   unreachable,
37   Util,
38   warn,
39 } from "../shared/util.js";
40 import {
41   collectActions,
42   escapeString,
43   getInheritableProperty,
44   getRotationMatrix,
45   isAscii,
46   numberToString,
47   stringToUTF16String,
48 } from "./core_utils.js";
49 import {
50   createDefaultAppearance,
51   FakeUnicodeFont,
52   getPdfColor,
53   parseAppearanceStream,
54   parseDefaultAppearance,
55 } from "./default_appearance.js";
56 import { Dict, isName, isRefsEqual, Name, Ref, RefSet } from "./primitives.js";
57 import { Stream, StringStream } from "./stream.js";
58 import { BaseStream } from "./base_stream.js";
59 import { bidi } from "./bidi.js";
60 import { Catalog } from "./catalog.js";
61 import { ColorSpace } from "./colorspace.js";
62 import { FileSpec } from "./file_spec.js";
63 import { JpegStream } from "./jpeg_stream.js";
64 import { ObjectLoader } from "./object_loader.js";
65 import { OperatorList } from "./operator_list.js";
66 import { writeObject } from "./writer.js";
67 import { XFAFactory } from "./xfa/factory.js";
68 
69 class AnnotationFactory {
70   static createGlobals(pdfManager) {
71     return Promise.all([
72       pdfManager.ensureCatalog("acroForm"),
73       pdfManager.ensureDoc("xfaDatasets"),
74       pdfManager.ensureCatalog("structTreeRoot"),
75       // Only necessary to prevent the `Catalog.baseUrl`-getter, used
76       // with some Annotations, from throwing and thus breaking parsing:
77       pdfManager.ensureCatalog("baseUrl"),
78       // Only necessary to prevent the `Catalog.attachments`-getter, used
79       // with "GoToE" actions, from throwing and thus breaking parsing:
80       pdfManager.ensureCatalog("attachments"),
81     ]).then(
82       ([acroForm, xfaDatasets, structTreeRoot, baseUrl, attachments]) => {
83         return {
84           pdfManager,
85           acroForm: acroForm instanceof Dict ? acroForm : Dict.empty,
86           xfaDatasets,
87           structTreeRoot,
88           baseUrl,
89           attachments,
90         };
91       },
92       reason => {
93         warn(`createGlobals: "${reason}".`);
94         return null;
95       }
96     );
97   }
98 
99   /**
100    * Create an `Annotation` object of the correct type for the given reference
101    * to an annotation dictionary. This yields a promise that is resolved when
102    * the `Annotation` object is constructed.
103    *
104    * @param {XRef} xref
105    * @param {Object} ref
106    * @params {Object} annotationGlobals
107    * @param {Object} idFactory
108    * @param {boolean} [collectFields]
109    * @param {Object} [pageRef]
110    * @returns {Promise} A promise that is resolved with an {Annotation}
111    *   instance.
112    */
113   static async create(
114     xref,
115     ref,
116     annotationGlobals,
117     idFactory,
118     collectFields,
119     pageRef
120   ) {
121     const pageIndex = collectFields
122       ? await this._getPageIndex(xref, ref, annotationGlobals.pdfManager)
123       : null;
124 
125     return annotationGlobals.pdfManager.ensure(this, "_create", [
126       xref,
127       ref,
128       annotationGlobals,
129       idFactory,
130       collectFields,
131       pageIndex,
132       pageRef,
133     ]);
134   }
135 
136   /**
137    * @private
138    */
139   static _create(
140     xref,
141     ref,
142     annotationGlobals,
143     idFactory,
144     collectFields = false,
145     pageIndex = null,
146     pageRef = null
147   ) {
148     const dict = xref.fetchIfRef(ref);
149     if (!(dict instanceof Dict)) {
150       return undefined;
151     }
152 
153     const { acroForm, pdfManager } = annotationGlobals;
154     const id =
155       ref instanceof Ref ? ref.toString() : `annot_${idFactory.createObjId()}`;
156 
157     // Determine the annotation's subtype.
158     let subtype = dict.get("Subtype");
159     subtype = subtype instanceof Name ? subtype.name : null;
160 
161     // Return the right annotation object based on the subtype and field type.
162     const parameters = {
163       xref,
164       ref,
165       dict,
166       subtype,
167       id,
168       annotationGlobals,
169       collectFields,
170       needAppearances:
171         !collectFields && acroForm.get("NeedAppearances") === true,
172       pageIndex,
173       evaluatorOptions: pdfManager.evaluatorOptions,
174       pageRef,
175     };
176 
177     switch (subtype) {
178       case "Link":
179         return new LinkAnnotation(parameters);
180 
181       case "Text":
182         return new TextAnnotation(parameters);
183 
184       case "Widget":
185         let fieldType = getInheritableProperty({ dict, key: "FT" });
186         fieldType = fieldType instanceof Name ? fieldType.name : null;
187 
188         switch (fieldType) {
189           case "Tx":
190             return new TextWidgetAnnotation(parameters);
191           case "Btn":
192             return new ButtonWidgetAnnotation(parameters);
193           case "Ch":
194             return new ChoiceWidgetAnnotation(parameters);
195           case "Sig":
196             return new SignatureWidgetAnnotation(parameters);
197         }
198         warn(
199           `Unimplemented widget field type "${fieldType}", ` +
200             "falling back to base field type."
201         );
202         return new WidgetAnnotation(parameters);
203 
204       case "Popup":
205         return new PopupAnnotation(parameters);
206 
207       case "FreeText":
208         return new FreeTextAnnotation(parameters);
209 
210       case "Line":
211         return new LineAnnotation(parameters);
212 
213       case "Square":
214         return new SquareAnnotation(parameters);
215 
216       case "Circle":
217         return new CircleAnnotation(parameters);
218 
219       case "PolyLine":
220         return new PolylineAnnotation(parameters);
221 
222       case "Polygon":
223         return new PolygonAnnotation(parameters);
224 
225       case "Caret":
226         return new CaretAnnotation(parameters);
227 
228       case "Ink":
229         return new InkAnnotation(parameters);
230 
231       case "Highlight":
232         return new HighlightAnnotation(parameters);
233 
234       case "Underline":
235         return new UnderlineAnnotation(parameters);
236 
237       case "Squiggly":
238         return new SquigglyAnnotation(parameters);
239 
240       case "StrikeOut":
241         return new StrikeOutAnnotation(parameters);
242 
243       case "Stamp":
244         return new StampAnnotation(parameters);
245 
246       case "FileAttachment":
247         return new FileAttachmentAnnotation(parameters);
248 
249       default:
250         if (!collectFields) {
251           if (!subtype) {
252             warn("Annotation is missing the required /Subtype.");
253           } else {
254             warn(
255               `Unimplemented annotation type "${subtype}", ` +
256                 "falling back to base annotation."
257             );
258           }
259         }
260         return new Annotation(parameters);
261     }
262   }
263 
264   static async _getPageIndex(xref, ref, pdfManager) {
265     try {
266       const annotDict = await xref.fetchIfRefAsync(ref);
267       if (!(annotDict instanceof Dict)) {
268         return -1;
269       }
270       const pageRef = annotDict.getRaw("P");
271       if (pageRef instanceof Ref) {
272         try {
273           const pageIndex = await pdfManager.ensureCatalog("getPageIndex", [
274             pageRef,
275           ]);
276           return pageIndex;
277         } catch (ex) {
278           info(`_getPageIndex -- not a valid page reference: "${ex}".`);
279         }
280       }
281       if (annotDict.has("Kids")) {
282         return -1; // Not an annotation reference.
283       }
284       // Fallback to, potentially, checking the annotations of all pages.
285       // PLEASE NOTE: This could force the *entire* PDF document to load,
286       //              hence it absolutely cannot be done unconditionally.
287       const numPages = await pdfManager.ensureDoc("numPages");
288 
289       for (let pageIndex = 0; pageIndex < numPages; pageIndex++) {
290         const page = await pdfManager.getPage(pageIndex);
291         const annotations = await pdfManager.ensure(page, "annotations");
292 
293         for (const annotRef of annotations) {
294           if (annotRef instanceof Ref && isRefsEqual(annotRef, ref)) {
295             return pageIndex;
296           }
297         }
298       }
299     } catch (ex) {
300       warn(`_getPageIndex: "${ex}".`);
301     }
302     return -1;
303   }
304 
305   static generateImages(annotations, xref, isOffscreenCanvasSupported) {
306     if (!isOffscreenCanvasSupported) {
307       warn(
308         "generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images."
309       );
310       return null;
311     }
312     let imagePromises;
313     for (const { bitmapId, bitmap } of annotations) {
314       if (!bitmap) {
315         continue;
316       }
317       imagePromises ||= new Map();
318       imagePromises.set(bitmapId, StampAnnotation.createImage(bitmap, xref));
319     }
320 
321     return imagePromises;
322   }
323 
324   static async saveNewAnnotations(evaluator, task, annotations, imagePromises) {
325     const xref = evaluator.xref;
326     let baseFontRef;
327     const dependencies = [];
328     const promises = [];
329     const { isOffscreenCanvasSupported } = evaluator.options;
330 
331     for (const annotation of annotations) {
332       if (annotation.deleted) {
333         continue;
334       }
335       switch (annotation.annotationType) {
336         case AnnotationEditorType.FREETEXT:
337           if (!baseFontRef) {
338             const baseFont = new Dict(xref);
339             baseFont.set("BaseFont", Name.get("Helvetica"));
340             baseFont.set("Type", Name.get("Font"));
341             baseFont.set("Subtype", Name.get("Type1"));
342             baseFont.set("Encoding", Name.get("WinAnsiEncoding"));
343             const buffer = [];
344             baseFontRef = xref.getNewTemporaryRef();
345             await writeObject(baseFontRef, baseFont, buffer, xref);
346             dependencies.push({ ref: baseFontRef, data: buffer.join("") });
347           }
348           promises.push(
349             FreeTextAnnotation.createNewAnnotation(
350               xref,
351               annotation,
352               dependencies,
353               { evaluator, task, baseFontRef }
354             )
355           );
356           break;
357         case AnnotationEditorType.HIGHLIGHT:
358           promises.push(
359             HighlightAnnotation.createNewAnnotation(
360               xref,
361               annotation,
362               dependencies
363             )
364           );
365           break;
366         case AnnotationEditorType.INK:
367           promises.push(
368             InkAnnotation.createNewAnnotation(xref, annotation, dependencies)
369           );
370           break;
371         case AnnotationEditorType.STAMP:
372           if (!isOffscreenCanvasSupported) {
373             break;
374           }
375           const image = await imagePromises.get(annotation.bitmapId);
376           if (image.imageStream) {
377             const { imageStream, smaskStream } = image;
378             const buffer = [];
379             if (smaskStream) {
380               const smaskRef = xref.getNewTemporaryRef();
381               await writeObject(smaskRef, smaskStream, buffer, xref);
382               dependencies.push({ ref: smaskRef, data: buffer.join("") });
383               imageStream.dict.set("SMask", smaskRef);
384               buffer.length = 0;
385             }
386             const imageRef = (image.imageRef = xref.getNewTemporaryRef());
387             await writeObject(imageRef, imageStream, buffer, xref);
388             dependencies.push({ ref: imageRef, data: buffer.join("") });
389             image.imageStream = image.smaskStream = null;
390           }
391           promises.push(
392             StampAnnotation.createNewAnnotation(
393               xref,
394               annotation,
395               dependencies,
396               { image }
397             )
398           );
399           break;
400       }
401     }
402 
403     return {
404       annotations: await Promise.all(promises),
405       dependencies,
406     };
407   }
408 
409   static async printNewAnnotations(
410     annotationGlobals,
411     evaluator,
412     task,
413     annotations,
414     imagePromises
415   ) {
416     if (!annotations) {
417       return null;
418     }
419 
420     const { options, xref } = evaluator;
421     const promises = [];
422     for (const annotation of annotations) {
423       if (annotation.deleted) {
424         continue;
425       }
426       switch (annotation.annotationType) {
427         case AnnotationEditorType.FREETEXT:
428           promises.push(
429             FreeTextAnnotation.createNewPrintAnnotation(
430               annotationGlobals,
431               xref,
432               annotation,
433               {
434                 evaluator,
435                 task,
436                 evaluatorOptions: options,
437               }
438             )
439           );
440           break;
441         case AnnotationEditorType.HIGHLIGHT:
442           promises.push(
443             HighlightAnnotation.createNewPrintAnnotation(
444               annotationGlobals,
445               xref,
446               annotation,
447               {
448                 evaluatorOptions: options,
449               }
450             )
451           );
452           break;
453         case AnnotationEditorType.INK:
454           promises.push(
455             InkAnnotation.createNewPrintAnnotation(
456               annotationGlobals,
457               xref,
458               annotation,
459               {
460                 evaluatorOptions: options,
461               }
462             )
463           );
464           break;
465         case AnnotationEditorType.STAMP:
466           if (!options.isOffscreenCanvasSupported) {
467             break;
468           }
469           const image = await imagePromises.get(annotation.bitmapId);
470           if (image.imageStream) {
471             const { imageStream, smaskStream } = image;
472             if (smaskStream) {
473               imageStream.dict.set("SMask", smaskStream);
474             }
475             image.imageRef = new JpegStream(imageStream, imageStream.length);
476             image.imageStream = image.smaskStream = null;
477           }
478           promises.push(
479             StampAnnotation.createNewPrintAnnotation(
480               annotationGlobals,
481               xref,
482               annotation,
483               {
484                 image,
485                 evaluatorOptions: options,
486               }
487             )
488           );
489           break;
490       }
491     }
492 
493     return Promise.all(promises);
494   }
495 }
496 
497 function getRgbColor(color, defaultColor = new Uint8ClampedArray(3)) {
498   if (!Array.isArray(color)) {
499     return defaultColor;
500   }
501 
502   const rgbColor = defaultColor || new Uint8ClampedArray(3);
503   switch (color.length) {
504     case 0: // Transparent, which we indicate with a null value
505       return null;
506 
507     case 1: // Convert grayscale to RGB
508       ColorSpace.singletons.gray.getRgbItem(color, 0, rgbColor, 0);
509       return rgbColor;
510 
511     case 3: // Convert RGB percentages to RGB
512       ColorSpace.singletons.rgb.getRgbItem(color, 0, rgbColor, 0);
513       return rgbColor;
514 
515     case 4: // Convert CMYK to RGB
516       ColorSpace.singletons.cmyk.getRgbItem(color, 0, rgbColor, 0);
517       return rgbColor;
518 
519     default:
520       return defaultColor;
521   }
522 }
523 
524 function getPdfColorArray(color) {
525   return Array.from(color, c => c / 255);
526 }
527 
528 function getQuadPoints(dict, rect) {
529   // The region is described as a number of quadrilaterals.
530   // Each quadrilateral must consist of eight coordinates.
531   const quadPoints = dict.getArray("QuadPoints");
532   if (
533     !Array.isArray(quadPoints) ||
534     quadPoints.length === 0 ||
535     quadPoints.length % 8 > 0
536   ) {
537     return null;
538   }
539 
540   const quadPointsLists = [];
541   for (let i = 0, ii = quadPoints.length / 8; i < ii; i++) {
542     // Each series of eight numbers represents the coordinates for one
543     // quadrilateral in the order [x1, y1, x2, y2, x3, y3, x4, y4].
544     // Convert this to an array of objects with x and y coordinates.
545     let minX = Infinity,
546       maxX = -Infinity,
547       minY = Infinity,
548       maxY = -Infinity;
549     for (let j = i * 8, jj = i * 8 + 8; j < jj; j += 2) {
550       const x = quadPoints[j];
551       const y = quadPoints[j + 1];
552 
553       minX = Math.min(x, minX);
554       maxX = Math.max(x, maxX);
555       minY = Math.min(y, minY);
556       maxY = Math.max(y, maxY);
557     }
558     // The quadpoints should be ignored if any coordinate in the array
559     // lies outside the region specified by the rectangle. The rectangle
560     // can be `null` for markup annotations since their rectangle may be
561     // incorrect (fixes bug 1538111).
562     if (
563       rect !== null &&
564       (minX < rect[0] || maxX > rect[2] || minY < rect[1] || maxY > rect[3])
565     ) {
566       return null;
567     }
568     // The PDF specification states in section 12.5.6.10 (figure 64) that the
569     // order of the quadpoints should be bottom left, bottom right, top right
570     // and top left. However, in practice PDF files use a different order,
571     // namely bottom left, bottom right, top left and top right (this is also
572     // mentioned on https://github.com/highkite/pdfAnnotate#QuadPoints), so
573     // this is the actual order we should work with. However, the situation is
574     // even worse since Adobe's own applications and other applications violate
575     // the specification and create annotations with other orders, namely top
576     // left, top right, bottom left and bottom right or even top left,
577     // top right, bottom right and bottom left. To avoid inconsistency and
578     // broken rendering, we normalize all lists to put the quadpoints in the
579     // same standard order (see https://stackoverflow.com/a/10729881).
580     quadPointsLists.push([
581       { x: minX, y: maxY },
582       { x: maxX, y: maxY },
583       { x: minX, y: minY },
584       { x: maxX, y: minY },
585     ]);
586   }
587   return quadPointsLists;
588 }
589 
590 function getTransformMatrix(rect, bbox, matrix) {
591   // 12.5.5: Algorithm: Appearance streams
592   const [minX, minY, maxX, maxY] = Util.getAxialAlignedBoundingBox(
593     bbox,
594     matrix
595   );
596   if (minX === maxX || minY === maxY) {
597     // From real-life file, bbox was [0, 0, 0, 0]. In this case,
598     // just apply the transform for rect
599     return [1, 0, 0, 1, rect[0], rect[1]];
600   }
601 
602   const xRatio = (rect[2] - rect[0]) / (maxX - minX);
603   const yRatio = (rect[3] - rect[1]) / (maxY - minY);
604   return [
605     xRatio,
606     0,
607     0,
608     yRatio,
609     rect[0] - minX * xRatio,
610     rect[1] - minY * yRatio,
611   ];
612 }
613 
614 class Annotation {
615   constructor(params) {
616     const { dict, xref, annotationGlobals } = params;
617 
618     this.setTitle(dict.get("T"));
619     this.setContents(dict.get("Contents"));
620     this.setModificationDate(dict.get("M"));
621     this.setFlags(dict.get("F"));
622     this.setRectangle(dict.getArray("Rect"));
623     this.setColor(dict.getArray("C"));
624     this.setBorderStyle(dict);
625     this.setAppearance(dict);
626     this.setOptionalContent(dict);
627 
628     const MK = dict.get("MK");
629     this.setBorderAndBackgroundColors(MK);
630     this.setRotation(MK, dict);
631     this.ref = params.ref instanceof Ref ? params.ref : null;
632 
633     this._streams = [];
634     if (this.appearance) {
635       this._streams.push(this.appearance);
636     }
637 
638     // The annotation cannot be changed (neither its position/visibility nor its
639     // contents), hence we can just display its appearance and don't generate
640     // a HTML element for it.
641     const isLocked = !!(this.flags & AnnotationFlag.LOCKED);
642     const isContentLocked = !!(this.flags & AnnotationFlag.LOCKEDCONTENTS);
643 
644     if (annotationGlobals.structTreeRoot) {
645       let structParent = dict.get("StructParent");
646       structParent =
647         Number.isInteger(structParent) && structParent >= 0 ? structParent : -1;
648 
649       annotationGlobals.structTreeRoot.addAnnotationIdToPage(
650         params.pageRef,
651         structParent
652       );
653     }
654 
655     // Expose public properties using a data object.
656     this.data = {
657       annotationFlags: this.flags,
658       borderStyle: this.borderStyle,
659       color: this.color,
660       backgroundColor: this.backgroundColor,
661       borderColor: this.borderColor,
662       rotation: this.rotation,
663       contentsObj: this._contents,
664       hasAppearance: !!this.appearance,
665       id: params.id,
666       modificationDate: this.modificationDate,
667       rect: this.rectangle,
668       subtype: params.subtype,
669       hasOwnCanvas: false,
670       noRotate: !!(this.flags & AnnotationFlag.NOROTATE),
671       noHTML: isLocked && isContentLocked,
672     };
673 
674     if (params.collectFields) {
675       // Fields can act as container for other fields and have
676       // some actions even if no Annotation inherit from them.
677       // Those fields can be referenced by CO (calculation order).
678       const kids = dict.get("Kids");
679       if (Array.isArray(kids)) {
680         const kidIds = [];
681         for (const kid of kids) {
682           if (kid instanceof Ref) {
683             kidIds.push(kid.toString());
684           }
685         }
686         if (kidIds.length !== 0) {
687           this.data.kidIds = kidIds;
688         }
689       }
690 
691       this.data.actions = collectActions(xref, dict, AnnotationActionEventType);
692       this.data.fieldName = this._constructFieldName(dict);
693       this.data.pageIndex = params.pageIndex;
694     }
695 
696     this._isOffscreenCanvasSupported =
697       params.evaluatorOptions.isOffscreenCanvasSupported;
698     this._fallbackFontDict = null;
699     this._needAppearances = false;
700   }
701 
702   /**
703    * @private
704    */
705   _hasFlag(flags, flag) {
706     return !!(flags & flag);
707   }
708 
709   /**
710    * @private
711    */
712   _isViewable(flags) {
713     return (
714       !this._hasFlag(flags, AnnotationFlag.INVISIBLE) &&
715       !this._hasFlag(flags, AnnotationFlag.NOVIEW)
716     );
717   }
718 
719   /**
720    * @private
721    */
722   _isPrintable(flags) {
723     // In Acrobat, hidden flag cancels the print one
724     // (see annotation_hidden_print.pdf).
725     return (
726       this._hasFlag(flags, AnnotationFlag.PRINT) &&
727       !this._hasFlag(flags, AnnotationFlag.HIDDEN) &&
728       !this._hasFlag(flags, AnnotationFlag.INVISIBLE)
729     );
730   }
731 
732   /**
733    * Check if the annotation must be displayed by taking into account
734    * the value found in the annotationStorage which may have been set
735    * through JS.
736    *
737    * @public
738    * @memberof Annotation
739    * @param {AnnotationStorage} [annotationStorage] - Storage for annotation
740    * @param {boolean} [_renderForms] - if true widgets are rendered thanks to
741    *                                   the annotation layer.
742    */
743   mustBeViewed(annotationStorage, _renderForms) {
744     const noView = annotationStorage?.get(this.data.id)?.noView;
745     if (noView !== undefined) {
746       return !noView;
747     }
748     return this.viewable && !this._hasFlag(this.flags, AnnotationFlag.HIDDEN);
749   }
750 
751   /**
752    * Check if the annotation must be printed by taking into account
753    * the value found in the annotationStorage which may have been set
754    * through JS.
755    *
756    * @public
757    * @memberof Annotation
758    * @param {AnnotationStorage} [annotationStorage] - Storage for annotation
759    */
760   mustBePrinted(annotationStorage) {
761     const noPrint = annotationStorage?.get(this.data.id)?.noPrint;
762     if (noPrint !== undefined) {
763       return !noPrint;
764     }
765     return this.printable;
766   }
767 
768   /**
769    * @type {boolean}
770    */
771   get viewable() {
772     if (this.data.quadPoints === null) {
773       return false;
774     }
775     if (this.flags === 0) {
776       return true;
777     }
778     return this._isViewable(this.flags);
779   }
780 
781   /**
782    * @type {boolean}
783    */
784   get printable() {
785     if (this.data.quadPoints === null) {
786       return false;
787     }
788     if (this.flags === 0) {
789       return false;
790     }
791     return this._isPrintable(this.flags);
792   }
793 
794   /**
795    * @private
796    */
797   _parseStringHelper(data) {
798     const str = typeof data === "string" ? stringToPDFString(data) : "";
799     const dir = str && bidi(str).dir === "rtl" ? "rtl" : "ltr";
800 
801     return { str, dir };
802   }
803 
804   setDefaultAppearance(params) {
805     const { dict, annotationGlobals } = params;
806 
807     const defaultAppearance =
808       getInheritableProperty({ dict, key: "DA" }) ||
809       annotationGlobals.acroForm.get("DA");
810     this._defaultAppearance =
811       typeof defaultAppearance === "string" ? defaultAppearance : "";
812     this.data.defaultAppearanceData = parseDefaultAppearance(
813       this._defaultAppearance
814     );
815   }
816 
817   /**
818    * Set the title.
819    *
820    * @param {string} title - The title of the annotation, used e.g. with
821    *   PopupAnnotations.
822    */
823   setTitle(title) {
824     this._title = this._parseStringHelper(title);
825   }
826 
827   /**
828    * Set the contents.
829    *
830    * @param {string} contents - Text to display for the annotation or, if the
831    *                            type of annotation does not display text, a
832    *                            description of the annotation's contents
833    */
834   setContents(contents) {
835     this._contents = this._parseStringHelper(contents);
836   }
837 
838   /**
839    * Set the modification date.
840    *
841    * @public
842    * @memberof Annotation
843    * @param {string} modificationDate - PDF date string that indicates when the
844    *                                    annotation was last modified
845    */
846   setModificationDate(modificationDate) {
847     this.modificationDate =
848       typeof modificationDate === "string" ? modificationDate : null;
849   }
850 
851   /**
852    * Set the flags.
853    *
854    * @public
855    * @memberof Annotation
856    * @param {number} flags - Unsigned 32-bit integer specifying annotation
857    *                         characteristics
858    * @see {@link shared/util.js}
859    */
860   setFlags(flags) {
861     this.flags = Number.isInteger(flags) && flags > 0 ? flags : 0;
862     if (
863       this.flags & AnnotationFlag.INVISIBLE &&
864       this.constructor.name !== "Annotation"
865     ) {
866       // From the pdf spec v1.7, section 12.5.3 (Annotation Flags):
867       //   If set, do not display the annotation if it does not belong to one of
868       //   the standard annotation types and no annotation handler is available.
869       //
870       // So we can remove the flag in case we have a known annotation type.
871       this.flags ^= AnnotationFlag.INVISIBLE;
872     }
873   }
874 
875   /**
876    * Check if a provided flag is set.
877    *
878    * @public
879    * @memberof Annotation
880    * @param {number} flag - Hexadecimal representation for an annotation
881    *                        characteristic
882    * @returns {boolean}
883    * @see {@link shared/util.js}
884    */
885   hasFlag(flag) {
886     return this._hasFlag(this.flags, flag);
887   }
888 
889   /**
890    * Set the rectangle.
891    *
892    * @public
893    * @memberof Annotation
894    * @param {Array} rectangle - The rectangle array with exactly four entries
895    */
896   setRectangle(rectangle) {
897     this.rectangle =
898       Array.isArray(rectangle) && rectangle.length === 4
899         ? Util.normalizeRect(rectangle)
900         : [0, 0, 0, 0];
901   }
902 
903   /**
904    * Set the color and take care of color space conversion.
905    * The default value is black, in RGB color space.
906    *
907    * @public
908    * @memberof Annotation
909    * @param {Array} color - The color array containing either 0
910    *                        (transparent), 1 (grayscale), 3 (RGB) or
911    *                        4 (CMYK) elements
912    */
913   setColor(color) {
914     this.color = getRgbColor(color);
915   }
916 
917   /**
918    * Set the line endings; should only be used with specific annotation types.
919    * @param {Array} lineEndings - The line endings array.
920    */
921   setLineEndings(lineEndings) {
922     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) {
923       throw new Error("Not implemented: setLineEndings");
924     }
925     this.lineEndings = ["None", "None"]; // The default values.
926 
927     if (Array.isArray(lineEndings) && lineEndings.length === 2) {
928       for (let i = 0; i < 2; i++) {
929         const obj = lineEndings[i];
930 
931         if (obj instanceof Name) {
932           switch (obj.name) {
933             case "None":
934               continue;
935             case "Square":
936             case "Circle":
937             case "Diamond":
938             case "OpenArrow":
939             case "ClosedArrow":
940             case "Butt":
941             case "ROpenArrow":
942             case "RClosedArrow":
943             case "Slash":
944               this.lineEndings[i] = obj.name;
945               continue;
946           }
947         }
948         warn(`Ignoring invalid lineEnding: ${obj}`);
949       }
950     }
951   }
952 
953   setRotation(mk, dict) {
954     this.rotation = 0;
955     let angle = mk instanceof Dict ? mk.get("R") || 0 : dict.get("Rotate") || 0;
956     if (Number.isInteger(angle) && angle !== 0) {
957       angle %= 360;
958       if (angle < 0) {
959         angle += 360;
960       }
961       if (angle % 90 === 0) {
962         this.rotation = angle;
963       }
964     }
965   }
966 
967   /**
968    * Set the color for background and border if any.
969    * The default values are transparent.
970    *
971    * @public
972    * @memberof Annotation
973    * @param {Dict} mk - The MK dictionary
974    */
975   setBorderAndBackgroundColors(mk) {
976     if (mk instanceof Dict) {
977       this.borderColor = getRgbColor(mk.getArray("BC"), null);
978       this.backgroundColor = getRgbColor(mk.getArray("BG"), null);
979     } else {
980       this.borderColor = this.backgroundColor = null;
981     }
982   }
983 
984   /**
985    * Set the border style (as AnnotationBorderStyle object).
986    *
987    * @public
988    * @memberof Annotation
989    * @param {Dict} borderStyle - The border style dictionary
990    */
991   setBorderStyle(borderStyle) {
992     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
993       assert(this.rectangle, "setRectangle must have been called previously.");
994     }
995 
996     this.borderStyle = new AnnotationBorderStyle();
997     if (!(borderStyle instanceof Dict)) {
998       return;
999     }
1000     if (borderStyle.has("BS")) {
1001       const dict = borderStyle.get("BS");
1002 
1003       if (dict instanceof Dict) {
1004         const dictType = dict.get("Type");
1005 
1006         if (!dictType || isName(dictType, "Border")) {
1007           this.borderStyle.setWidth(dict.get("W"), this.rectangle);
1008           this.borderStyle.setStyle(dict.get("S"));
1009           this.borderStyle.setDashArray(dict.getArray("D"));
1010         }
1011       }
1012     } else if (borderStyle.has("Border")) {
1013       const array = borderStyle.getArray("Border");
1014       if (Array.isArray(array) && array.length >= 3) {
1015         this.borderStyle.setHorizontalCornerRadius(array[0]);
1016         this.borderStyle.setVerticalCornerRadius(array[1]);
1017         this.borderStyle.setWidth(array[2], this.rectangle);
1018 
1019         if (array.length === 4) {
1020           // Dash array available
1021           this.borderStyle.setDashArray(array[3], /* forceStyle = */ true);
1022         }
1023       }
1024     } else {
1025       // There are no border entries in the dictionary. According to the
1026       // specification, we should draw a solid border of width 1 in that
1027       // case, but Adobe Reader did not implement that part of the
1028       // specification and instead draws no border at all, so we do the same.
1029       // See also https://github.com/mozilla/pdf.js/issues/6179.
1030       this.borderStyle.setWidth(0);
1031     }
1032   }
1033 
1034   /**
1035    * Set the (normal) appearance.
1036    *
1037    * @public
1038    * @memberof Annotation
1039    * @param {Dict} dict - The annotation's data dictionary
1040    */
1041   setAppearance(dict) {
1042     this.appearance = null;
1043 
1044     const appearanceStates = dict.get("AP");
1045     if (!(appearanceStates instanceof Dict)) {
1046       return;
1047     }
1048 
1049     // In case the normal appearance is a stream, then it is used directly.
1050     const normalAppearanceState = appearanceStates.get("N");
1051     if (normalAppearanceState instanceof BaseStream) {
1052       this.appearance = normalAppearanceState;
1053       return;
1054     }
1055     if (!(normalAppearanceState instanceof Dict)) {
1056       return;
1057     }
1058 
1059     // In case the normal appearance is a dictionary, the `AS` entry provides
1060     // the key of the stream in this dictionary.
1061     const as = dict.get("AS");
1062     if (!(as instanceof Name) || !normalAppearanceState.has(as.name)) {
1063       return;
1064     }
1065     const appearance = normalAppearanceState.get(as.name);
1066     if (appearance instanceof BaseStream) {
1067       this.appearance = appearance;
1068     }
1069   }
1070 
1071   setOptionalContent(dict) {
1072     this.oc = null;
1073 
1074     const oc = dict.get("OC");
1075     if (oc instanceof Name) {
1076       warn("setOptionalContent: Support for /Name-entry is not implemented.");
1077     } else if (oc instanceof Dict) {
1078       this.oc = oc;
1079     }
1080   }
1081 
1082   loadResources(keys, appearance) {
1083     return appearance.dict.getAsync("Resources").then(resources => {
1084       if (!resources) {
1085         return undefined;
1086       }
1087 
1088       const objectLoader = new ObjectLoader(resources, keys, resources.xref);
1089       return objectLoader.load().then(function () {
1090         return resources;
1091       });
1092     });
1093   }
1094 
1095   async getOperatorList(
1096     evaluator,
1097     task,
1098     intent,
1099     renderForms,
1100     annotationStorage
1101   ) {
1102     const data = this.data;
1103     let appearance = this.appearance;
1104     const isUsingOwnCanvas = !!(
1105       this.data.hasOwnCanvas && intent & RenderingIntentFlag.DISPLAY
1106     );
1107     if (!appearance) {
1108       if (!isUsingOwnCanvas) {
1109         return {
1110           opList: new OperatorList(),
1111           separateForm: false,
1112           separateCanvas: false,
1113         };
1114       }
1115       appearance = new StringStream("");
1116       appearance.dict = new Dict();
1117     }
1118 
1119     const appearanceDict = appearance.dict;
1120     const resources = await this.loadResources(
1121       ["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"],
1122       appearance
1123     );
1124     const bbox = appearanceDict.getArray("BBox") || [0, 0, 1, 1];
1125     const matrix = appearanceDict.getArray("Matrix") || [1, 0, 0, 1, 0, 0];
1126     const transform = getTransformMatrix(data.rect, bbox, matrix);
1127 
1128     const opList = new OperatorList();
1129 
1130     let optionalContent;
1131     if (this.oc) {
1132       optionalContent = await evaluator.parseMarkedContentProps(
1133         this.oc,
1134         /* resources = */ null
1135       );
1136     }
1137     if (optionalContent !== undefined) {
1138       opList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
1139     }
1140 
1141     opList.addOp(OPS.beginAnnotation, [
1142       data.id,
1143       data.rect,
1144       transform,
1145       matrix,
1146       isUsingOwnCanvas,
1147     ]);
1148 
1149     await evaluator.getOperatorList({
1150       stream: appearance,
1151       task,
1152       resources,
1153       operatorList: opList,
1154       fallbackFontDict: this._fallbackFontDict,
1155     });
1156     opList.addOp(OPS.endAnnotation, []);
1157 
1158     if (optionalContent !== undefined) {
1159       opList.addOp(OPS.endMarkedContent, []);
1160     }
1161     this.reset();
1162     return { opList, separateForm: false, separateCanvas: isUsingOwnCanvas };
1163   }
1164 
1165   async save(evaluator, task, annotationStorage) {
1166     return null;
1167   }
1168 
1169   get hasTextContent() {
1170     return false;
1171   }
1172 
1173   async extractTextContent(evaluator, task, viewBox) {
1174     if (!this.appearance) {
1175       return;
1176     }
1177 
1178     const resources = await this.loadResources(
1179       ["ExtGState", "Font", "Properties", "XObject"],
1180       this.appearance
1181     );
1182 
1183     const text = [];
1184     const buffer = [];
1185     let firstPosition = null;
1186     const sink = {
1187       desiredSize: Math.Infinity,
1188       ready: true,
1189 
1190       enqueue(chunk, size) {
1191         for (const item of chunk.items) {
1192           if (item.str === undefined) {
1193             continue;
1194           }
1195           firstPosition ||= item.transform.slice(-2);
1196           buffer.push(item.str);
1197           if (item.hasEOL) {
1198             text.push(buffer.join("").trimEnd());
1199             buffer.length = 0;
1200           }
1201         }
1202       },
1203     };
1204 
1205     await evaluator.getTextContent({
1206       stream: this.appearance,
1207       task,
1208       resources,
1209       includeMarkedContent: true,
1210       keepWhiteSpace: true,
1211       sink,
1212       viewBox,
1213     });
1214     this.reset();
1215 
1216     if (buffer.length) {
1217       text.push(buffer.join("").trimEnd());
1218     }
1219 
1220     if (text.length > 1 || text[0]) {
1221       const appearanceDict = this.appearance.dict;
1222       this.data.textPosition = this._transformPoint(
1223         firstPosition,
1224         appearanceDict.getArray("BBox"),
1225         appearanceDict.getArray("Matrix")
1226       );
1227       this.data.textContent = text;
1228     }
1229   }
1230 
1231   _transformPoint(coords, bbox, matrix) {
1232     const { rect } = this.data;
1233     bbox ||= [0, 0, 1, 1];
1234     matrix ||= [1, 0, 0, 1, 0, 0];
1235     const transform = getTransformMatrix(rect, bbox, matrix);
1236     transform[4] -= rect[0];
1237     transform[5] -= rect[1];
1238     coords = Util.applyTransform(coords, transform);
1239     return Util.applyTransform(coords, matrix);
1240   }
1241 
1242   /**
1243    * Get field data for usage in JS sandbox.
1244    *
1245    * Field object is defined here:
1246    * https://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/js_api_reference.pdf#page=16
1247    *
1248    * @public
1249    * @memberof Annotation
1250    * @returns {Object | null}
1251    */
1252   getFieldObject() {
1253     if (this.data.kidIds) {
1254       return {
1255         id: this.data.id,
1256         actions: this.data.actions,
1257         name: this.data.fieldName,
1258         strokeColor: this.data.borderColor,
1259         fillColor: this.data.backgroundColor,
1260         type: "",
1261         kidIds: this.data.kidIds,
1262         page: this.data.pageIndex,
1263         rotation: this.rotation,
1264       };
1265     }
1266     return null;
1267   }
1268 
1269   /**
1270    * Reset the annotation.
1271    *
1272    * This involves resetting the various streams that are either cached on the
1273    * annotation instance or created during its construction.
1274    *
1275    * @public
1276    * @memberof Annotation
1277    */
1278   reset() {
1279     if (
1280       (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) &&
1281       this.appearance &&
1282       !this._streams.includes(this.appearance)
1283     ) {
1284       unreachable("The appearance stream should always be reset.");
1285     }
1286 
1287     for (const stream of this._streams) {
1288       stream.reset();
1289     }
1290   }
1291 
1292   /**
1293    * Construct the (fully qualified) field name from the (partial) field
1294    * names of the field and its ancestors.
1295    *
1296    * @private
1297    * @memberof Annotation
1298    * @param {Dict} dict - Complete widget annotation dictionary
1299    * @returns {string}
1300    */
1301   _constructFieldName(dict) {
1302     // Both the `Parent` and `T` fields are optional. While at least one of
1303     // them should be provided, bad PDF generators may fail to do so.
1304     if (!dict.has("T") && !dict.has("Parent")) {
1305       warn("Unknown field name, falling back to empty field name.");
1306       return "";
1307     }
1308 
1309     // If no parent exists, the partial and fully qualified names are equal.
1310     if (!dict.has("Parent")) {
1311       return stringToPDFString(dict.get("T"));
1312     }
1313 
1314     // Form the fully qualified field name by appending the partial name to
1315     // the parent's fully qualified name, separated by a period.
1316     const fieldName = [];
1317     if (dict.has("T")) {
1318       fieldName.unshift(stringToPDFString(dict.get("T")));
1319     }
1320 
1321     let loopDict = dict;
1322     const visited = new RefSet();
1323     if (dict.objId) {
1324       visited.put(dict.objId);
1325     }
1326     while (loopDict.has("Parent")) {
1327       loopDict = loopDict.get("Parent");
1328       if (
1329         !(loopDict instanceof Dict) ||
1330         (loopDict.objId && visited.has(loopDict.objId))
1331       ) {
1332         // Even though it is not allowed according to the PDF specification,
1333         // bad PDF generators may provide a `Parent` entry that is not a
1334         // dictionary, but `null` for example (issue 8143).
1335         //
1336         // If parent has been already visited, it means that we're
1337         // in an infinite loop.
1338         break;
1339       }
1340       if (loopDict.objId) {
1341         visited.put(loopDict.objId);
1342       }
1343 
1344       if (loopDict.has("T")) {
1345         fieldName.unshift(stringToPDFString(loopDict.get("T")));
1346       }
1347     }
1348     return fieldName.join(".");
1349   }
1350 }
1351 
1352 /**
1353  * Contains all data regarding an annotation's border style.
1354  */
1355 class AnnotationBorderStyle {
1356   constructor() {
1357     this.width = 1;
1358     this.style = AnnotationBorderStyleType.SOLID;
1359     this.dashArray = [3];
1360     this.horizontalCornerRadius = 0;
1361     this.verticalCornerRadius = 0;
1362   }
1363 
1364   /**
1365    * Set the width.
1366    *
1367    * @public
1368    * @memberof AnnotationBorderStyle
1369    * @param {number} width - The width.
1370    * @param {Array} rect - The annotation `Rect` entry.
1371    */
1372   setWidth(width, rect = [0, 0, 0, 0]) {
1373     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1374       assert(
1375         Array.isArray(rect) && rect.length === 4,
1376         "A valid `rect` parameter must be provided."
1377       );
1378     }
1379 
1380     // Some corrupt PDF generators may provide the width as a `Name`,
1381     // rather than as a number (fixes issue 10385).
1382     if (width instanceof Name) {
1383       this.width = 0; // This is consistent with the behaviour in Adobe Reader.
1384       return;
1385     }
1386     if (typeof width === "number") {
1387       if (width > 0) {
1388         const maxWidth = (rect[2] - rect[0]) / 2;
1389         const maxHeight = (rect[3] - rect[1]) / 2;
1390 
1391         // Ignore large `width`s, since they lead to the Annotation overflowing
1392         // the size set by the `Rect` entry thus causing the `annotationLayer`
1393         // to render it over the surrounding document (fixes bug1552113.pdf).
1394         if (
1395           maxWidth > 0 &&
1396           maxHeight > 0 &&
1397           (width > maxWidth || width > maxHeight)
1398         ) {
1399           warn(`AnnotationBorderStyle.setWidth - ignoring width: ${width}`);
1400           width = 1;
1401         }
1402       }
1403       this.width = width;
1404     }
1405   }
1406 
1407   /**
1408    * Set the style.
1409    *
1410    * @public
1411    * @memberof AnnotationBorderStyle
1412    * @param {Name} style - The annotation style.
1413    * @see {@link shared/util.js}
1414    */
1415   setStyle(style) {
1416     if (!(style instanceof Name)) {
1417       return;
1418     }
1419     switch (style.name) {
1420       case "S":
1421         this.style = AnnotationBorderStyleType.SOLID;
1422         break;
1423 
1424       case "D":
1425         this.style = AnnotationBorderStyleType.DASHED;
1426         break;
1427 
1428       case "B":
1429         this.style = AnnotationBorderStyleType.BEVELED;
1430         break;
1431 
1432       case "I":
1433         this.style = AnnotationBorderStyleType.INSET;
1434         break;
1435 
1436       case "U":
1437         this.style = AnnotationBorderStyleType.UNDERLINE;
1438         break;
1439 
1440       default:
1441         break;
1442     }
1443   }
1444 
1445   /**
1446    * Set the dash array.
1447    *
1448    * @public
1449    * @memberof AnnotationBorderStyle
1450    * @param {Array} dashArray - The dash array with at least one element
1451    * @param {boolean} [forceStyle]
1452    */
1453   setDashArray(dashArray, forceStyle = false) {
1454     // We validate the dash array, but we do not use it because CSS does not
1455     // allow us to change spacing of dashes. For more information, visit
1456     // http://www.w3.org/TR/css3-background/#the-border-style.
1457     if (Array.isArray(dashArray) && dashArray.length > 0) {
1458       // According to the PDF specification: the elements in `dashArray`
1459       // shall be numbers that are nonnegative and not all equal to zero.
1460       let isValid = true;
1461       let allZeros = true;
1462       for (const element of dashArray) {
1463         const validNumber = +element >= 0;
1464         if (!validNumber) {
1465           isValid = false;
1466           break;
1467         } else if (element > 0) {
1468           allZeros = false;
1469         }
1470       }
1471       if (isValid && !allZeros) {
1472         this.dashArray = dashArray;
1473 
1474         if (forceStyle) {
1475           // Even though we cannot use the dash array in the display layer,
1476           // at least ensure that we use the correct border-style.
1477           this.setStyle(Name.get("D"));
1478         }
1479       } else {
1480         this.width = 0; // Adobe behavior when the array is invalid.
1481       }
1482     } else if (dashArray) {
1483       this.width = 0; // Adobe behavior when the array is invalid.
1484     }
1485   }
1486 
1487   /**
1488    * Set the horizontal corner radius (from a Border dictionary).
1489    *
1490    * @public
1491    * @memberof AnnotationBorderStyle
1492    * @param {number} radius - The horizontal corner radius.
1493    */
1494   setHorizontalCornerRadius(radius) {
1495     if (Number.isInteger(radius)) {
1496       this.horizontalCornerRadius = radius;
1497     }
1498   }
1499 
1500   /**
1501    * Set the vertical corner radius (from a Border dictionary).
1502    *
1503    * @public
1504    * @memberof AnnotationBorderStyle
1505    * @param {number} radius - The vertical corner radius.
1506    */
1507   setVerticalCornerRadius(radius) {
1508     if (Number.isInteger(radius)) {
1509       this.verticalCornerRadius = radius;
1510     }
1511   }
1512 }
1513 
1514 class MarkupAnnotation extends Annotation {
1515   constructor(params) {
1516     super(params);
1517 
1518     const { dict } = params;
1519 
1520     if (dict.has("IRT")) {
1521       const rawIRT = dict.getRaw("IRT");
1522       this.data.inReplyTo = rawIRT instanceof Ref ? rawIRT.toString() : null;
1523 
1524       const rt = dict.get("RT");
1525       this.data.replyType =
1526         rt instanceof Name ? rt.name : AnnotationReplyType.REPLY;
1527     }
1528     let popupRef = null;
1529 
1530     if (this.data.replyType === AnnotationReplyType.GROUP) {
1531       // Subordinate annotations in a group should inherit
1532       // the group attributes from the primary annotation.
1533       const parent = dict.get("IRT");
1534 
1535       this.setTitle(parent.get("T"));
1536       this.data.titleObj = this._title;
1537 
1538       this.setContents(parent.get("Contents"));
1539       this.data.contentsObj = this._contents;
1540 
1541       if (!parent.has("CreationDate")) {
1542         this.data.creationDate = null;
1543       } else {
1544         this.setCreationDate(parent.get("CreationDate"));
1545         this.data.creationDate = this.creationDate;
1546       }
1547 
1548       if (!parent.has("M")) {
1549         this.data.modificationDate = null;
1550       } else {
1551         this.setModificationDate(parent.get("M"));
1552         this.data.modificationDate = this.modificationDate;
1553       }
1554 
1555       popupRef = parent.getRaw("Popup");
1556 
1557       if (!parent.has("C")) {
1558         // Fall back to the default background color.
1559         this.data.color = null;
1560       } else {
1561         this.setColor(parent.getArray("C"));
1562         this.data.color = this.color;
1563       }
1564     } else {
1565       this.data.titleObj = this._title;
1566 
1567       this.setCreationDate(dict.get("CreationDate"));
1568       this.data.creationDate = this.creationDate;
1569 
1570       popupRef = dict.getRaw("Popup");
1571 
1572       if (!dict.has("C")) {
1573         // Fall back to the default background color.
1574         this.data.color = null;
1575       }
1576     }
1577 
1578     this.data.popupRef = popupRef instanceof Ref ? popupRef.toString() : null;
1579 
1580     if (dict.has("RC")) {
1581       this.data.richText = XFAFactory.getRichTextAsHtml(dict.get("RC"));
1582     }
1583   }
1584 
1585   /**
1586    * Set the creation date.
1587    *
1588    * @public
1589    * @memberof MarkupAnnotation
1590    * @param {string} creationDate - PDF date string that indicates when the
1591    *                                annotation was originally created
1592    */
1593   setCreationDate(creationDate) {
1594     this.creationDate = typeof creationDate === "string" ? creationDate : null;
1595   }
1596 
1597   _setDefaultAppearance({
1598     xref,
1599     extra,
1600     strokeColor,
1601     fillColor,
1602     blendMode,
1603     strokeAlpha,
1604     fillAlpha,
1605     pointsCallback,
1606   }) {
1607     let minX = Number.MAX_VALUE;
1608     let minY = Number.MAX_VALUE;
1609     let maxX = Number.MIN_VALUE;
1610     let maxY = Number.MIN_VALUE;
1611 
1612     const buffer = ["q"];
1613     if (extra) {
1614       buffer.push(extra);
1615     }
1616     if (strokeColor) {
1617       buffer.push(`${strokeColor[0]} ${strokeColor[1]} ${strokeColor[2]} RG`);
1618     }
1619     if (fillColor) {
1620       buffer.push(`${fillColor[0]} ${fillColor[1]} ${fillColor[2]} rg`);
1621     }
1622 
1623     let pointsArray = this.data.quadPoints;
1624     if (!pointsArray) {
1625       // If there are no quadpoints, the rectangle should be used instead.
1626       // Convert the rectangle definition to a points array similar to how the
1627       // quadpoints are defined.
1628       pointsArray = [
1629         [
1630           { x: this.rectangle[0], y: this.rectangle[3] },
1631           { x: this.rectangle[2], y: this.rectangle[3] },
1632           { x: this.rectangle[0], y: this.rectangle[1] },
1633           { x: this.rectangle[2], y: this.rectangle[1] },
1634         ],
1635       ];
1636     }
1637 
1638     for (const points of pointsArray) {
1639       const [mX, MX, mY, MY] = pointsCallback(buffer, points);
1640       minX = Math.min(minX, mX);
1641       maxX = Math.max(maxX, MX);
1642       minY = Math.min(minY, mY);
1643       maxY = Math.max(maxY, MY);
1644     }
1645     buffer.push("Q");
1646 
1647     const formDict = new Dict(xref);
1648     const appearanceStreamDict = new Dict(xref);
1649     appearanceStreamDict.set("Subtype", Name.get("Form"));
1650 
1651     const appearanceStream = new StringStream(buffer.join(" "));
1652     appearanceStream.dict = appearanceStreamDict;
1653     formDict.set("Fm0", appearanceStream);
1654 
1655     const gsDict = new Dict(xref);
1656     if (blendMode) {
1657       gsDict.set("BM", Name.get(blendMode));
1658     }
1659     if (typeof strokeAlpha === "number") {
1660       gsDict.set("CA", strokeAlpha);
1661     }
1662     if (typeof fillAlpha === "number") {
1663       gsDict.set("ca", fillAlpha);
1664     }
1665 
1666     const stateDict = new Dict(xref);
1667     stateDict.set("GS0", gsDict);
1668 
1669     const resources = new Dict(xref);
1670     resources.set("ExtGState", stateDict);
1671     resources.set("XObject", formDict);
1672 
1673     const appearanceDict = new Dict(xref);
1674     appearanceDict.set("Resources", resources);
1675     const bbox = (this.data.rect = [minX, minY, maxX, maxY]);
1676     appearanceDict.set("BBox", bbox);
1677 
1678     this.appearance = new StringStream("/GS0 gs /Fm0 Do");
1679     this.appearance.dict = appearanceDict;
1680 
1681     // This method is only called if there is no appearance for the annotation,
1682     // so `this.appearance` is not pushed yet in the `Annotation` constructor.
1683     this._streams.push(this.appearance, appearanceStream);
1684   }
1685 
1686   static async createNewAnnotation(xref, annotation, dependencies, params) {
1687     const annotationRef = (annotation.ref ||= xref.getNewTemporaryRef());
1688     const ap = await this.createNewAppearanceStream(annotation, xref, params);
1689     const buffer = [];
1690     let annotationDict;
1691 
1692     if (ap) {
1693       const apRef = xref.getNewTemporaryRef();
1694       annotationDict = this.createNewDict(annotation, xref, { apRef });
1695       await writeObject(apRef, ap, buffer, xref);
1696       dependencies.push({ ref: apRef, data: buffer.join("") });
1697     } else {
1698       annotationDict = this.createNewDict(annotation, xref, {});
1699     }
1700     if (Number.isInteger(annotation.parentTreeId)) {
1701       annotationDict.set("StructParent", annotation.parentTreeId);
1702     }
1703 
1704     buffer.length = 0;
1705     await writeObject(annotationRef, annotationDict, buffer, xref);
1706 
1707     return { ref: annotationRef, data: buffer.join("") };
1708   }
1709 
1710   static async createNewPrintAnnotation(
1711     annotationGlobals,
1712     xref,
1713     annotation,
1714     params
1715   ) {
1716     const ap = await this.createNewAppearanceStream(annotation, xref, params);
1717     const annotationDict = this.createNewDict(annotation, xref, { ap });
1718 
1719     const newAnnotation = new this.prototype.constructor({
1720       dict: annotationDict,
1721       xref,
1722       annotationGlobals,
1723       evaluatorOptions: params.evaluatorOptions,
1724     });
1725 
1726     if (annotation.ref) {
1727       newAnnotation.ref = newAnnotation.refToReplace = annotation.ref;
1728     }
1729 
1730     return newAnnotation;
1731   }
1732 }
1733 
1734 class WidgetAnnotation extends Annotation {
1735   constructor(params) {
1736     super(params);
1737 
1738     const { dict, xref, annotationGlobals } = params;
1739     const data = this.data;
1740     this._needAppearances = params.needAppearances;
1741 
1742     data.annotationType = AnnotationType.WIDGET;
1743     if (data.fieldName === undefined) {
1744       data.fieldName = this._constructFieldName(dict);
1745     }
1746 
1747     if (data.actions === undefined) {
1748       data.actions = collectActions(xref, dict, AnnotationActionEventType);
1749     }
1750 
1751     let fieldValue = getInheritableProperty({
1752       dict,
1753       key: "V",
1754       getArray: true,
1755     });
1756     data.fieldValue = this._decodeFormValue(fieldValue);
1757 
1758     const defaultFieldValue = getInheritableProperty({
1759       dict,
1760       key: "DV",
1761       getArray: true,
1762     });
1763     data.defaultFieldValue = this._decodeFormValue(defaultFieldValue);
1764 
1765     if (fieldValue === undefined && annotationGlobals.xfaDatasets) {
1766       // Try to figure out if we have something in the xfa dataset.
1767       const path = this._title.str;
1768       if (path) {
1769         this._hasValueFromXFA = true;
1770         data.fieldValue = fieldValue =
1771           annotationGlobals.xfaDatasets.getValue(path);
1772       }
1773     }
1774 
1775     // When no "V" entry exists, let the fieldValue fallback to the "DV" entry
1776     // (fixes issue13823.pdf).
1777     if (fieldValue === undefined && data.defaultFieldValue !== null) {
1778       data.fieldValue = data.defaultFieldValue;
1779     }
1780 
1781     data.alternativeText = stringToPDFString(dict.get("TU") || "");
1782 
1783     this.setDefaultAppearance(params);
1784 
1785     data.hasAppearance ||=
1786       this._needAppearances &&
1787       data.fieldValue !== undefined &&
1788       data.fieldValue !== null;
1789 
1790     const fieldType = getInheritableProperty({ dict, key: "FT" });
1791     data.fieldType = fieldType instanceof Name ? fieldType.name : null;
1792 
1793     const localResources = getInheritableProperty({ dict, key: "DR" });
1794     const acroFormResources = annotationGlobals.acroForm.get("DR");
1795     const appearanceResources = this.appearance?.dict.get("Resources");
1796 
1797     this._fieldResources = {
1798       localResources,
1799       acroFormResources,
1800       appearanceResources,
1801       mergedResources: Dict.merge({
1802         xref,
1803         dictArray: [localResources, appearanceResources, acroFormResources],
1804         mergeSubDicts: true,
1805       }),
1806     };
1807 
1808     data.fieldFlags = getInheritableProperty({ dict, key: "Ff" });
1809     if (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) {
1810       data.fieldFlags = 0;
1811     }
1812 
1813     data.readOnly = this.hasFieldFlag(AnnotationFieldFlag.READONLY);
1814     data.required = this.hasFieldFlag(AnnotationFieldFlag.REQUIRED);
1815     data.hidden =
1816       this._hasFlag(data.annotationFlags, AnnotationFlag.HIDDEN) ||
1817       this._hasFlag(data.annotationFlags, AnnotationFlag.NOVIEW);
1818   }
1819 
1820   /**
1821    * Decode the given form value.
1822    *
1823    * @private
1824    * @memberof WidgetAnnotation
1825    * @param {Array<string>|Name|string} formValue - The (possibly encoded)
1826    *   form value.
1827    * @returns {Array<string>|string|null}
1828    */
1829   _decodeFormValue(formValue) {
1830     if (Array.isArray(formValue)) {
1831       return formValue
1832         .filter(item => typeof item === "string")
1833         .map(item => stringToPDFString(item));
1834     } else if (formValue instanceof Name) {
1835       return stringToPDFString(formValue.name);
1836     } else if (typeof formValue === "string") {
1837       return stringToPDFString(formValue);
1838     }
1839     return null;
1840   }
1841 
1842   /**
1843    * Check if a provided field flag is set.
1844    *
1845    * @public
1846    * @memberof WidgetAnnotation
1847    * @param {number} flag - Hexadecimal representation for an annotation
1848    *                        field characteristic
1849    * @returns {boolean}
1850    * @see {@link shared/util.js}
1851    */
1852   hasFieldFlag(flag) {
1853     return !!(this.data.fieldFlags & flag);
1854   }
1855 
1856   /** @inheritdoc */
1857   _isViewable(flags) {
1858     // We don't take into account the `NOVIEW` or `HIDDEN` flags here,
1859     // since the visibility can be changed by js code, hence in case
1860     // it's made viewable, we should render it (with visibility set to
1861     // hidden).
1862     // We don't take into account the `INVISIBLE` flag here, since we've a known
1863     // annotation type.
1864     return true;
1865   }
1866 
1867   /** @inheritdoc */
1868   mustBeViewed(annotationStorage, renderForms) {
1869     if (renderForms) {
1870       return this.viewable;
1871     }
1872     return (
1873       super.mustBeViewed(annotationStorage, renderForms) &&
1874       !this._hasFlag(this.flags, AnnotationFlag.NOVIEW)
1875     );
1876   }
1877 
1878   getRotationMatrix(annotationStorage) {
1879     let rotation = annotationStorage?.get(this.data.id)?.rotation;
1880     if (rotation === undefined) {
1881       rotation = this.rotation;
1882     }
1883 
1884     if (rotation === 0) {
1885       return IDENTITY_MATRIX;
1886     }
1887 
1888     const width = this.data.rect[2] - this.data.rect[0];
1889     const height = this.data.rect[3] - this.data.rect[1];
1890 
1891     return getRotationMatrix(rotation, width, height);
1892   }
1893 
1894   getBorderAndBackgroundAppearances(annotationStorage) {
1895     let rotation = annotationStorage?.get(this.data.id)?.rotation;
1896     if (rotation === undefined) {
1897       rotation = this.rotation;
1898     }
1899 
1900     if (!this.backgroundColor && !this.borderColor) {
1901       return "";
1902     }
1903     const width = this.data.rect[2] - this.data.rect[0];
1904     const height = this.data.rect[3] - this.data.rect[1];
1905     const rect =
1906       rotation === 0 || rotation === 180
1907         ? `0 0 ${width} ${height} re`
1908         : `0 0 ${height} ${width} re`;
1909 
1910     let str = "";
1911     if (this.backgroundColor) {
1912       str = `${getPdfColor(
1913         this.backgroundColor,
1914         /* isFill */ true
1915       )} ${rect} f `;
1916     }
1917 
1918     if (this.borderColor) {
1919       const borderWidth = this.borderStyle.width || 1;
1920       str += `${borderWidth} w ${getPdfColor(
1921         this.borderColor,
1922         /* isFill */ false
1923       )} ${rect} S `;
1924     }
1925 
1926     return str;
1927   }
1928 
1929   async getOperatorList(
1930     evaluator,
1931     task,
1932     intent,
1933     renderForms,
1934     annotationStorage
1935   ) {
1936     // Do not render form elements on the canvas when interactive forms are
1937     // enabled. The display layer is responsible for rendering them instead.
1938     if (
1939       renderForms &&
1940       !(this instanceof SignatureWidgetAnnotation) &&
1941       !this.data.noHTML &&
1942       !this.data.hasOwnCanvas
1943     ) {
1944       return {
1945         opList: new OperatorList(),
1946         separateForm: true,
1947         separateCanvas: false,
1948       };
1949     }
1950 
1951     if (!this._hasText) {
1952       return super.getOperatorList(
1953         evaluator,
1954         task,
1955         intent,
1956         renderForms,
1957         annotationStorage
1958       );
1959     }
1960 
1961     const content = await this._getAppearance(
1962       evaluator,
1963       task,
1964       intent,
1965       annotationStorage
1966     );
1967     if (this.appearance && content === null) {
1968       return super.getOperatorList(
1969         evaluator,
1970         task,
1971         intent,
1972         renderForms,
1973         annotationStorage
1974       );
1975     }
1976 
1977     const opList = new OperatorList();
1978 
1979     // Even if there is an appearance stream, ignore it. This is the
1980     // behaviour used by Adobe Reader.
1981     if (!this._defaultAppearance || content === null) {
1982       return { opList, separateForm: false, separateCanvas: false };
1983     }
1984 
1985     const isUsingOwnCanvas = !!(
1986       this.data.hasOwnCanvas && intent & RenderingIntentFlag.DISPLAY
1987     );
1988 
1989     const matrix = [1, 0, 0, 1, 0, 0];
1990     const bbox = [
1991       0,
1992       0,
1993       this.data.rect[2] - this.data.rect[0],
1994       this.data.rect[3] - this.data.rect[1],
1995     ];
1996     const transform = getTransformMatrix(this.data.rect, bbox, matrix);
1997 
1998     let optionalContent;
1999     if (this.oc) {
2000       optionalContent = await evaluator.parseMarkedContentProps(
2001         this.oc,
2002         /* resources = */ null
2003       );
2004     }
2005     if (optionalContent !== undefined) {
2006       opList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
2007     }
2008 
2009     opList.addOp(OPS.beginAnnotation, [
2010       this.data.id,
2011       this.data.rect,
2012       transform,
2013       this.getRotationMatrix(annotationStorage),
2014       isUsingOwnCanvas,
2015     ]);
2016 
2017     const stream = new StringStream(content);
2018     await evaluator.getOperatorList({
2019       stream,
2020       task,
2021       resources: this._fieldResources.mergedResources,
2022       operatorList: opList,
2023     });
2024     opList.addOp(OPS.endAnnotation, []);
2025 
2026     if (optionalContent !== undefined) {
2027       opList.addOp(OPS.endMarkedContent, []);
2028     }
2029     return { opList, separateForm: false, separateCanvas: isUsingOwnCanvas };
2030   }
2031 
2032   _getMKDict(rotation) {
2033     const mk = new Dict(null);
2034     if (rotation) {
2035       mk.set("R", rotation);
2036     }
2037     if (this.borderColor) {
2038       mk.set("BC", getPdfColorArray(this.borderColor));
2039     }
2040     if (this.backgroundColor) {
2041       mk.set("BG", getPdfColorArray(this.backgroundColor));
2042     }
2043     return mk.size > 0 ? mk : null;
2044   }
2045 
2046   amendSavedDict(annotationStorage, dict) {}
2047 
2048   async save(evaluator, task, annotationStorage) {
2049     const storageEntry = annotationStorage?.get(this.data.id);
2050     let value = storageEntry?.value,
2051       rotation = storageEntry?.rotation;
2052     if (value === this.data.fieldValue || value === undefined) {
2053       if (!this._hasValueFromXFA && rotation === undefined) {
2054         return null;
2055       }
2056       value ||= this.data.fieldValue;
2057     }
2058 
2059     // Value can be an array (with choice list and multiple selections)
2060     if (
2061       rotation === undefined &&
2062       !this._hasValueFromXFA &&
2063       Array.isArray(value) &&
2064       Array.isArray(this.data.fieldValue) &&
2065       value.length === this.data.fieldValue.length &&
2066       value.every((x, i) => x === this.data.fieldValue[i])
2067     ) {
2068       return null;
2069     }
2070 
2071     if (rotation === undefined) {
2072       rotation = this.rotation;
2073     }
2074 
2075     let appearance = null;
2076     if (!this._needAppearances) {
2077       appearance = await this._getAppearance(
2078         evaluator,
2079         task,
2080         RenderingIntentFlag.SAVE,
2081         annotationStorage
2082       );
2083       if (appearance === null) {
2084         // Appearance didn't change.
2085         return null;
2086       }
2087     } else {
2088       // No need to create an appearance: the pdf has the flag /NeedAppearances
2089       // which means that it's up to the reader to produce an appearance.
2090     }
2091 
2092     let needAppearances = false;
2093     if (appearance?.needAppearances) {
2094       needAppearances = true;
2095       appearance = null;
2096     }
2097 
2098     const { xref } = evaluator;
2099 
2100     const originalDict = xref.fetchIfRef(this.ref);
2101     if (!(originalDict instanceof Dict)) {
2102       return null;
2103     }
2104 
2105     const dict = new Dict(xref);
2106     for (const key of originalDict.getKeys()) {
2107       if (key !== "AP") {
2108         dict.set(key, originalDict.getRaw(key));
2109       }
2110     }
2111 
2112     const xfa = {
2113       path: this.data.fieldName,
2114       value,
2115     };
2116 
2117     const encoder = val => {
2118       return isAscii(val)
2119         ? val
2120         : stringToUTF16String(val, /* bigEndian = */ true);
2121     };
2122     dict.set("V", Array.isArray(value) ? value.map(encoder) : encoder(value));
2123     this.amendSavedDict(annotationStorage, dict);
2124 
2125     const maybeMK = this._getMKDict(rotation);
2126     if (maybeMK) {
2127       dict.set("MK", maybeMK);
2128     }
2129 
2130     const buffer = [];
2131     const changes = [
2132       // data for the original object
2133       // V field changed + reference for new AP
2134       { ref: this.ref, data: "", xfa, needAppearances },
2135     ];
2136     if (appearance !== null) {
2137       const newRef = xref.getNewTemporaryRef();
2138       const AP = new Dict(xref);
2139       dict.set("AP", AP);
2140       AP.set("N", newRef);
2141 
2142       const resources = this._getSaveFieldResources(xref);
2143       const appearanceStream = new StringStream(appearance);
2144       const appearanceDict = (appearanceStream.dict = new Dict(xref));
2145       appearanceDict.set("Subtype", Name.get("Form"));
2146       appearanceDict.set("Resources", resources);
2147       appearanceDict.set("BBox", [
2148         0,
2149         0,
2150         this.data.rect[2] - this.data.rect[0],
2151         this.data.rect[3] - this.data.rect[1],
2152       ]);
2153 
2154       const rotationMatrix = this.getRotationMatrix(annotationStorage);
2155       if (rotationMatrix !== IDENTITY_MATRIX) {
2156         // The matrix isn't the identity one.
2157         appearanceDict.set("Matrix", rotationMatrix);
2158       }
2159 
2160       await writeObject(newRef, appearanceStream, buffer, xref);
2161 
2162       changes.push(
2163         // data for the new AP
2164         {
2165           ref: newRef,
2166           data: buffer.join(""),
2167           xfa: null,
2168           needAppearances: false,
2169         }
2170       );
2171       buffer.length = 0;
2172     }
2173 
2174     dict.set("M", `D:${getModificationDate()}`);
2175     await writeObject(this.ref, dict, buffer, xref);
2176 
2177     changes[0].data = buffer.join("");
2178 
2179     return changes;
2180   }
2181 
2182   async _getAppearance(evaluator, task, intent, annotationStorage) {
2183     const isPassword = this.hasFieldFlag(AnnotationFieldFlag.PASSWORD);
2184     if (isPassword) {
2185       return null;
2186     }
2187     const storageEntry = annotationStorage?.get(this.data.id);
2188     let value, rotation;
2189     if (storageEntry) {
2190       value = storageEntry.formattedValue || storageEntry.value;
2191       rotation = storageEntry.rotation;
2192     }
2193 
2194     if (
2195       rotation === undefined &&
2196       value === undefined &&
2197       !this._needAppearances
2198     ) {
2199       if (!this._hasValueFromXFA || this.appearance) {
2200         // The annotation hasn't been rendered so use the appearance.
2201         return null;
2202       }
2203     }
2204 
2205     // Empty or it has a trailing whitespace.
2206     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2207 
2208     if (value === undefined) {
2209       // The annotation has its value in XFA datasets but not in the V field.
2210       value = this.data.fieldValue;
2211       if (!value) {
2212         return `/Tx BMC q ${colors}Q EMC`;
2213       }
2214     }
2215 
2216     if (Array.isArray(value) && value.length === 1) {
2217       value = value[0];
2218     }
2219 
2220     assert(typeof value === "string", "Expected `value` to be a string.");
2221     value = value.trim();
2222 
2223     if (this.data.combo) {
2224       // The value can be one of the exportValue or any other values.
2225       const option = this.data.options.find(
2226         ({ exportValue }) => value === exportValue
2227       );
2228       value = option?.displayValue || value;
2229     }
2230 
2231     if (value === "") {
2232       // the field is empty: nothing to render
2233       return `/Tx BMC q ${colors}Q EMC`;
2234     }
2235 
2236     if (rotation === undefined) {
2237       rotation = this.rotation;
2238     }
2239 
2240     let lineCount = -1;
2241     let lines;
2242 
2243     // We could have a text containing for example some sequences of chars and
2244     // their diacritics (e.g. "é".normalize("NFKD") shows 1 char when it's 2).
2245     // Positioning diacritics is really something we don't want to do here.
2246     // So if a font has a glyph for a acute accent and one for "e" then we won't
2247     // get any encoding issues but we'll render "e" and then "´".
2248     // It's why we normalize the string. We use NFC to preserve the initial
2249     // string, (e.g. "²".normalize("NFC") === "²"
2250     // but "²".normalize("NFKC") === "2").
2251     //
2252     // TODO: it isn't a perfect solution, some chars like "ẹ́" will be
2253     // decomposed into two chars ("ẹ" and "´"), so we should detect such
2254     // situations and then use either FakeUnicodeFont or set the
2255     // /NeedAppearances flag.
2256     if (this.data.multiLine) {
2257       lines = value.split(/\r\n?|\n/).map(line => line.normalize("NFC"));
2258       lineCount = lines.length;
2259     } else {
2260       lines = [value.replace(/\r\n?|\n/, "").normalize("NFC")];
2261     }
2262 
2263     const defaultPadding = 1;
2264     const defaultHPadding = 2;
2265     let totalHeight = this.data.rect[3] - this.data.rect[1];
2266     let totalWidth = this.data.rect[2] - this.data.rect[0];
2267 
2268     if (rotation === 90 || rotation === 270) {
2269       [totalWidth, totalHeight] = [totalHeight, totalWidth];
2270     }
2271 
2272     if (!this._defaultAppearance) {
2273       // The DA is required and must be a string.
2274       // If there is no font named Helvetica in the resource dictionary,
2275       // the evaluator will fall back to a default font.
2276       // Doing so prevents exceptions and allows saving/printing
2277       // the file as expected.
2278       this.data.defaultAppearanceData = parseDefaultAppearance(
2279         (this._defaultAppearance = "/Helvetica 0 Tf 0 g")
2280       );
2281     }
2282 
2283     let font = await WidgetAnnotation._getFontData(
2284       evaluator,
2285       task,
2286       this.data.defaultAppearanceData,
2287       this._fieldResources.mergedResources
2288     );
2289 
2290     let defaultAppearance, fontSize, lineHeight;
2291     const encodedLines = [];
2292     let encodingError = false;
2293     for (const line of lines) {
2294       const encodedString = font.encodeString(line);
2295       if (encodedString.length > 1) {
2296         encodingError = true;
2297       }
2298       encodedLines.push(encodedString.join(""));
2299     }
2300 
2301     if (encodingError && intent & RenderingIntentFlag.SAVE) {
2302       // We don't have a way to render the field, so we just rely on the
2303       // /NeedAppearances trick to let the different sofware correctly render
2304       // this pdf.
2305       return { needAppearances: true };
2306     }
2307 
2308     // We check that the font is able to encode the string.
2309     if (encodingError && this._isOffscreenCanvasSupported) {
2310       // If it can't then we fallback on fake unicode font (mapped to sans-serif
2311       // for the rendering).
2312       // It means that a printed form can be rendered differently (it depends on
2313       // the sans-serif font) but at least we've something to render.
2314       // In an ideal world the associated font should correctly handle the
2315       // possible chars but a user can add a smiley or whatever.
2316       // We could try to embed a font but it means that we must have access
2317       // to the raw font file.
2318       const fontFamily = this.data.comb ? "monospace" : "sans-serif";
2319       const fakeUnicodeFont = new FakeUnicodeFont(evaluator.xref, fontFamily);
2320       const resources = fakeUnicodeFont.createFontResources(lines.join(""));
2321       const newFont = resources.getRaw("Font");
2322 
2323       if (this._fieldResources.mergedResources.has("Font")) {
2324         const oldFont = this._fieldResources.mergedResources.get("Font");
2325         for (const key of newFont.getKeys()) {
2326           oldFont.set(key, newFont.getRaw(key));
2327         }
2328       } else {
2329         this._fieldResources.mergedResources.set("Font", newFont);
2330       }
2331 
2332       const fontName = fakeUnicodeFont.fontName.name;
2333       font = await WidgetAnnotation._getFontData(
2334         evaluator,
2335         task,
2336         { fontName, fontSize: 0 },
2337         resources
2338       );
2339 
2340       for (let i = 0, ii = encodedLines.length; i < ii; i++) {
2341         encodedLines[i] = stringToUTF16String(lines[i]);
2342       }
2343 
2344       const savedDefaultAppearance = Object.assign(
2345         Object.create(null),
2346         this.data.defaultAppearanceData
2347       );
2348       this.data.defaultAppearanceData.fontSize = 0;
2349       this.data.defaultAppearanceData.fontName = fontName;
2350 
2351       [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(
2352         totalHeight - 2 * defaultPadding,
2353         totalWidth - 2 * defaultHPadding,
2354         value,
2355         font,
2356         lineCount
2357       );
2358 
2359       this.data.defaultAppearanceData = savedDefaultAppearance;
2360     } else {
2361       if (!this._isOffscreenCanvasSupported) {
2362         warn(
2363           "_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly."
2364         );
2365       }
2366 
2367       [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(
2368         totalHeight - 2 * defaultPadding,
2369         totalWidth - 2 * defaultHPadding,
2370         value,
2371         font,
2372         lineCount
2373       );
2374     }
2375 
2376     let descent = font.descent;
2377     if (isNaN(descent)) {
2378       descent = BASELINE_FACTOR * lineHeight;
2379     } else {
2380       descent = Math.max(
2381         BASELINE_FACTOR * lineHeight,
2382         Math.abs(descent) * fontSize
2383       );
2384     }
2385 
2386     // Take into account the space we have to compute the default vertical
2387     // padding.
2388     const defaultVPadding = Math.min(
2389       Math.floor((totalHeight - fontSize) / 2),
2390       defaultPadding
2391     );
2392     const alignment = this.data.textAlignment;
2393 
2394     if (this.data.multiLine) {
2395       return this._getMultilineAppearance(
2396         defaultAppearance,
2397         encodedLines,
2398         font,
2399         fontSize,
2400         totalWidth,
2401         totalHeight,
2402         alignment,
2403         defaultHPadding,
2404         defaultVPadding,
2405         descent,
2406         lineHeight,
2407         annotationStorage
2408       );
2409     }
2410 
2411     if (this.data.comb) {
2412       return this._getCombAppearance(
2413         defaultAppearance,
2414         font,
2415         encodedLines[0],
2416         fontSize,
2417         totalWidth,
2418         totalHeight,
2419         defaultHPadding,
2420         defaultVPadding,
2421         descent,
2422         lineHeight,
2423         annotationStorage
2424       );
2425     }
2426 
2427     const bottomPadding = defaultVPadding + descent;
2428     if (alignment === 0 || alignment > 2) {
2429       // Left alignment: nothing to do
2430       return (
2431         `/Tx BMC q ${colors}BT ` +
2432         defaultAppearance +
2433         ` 1 0 0 1 ${numberToString(defaultHPadding)} ${numberToString(
2434           bottomPadding
2435         )} Tm (${escapeString(encodedLines[0])}) Tj` +
2436         " ET Q EMC"
2437       );
2438     }
2439 
2440     const prevInfo = { shift: 0 };
2441     const renderedText = this._renderText(
2442       encodedLines[0],
2443       font,
2444       fontSize,
2445       totalWidth,
2446       alignment,
2447       prevInfo,
2448       defaultHPadding,
2449       bottomPadding
2450     );
2451     return (
2452       `/Tx BMC q ${colors}BT ` +
2453       defaultAppearance +
2454       ` 1 0 0 1 0 0 Tm ${renderedText}` +
2455       " ET Q EMC"
2456     );
2457   }
2458 
2459   static async _getFontData(evaluator, task, appearanceData, resources) {
2460     const operatorList = new OperatorList();
2461     const initialState = {
2462       font: null,
2463       clone() {
2464         return this;
2465       },
2466     };
2467 
2468     const { fontName, fontSize } = appearanceData;
2469     await evaluator.handleSetFont(
2470       resources,
2471       [fontName && Name.get(fontName), fontSize],
2472       /* fontRef = */ null,
2473       operatorList,
2474       task,
2475       initialState,
2476       /* fallbackFontDict = */ null
2477     );
2478 
2479     return initialState.font;
2480   }
2481 
2482   _getTextWidth(text, font) {
2483     return (
2484       font
2485         .charsToGlyphs(text)
2486         .reduce((width, glyph) => width + glyph.width, 0) / 1000
2487     );
2488   }
2489 
2490   _computeFontSize(height, width, text, font, lineCount) {
2491     let { fontSize } = this.data.defaultAppearanceData;
2492     let lineHeight = (fontSize || 12) * LINE_FACTOR,
2493       numberOfLines = Math.round(height / lineHeight);
2494 
2495     if (!fontSize) {
2496       // A zero value for size means that the font shall be auto-sized:
2497       // its size shall be computed as a function of the height of the
2498       // annotation rectangle (see 12.7.3.3).
2499 
2500       const roundWithTwoDigits = x => Math.floor(x * 100) / 100;
2501 
2502       if (lineCount === -1) {
2503         const textWidth = this._getTextWidth(text, font);
2504         fontSize = roundWithTwoDigits(
2505           Math.min(
2506             height / LINE_FACTOR,
2507             textWidth > width ? width / textWidth : Infinity
2508           )
2509         );
2510         numberOfLines = 1;
2511       } else {
2512         const lines = text.split(/\r\n?|\n/);
2513         const cachedLines = [];
2514         for (const line of lines) {
2515           const encoded = font.encodeString(line).join("");
2516           const glyphs = font.charsToGlyphs(encoded);
2517           const positions = font.getCharPositions(encoded);
2518           cachedLines.push({
2519             line: encoded,
2520             glyphs,
2521             positions,
2522           });
2523         }
2524 
2525         const isTooBig = fsize => {
2526           // Return true when the text doesn't fit the given height.
2527           let totalHeight = 0;
2528           for (const cache of cachedLines) {
2529             const chunks = this._splitLine(null, font, fsize, width, cache);
2530             totalHeight += chunks.length * fsize;
2531             if (totalHeight > height) {
2532               return true;
2533             }
2534           }
2535           return false;
2536         };
2537 
2538         // Hard to guess how many lines there are.
2539         // The field may have been sized to have 10 lines
2540         // and the user entered only 1 so if we get font size from
2541         // height and number of lines then we'll get something too big.
2542         // So we compute a fake number of lines based on height and
2543         // a font size equal to 12 (this is the default font size in
2544         // Acrobat).
2545         // Then we'll adjust font size to what we have really.
2546         numberOfLines = Math.max(numberOfLines, lineCount);
2547 
2548         while (true) {
2549           lineHeight = height / numberOfLines;
2550           fontSize = roundWithTwoDigits(lineHeight / LINE_FACTOR);
2551 
2552           if (isTooBig(fontSize)) {
2553             numberOfLines++;
2554             continue;
2555           }
2556 
2557           break;
2558         }
2559       }
2560 
2561       const { fontName, fontColor } = this.data.defaultAppearanceData;
2562       this._defaultAppearance = createDefaultAppearance({
2563         fontSize,
2564         fontName,
2565         fontColor,
2566       });
2567     }
2568 
2569     return [this._defaultAppearance, fontSize, height / numberOfLines];
2570   }
2571 
2572   _renderText(
2573     text,
2574     font,
2575     fontSize,
2576     totalWidth,
2577     alignment,
2578     prevInfo,
2579     hPadding,
2580     vPadding
2581   ) {
2582     // TODO: we need to take into account (if possible) how the text
2583     // is rendered. For example in arabic, the cumulated width of some
2584     // glyphs isn't equal to the width of the rendered glyphs because
2585     // of ligatures.
2586     let shift;
2587     if (alignment === 1) {
2588       // Center
2589       const width = this._getTextWidth(text, font) * fontSize;
2590       shift = (totalWidth - width) / 2;
2591     } else if (alignment === 2) {
2592       // Right
2593       const width = this._getTextWidth(text, font) * fontSize;
2594       shift = totalWidth - width - hPadding;
2595     } else {
2596       shift = hPadding;
2597     }
2598     const shiftStr = numberToString(shift - prevInfo.shift);
2599     prevInfo.shift = shift;
2600     vPadding = numberToString(vPadding);
2601 
2602     return `${shiftStr} ${vPadding} Td (${escapeString(text)}) Tj`;
2603   }
2604 
2605   /**
2606    * @private
2607    */
2608   _getSaveFieldResources(xref) {
2609     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
2610       assert(
2611         this.data.defaultAppearanceData,
2612         "Expected `_defaultAppearanceData` to have been set."
2613       );
2614     }
2615     const { localResources, appearanceResources, acroFormResources } =
2616       this._fieldResources;
2617 
2618     const fontName = this.data.defaultAppearanceData?.fontName;
2619     if (!fontName) {
2620       return localResources || Dict.empty;
2621     }
2622 
2623     for (const resources of [localResources, appearanceResources]) {
2624       if (resources instanceof Dict) {
2625         const localFont = resources.get("Font");
2626         if (localFont instanceof Dict && localFont.has(fontName)) {
2627           return resources;
2628         }
2629       }
2630     }
2631     if (acroFormResources instanceof Dict) {
2632       const acroFormFont = acroFormResources.get("Font");
2633       if (acroFormFont instanceof Dict && acroFormFont.has(fontName)) {
2634         const subFontDict = new Dict(xref);
2635         subFontDict.set(fontName, acroFormFont.getRaw(fontName));
2636 
2637         const subResourcesDict = new Dict(xref);
2638         subResourcesDict.set("Font", subFontDict);
2639 
2640         return Dict.merge({
2641           xref,
2642           dictArray: [subResourcesDict, localResources],
2643           mergeSubDicts: true,
2644         });
2645       }
2646     }
2647     return localResources || Dict.empty;
2648   }
2649 
2650   getFieldObject() {
2651     return null;
2652   }
2653 }
2654 
2655 class TextWidgetAnnotation extends WidgetAnnotation {
2656   constructor(params) {
2657     super(params);
2658 
2659     this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML;
2660     this._hasText = true;
2661 
2662     const dict = params.dict;
2663 
2664     // The field value is always a string.
2665     if (typeof this.data.fieldValue !== "string") {
2666       this.data.fieldValue = "";
2667     }
2668 
2669     // Determine the alignment of text in the field.
2670     let alignment = getInheritableProperty({ dict, key: "Q" });
2671     if (!Number.isInteger(alignment) || alignment < 0 || alignment > 2) {
2672       alignment = null;
2673     }
2674     this.data.textAlignment = alignment;
2675 
2676     // Determine the maximum length of text in the field.
2677     let maximumLength = getInheritableProperty({ dict, key: "MaxLen" });
2678     if (!Number.isInteger(maximumLength) || maximumLength < 0) {
2679       maximumLength = 0;
2680     }
2681     this.data.maxLen = maximumLength;
2682 
2683     // Process field flags for the display layer.
2684     this.data.multiLine = this.hasFieldFlag(AnnotationFieldFlag.MULTILINE);
2685     this.data.comb =
2686       this.hasFieldFlag(AnnotationFieldFlag.COMB) &&
2687       !this.hasFieldFlag(AnnotationFieldFlag.MULTILINE) &&
2688       !this.hasFieldFlag(AnnotationFieldFlag.PASSWORD) &&
2689       !this.hasFieldFlag(AnnotationFieldFlag.FILESELECT) &&
2690       this.data.maxLen !== 0;
2691     this.data.doNotScroll = this.hasFieldFlag(AnnotationFieldFlag.DONOTSCROLL);
2692   }
2693 
2694   get hasTextContent() {
2695     return !!this.appearance && !this._needAppearances;
2696   }
2697 
2698   _getCombAppearance(
2699     defaultAppearance,
2700     font,
2701     text,
2702     fontSize,
2703     width,
2704     height,
2705     hPadding,
2706     vPadding,
2707     descent,
2708     lineHeight,
2709     annotationStorage
2710   ) {
2711     const combWidth = width / this.data.maxLen;
2712     // Empty or it has a trailing whitespace.
2713     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2714 
2715     const buf = [];
2716     const positions = font.getCharPositions(text);
2717     for (const [start, end] of positions) {
2718       buf.push(`(${escapeString(text.substring(start, end))}) Tj`);
2719     }
2720 
2721     const renderedComb = buf.join(` ${numberToString(combWidth)} 0 Td `);
2722     return (
2723       `/Tx BMC q ${colors}BT ` +
2724       defaultAppearance +
2725       ` 1 0 0 1 ${numberToString(hPadding)} ${numberToString(
2726         vPadding + descent
2727       )} Tm ${renderedComb}` +
2728       " ET Q EMC"
2729     );
2730   }
2731 
2732   _getMultilineAppearance(
2733     defaultAppearance,
2734     lines,
2735     font,
2736     fontSize,
2737     width,
2738     height,
2739     alignment,
2740     hPadding,
2741     vPadding,
2742     descent,
2743     lineHeight,
2744     annotationStorage
2745   ) {
2746     const buf = [];
2747     const totalWidth = width - 2 * hPadding;
2748     const prevInfo = { shift: 0 };
2749     for (let i = 0, ii = lines.length; i < ii; i++) {
2750       const line = lines[i];
2751       const chunks = this._splitLine(line, font, fontSize, totalWidth);
2752       for (let j = 0, jj = chunks.length; j < jj; j++) {
2753         const chunk = chunks[j];
2754         const vShift =
2755           i === 0 && j === 0 ? -vPadding - (lineHeight - descent) : -lineHeight;
2756         buf.push(
2757           this._renderText(
2758             chunk,
2759             font,
2760             fontSize,
2761             width,
2762             alignment,
2763             prevInfo,
2764             hPadding,
2765             vShift
2766           )
2767         );
2768       }
2769     }
2770 
2771     // Empty or it has a trailing whitespace.
2772     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2773     const renderedText = buf.join("\n");
2774 
2775     return (
2776       `/Tx BMC q ${colors}BT ` +
2777       defaultAppearance +
2778       ` 1 0 0 1 0 ${numberToString(height)} Tm ${renderedText}` +
2779       " ET Q EMC"
2780     );
2781   }
2782 
2783   _splitLine(line, font, fontSize, width, cache = {}) {
2784     line = cache.line || line;
2785 
2786     const glyphs = cache.glyphs || font.charsToGlyphs(line);
2787 
2788     if (glyphs.length <= 1) {
2789       // Nothing to split
2790       return [line];
2791     }
2792 
2793     const positions = cache.positions || font.getCharPositions(line);
2794     const scale = fontSize / 1000;
2795     const chunks = [];
2796 
2797     let lastSpacePosInStringStart = -1,
2798       lastSpacePosInStringEnd = -1,
2799       lastSpacePos = -1,
2800       startChunk = 0,
2801       currentWidth = 0;
2802 
2803     for (let i = 0, ii = glyphs.length; i < ii; i++) {
2804       const [start, end] = positions[i];
2805       const glyph = glyphs[i];
2806       const glyphWidth = glyph.width * scale;
2807       if (glyph.unicode === " ") {
2808         if (currentWidth + glyphWidth > width) {
2809           // We can break here
2810           chunks.push(line.substring(startChunk, start));
2811           startChunk = start;
2812           currentWidth = glyphWidth;
2813           lastSpacePosInStringStart = -1;
2814           lastSpacePos = -1;
2815         } else {
2816           currentWidth += glyphWidth;
2817           lastSpacePosInStringStart = start;
2818           lastSpacePosInStringEnd = end;
2819           lastSpacePos = i;
2820         }
2821       } else if (currentWidth + glyphWidth > width) {
2822         // We must break to the last white position (if available)
2823         if (lastSpacePosInStringStart !== -1) {
2824           chunks.push(line.substring(startChunk, lastSpacePosInStringEnd));
2825           startChunk = lastSpacePosInStringEnd;
2826           i = lastSpacePos + 1;
2827           lastSpacePosInStringStart = -1;
2828           currentWidth = 0;
2829         } else {
2830           // Just break in the middle of the word
2831           chunks.push(line.substring(startChunk, start));
2832           startChunk = start;
2833           currentWidth = glyphWidth;
2834         }
2835       } else {
2836         currentWidth += glyphWidth;
2837       }
2838     }
2839 
2840     if (startChunk < line.length) {
2841       chunks.push(line.substring(startChunk, line.length));
2842     }
2843 
2844     return chunks;
2845   }
2846 
2847   getFieldObject() {
2848     return {
2849       id: this.data.id,
2850       value: this.data.fieldValue,
2851       defaultValue: this.data.defaultFieldValue || "",
2852       multiline: this.data.multiLine,
2853       password: this.hasFieldFlag(AnnotationFieldFlag.PASSWORD),
2854       charLimit: this.data.maxLen,
2855       comb: this.data.comb,
2856       editable: !this.data.readOnly,
2857       hidden: this.data.hidden,
2858       name: this.data.fieldName,
2859       rect: this.data.rect,
2860       actions: this.data.actions,
2861       page: this.data.pageIndex,
2862       strokeColor: this.data.borderColor,
2863       fillColor: this.data.backgroundColor,
2864       rotation: this.rotation,
2865       type: "text",
2866     };
2867   }
2868 }
2869 
2870 class ButtonWidgetAnnotation extends WidgetAnnotation {
2871   constructor(params) {
2872     super(params);
2873 
2874     this.checkedAppearance = null;
2875     this.uncheckedAppearance = null;
2876 
2877     this.data.checkBox =
2878       !this.hasFieldFlag(AnnotationFieldFlag.RADIO) &&
2879       !this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2880     this.data.radioButton =
2881       this.hasFieldFlag(AnnotationFieldFlag.RADIO) &&
2882       !this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2883     this.data.pushButton = this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2884     this.data.isTooltipOnly = false;
2885 
2886     if (this.data.checkBox) {
2887       this._processCheckBox(params);
2888     } else if (this.data.radioButton) {
2889       this._processRadioButton(params);
2890     } else if (this.data.pushButton) {
2891       this.data.hasOwnCanvas = true;
2892       this.data.noHTML = false;
2893       this._processPushButton(params);
2894     } else {
2895       warn("Invalid field flags for button widget annotation");
2896     }
2897   }
2898 
2899   async getOperatorList(
2900     evaluator,
2901     task,
2902     intent,
2903     renderForms,
2904     annotationStorage
2905   ) {
2906     if (this.data.pushButton) {
2907       return super.getOperatorList(
2908         evaluator,
2909         task,
2910         intent,
2911         false, // we use normalAppearance to render the button
2912         annotationStorage
2913       );
2914     }
2915 
2916     let value = null;
2917     let rotation = null;
2918     if (annotationStorage) {
2919       const storageEntry = annotationStorage.get(this.data.id);
2920       value = storageEntry ? storageEntry.value : null;
2921       rotation = storageEntry ? storageEntry.rotation : null;
2922     }
2923 
2924     if (value === null && this.appearance) {
2925       // Nothing in the annotationStorage.
2926       // But we've a default appearance so use it.
2927       return super.getOperatorList(
2928         evaluator,
2929         task,
2930         intent,
2931         renderForms,
2932         annotationStorage
2933       );
2934     }
2935 
2936     if (value === null || value === undefined) {
2937       // There is no default appearance so use the one derived
2938       // from the field value.
2939       value = this.data.checkBox
2940         ? this.data.fieldValue === this.data.exportValue
2941         : this.data.fieldValue === this.data.buttonValue;
2942     }
2943 
2944     const appearance = value
2945       ? this.checkedAppearance
2946       : this.uncheckedAppearance;
2947     if (appearance) {
2948       const savedAppearance = this.appearance;
2949       const savedMatrix = appearance.dict.getArray("Matrix") || IDENTITY_MATRIX;
2950 
2951       if (rotation) {
2952         appearance.dict.set(
2953           "Matrix",
2954           this.getRotationMatrix(annotationStorage)
2955         );
2956       }
2957 
2958       this.appearance = appearance;
2959       const operatorList = super.getOperatorList(
2960         evaluator,
2961         task,
2962         intent,
2963         renderForms,
2964         annotationStorage
2965       );
2966       this.appearance = savedAppearance;
2967       appearance.dict.set("Matrix", savedMatrix);
2968       return operatorList;
2969     }
2970 
2971     // No appearance
2972     return {
2973       opList: new OperatorList(),
2974       separateForm: false,
2975       separateCanvas: false,
2976     };
2977   }
2978 
2979   async save(evaluator, task, annotationStorage) {
2980     if (this.data.checkBox) {
2981       return this._saveCheckbox(evaluator, task, annotationStorage);
2982     }
2983 
2984     if (this.data.radioButton) {
2985       return this._saveRadioButton(evaluator, task, annotationStorage);
2986     }
2987 
2988     // Nothing to save
2989     return null;
2990   }
2991 
2992   async _saveCheckbox(evaluator, task, annotationStorage) {
2993     if (!annotationStorage) {
2994       return null;
2995     }
2996     const storageEntry = annotationStorage.get(this.data.id);
2997     let rotation = storageEntry?.rotation,
2998       value = storageEntry?.value;
2999 
3000     if (rotation === undefined) {
3001       if (value === undefined) {
3002         return null;
3003       }
3004 
3005       const defaultValue = this.data.fieldValue === this.data.exportValue;
3006       if (defaultValue === value) {
3007         return null;
3008       }
3009     }
3010 
3011     const dict = evaluator.xref.fetchIfRef(this.ref);
3012     if (!(dict instanceof Dict)) {
3013       return null;
3014     }
3015 
3016     if (rotation === undefined) {
3017       rotation = this.rotation;
3018     }
3019     if (value === undefined) {
3020       value = this.data.fieldValue === this.data.exportValue;
3021     }
3022 
3023     const xfa = {
3024       path: this.data.fieldName,
3025       value: value ? this.data.exportValue : "",
3026     };
3027 
3028     const name = Name.get(value ? this.data.exportValue : "Off");
3029     dict.set("V", name);
3030     dict.set("AS", name);
3031     dict.set("M", `D:${getModificationDate()}`);
3032 
3033     const maybeMK = this._getMKDict(rotation);
3034     if (maybeMK) {
3035       dict.set("MK", maybeMK);
3036     }
3037 
3038     const buffer = [];
3039     await writeObject(this.ref, dict, buffer, evaluator.xref);
3040 
3041     return [{ ref: this.ref, data: buffer.join(""), xfa }];
3042   }
3043 
3044   async _saveRadioButton(evaluator, task, annotationStorage) {
3045     if (!annotationStorage) {
3046       return null;
3047     }
3048     const storageEntry = annotationStorage.get(this.data.id);
3049     let rotation = storageEntry?.rotation,
3050       value = storageEntry?.value;
3051 
3052     if (rotation === undefined) {
3053       if (value === undefined) {
3054         return null;
3055       }
3056 
3057       const defaultValue = this.data.fieldValue === this.data.buttonValue;
3058       if (defaultValue === value) {
3059         return null;
3060       }
3061     }
3062 
3063     const dict = evaluator.xref.fetchIfRef(this.ref);
3064     if (!(dict instanceof Dict)) {
3065       return null;
3066     }
3067 
3068     if (value === undefined) {
3069       value = this.data.fieldValue === this.data.buttonValue;
3070     }
3071 
3072     if (rotation === undefined) {
3073       rotation = this.rotation;
3074     }
3075 
3076     const xfa = {
3077       path: this.data.fieldName,
3078       value: value ? this.data.buttonValue : "",
3079     };
3080 
3081     const name = Name.get(value ? this.data.buttonValue : "Off");
3082     const buffer = [];
3083     let parentData = null;
3084 
3085     if (value) {
3086       if (this.parent instanceof Ref) {
3087         const parent = evaluator.xref.fetch(this.parent);
3088         parent.set("V", name);
3089         await writeObject(this.parent, parent, buffer, evaluator.xref);
3090         parentData = buffer.join("");
3091         buffer.length = 0;
3092       } else if (this.parent instanceof Dict) {
3093         this.parent.set("V", name);
3094       }
3095     }
3096 
3097     dict.set("AS", name);
3098     dict.set("M", `D:${getModificationDate()}`);
3099 
3100     const maybeMK = this._getMKDict(rotation);
3101     if (maybeMK) {
3102       dict.set("MK", maybeMK);
3103     }
3104 
3105     await writeObject(this.ref, dict, buffer, evaluator.xref);
3106     const newRefs = [{ ref: this.ref, data: buffer.join(""), xfa }];
3107     if (parentData) {
3108       newRefs.push({ ref: this.parent, data: parentData, xfa: null });
3109     }
3110 
3111     return newRefs;
3112   }
3113 
3114   _getDefaultCheckedAppearance(params, type) {
3115     const width = this.data.rect[2] - this.data.rect[0];
3116     const height = this.data.rect[3] - this.data.rect[1];
3117     const bbox = [0, 0, width, height];
3118 
3119     // Ratio used to have a mark slightly smaller than the bbox.
3120     const FONT_RATIO = 0.8;
3121     const fontSize = Math.min(width, height) * FONT_RATIO;
3122 
3123     // Char Metrics
3124     // Widths came from widths for ZapfDingbats.
3125     // Heights are guessed with Fontforge and FoxitDingbats.pfb.
3126     let metrics, char;
3127     if (type === "check") {
3128       // Char 33 (2713 in unicode)
3129       metrics = {
3130         width: 0.755 * fontSize,
3131         height: 0.705 * fontSize,
3132       };
3133       char = "\x33";
3134     } else if (type === "disc") {
3135       // Char 6C (25CF in unicode)
3136       metrics = {
3137         width: 0.791 * fontSize,
3138         height: 0.705 * fontSize,
3139       };
3140       char = "\x6C";
3141     } else {
3142       unreachable(`_getDefaultCheckedAppearance - unsupported type: ${type}`);
3143     }
3144 
3145     // Values to center the glyph in the bbox.
3146     const xShift = numberToString((width - metrics.width) / 2);
3147     const yShift = numberToString((height - metrics.height) / 2);
3148 
3149     const appearance = `q BT /PdfJsZaDb ${fontSize} Tf 0 g ${xShift} ${yShift} Td (${char}) Tj ET Q`;
3150 
3151     const appearanceStreamDict = new Dict(params.xref);
3152     appearanceStreamDict.set("FormType", 1);
3153     appearanceStreamDict.set("Subtype", Name.get("Form"));
3154     appearanceStreamDict.set("Type", Name.get("XObject"));
3155     appearanceStreamDict.set("BBox", bbox);
3156     appearanceStreamDict.set("Matrix", [1, 0, 0, 1, 0, 0]);
3157     appearanceStreamDict.set("Length", appearance.length);
3158 
3159     const resources = new Dict(params.xref);
3160     const font = new Dict(params.xref);
3161     font.set("PdfJsZaDb", this.fallbackFontDict);
3162     resources.set("Font", font);
3163 
3164     appearanceStreamDict.set("Resources", resources);
3165 
3166     this.checkedAppearance = new StringStream(appearance);
3167     this.checkedAppearance.dict = appearanceStreamDict;
3168 
3169     this._streams.push(this.checkedAppearance);
3170   }
3171 
3172   _processCheckBox(params) {
3173     const customAppearance = params.dict.get("AP");
3174     if (!(customAppearance instanceof Dict)) {
3175       return;
3176     }
3177 
3178     const normalAppearance = customAppearance.get("N");
3179     if (!(normalAppearance instanceof Dict)) {
3180       return;
3181     }
3182 
3183     // See https://bugzilla.mozilla.org/show_bug.cgi?id=1722036.
3184     // If we've an AS and a V then take AS.
3185     const asValue = this._decodeFormValue(params.dict.get("AS"));
3186     if (typeof asValue === "string") {
3187       this.data.fieldValue = asValue;
3188     }
3189 
3190     const yes =
3191       this.data.fieldValue !== null && this.data.fieldValue !== "Off"
3192         ? this.data.fieldValue
3193         : "Yes";
3194 
3195     const exportValues = normalAppearance.getKeys();
3196     if (exportValues.length === 0) {
3197       exportValues.push("Off", yes);
3198     } else if (exportValues.length === 1) {
3199       if (exportValues[0] === "Off") {
3200         exportValues.push(yes);
3201       } else {
3202         exportValues.unshift("Off");
3203       }
3204     } else if (exportValues.includes(yes)) {
3205       exportValues.length = 0;
3206       exportValues.push("Off", yes);
3207     } else {
3208       const otherYes = exportValues.find(v => v !== "Off");
3209       exportValues.length = 0;
3210       exportValues.push("Off", otherYes);
3211     }
3212 
3213     // Don't use a "V" entry pointing to a non-existent appearance state,
3214     // see e.g. bug1720411.pdf where it's an *empty* Name-instance.
3215     if (!exportValues.includes(this.data.fieldValue)) {
3216       this.data.fieldValue = "Off";
3217     }
3218 
3219     this.data.exportValue = exportValues[1];
3220 
3221     const checkedAppearance = normalAppearance.get(this.data.exportValue);
3222     this.checkedAppearance =
3223       checkedAppearance instanceof BaseStream ? checkedAppearance : null;
3224     const uncheckedAppearance = normalAppearance.get("Off");
3225     this.uncheckedAppearance =
3226       uncheckedAppearance instanceof BaseStream ? uncheckedAppearance : null;
3227 
3228     if (this.checkedAppearance) {
3229       this._streams.push(this.checkedAppearance);
3230     } else {
3231       this._getDefaultCheckedAppearance(params, "check");
3232     }
3233     if (this.uncheckedAppearance) {
3234       this._streams.push(this.uncheckedAppearance);
3235     }
3236     this._fallbackFontDict = this.fallbackFontDict;
3237     if (this.data.defaultFieldValue === null) {
3238       this.data.defaultFieldValue = "Off";
3239     }
3240   }
3241 
3242   _processRadioButton(params) {
3243     this.data.buttonValue = null;
3244 
3245     // The parent field's `V` entry holds a `Name` object with the appearance
3246     // state of whichever child field is currently in the "on" state.
3247     const fieldParent = params.dict.get("Parent");
3248     if (fieldParent instanceof Dict) {
3249       this.parent = params.dict.getRaw("Parent");
3250       const fieldParentValue = fieldParent.get("V");
3251       if (fieldParentValue instanceof Name) {
3252         this.data.fieldValue = this._decodeFormValue(fieldParentValue);
3253       }
3254     }
3255 
3256     // The button's value corresponds to its appearance state.
3257     const appearanceStates = params.dict.get("AP");
3258     if (!(appearanceStates instanceof Dict)) {
3259       return;
3260     }
3261     const normalAppearance = appearanceStates.get("N");
3262     if (!(normalAppearance instanceof Dict)) {
3263       return;
3264     }
3265     for (const key of normalAppearance.getKeys()) {
3266       if (key !== "Off") {
3267         this.data.buttonValue = this._decodeFormValue(key);
3268         break;
3269       }
3270     }
3271 
3272     const checkedAppearance = normalAppearance.get(this.data.buttonValue);
3273     this.checkedAppearance =
3274       checkedAppearance instanceof BaseStream ? checkedAppearance : null;
3275     const uncheckedAppearance = normalAppearance.get("Off");
3276     this.uncheckedAppearance =
3277       uncheckedAppearance instanceof BaseStream ? uncheckedAppearance : null;
3278 
3279     if (this.checkedAppearance) {
3280       this._streams.push(this.checkedAppearance);
3281     } else {
3282       this._getDefaultCheckedAppearance(params, "disc");
3283     }
3284     if (this.uncheckedAppearance) {
3285       this._streams.push(this.uncheckedAppearance);
3286     }
3287     this._fallbackFontDict = this.fallbackFontDict;
3288     if (this.data.defaultFieldValue === null) {
3289       this.data.defaultFieldValue = "Off";
3290     }
3291   }
3292 
3293   _processPushButton(params) {
3294     const { dict, annotationGlobals } = params;
3295 
3296     if (!dict.has("A") && !dict.has("AA") && !this.data.alternativeText) {
3297       warn("Push buttons without action dictionaries are not supported");
3298       return;
3299     }
3300 
3301     this.data.isTooltipOnly = !dict.has("A") && !dict.has("AA");
3302 
3303     Catalog.parseDestDictionary({
3304       destDict: dict,
3305       resultObj: this.data,
3306       docBaseUrl: annotationGlobals.baseUrl,
3307       docAttachments: annotationGlobals.attachments,
3308     });
3309   }
3310 
3311   getFieldObject() {
3312     let type = "button";
3313     let exportValues;
3314     if (this.data.checkBox) {
3315       type = "checkbox";
3316       exportValues = this.data.exportValue;
3317     } else if (this.data.radioButton) {
3318       type = "radiobutton";
3319       exportValues = this.data.buttonValue;
3320     }
3321     return {
3322       id: this.data.id,
3323       value: this.data.fieldValue || "Off",
3324       defaultValue: this.data.defaultFieldValue,
3325       exportValues,
3326       editable: !this.data.readOnly,
3327       name: this.data.fieldName,
3328       rect: this.data.rect,
3329       hidden: this.data.hidden,
3330       actions: this.data.actions,
3331       page: this.data.pageIndex,
3332       strokeColor: this.data.borderColor,
3333       fillColor: this.data.backgroundColor,
3334       rotation: this.rotation,
3335       type,
3336     };
3337   }
3338 
3339   get fallbackFontDict() {
3340     const dict = new Dict();
3341     dict.set("BaseFont", Name.get("ZapfDingbats"));
3342     dict.set("Type", Name.get("FallbackType"));
3343     dict.set("Subtype", Name.get("FallbackType"));
3344     dict.set("Encoding", Name.get("ZapfDingbatsEncoding"));
3345 
3346     return shadow(this, "fallbackFontDict", dict);
3347   }
3348 }
3349 
3350 class ChoiceWidgetAnnotation extends WidgetAnnotation {
3351   constructor(params) {
3352     super(params);
3353 
3354     const { dict, xref } = params;
3355 
3356     this.indices = dict.getArray("I");
3357     this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0;
3358 
3359     // Determine the options. The options array may consist of strings or
3360     // arrays. If the array consists of arrays, then the first element of
3361     // each array is the export value and the second element of each array is
3362     // the display value. If the array consists of strings, then these
3363     // represent both the export and display value. In this case, we convert
3364     // it to an array of arrays as well for convenience in the display layer.
3365     // Note that the specification does not state that the `Opt` field is
3366     // inheritable, but in practice PDF generators do make annotations
3367     // inherit the options from a parent annotation (issue 8094).
3368     this.data.options = [];
3369 
3370     const options = getInheritableProperty({ dict, key: "Opt" });
3371     if (Array.isArray(options)) {
3372       for (let i = 0, ii = options.length; i < ii; i++) {
3373         const option = xref.fetchIfRef(options[i]);
3374         const isOptionArray = Array.isArray(option);
3375 
3376         this.data.options[i] = {
3377           exportValue: this._decodeFormValue(
3378             isOptionArray ? xref.fetchIfRef(option[0]) : option
3379           ),
3380           displayValue: this._decodeFormValue(
3381             isOptionArray ? xref.fetchIfRef(option[1]) : option
3382           ),
3383         };
3384       }
3385     }
3386 
3387     if (!this.hasIndices) {
3388       // The field value can be `null` if no item is selected, a string if one
3389       // item is selected or an array of strings if multiple items are selected.
3390       // For consistency in the API and convenience in the display layer, we
3391       // always make the field value an array with zero, one or multiple items.
3392       if (typeof this.data.fieldValue === "string") {
3393         this.data.fieldValue = [this.data.fieldValue];
3394       } else if (!this.data.fieldValue) {
3395         this.data.fieldValue = [];
3396       }
3397     } else {
3398       // The specs say that we should have an indices array only with
3399       // multiselectable Choice and the "V" entry should have the
3400       // precedence, but Acrobat itself is using it whatever the
3401       // the "V" entry is (see bug 1770750).
3402       this.data.fieldValue = [];
3403       const ii = this.data.options.length;
3404       for (const i of this.indices) {
3405         if (Number.isInteger(i) && i >= 0 && i < ii) {
3406           this.data.fieldValue.push(this.data.options[i].exportValue);
3407         }
3408       }
3409     }
3410 
3411     // Process field flags for the display layer.
3412     this.data.combo = this.hasFieldFlag(AnnotationFieldFlag.COMBO);
3413     this.data.multiSelect = this.hasFieldFlag(AnnotationFieldFlag.MULTISELECT);
3414     this._hasText = true;
3415   }
3416 
3417   getFieldObject() {
3418     const type = this.data.combo ? "combobox" : "listbox";
3419     const value =
3420       this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
3421     return {
3422       id: this.data.id,
3423       value,
3424       defaultValue: this.data.defaultFieldValue,
3425       editable: !this.data.readOnly,
3426       name: this.data.fieldName,
3427       rect: this.data.rect,
3428       numItems: this.data.fieldValue.length,
3429       multipleSelection: this.data.multiSelect,
3430       hidden: this.data.hidden,
3431       actions: this.data.actions,
3432       items: this.data.options,
3433       page: this.data.pageIndex,
3434       strokeColor: this.data.borderColor,
3435       fillColor: this.data.backgroundColor,
3436       rotation: this.rotation,
3437       type,
3438     };
3439   }
3440 
3441   amendSavedDict(annotationStorage, dict) {
3442     if (!this.hasIndices) {
3443       return;
3444     }
3445     let values = annotationStorage?.get(this.data.id)?.value;
3446     if (!Array.isArray(values)) {
3447       values = [values];
3448     }
3449     const indices = [];
3450     const { options } = this.data;
3451     for (let i = 0, j = 0, ii = options.length; i < ii; i++) {
3452       if (options[i].exportValue === values[j]) {
3453         indices.push(i);
3454         j += 1;
3455       }
3456     }
3457     dict.set("I", indices);
3458   }
3459 
3460   async _getAppearance(evaluator, task, intent, annotationStorage) {
3461     if (this.data.combo) {
3462       return super._getAppearance(evaluator, task, intent, annotationStorage);
3463     }
3464 
3465     let exportedValue, rotation;
3466     const storageEntry = annotationStorage?.get(this.data.id);
3467     if (storageEntry) {
3468       rotation = storageEntry.rotation;
3469       exportedValue = storageEntry.value;
3470     }
3471 
3472     if (
3473       rotation === undefined &&
3474       exportedValue === undefined &&
3475       !this._needAppearances
3476     ) {
3477       // The annotation hasn't been rendered so use the appearance
3478       return null;
3479     }
3480 
3481     if (exportedValue === undefined) {
3482       exportedValue = this.data.fieldValue;
3483     } else if (!Array.isArray(exportedValue)) {
3484       exportedValue = [exportedValue];
3485     }
3486 
3487     const defaultPadding = 1;
3488     const defaultHPadding = 2;
3489     let totalHeight = this.data.rect[3] - this.data.rect[1];
3490     let totalWidth = this.data.rect[2] - this.data.rect[0];
3491 
3492     if (rotation === 90 || rotation === 270) {
3493       [totalWidth, totalHeight] = [totalHeight, totalWidth];
3494     }
3495 
3496     const lineCount = this.data.options.length;
3497     const valueIndices = [];
3498     for (let i = 0; i < lineCount; i++) {
3499       const { exportValue } = this.data.options[i];
3500       if (exportedValue.includes(exportValue)) {
3501         valueIndices.push(i);
3502       }
3503     }
3504 
3505     if (!this._defaultAppearance) {
3506       // The DA is required and must be a string.
3507       // If there is no font named Helvetica in the resource dictionary,
3508       // the evaluator will fall back to a default font.
3509       // Doing so prevents exceptions and allows saving/printing
3510       // the file as expected.
3511       this.data.defaultAppearanceData = parseDefaultAppearance(
3512         (this._defaultAppearance = "/Helvetica 0 Tf 0 g")
3513       );
3514     }
3515 
3516     const font = await WidgetAnnotation._getFontData(
3517       evaluator,
3518       task,
3519       this.data.defaultAppearanceData,
3520       this._fieldResources.mergedResources
3521     );
3522 
3523     let defaultAppearance;
3524     let { fontSize } = this.data.defaultAppearanceData;
3525     if (!fontSize) {
3526       const lineHeight = (totalHeight - defaultPadding) / lineCount;
3527       let lineWidth = -1;
3528       let value;
3529       for (const { displayValue } of this.data.options) {
3530         const width = this._getTextWidth(displayValue, font);
3531         if (width > lineWidth) {
3532           lineWidth = width;
3533           value = displayValue;
3534         }
3535       }
3536 
3537       [defaultAppearance, fontSize] = this._computeFontSize(
3538         lineHeight,
3539         totalWidth - 2 * defaultHPadding,
3540         value,
3541         font,
3542         -1
3543       );
3544     } else {
3545       defaultAppearance = this._defaultAppearance;
3546     }
3547 
3548     const lineHeight = fontSize * LINE_FACTOR;
3549     const vPadding = (lineHeight - fontSize) / 2;
3550     const numberOfVisibleLines = Math.floor(totalHeight / lineHeight);
3551 
3552     let firstIndex = 0;
3553     if (valueIndices.length > 0) {
3554       const minIndex = Math.min(...valueIndices);
3555       const maxIndex = Math.max(...valueIndices);
3556 
3557       firstIndex = Math.max(0, maxIndex - numberOfVisibleLines + 1);
3558       if (firstIndex > minIndex) {
3559         firstIndex = minIndex;
3560       }
3561     }
3562     const end = Math.min(firstIndex + numberOfVisibleLines + 1, lineCount);
3563 
3564     const buf = ["/Tx BMC q", `1 1 ${totalWidth} ${totalHeight} re W n`];
3565 
3566     if (valueIndices.length) {
3567       // This value has been copied/pasted from annotation-choice-widget.pdf.
3568       // It corresponds to rgb(153, 193, 218).
3569       buf.push("0.600006 0.756866 0.854904 rg");
3570 
3571       // Highlight the lines in filling a blue rectangle at the selected
3572       // positions.
3573       for (const index of valueIndices) {
3574         if (firstIndex <= index && index < end) {
3575           buf.push(
3576             `1 ${
3577               totalHeight - (index - firstIndex + 1) * lineHeight
3578             } ${totalWidth} ${lineHeight} re f`
3579           );
3580         }
3581       }
3582     }
3583     buf.push("BT", defaultAppearance, `1 0 0 1 0 ${totalHeight} Tm`);
3584 
3585     const prevInfo = { shift: 0 };
3586     for (let i = firstIndex; i < end; i++) {
3587       const { displayValue } = this.data.options[i];
3588       const vpadding = i === firstIndex ? vPadding : 0;
3589       buf.push(
3590         this._renderText(
3591           displayValue,
3592           font,
3593           fontSize,
3594           totalWidth,
3595           0,
3596           prevInfo,
3597           defaultHPadding,
3598           -lineHeight + vpadding
3599         )
3600       );
3601     }
3602 
3603     buf.push("ET Q EMC");
3604 
3605     return buf.join("\n");
3606   }
3607 }
3608 
3609 class SignatureWidgetAnnotation extends WidgetAnnotation {
3610   constructor(params) {
3611     super(params);
3612 
3613     // Unset the fieldValue since it's (most likely) a `Dict` which is
3614     // non-serializable and will thus cause errors when sending annotations
3615     // to the main-thread (issue 10347).
3616     this.data.fieldValue = null;
3617     this.data.hasOwnCanvas = this.data.noRotate;
3618     this.data.noHTML = !this.data.hasOwnCanvas;
3619   }
3620 
3621   getFieldObject() {
3622     return {
3623       id: this.data.id,
3624       value: null,
3625       page: this.data.pageIndex,
3626       type: "signature",
3627     };
3628   }
3629 }
3630 
3631 class TextAnnotation extends MarkupAnnotation {
3632   constructor(params) {
3633     const DEFAULT_ICON_SIZE = 22; // px
3634 
3635     super(params);
3636 
3637     // No rotation for Text (see 12.5.6.4).
3638     this.data.noRotate = true;
3639     this.data.hasOwnCanvas = this.data.noRotate;
3640     this.data.noHTML = false;
3641 
3642     const { dict } = params;
3643     this.data.annotationType = AnnotationType.TEXT;
3644 
3645     if (this.data.hasAppearance) {
3646       this.data.name = "NoIcon";
3647     } else {
3648       this.data.rect[1] = this.data.rect[3] - DEFAULT_ICON_SIZE;
3649       this.data.rect[2] = this.data.rect[0] + DEFAULT_ICON_SIZE;
3650       this.data.name = dict.has("Name") ? dict.get("Name").name : "Note";
3651     }
3652 
3653     if (dict.has("State")) {
3654       this.data.state = dict.get("State") || null;
3655       this.data.stateModel = dict.get("StateModel") || null;
3656     } else {
3657       this.data.state = null;
3658       this.data.stateModel = null;
3659     }
3660   }
3661 }
3662 
3663 class LinkAnnotation extends Annotation {
3664   constructor(params) {
3665     super(params);
3666 
3667     const { dict, annotationGlobals } = params;
3668     this.data.annotationType = AnnotationType.LINK;
3669 
3670     const quadPoints = getQuadPoints(dict, this.rectangle);
3671     if (quadPoints) {
3672       this.data.quadPoints = quadPoints;
3673     }
3674 
3675     // The color entry for a link annotation is the color of the border.
3676     this.data.borderColor ||= this.data.color;
3677 
3678     Catalog.parseDestDictionary({
3679       destDict: dict,
3680       resultObj: this.data,
3681       docBaseUrl: annotationGlobals.baseUrl,
3682       docAttachments: annotationGlobals.attachments,
3683     });
3684   }
3685 }
3686 
3687 class PopupAnnotation extends Annotation {
3688   constructor(params) {
3689     super(params);
3690 
3691     const { dict } = params;
3692     this.data.annotationType = AnnotationType.POPUP;
3693 
3694     // A pop-up is never rendered on the main canvas so we must render its HTML
3695     // version.
3696     this.data.noHTML = false;
3697 
3698     if (
3699       this.data.rect[0] === this.data.rect[2] ||
3700       this.data.rect[1] === this.data.rect[3]
3701     ) {
3702       this.data.rect = null;
3703     }
3704 
3705     let parentItem = dict.get("Parent");
3706     if (!parentItem) {
3707       warn("Popup annotation has a missing or invalid parent annotation.");
3708       return;
3709     }
3710 
3711     const parentRect = parentItem.getArray("Rect");
3712     this.data.parentRect =
3713       Array.isArray(parentRect) && parentRect.length === 4
3714         ? Util.normalizeRect(parentRect)
3715         : null;
3716 
3717     const rt = parentItem.get("RT");
3718     if (isName(rt, AnnotationReplyType.GROUP)) {
3719       // Subordinate annotations in a group should inherit
3720       // the group attributes from the primary annotation.
3721       parentItem = parentItem.get("IRT");
3722     }
3723 
3724     if (!parentItem.has("M")) {
3725       this.data.modificationDate = null;
3726     } else {
3727       this.setModificationDate(parentItem.get("M"));
3728       this.data.modificationDate = this.modificationDate;
3729     }
3730 
3731     if (!parentItem.has("C")) {
3732       // Fall back to the default background color.
3733       this.data.color = null;
3734     } else {
3735       this.setColor(parentItem.getArray("C"));
3736       this.data.color = this.color;
3737     }
3738 
3739     // If the Popup annotation is not viewable, but the parent annotation is,
3740     // that is most likely a bug. Fallback to inherit the flags from the parent
3741     // annotation (this is consistent with the behaviour in Adobe Reader).
3742     if (!this.viewable) {
3743       const parentFlags = parentItem.get("F");
3744       if (this._isViewable(parentFlags)) {
3745         this.setFlags(parentFlags);
3746       }
3747     }
3748 
3749     this.setTitle(parentItem.get("T"));
3750     this.data.titleObj = this._title;
3751 
3752     this.setContents(parentItem.get("Contents"));
3753     this.data.contentsObj = this._contents;
3754 
3755     if (parentItem.has("RC")) {
3756       this.data.richText = XFAFactory.getRichTextAsHtml(parentItem.get("RC"));
3757     }
3758 
3759     this.data.open = !!dict.get("Open");
3760   }
3761 }
3762 
3763 class FreeTextAnnotation extends MarkupAnnotation {
3764   constructor(params) {
3765     super(params);
3766 
3767     // It uses its own canvas in order to be hidden if edited.
3768     // But if it has the noHTML flag, it means that we don't want to be able
3769     // to modify it so we can just draw it on the main canvas.
3770     this.data.hasOwnCanvas = !this.data.noHTML;
3771     // We want to be able to add mouse listeners to the annotation.
3772     this.data.noHTML = false;
3773 
3774     const { evaluatorOptions, xref } = params;
3775     this.data.annotationType = AnnotationType.FREETEXT;
3776     this.setDefaultAppearance(params);
3777     this._hasAppearance = !!this.appearance;
3778 
3779     if (this._hasAppearance) {
3780       const { fontColor, fontSize } = parseAppearanceStream(
3781         this.appearance,
3782         evaluatorOptions,
3783         xref
3784       );
3785       this.data.defaultAppearanceData.fontColor = fontColor;
3786       this.data.defaultAppearanceData.fontSize = fontSize || 10;
3787     } else {
3788       this.data.defaultAppearanceData.fontSize ||= 10;
3789       const { fontColor, fontSize } = this.data.defaultAppearanceData;
3790       if (this._contents.str) {
3791         this.data.textContent = this._contents.str
3792           .split(/\r\n?|\n/)
3793           .map(line => line.trimEnd());
3794         const { coords, bbox, matrix } = FakeUnicodeFont.getFirstPositionInfo(
3795           this.rectangle,
3796           this.rotation,
3797           fontSize
3798         );
3799         this.data.textPosition = this._transformPoint(coords, bbox, matrix);
3800       }
3801       if (this._isOffscreenCanvasSupported) {
3802         const strokeAlpha = params.dict.get("CA");
3803         const fakeUnicodeFont = new FakeUnicodeFont(xref, "sans-serif");
3804         this.appearance = fakeUnicodeFont.createAppearance(
3805           this._contents.str,
3806           this.rectangle,
3807           this.rotation,
3808           fontSize,
3809           fontColor,
3810           strokeAlpha
3811         );
3812         this._streams.push(this.appearance, FakeUnicodeFont.toUnicodeStream);
3813       } else {
3814         warn(
3815           "FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly."
3816         );
3817       }
3818     }
3819   }
3820 
3821   get hasTextContent() {
3822     return this._hasAppearance;
3823   }
3824 
3825   static createNewDict(annotation, xref, { apRef, ap }) {
3826     const { color, fontSize, rect, rotation, user, value } = annotation;
3827     const freetext = new Dict(xref);
3828     freetext.set("Type", Name.get("Annot"));
3829     freetext.set("Subtype", Name.get("FreeText"));
3830     freetext.set("CreationDate", `D:${getModificationDate()}`);
3831     freetext.set("Rect", rect);
3832     const da = `/Helv ${fontSize} Tf ${getPdfColor(color, /* isFill */ true)}`;
3833     freetext.set("DA", da);
3834     freetext.set(
3835       "Contents",
3836       isAscii(value)
3837         ? value
3838         : stringToUTF16String(value, /* bigEndian = */ true)
3839     );
3840     freetext.set("F", 4);
3841     freetext.set("Border", [0, 0, 0]);
3842     freetext.set("Rotate", rotation);
3843 
3844     if (user) {
3845       freetext.set(
3846         "T",
3847         isAscii(user) ? user : stringToUTF16String(user, /* bigEndian = */ true)
3848       );
3849     }
3850 
3851     if (apRef || ap) {
3852       const n = new Dict(xref);
3853       freetext.set("AP", n);
3854 
3855       if (apRef) {
3856         n.set("N", apRef);
3857       } else {
3858         n.set("N", ap);
3859       }
3860     }
3861 
3862     return freetext;
3863   }
3864 
3865   static async createNewAppearanceStream(annotation, xref, params) {
3866     const { baseFontRef, evaluator, task } = params;
3867     const { color, fontSize, rect, rotation, value } = annotation;
3868 
3869     const resources = new Dict(xref);
3870     const font = new Dict(xref);
3871 
3872     if (baseFontRef) {
3873       font.set("Helv", baseFontRef);
3874     } else {
3875       const baseFont = new Dict(xref);
3876       baseFont.set("BaseFont", Name.get("Helvetica"));
3877       baseFont.set("Type", Name.get("Font"));
3878       baseFont.set("Subtype", Name.get("Type1"));
3879       baseFont.set("Encoding", Name.get("WinAnsiEncoding"));
3880       font.set("Helv", baseFont);
3881     }
3882     resources.set("Font", font);
3883 
3884     const helv = await WidgetAnnotation._getFontData(
3885       evaluator,
3886       task,
3887       {
3888         fontName: "Helv",
3889         fontSize,
3890       },
3891       resources
3892     );
3893 
3894     const [x1, y1, x2, y2] = rect;
3895     let w = x2 - x1;
3896     let h = y2 - y1;
3897 
3898     if (rotation % 180 !== 0) {
3899       [w, h] = [h, w];
3900     }
3901 
3902     const lines = value.split("\n");
3903     const scale = fontSize / 1000;
3904     let totalWidth = -Infinity;
3905     const encodedLines = [];
3906     for (let line of lines) {
3907       const encoded = helv.encodeString(line);
3908       if (encoded.length > 1) {
3909         // The font doesn't contain all the chars.
3910         return null;
3911       }
3912       line = encoded.join("");
3913       encodedLines.push(line);
3914       let lineWidth = 0;
3915       const glyphs = helv.charsToGlyphs(line);
3916       for (const glyph of glyphs) {
3917         lineWidth += glyph.width * scale;
3918       }
3919       totalWidth = Math.max(totalWidth, lineWidth);
3920     }
3921 
3922     let hscale = 1;
3923     if (totalWidth > w) {
3924       hscale = w / totalWidth;
3925     }
3926     let vscale = 1;
3927     const lineHeight = LINE_FACTOR * fontSize;
3928     const lineAscent = (LINE_FACTOR - LINE_DESCENT_FACTOR) * fontSize;
3929     const totalHeight = lineHeight * lines.length;
3930     if (totalHeight > h) {
3931       vscale = h / totalHeight;
3932     }
3933     const fscale = Math.min(hscale, vscale);
3934     const newFontSize = fontSize * fscale;
3935     let firstPoint, clipBox, matrix;
3936     switch (rotation) {
3937       case 0:
3938         matrix = [1, 0, 0, 1];
3939         clipBox = [rect[0], rect[1], w, h];
3940         firstPoint = [rect[0], rect[3] - lineAscent];
3941         break;
3942       case 90:
3943         matrix = [0, 1, -1, 0];
3944         clipBox = [rect[1], -rect[2], w, h];
3945         firstPoint = [rect[1], -rect[0] - lineAscent];
3946         break;
3947       case 180:
3948         matrix = [-1, 0, 0, -1];
3949         clipBox = [-rect[2], -rect[3], w, h];
3950         firstPoint = [-rect[2], -rect[1] - lineAscent];
3951         break;
3952       case 270:
3953         matrix = [0, -1, 1, 0];
3954         clipBox = [-rect[3], rect[0], w, h];
3955         firstPoint = [-rect[3], rect[2] - lineAscent];
3956         break;
3957     }
3958 
3959     const buffer = [
3960       "q",
3961       `${matrix.join(" ")} 0 0 cm`,
3962       `${clipBox.join(" ")} re W n`,
3963       `BT`,
3964       `${getPdfColor(color, /* isFill */ true)}`,
3965       `0 Tc /Helv ${numberToString(newFontSize)} Tf`,
3966     ];
3967 
3968     buffer.push(
3969       `${firstPoint.join(" ")} Td (${escapeString(encodedLines[0])}) Tj`
3970     );
3971     const vShift = numberToString(lineHeight);
3972     for (let i = 1, ii = encodedLines.length; i < ii; i++) {
3973       const line = encodedLines[i];
3974       buffer.push(`0 -${vShift} Td (${escapeString(line)}) Tj`);
3975     }
3976     buffer.push("ET", "Q");
3977     const appearance = buffer.join("\n");
3978 
3979     const appearanceStreamDict = new Dict(xref);
3980     appearanceStreamDict.set("FormType", 1);
3981     appearanceStreamDict.set("Subtype", Name.get("Form"));
3982     appearanceStreamDict.set("Type", Name.get("XObject"));
3983     appearanceStreamDict.set("BBox", rect);
3984     appearanceStreamDict.set("Resources", resources);
3985     appearanceStreamDict.set("Matrix", [1, 0, 0, 1, -rect[0], -rect[1]]);
3986 
3987     const ap = new StringStream(appearance);
3988     ap.dict = appearanceStreamDict;
3989 
3990     return ap;
3991   }
3992 }
3993 
3994 class LineAnnotation extends MarkupAnnotation {
3995   constructor(params) {
3996     super(params);
3997 
3998     const { dict, xref } = params;
3999     this.data.annotationType = AnnotationType.LINE;
4000     this.data.hasOwnCanvas = this.data.noRotate;
4001     this.data.noHTML = false;
4002 
4003     const lineCoordinates = dict.getArray("L");
4004     this.data.lineCoordinates = Util.normalizeRect(lineCoordinates);
4005 
4006     if (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) {
4007       this.setLineEndings(dict.getArray("LE"));
4008       this.data.lineEndings = this.lineEndings;
4009     }
4010 
4011     if (!this.appearance) {
4012       // The default stroke color is black.
4013       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4014       const strokeAlpha = dict.get("CA");
4015 
4016       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4017       // The default fill color is transparent. Setting the fill colour is
4018       // necessary if/when we want to add support for non-default line endings.
4019       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4020       const fillAlpha = fillColor ? strokeAlpha : null;
4021 
4022       const borderWidth = this.borderStyle.width || 1,
4023         borderAdjust = 2 * borderWidth;
4024 
4025       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4026       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4027       const bbox = [
4028         this.data.lineCoordinates[0] - borderAdjust,
4029         this.data.lineCoordinates[1] - borderAdjust,
4030         this.data.lineCoordinates[2] + borderAdjust,
4031         this.data.lineCoordinates[3] + borderAdjust,
4032       ];
4033       if (!Util.intersect(this.rectangle, bbox)) {
4034         this.rectangle = bbox;
4035       }
4036 
4037       this._setDefaultAppearance({
4038         xref,
4039         extra: `${borderWidth} w`,
4040         strokeColor,
4041         fillColor,
4042         strokeAlpha,
4043         fillAlpha,
4044         pointsCallback: (buffer, points) => {
4045           buffer.push(
4046             `${lineCoordinates[0]} ${lineCoordinates[1]} m`,
4047             `${lineCoordinates[2]} ${lineCoordinates[3]} l`,
4048             "S"
4049           );
4050           return [
4051             points[0].x - borderWidth,
4052             points[1].x + borderWidth,
4053             points[3].y - borderWidth,
4054             points[1].y + borderWidth,
4055           ];
4056         },
4057       });
4058     }
4059   }
4060 }
4061 
4062 class SquareAnnotation extends MarkupAnnotation {
4063   constructor(params) {
4064     super(params);
4065 
4066     const { dict, xref } = params;
4067     this.data.annotationType = AnnotationType.SQUARE;
4068     this.data.hasOwnCanvas = this.data.noRotate;
4069     this.data.noHTML = false;
4070 
4071     if (!this.appearance) {
4072       // The default stroke color is black.
4073       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4074       const strokeAlpha = dict.get("CA");
4075 
4076       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4077       // The default fill color is transparent.
4078       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4079       const fillAlpha = fillColor ? strokeAlpha : null;
4080 
4081       if (this.borderStyle.width === 0 && !fillColor) {
4082         // Prevent rendering a "hairline" border (fixes issue14164.pdf).
4083         return;
4084       }
4085 
4086       this._setDefaultAppearance({
4087         xref,
4088         extra: `${this.borderStyle.width} w`,
4089         strokeColor,
4090         fillColor,
4091         strokeAlpha,
4092         fillAlpha,
4093         pointsCallback: (buffer, points) => {
4094           const x = points[2].x + this.borderStyle.width / 2;
4095           const y = points[2].y + this.borderStyle.width / 2;
4096           const width = points[3].x - points[2].x - this.borderStyle.width;
4097           const height = points[1].y - points[3].y - this.borderStyle.width;
4098           buffer.push(`${x} ${y} ${width} ${height} re`);
4099           if (fillColor) {
4100             buffer.push("B");
4101           } else {
4102             buffer.push("S");
4103           }
4104           return [points[0].x, points[1].x, points[3].y, points[1].y];
4105         },
4106       });
4107     }
4108   }
4109 }
4110 
4111 class CircleAnnotation extends MarkupAnnotation {
4112   constructor(params) {
4113     super(params);
4114 
4115     const { dict, xref } = params;
4116     this.data.annotationType = AnnotationType.CIRCLE;
4117 
4118     if (!this.appearance) {
4119       // The default stroke color is black.
4120       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4121       const strokeAlpha = dict.get("CA");
4122 
4123       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4124       // The default fill color is transparent.
4125       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4126       const fillAlpha = fillColor ? strokeAlpha : null;
4127 
4128       if (this.borderStyle.width === 0 && !fillColor) {
4129         // Prevent rendering a "hairline" border (fixes issue14164.pdf).
4130         return;
4131       }
4132 
4133       // Circles are approximated by Bézier curves with four segments since
4134       // there is no circle primitive in the PDF specification. For the control
4135       // points distance, see https://stackoverflow.com/a/27863181.
4136       const controlPointsDistance = (4 / 3) * Math.tan(Math.PI / (2 * 4));
4137 
4138       this._setDefaultAppearance({
4139         xref,
4140         extra: `${this.borderStyle.width} w`,
4141         strokeColor,
4142         fillColor,
4143         strokeAlpha,
4144         fillAlpha,
4145         pointsCallback: (buffer, points) => {
4146           const x0 = points[0].x + this.borderStyle.width / 2;
4147           const y0 = points[0].y - this.borderStyle.width / 2;
4148           const x1 = points[3].x - this.borderStyle.width / 2;
4149           const y1 = points[3].y + this.borderStyle.width / 2;
4150           const xMid = x0 + (x1 - x0) / 2;
4151           const yMid = y0 + (y1 - y0) / 2;
4152           const xOffset = ((x1 - x0) / 2) * controlPointsDistance;
4153           const yOffset = ((y1 - y0) / 2) * controlPointsDistance;
4154 
4155           buffer.push(
4156             `${xMid} ${y1} m`,
4157             `${xMid + xOffset} ${y1} ${x1} ${yMid + yOffset} ${x1} ${yMid} c`,
4158             `${x1} ${yMid - yOffset} ${xMid + xOffset} ${y0} ${xMid} ${y0} c`,
4159             `${xMid - xOffset} ${y0} ${x0} ${yMid - yOffset} ${x0} ${yMid} c`,
4160             `${x0} ${yMid + yOffset} ${xMid - xOffset} ${y1} ${xMid} ${y1} c`,
4161             "h"
4162           );
4163           if (fillColor) {
4164             buffer.push("B");
4165           } else {
4166             buffer.push("S");
4167           }
4168           return [points[0].x, points[1].x, points[3].y, points[1].y];
4169         },
4170       });
4171     }
4172   }
4173 }
4174 
4175 class PolylineAnnotation extends MarkupAnnotation {
4176   constructor(params) {
4177     super(params);
4178 
4179     const { dict, xref } = params;
4180     this.data.annotationType = AnnotationType.POLYLINE;
4181     this.data.hasOwnCanvas = this.data.noRotate;
4182     this.data.noHTML = false;
4183     this.data.vertices = [];
4184 
4185     if (
4186       (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) &&
4187       !(this instanceof PolygonAnnotation)
4188     ) {
4189       // Only meaningful for polyline annotations.
4190       this.setLineEndings(dict.getArray("LE"));
4191       this.data.lineEndings = this.lineEndings;
4192     }
4193 
4194     // The vertices array is an array of numbers representing the alternating
4195     // horizontal and vertical coordinates, respectively, of each vertex.
4196     // Convert this to an array of objects with x and y coordinates.
4197     const rawVertices = dict.getArray("Vertices");
4198     if (!Array.isArray(rawVertices)) {
4199       return;
4200     }
4201     for (let i = 0, ii = rawVertices.length; i < ii; i += 2) {
4202       this.data.vertices.push({
4203         x: rawVertices[i],
4204         y: rawVertices[i + 1],
4205       });
4206     }
4207 
4208     if (!this.appearance) {
4209       // The default stroke color is black.
4210       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4211       const strokeAlpha = dict.get("CA");
4212 
4213       const borderWidth = this.borderStyle.width || 1,
4214         borderAdjust = 2 * borderWidth;
4215 
4216       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4217       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4218       const bbox = [Infinity, Infinity, -Infinity, -Infinity];
4219       for (const vertex of this.data.vertices) {
4220         bbox[0] = Math.min(bbox[0], vertex.x - borderAdjust);
4221         bbox[1] = Math.min(bbox[1], vertex.y - borderAdjust);
4222         bbox[2] = Math.max(bbox[2], vertex.x + borderAdjust);
4223         bbox[3] = Math.max(bbox[3], vertex.y + borderAdjust);
4224       }
4225       if (!Util.intersect(this.rectangle, bbox)) {
4226         this.rectangle = bbox;
4227       }
4228 
4229       this._setDefaultAppearance({
4230         xref,
4231         extra: `${borderWidth} w`,
4232         strokeColor,
4233         strokeAlpha,
4234         pointsCallback: (buffer, points) => {
4235           const vertices = this.data.vertices;
4236           for (let i = 0, ii = vertices.length; i < ii; i++) {
4237             buffer.push(
4238               `${vertices[i].x} ${vertices[i].y} ${i === 0 ? "m" : "l"}`
4239             );
4240           }
4241           buffer.push("S");
4242           return [points[0].x, points[1].x, points[3].y, points[1].y];
4243         },
4244       });
4245     }
4246   }
4247 }
4248 
4249 class PolygonAnnotation extends PolylineAnnotation {
4250   constructor(params) {
4251     // Polygons are specific forms of polylines, so reuse their logic.
4252     super(params);
4253 
4254     this.data.annotationType = AnnotationType.POLYGON;
4255   }
4256 }
4257 
4258 class CaretAnnotation extends MarkupAnnotation {
4259   constructor(params) {
4260     super(params);
4261 
4262     this.data.annotationType = AnnotationType.CARET;
4263   }
4264 }
4265 
4266 class InkAnnotation extends MarkupAnnotation {
4267   constructor(params) {
4268     super(params);
4269 
4270     this.data.hasOwnCanvas = this.data.noRotate;
4271     this.data.noHTML = false;
4272 
4273     const { dict, xref } = params;
4274     this.data.annotationType = AnnotationType.INK;
4275     this.data.inkLists = [];
4276 
4277     const rawInkLists = dict.getArray("InkList");
4278     if (!Array.isArray(rawInkLists)) {
4279       return;
4280     }
4281     for (let i = 0, ii = rawInkLists.length; i < ii; ++i) {
4282       // The raw ink lists array contains arrays of numbers representing
4283       // the alternating horizontal and vertical coordinates, respectively,
4284       // of each vertex. Convert this to an array of objects with x and y
4285       // coordinates.
4286       this.data.inkLists.push([]);
4287       for (let j = 0, jj = rawInkLists[i].length; j < jj; j += 2) {
4288         this.data.inkLists[i].push({
4289           x: xref.fetchIfRef(rawInkLists[i][j]),
4290           y: xref.fetchIfRef(rawInkLists[i][j + 1]),
4291         });
4292       }
4293     }
4294 
4295     if (!this.appearance) {
4296       // The default stroke color is black.
4297       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4298       const strokeAlpha = dict.get("CA");
4299 
4300       const borderWidth = this.borderStyle.width || 1,
4301         borderAdjust = 2 * borderWidth;
4302 
4303       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4304       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4305       const bbox = [Infinity, Infinity, -Infinity, -Infinity];
4306       for (const inkLists of this.data.inkLists) {
4307         for (const vertex of inkLists) {
4308           bbox[0] = Math.min(bbox[0], vertex.x - borderAdjust);
4309           bbox[1] = Math.min(bbox[1], vertex.y - borderAdjust);
4310           bbox[2] = Math.max(bbox[2], vertex.x + borderAdjust);
4311           bbox[3] = Math.max(bbox[3], vertex.y + borderAdjust);
4312         }
4313       }
4314       if (!Util.intersect(this.rectangle, bbox)) {
4315         this.rectangle = bbox;
4316       }
4317 
4318       this._setDefaultAppearance({
4319         xref,
4320         extra: `${borderWidth} w`,
4321         strokeColor,
4322         strokeAlpha,
4323         pointsCallback: (buffer, points) => {
4324           // According to the specification, see "12.5.6.13 Ink Annotations":
4325           //   When drawn, the points shall be connected by straight lines or
4326           //   curves in an implementation-dependent way.
4327           // In order to simplify things, we utilize straight lines for now.
4328           for (const inkList of this.data.inkLists) {
4329             for (let i = 0, ii = inkList.length; i < ii; i++) {
4330               buffer.push(
4331                 `${inkList[i].x} ${inkList[i].y} ${i === 0 ? "m" : "l"}`
4332               );
4333             }
4334             buffer.push("S");
4335           }
4336           return [points[0].x, points[1].x, points[3].y, points[1].y];
4337         },
4338       });
4339     }
4340   }
4341 
4342   static createNewDict(annotation, xref, { apRef, ap }) {
4343     const { color, opacity, paths, rect, rotation, thickness } = annotation;
4344     const ink = new Dict(xref);
4345     ink.set("Type", Name.get("Annot"));
4346     ink.set("Subtype", Name.get("Ink"));
4347     ink.set("CreationDate", `D:${getModificationDate()}`);
4348     ink.set("Rect", rect);
4349     ink.set(
4350       "InkList",
4351       paths.map(p => p.points)
4352     );
4353     ink.set("F", 4);
4354     ink.set("Rotate", rotation);
4355 
4356     // Line thickness.
4357     const bs = new Dict(xref);
4358     ink.set("BS", bs);
4359     bs.set("W", thickness);
4360 
4361     // Color.
4362     ink.set(
4363       "C",
4364       Array.from(color, c => c / 255)
4365     );
4366 
4367     // Opacity.
4368     ink.set("CA", opacity);
4369 
4370     const n = new Dict(xref);
4371     ink.set("AP", n);
4372 
4373     if (apRef) {
4374       n.set("N", apRef);
4375     } else {
4376       n.set("N", ap);
4377     }
4378 
4379     return ink;
4380   }
4381 
4382   static async createNewAppearanceStream(annotation, xref, params) {
4383     const { color, rect, paths, thickness, opacity } = annotation;
4384 
4385     const appearanceBuffer = [
4386       `${thickness} w 1 J 1 j`,
4387       `${getPdfColor(color, /* isFill */ false)}`,
4388     ];
4389 
4390     if (opacity !== 1) {
4391       appearanceBuffer.push("/R0 gs");
4392     }
4393 
4394     const buffer = [];
4395     for (const { bezier } of paths) {
4396       buffer.length = 0;
4397       buffer.push(
4398         `${numberToString(bezier[0])} ${numberToString(bezier[1])} m`
4399       );
4400       for (let i = 2, ii = bezier.length; i < ii; i += 6) {
4401         const curve = bezier
4402           .slice(i, i + 6)
4403           .map(numberToString)
4404           .join(" ");
4405         buffer.push(`${curve} c`);
4406       }
4407       buffer.push("S");
4408       appearanceBuffer.push(buffer.join("\n"));
4409     }
4410     const appearance = appearanceBuffer.join("\n");
4411 
4412     const appearanceStreamDict = new Dict(xref);
4413     appearanceStreamDict.set("FormType", 1);
4414     appearanceStreamDict.set("Subtype", Name.get("Form"));
4415     appearanceStreamDict.set("Type", Name.get("XObject"));
4416     appearanceStreamDict.set("BBox", rect);
4417     appearanceStreamDict.set("Length", appearance.length);
4418 
4419     if (opacity !== 1) {
4420       const resources = new Dict(xref);
4421       const extGState = new Dict(xref);
4422       const r0 = new Dict(xref);
4423       r0.set("CA", opacity);
4424       r0.set("Type", Name.get("ExtGState"));
4425       extGState.set("R0", r0);
4426       resources.set("ExtGState", extGState);
4427       appearanceStreamDict.set("Resources", resources);
4428     }
4429 
4430     const ap = new StringStream(appearance);
4431     ap.dict = appearanceStreamDict;
4432 
4433     return ap;
4434   }
4435 }
4436 
4437 class HighlightAnnotation extends MarkupAnnotation {
4438   constructor(params) {
4439     super(params);
4440 
4441     const { dict, xref } = params;
4442     this.data.annotationType = AnnotationType.HIGHLIGHT;
4443 
4444     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4445     if (quadPoints) {
4446       const resources = this.appearance?.dict.get("Resources");
4447 
4448       if (!this.appearance || !resources?.has("ExtGState")) {
4449         if (this.appearance) {
4450           // Workaround for cases where there's no /ExtGState-entry directly
4451           // available, e.g. when the appearance stream contains a /XObject of
4452           // the /Form-type, since that causes the highlighting to completely
4453           // obscure the PDF content below it (fixes issue13242.pdf).
4454           warn("HighlightAnnotation - ignoring built-in appearance stream.");
4455         }
4456         // Default color is yellow in Acrobat Reader
4457         const fillColor = this.color ? getPdfColorArray(this.color) : [1, 1, 0];
4458         const fillAlpha = dict.get("CA");
4459 
4460         this._setDefaultAppearance({
4461           xref,
4462           fillColor,
4463           blendMode: "Multiply",
4464           fillAlpha,
4465           pointsCallback: (buffer, points) => {
4466             buffer.push(
4467               `${points[0].x} ${points[0].y} m`,
4468               `${points[1].x} ${points[1].y} l`,
4469               `${points[3].x} ${points[3].y} l`,
4470               `${points[2].x} ${points[2].y} l`,
4471               "f"
4472             );
4473             return [points[0].x, points[1].x, points[3].y, points[1].y];
4474           },
4475         });
4476       }
4477     } else {
4478       this.data.popupRef = null;
4479     }
4480   }
4481 
4482   static createNewDict(annotation, xref, { apRef, ap }) {
4483     const { color, opacity, rect, rotation, user, quadPoints } = annotation;
4484     const highlight = new Dict(xref);
4485     highlight.set("Type", Name.get("Annot"));
4486     highlight.set("Subtype", Name.get("Highlight"));
4487     highlight.set("CreationDate", `D:${getModificationDate()}`);
4488     highlight.set("Rect", rect);
4489     highlight.set("F", 4);
4490     highlight.set("Border", [0, 0, 0]);
4491     highlight.set("Rotate", rotation);
4492     highlight.set("QuadPoints", quadPoints);
4493 
4494     // Color.
4495     highlight.set(
4496       "C",
4497       Array.from(color, c => c / 255)
4498     );
4499 
4500     // Opacity.
4501     highlight.set("CA", opacity);
4502 
4503     if (user) {
4504       highlight.set(
4505         "T",
4506         isAscii(user) ? user : stringToUTF16String(user, /* bigEndian = */ true)
4507       );
4508     }
4509 
4510     if (apRef || ap) {
4511       const n = new Dict(xref);
4512       highlight.set("AP", n);
4513       n.set("N", apRef || ap);
4514     }
4515 
4516     return highlight;
4517   }
4518 
4519   static async createNewAppearanceStream(annotation, xref, params) {
4520     const { color, rect, outlines, opacity } = annotation;
4521 
4522     const appearanceBuffer = [
4523       `${getPdfColor(color, /* isFill */ true)}`,
4524       "/R0 gs",
4525     ];
4526 
4527     const buffer = [];
4528     for (const outline of outlines) {
4529       buffer.length = 0;
4530       buffer.push(
4531         `${numberToString(outline[0])} ${numberToString(outline[1])} m`
4532       );
4533       for (let i = 2, ii = outline.length; i < ii; i += 2) {
4534         buffer.push(
4535           `${numberToString(outline[i])} ${numberToString(outline[i + 1])} l`
4536         );
4537       }
4538       buffer.push("h");
4539       appearanceBuffer.push(buffer.join("\n"));
4540     }
4541     appearanceBuffer.push("f*");
4542     const appearance = appearanceBuffer.join("\n");
4543 
4544     const appearanceStreamDict = new Dict(xref);
4545     appearanceStreamDict.set("FormType", 1);
4546     appearanceStreamDict.set("Subtype", Name.get("Form"));
4547     appearanceStreamDict.set("Type", Name.get("XObject"));
4548     appearanceStreamDict.set("BBox", rect);
4549     appearanceStreamDict.set("Length", appearance.length);
4550 
4551     const resources = new Dict(xref);
4552     const extGState = new Dict(xref);
4553     resources.set("ExtGState", extGState);
4554     appearanceStreamDict.set("Resources", resources);
4555     const r0 = new Dict(xref);
4556     extGState.set("R0", r0);
4557     r0.set("BM", Name.get("Multiply"));
4558 
4559     if (opacity !== 1) {
4560       r0.set("ca", opacity);
4561       r0.set("Type", Name.get("ExtGState"));
4562     }
4563 
4564     const ap = new StringStream(appearance);
4565     ap.dict = appearanceStreamDict;
4566 
4567     return ap;
4568   }
4569 }
4570 
4571 class UnderlineAnnotation extends MarkupAnnotation {
4572   constructor(params) {
4573     super(params);
4574 
4575     const { dict, xref } = params;
4576     this.data.annotationType = AnnotationType.UNDERLINE;
4577 
4578     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4579     if (quadPoints) {
4580       if (!this.appearance) {
4581         // Default color is black
4582         const strokeColor = this.color
4583           ? getPdfColorArray(this.color)
4584           : [0, 0, 0];
4585         const strokeAlpha = dict.get("CA");
4586 
4587         // The values 0.571 and 1.3 below corresponds to what Acrobat is doing.
4588         this._setDefaultAppearance({
4589           xref,
4590           extra: "[] 0 d 0.571 w",
4591           strokeColor,
4592           strokeAlpha,
4593           pointsCallback: (buffer, points) => {
4594             buffer.push(
4595               `${points[2].x} ${points[2].y + 1.3} m`,
4596               `${points[3].x} ${points[3].y + 1.3} l`,
4597               "S"
4598             );
4599             return [points[0].x, points[1].x, points[3].y, points[1].y];
4600           },
4601         });
4602       }
4603     } else {
4604       this.data.popupRef = null;
4605     }
4606   }
4607 }
4608 
4609 class SquigglyAnnotation extends MarkupAnnotation {
4610   constructor(params) {
4611     super(params);
4612 
4613     const { dict, xref } = params;
4614     this.data.annotationType = AnnotationType.SQUIGGLY;
4615 
4616     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4617     if (quadPoints) {
4618       if (!this.appearance) {
4619         // Default color is black
4620         const strokeColor = this.color
4621           ? getPdfColorArray(this.color)
4622           : [0, 0, 0];
4623         const strokeAlpha = dict.get("CA");
4624 
4625         this._setDefaultAppearance({
4626           xref,
4627           extra: "[] 0 d 1 w",
4628           strokeColor,
4629           strokeAlpha,
4630           pointsCallback: (buffer, points) => {
4631             const dy = (points[0].y - points[2].y) / 6;
4632             let shift = dy;
4633             let x = points[2].x;
4634             const y = points[2].y;
4635             const xEnd = points[3].x;
4636             buffer.push(`${x} ${y + shift} m`);
4637             do {
4638               x += 2;
4639               shift = shift === 0 ? dy : 0;
4640               buffer.push(`${x} ${y + shift} l`);
4641             } while (x < xEnd);
4642             buffer.push("S");
4643             return [points[2].x, xEnd, y - 2 * dy, y + 2 * dy];
4644           },
4645         });
4646       }
4647     } else {
4648       this.data.popupRef = null;
4649     }
4650   }
4651 }
4652 
4653 class StrikeOutAnnotation extends MarkupAnnotation {
4654   constructor(params) {
4655     super(params);
4656 
4657     const { dict, xref } = params;
4658     this.data.annotationType = AnnotationType.STRIKEOUT;
4659 
4660     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4661     if (quadPoints) {
4662       if (!this.appearance) {
4663         // Default color is black
4664         const strokeColor = this.color
4665           ? getPdfColorArray(this.color)
4666           : [0, 0, 0];
4667         const strokeAlpha = dict.get("CA");
4668 
4669         this._setDefaultAppearance({
4670           xref,
4671           extra: "[] 0 d 1 w",
4672           strokeColor,
4673           strokeAlpha,
4674           pointsCallback: (buffer, points) => {
4675             buffer.push(
4676               `${(points[0].x + points[2].x) / 2} ` +
4677                 `${(points[0].y + points[2].y) / 2} m`,
4678               `${(points[1].x + points[3].x) / 2} ` +
4679                 `${(points[1].y + points[3].y) / 2} l`,
4680               "S"
4681             );
4682             return [points[0].x, points[1].x, points[3].y, points[1].y];
4683           },
4684         });
4685       }
4686     } else {
4687       this.data.popupRef = null;
4688     }
4689   }
4690 }
4691 
4692 class StampAnnotation extends MarkupAnnotation {
4693   constructor(params) {
4694     super(params);
4695 
4696     this.data.annotationType = AnnotationType.STAMP;
4697     this.data.hasOwnCanvas = this.data.noRotate;
4698     this.data.noHTML = false;
4699   }
4700 
4701   static async createImage(bitmap, xref) {
4702     // TODO: when printing, we could have a specific internal colorspace
4703     // (e.g. something like DeviceRGBA) in order avoid any conversion (i.e. no
4704     // jpeg, no rgba to rgb conversion, etc...)
4705 
4706     const { width, height } = bitmap;
4707     const canvas = new OffscreenCanvas(width, height);
4708     const ctx = canvas.getContext("2d", { alpha: true });
4709 
4710     // Draw the image and get the data in order to extract the transparency.
4711     ctx.drawImage(bitmap, 0, 0);
4712     const data = ctx.getImageData(0, 0, width, height).data;
4713     const buf32 = new Uint32Array(data.buffer);
4714     const hasAlpha = buf32.some(
4715       FeatureTest.isLittleEndian
4716         ? x => x >>> 24 !== 0xff
4717         : x => (x & 0xff) !== 0xff
4718     );
4719 
4720     if (hasAlpha) {
4721       // Redraw the image on a white background in order to remove the thin gray
4722       // line which can appear when exporting to jpeg.
4723       ctx.fillStyle = "white";
4724       ctx.fillRect(0, 0, width, height);
4725       ctx.drawImage(bitmap, 0, 0);
4726     }
4727 
4728     const jpegBufferPromise = canvas
4729       .convertToBlob({ type: "image/jpeg", quality: 1 })
4730       .then(blob => {
4731         return blob.arrayBuffer();
4732       });
4733 
4734     const xobjectName = Name.get("XObject");
4735     const imageName = Name.get("Image");
4736     const image = new Dict(xref);
4737     image.set("Type", xobjectName);
4738     image.set("Subtype", imageName);
4739     image.set("BitsPerComponent", 8);
4740     image.set("ColorSpace", Name.get("DeviceRGB"));
4741     image.set("Filter", Name.get("DCTDecode"));
4742     image.set("BBox", [0, 0, width, height]);
4743     image.set("Width", width);
4744     image.set("Height", height);
4745 
4746     let smaskStream = null;
4747     if (hasAlpha) {
4748       const alphaBuffer = new Uint8Array(buf32.length);
4749       if (FeatureTest.isLittleEndian) {
4750         for (let i = 0, ii = buf32.length; i < ii; i++) {
4751           alphaBuffer[i] = buf32[i] >>> 24;
4752         }
4753       } else {
4754         for (let i = 0, ii = buf32.length; i < ii; i++) {
4755           alphaBuffer[i] = buf32[i] & 0xff;
4756         }
4757       }
4758 
4759       const smask = new Dict(xref);
4760       smask.set("Type", xobjectName);
4761       smask.set("Subtype", imageName);
4762       smask.set("BitsPerComponent", 8);
4763       smask.set("ColorSpace", Name.get("DeviceGray"));
4764       smask.set("Width", width);
4765       smask.set("Height", height);
4766 
4767       smaskStream = new Stream(alphaBuffer, 0, 0, smask);
4768     }
4769     const imageStream = new Stream(await jpegBufferPromise, 0, 0, image);
4770 
4771     return {
4772       imageStream,
4773       smaskStream,
4774       width,
4775       height,
4776     };
4777   }
4778 
4779   static createNewDict(annotation, xref, { apRef, ap }) {
4780     const { rect, rotation, user } = annotation;
4781     const stamp = new Dict(xref);
4782     stamp.set("Type", Name.get("Annot"));
4783     stamp.set("Subtype", Name.get("Stamp"));
4784     stamp.set("CreationDate", `D:${getModificationDate()}`);
4785     stamp.set("Rect", rect);
4786     stamp.set("F", 4);
4787     stamp.set("Border", [0, 0, 0]);
4788     stamp.set("Rotate", rotation);
4789 
4790     if (user) {
4791       stamp.set(
4792         "T",
4793         isAscii(user) ? user : stringToUTF16String(user, /* bigEndian = */ true)
4794       );
4795     }
4796 
4797     if (apRef || ap) {
4798       const n = new Dict(xref);
4799       stamp.set("AP", n);
4800 
4801       if (apRef) {
4802         n.set("N", apRef);
4803       } else {
4804         n.set("N", ap);
4805       }
4806     }
4807 
4808     return stamp;
4809   }
4810 
4811   static async createNewAppearanceStream(annotation, xref, params) {
4812     const { rotation } = annotation;
4813     const { imageRef, width, height } = params.image;
4814     const resources = new Dict(xref);
4815     const xobject = new Dict(xref);
4816     resources.set("XObject", xobject);
4817     xobject.set("Im0", imageRef);
4818     const appearance = `q ${width} 0 0 ${height} 0 0 cm /Im0 Do Q`;
4819 
4820     const appearanceStreamDict = new Dict(xref);
4821     appearanceStreamDict.set("FormType", 1);
4822     appearanceStreamDict.set("Subtype", Name.get("Form"));
4823     appearanceStreamDict.set("Type", Name.get("XObject"));
4824     appearanceStreamDict.set("BBox", [0, 0, width, height]);
4825     appearanceStreamDict.set("Resources", resources);
4826 
4827     if (rotation) {
4828       const matrix = getRotationMatrix(rotation, width, height);
4829       appearanceStreamDict.set("Matrix", matrix);
4830     }
4831 
4832     const ap = new StringStream(appearance);
4833     ap.dict = appearanceStreamDict;
4834 
4835     return ap;
4836   }
4837 }
4838 
4839 class FileAttachmentAnnotation extends MarkupAnnotation {
4840   constructor(params) {
4841     super(params);
4842 
4843     const { dict, xref } = params;
4844     const file = new FileSpec(dict.get("FS"), xref);
4845 
4846     this.data.annotationType = AnnotationType.FILEATTACHMENT;
4847     this.data.hasOwnCanvas = this.data.noRotate;
4848     this.data.noHTML = false;
4849     this.data.file = file.serializable;
4850 
4851     const name = dict.get("Name");
4852     this.data.name =
4853       name instanceof Name ? stringToPDFString(name.name) : "PushPin";
4854 
4855     const fillAlpha = dict.get("ca");
4856     this.data.fillAlpha =
4857       typeof fillAlpha === "number" && fillAlpha >= 0 && fillAlpha <= 1
4858         ? fillAlpha
4859         : null;
4860   }
4861 }
4862 
4863 export {
4864   Annotation,
4865   AnnotationBorderStyle,
4866   AnnotationFactory,
4867   getQuadPoints,
4868   MarkupAnnotation,
4869   PopupAnnotation,
4870 };
File:
src/display/editor/ink.js
1 /* Copyright 2022 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AnnotationEditorParamsType,
18   AnnotationEditorType,
19   Util,
20 } from "../../shared/util.js";
21 import { AnnotationEditor } from "./editor.js";
22 import { InkAnnotationElement } from "../annotation_layer.js";
23 import { noContextMenu } from "../display_utils.js";
24 import { opacityToHex } from "./tools.js";
25 
26 /**
27  * Basic draw editor in order to generate an Ink annotation.
28  */
29 class InkEditor extends AnnotationEditor {
30   #baseHeight = 0;
31 
32   #baseWidth = 0;
33 
34   #boundCanvasPointermove = this.canvasPointermove.bind(this);
35 
36   #boundCanvasPointerleave = this.canvasPointerleave.bind(this);
37 
38   #boundCanvasPointerup = this.canvasPointerup.bind(this);
39 
40   #boundCanvasPointerdown = this.canvasPointerdown.bind(this);
41 
42   #canvasContextMenuTimeoutId = null;
43 
44   #currentPath2D = new Path2D();
45 
46   #disableEditing = false;
47 
48   #hasSomethingToDraw = false;
49 
50   #isCanvasInitialized = false;
51 
52   #observer = null;
53 
54   #realWidth = 0;
55 
56   #realHeight = 0;
57 
58   #requestFrameCallback = null;
59 
60   static _defaultColor = null;
61 
62   static _defaultOpacity = 1;
63 
64   static _defaultThickness = 1;
65 
66   static _type = "ink";
67 
68   static _editorType = AnnotationEditorType.INK;
69 
70   constructor(params) {
71     super({ ...params, name: "inkEditor" });
72     this.color = params.color || null;
73     this.thickness = params.thickness || null;
74     this.opacity = params.opacity || null;
75     this.paths = [];
76     this.bezierPath2D = [];
77     this.allRawPaths = [];
78     this.currentPath = [];
79     this.scaleFactor = 1;
80     this.translationX = this.translationY = 0;
81     this.x = 0;
82     this.y = 0;
83     this._willKeepAspectRatio = true;
84   }
85 
86   /** @inheritdoc */
87   static initialize(l10n, uiManager) {
88     AnnotationEditor.initialize(l10n, uiManager);
89   }
90 
91   /** @inheritdoc */
92   static updateDefaultParams(type, value) {
93     switch (type) {
94       case AnnotationEditorParamsType.INK_THICKNESS:
95         InkEditor._defaultThickness = value;
96         break;
97       case AnnotationEditorParamsType.INK_COLOR:
98         InkEditor._defaultColor = value;
99         break;
100       case AnnotationEditorParamsType.INK_OPACITY:
101         InkEditor._defaultOpacity = value / 100;
102         break;
103     }
104   }
105 
106   /** @inheritdoc */
107   updateParams(type, value) {
108     switch (type) {
109       case AnnotationEditorParamsType.INK_THICKNESS:
110         this.#updateThickness(value);
111         break;
112       case AnnotationEditorParamsType.INK_COLOR:
113         this.#updateColor(value);
114         break;
115       case AnnotationEditorParamsType.INK_OPACITY:
116         this.#updateOpacity(value);
117         break;
118     }
119   }
120 
121   /** @inheritdoc */
122   static get defaultPropertiesToUpdate() {
123     return [
124       [AnnotationEditorParamsType.INK_THICKNESS, InkEditor._defaultThickness],
125       [
126         AnnotationEditorParamsType.INK_COLOR,
127         InkEditor._defaultColor || AnnotationEditor._defaultLineColor,
128       ],
129       [
130         AnnotationEditorParamsType.INK_OPACITY,
131         Math.round(InkEditor._defaultOpacity * 100),
132       ],
133     ];
134   }
135 
136   /** @inheritdoc */
137   get propertiesToUpdate() {
138     return [
139       [
140         AnnotationEditorParamsType.INK_THICKNESS,
141         this.thickness || InkEditor._defaultThickness,
142       ],
143       [
144         AnnotationEditorParamsType.INK_COLOR,
145         this.color ||
146           InkEditor._defaultColor ||
147           AnnotationEditor._defaultLineColor,
148       ],
149       [
150         AnnotationEditorParamsType.INK_OPACITY,
151         Math.round(100 * (this.opacity ?? InkEditor._defaultOpacity)),
152       ],
153     ];
154   }
155 
156   /**
157    * Update the thickness and make this action undoable.
158    * @param {number} thickness
159    */
160   #updateThickness(thickness) {
161     const savedThickness = this.thickness;
162     this.addCommands({
163       cmd: () => {
164         this.thickness = thickness;
165         this.#fitToContent();
166       },
167       undo: () => {
168         this.thickness = savedThickness;
169         this.#fitToContent();
170       },
171       mustExec: true,
172       type: AnnotationEditorParamsType.INK_THICKNESS,
173       overwriteIfSameType: true,
174       keepUndo: true,
175     });
176   }
177 
178   /**
179    * Update the color and make this action undoable.
180    * @param {string} color
181    */
182   #updateColor(color) {
183     const savedColor = this.color;
184     this.addCommands({
185       cmd: () => {
186         this.color = color;
187         this.#redraw();
188       },
189       undo: () => {
190         this.color = savedColor;
191         this.#redraw();
192       },
193       mustExec: true,
194       type: AnnotationEditorParamsType.INK_COLOR,
195       overwriteIfSameType: true,
196       keepUndo: true,
197     });
198   }
199 
200   /**
201    * Update the opacity and make this action undoable.
202    * @param {number} opacity
203    */
204   #updateOpacity(opacity) {
205     opacity /= 100;
206     const savedOpacity = this.opacity;
207     this.addCommands({
208       cmd: () => {
209         this.opacity = opacity;
210         this.#redraw();
211       },
212       undo: () => {
213         this.opacity = savedOpacity;
214         this.#redraw();
215       },
216       mustExec: true,
217       type: AnnotationEditorParamsType.INK_OPACITY,
218       overwriteIfSameType: true,
219       keepUndo: true,
220     });
221   }
222 
223   /** @inheritdoc */
224   rebuild() {
225     if (!this.parent) {
226       return;
227     }
228     super.rebuild();
229     if (this.div === null) {
230       return;
231     }
232 
233     if (!this.canvas) {
234       this.#createCanvas();
235       this.#createObserver();
236     }
237 
238     if (!this.isAttachedToDOM) {
239       // At some point this editor was removed and we're rebuilding it,
240       // hence we must add it to its parent.
241       this.parent.add(this);
242       this.#setCanvasDims();
243     }
244     this.#fitToContent();
245   }
246 
247   /** @inheritdoc */
248   remove() {
249     if (this.canvas === null) {
250       return;
251     }
252 
253     if (!this.isEmpty()) {
254       this.commit();
255     }
256 
257     // Destroy the canvas.
258     this.canvas.width = this.canvas.height = 0;
259     this.canvas.remove();
260     this.canvas = null;
261 
262     if (this.#canvasContextMenuTimeoutId) {
263       clearTimeout(this.#canvasContextMenuTimeoutId);
264       this.#canvasContextMenuTimeoutId = null;
265     }
266 
267     this.#observer.disconnect();
268     this.#observer = null;
269 
270     super.remove();
271   }
272 
273   setParent(parent) {
274     if (!this.parent && parent) {
275       // We've a parent hence the rescale will be handled thanks to the
276       // ResizeObserver.
277       this._uiManager.removeShouldRescale(this);
278     } else if (this.parent && parent === null) {
279       // The editor is removed from the DOM, hence we handle the rescale thanks
280       // to the onScaleChanging callback.
281       // This way, it'll be saved/printed correctly.
282       this._uiManager.addShouldRescale(this);
283     }
284     super.setParent(parent);
285   }
286 
287   onScaleChanging() {
288     const [parentWidth, parentHeight] = this.parentDimensions;
289     const width = this.width * parentWidth;
290     const height = this.height * parentHeight;
291     this.setDimensions(width, height);
292   }
293 
294   /** @inheritdoc */
295   enableEditMode() {
296     if (this.#disableEditing || this.canvas === null) {
297       return;
298     }
299 
300     super.enableEditMode();
301     this._isDraggable = false;
302     this.canvas.addEventListener("pointerdown", this.#boundCanvasPointerdown);
303   }
304 
305   /** @inheritdoc */
306   disableEditMode() {
307     if (!this.isInEditMode() || this.canvas === null) {
308       return;
309     }
310 
311     super.disableEditMode();
312     this._isDraggable = !this.isEmpty();
313     this.div.classList.remove("editing");
314 
315     this.canvas.removeEventListener(
316       "pointerdown",
317       this.#boundCanvasPointerdown
318     );
319   }
320 
321   /** @inheritdoc */
322   onceAdded() {
323     this._isDraggable = !this.isEmpty();
324   }
325 
326   /** @inheritdoc */
327   isEmpty() {
328     return (
329       this.paths.length === 0 ||
330       (this.paths.length === 1 && this.paths[0].length === 0)
331     );
332   }
333 
334   #getInitialBBox() {
335     const {
336       parentRotation,
337       parentDimensions: [width, height],
338     } = this;
339     switch (parentRotation) {
340       case 90:
341         return [0, height, height, width];
342       case 180:
343         return [width, height, width, height];
344       case 270:
345         return [width, 0, height, width];
346       default:
347         return [0, 0, width, height];
348     }
349   }
350 
351   /**
352    * Set line styles.
353    */
354   #setStroke() {
355     const { ctx, color, opacity, thickness, parentScale, scaleFactor } = this;
356     ctx.lineWidth = (thickness * parentScale) / scaleFactor;
357     ctx.lineCap = "round";
358     ctx.lineJoin = "round";
359     ctx.miterLimit = 10;
360     ctx.strokeStyle = `${color}${opacityToHex(opacity)}`;
361   }
362 
363   /**
364    * Start to draw on the canvas.
365    * @param {number} x
366    * @param {number} y
367    */
368   #startDrawing(x, y) {
369     this.canvas.addEventListener("contextmenu", noContextMenu);
370     this.canvas.addEventListener("pointerleave", this.#boundCanvasPointerleave);
371     this.canvas.addEventListener("pointermove", this.#boundCanvasPointermove);
372     this.canvas.addEventListener("pointerup", this.#boundCanvasPointerup);
373     this.canvas.removeEventListener(
374       "pointerdown",
375       this.#boundCanvasPointerdown
376     );
377 
378     this.isEditing = true;
379     if (!this.#isCanvasInitialized) {
380       this.#isCanvasInitialized = true;
381       this.#setCanvasDims();
382       this.thickness ||= InkEditor._defaultThickness;
383       this.color ||=
384         InkEditor._defaultColor || AnnotationEditor._defaultLineColor;
385       this.opacity ??= InkEditor._defaultOpacity;
386     }
387     this.currentPath.push([x, y]);
388     this.#hasSomethingToDraw = false;
389     this.#setStroke();
390 
391     this.#requestFrameCallback = () => {
392       this.#drawPoints();
393       if (this.#requestFrameCallback) {
394         window.requestAnimationFrame(this.#requestFrameCallback);
395       }
396     };
397     window.requestAnimationFrame(this.#requestFrameCallback);
398   }
399 
400   /**
401    * Draw on the canvas.
402    * @param {number} x
403    * @param {number} y
404    */
405   #draw(x, y) {
406     const [lastX, lastY] = this.currentPath.at(-1);
407     if (this.currentPath.length > 1 && x === lastX && y === lastY) {
408       return;
409     }
410     const currentPath = this.currentPath;
411     let path2D = this.#currentPath2D;
412     currentPath.push([x, y]);
413     this.#hasSomethingToDraw = true;
414 
415     if (currentPath.length <= 2) {
416       path2D.moveTo(...currentPath[0]);
417       path2D.lineTo(x, y);
418       return;
419     }
420 
421     if (currentPath.length === 3) {
422       this.#currentPath2D = path2D = new Path2D();
423       path2D.moveTo(...currentPath[0]);
424     }
425 
426     this.#makeBezierCurve(
427       path2D,
428       ...currentPath.at(-3),
429       ...currentPath.at(-2),
430       x,
431       y
432     );
433   }
434 
435   #endPath() {
436     if (this.currentPath.length === 0) {
437       return;
438     }
439     const lastPoint = this.currentPath.at(-1);
440     this.#currentPath2D.lineTo(...lastPoint);
441   }
442 
443   /**
444    * Stop to draw on the canvas.
445    * @param {number} x
446    * @param {number} y
447    */
448   #stopDrawing(x, y) {
449     this.#requestFrameCallback = null;
450 
451     x = Math.min(Math.max(x, 0), this.canvas.width);
452     y = Math.min(Math.max(y, 0), this.canvas.height);
453 
454     this.#draw(x, y);
455     this.#endPath();
456 
457     // Interpolate the path entered by the user with some
458     // Bezier's curves in order to have a smoother path and
459     // to reduce the data size used to draw it in the PDF.
460     let bezier;
461     if (this.currentPath.length !== 1) {
462       bezier = this.#generateBezierPoints();
463     } else {
464       // We have only one point finally.
465       const xy = [x, y];
466       bezier = [[xy, xy.slice(), xy.slice(), xy]];
467     }
468     const path2D = this.#currentPath2D;
469     const currentPath = this.currentPath;
470     this.currentPath = [];
471     this.#currentPath2D = new Path2D();
472 
473     const cmd = () => {
474       this.allRawPaths.push(currentPath);
475       this.paths.push(bezier);
476       this.bezierPath2D.push(path2D);
477       this.rebuild();
478     };
479 
480     const undo = () => {
481       this.allRawPaths.pop();
482       this.paths.pop();
483       this.bezierPath2D.pop();
484       if (this.paths.length === 0) {
485         this.remove();
486       } else {
487         if (!this.canvas) {
488           this.#createCanvas();
489           this.#createObserver();
490         }
491         this.#fitToContent();
492       }
493     };
494 
495     this.addCommands({ cmd, undo, mustExec: true });
496   }
497 
498   #drawPoints() {
499     if (!this.#hasSomethingToDraw) {
500       return;
501     }
502     this.#hasSomethingToDraw = false;
503 
504     const thickness = Math.ceil(this.thickness * this.parentScale);
505     const lastPoints = this.currentPath.slice(-3);
506     const x = lastPoints.map(xy => xy[0]);
507     const y = lastPoints.map(xy => xy[1]);
508     const xMin = Math.min(...x) - thickness;
509     const xMax = Math.max(...x) + thickness;
510     const yMin = Math.min(...y) - thickness;
511     const yMax = Math.max(...y) + thickness;
512 
513     const { ctx } = this;
514     ctx.save();
515 
516     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) {
517       // In Chrome, the clip() method doesn't work as expected.
518       ctx.clearRect(xMin, yMin, xMax - xMin, yMax - yMin);
519       ctx.beginPath();
520       ctx.rect(xMin, yMin, xMax - xMin, yMax - yMin);
521       ctx.clip();
522     } else {
523       ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
524     }
525 
526     for (const path of this.bezierPath2D) {
527       ctx.stroke(path);
528     }
529     ctx.stroke(this.#currentPath2D);
530 
531     ctx.restore();
532   }
533 
534   #makeBezierCurve(path2D, x0, y0, x1, y1, x2, y2) {
535     const prevX = (x0 + x1) / 2;
536     const prevY = (y0 + y1) / 2;
537     const x3 = (x1 + x2) / 2;
538     const y3 = (y1 + y2) / 2;
539 
540     path2D.bezierCurveTo(
541       prevX + (2 * (x1 - prevX)) / 3,
542       prevY + (2 * (y1 - prevY)) / 3,
543       x3 + (2 * (x1 - x3)) / 3,
544       y3 + (2 * (y1 - y3)) / 3,
545       x3,
546       y3
547     );
548   }
549 
550   #generateBezierPoints() {
551     const path = this.currentPath;
552     if (path.length <= 2) {
553       return [[path[0], path[0], path.at(-1), path.at(-1)]];
554     }
555 
556     const bezierPoints = [];
557     let i;
558     let [x0, y0] = path[0];
559     for (i = 1; i < path.length - 2; i++) {
560       const [x1, y1] = path[i];
561       const [x2, y2] = path[i + 1];
562       const x3 = (x1 + x2) / 2;
563       const y3 = (y1 + y2) / 2;
564 
565       // The quadratic is: [[x0, y0], [x1, y1], [x3, y3]].
566       // Convert the quadratic to a cubic
567       // (see https://fontforge.org/docs/techref/bezier.html#converting-truetype-to-postscript)
568       const control1 = [x0 + (2 * (x1 - x0)) / 3, y0 + (2 * (y1 - y0)) / 3];
569       const control2 = [x3 + (2 * (x1 - x3)) / 3, y3 + (2 * (y1 - y3)) / 3];
570 
571       bezierPoints.push([[x0, y0], control1, control2, [x3, y3]]);
572 
573       [x0, y0] = [x3, y3];
574     }
575 
576     const [x1, y1] = path[i];
577     const [x2, y2] = path[i + 1];
578 
579     // The quadratic is: [[x0, y0], [x1, y1], [x2, y2]].
580     const control1 = [x0 + (2 * (x1 - x0)) / 3, y0 + (2 * (y1 - y0)) / 3];
581     const control2 = [x2 + (2 * (x1 - x2)) / 3, y2 + (2 * (y1 - y2)) / 3];
582 
583     bezierPoints.push([[x0, y0], control1, control2, [x2, y2]]);
584     return bezierPoints;
585   }
586 
587   /**
588    * Redraw all the paths.
589    */
590   #redraw() {
591     if (this.isEmpty()) {
592       this.#updateTransform();
593       return;
594     }
595     this.#setStroke();
596 
597     const { canvas, ctx } = this;
598     ctx.setTransform(1, 0, 0, 1, 0, 0);
599     ctx.clearRect(0, 0, canvas.width, canvas.height);
600     this.#updateTransform();
601 
602     for (const path of this.bezierPath2D) {
603       ctx.stroke(path);
604     }
605   }
606 
607   /**
608    * Commit the curves we have in this editor.
609    */
610   commit() {
611     if (this.#disableEditing) {
612       return;
613     }
614 
615     super.commit();
616 
617     this.isEditing = false;
618     this.disableEditMode();
619 
620     // This editor must be on top of the main ink editor.
621     this.setInForeground();
622 
623     this.#disableEditing = true;
624     this.div.classList.add("disabled");
625 
626     this.#fitToContent(/* firstTime = */ true);
627     this.select();
628 
629     this.parent.addInkEditorIfNeeded(/* isCommitting = */ true);
630 
631     // When commiting, the position of this editor is changed, hence we must
632     // move it to the right position in the DOM.
633     this.moveInDOM();
634     this.div.focus({
635       preventScroll: true /* See issue #15744 */,
636     });
637   }
638 
639   /** @inheritdoc */
640   focusin(event) {
641     if (!this._focusEventsAllowed) {
642       return;
643     }
644     super.focusin(event);
645     this.enableEditMode();
646   }
647 
648   /**
649    * onpointerdown callback for the canvas we're drawing on.
650    * @param {PointerEvent} event
651    */
652   canvasPointerdown(event) {
653     if (event.button !== 0 || !this.isInEditMode() || this.#disableEditing) {
654       return;
655     }
656 
657     // We want to draw on top of any other editors.
658     // Since it's the last child, there's no need to give it a higher z-index.
659     this.setInForeground();
660 
661     event.preventDefault();
662 
663     if (!this.div.contains(document.activeElement)) {
664       this.div.focus({
665         preventScroll: true /* See issue #17327 */,
666       });
667     }
668 
669     this.#startDrawing(event.offsetX, event.offsetY);
670   }
671 
672   /**
673    * onpointermove callback for the canvas we're drawing on.
674    * @param {PointerEvent} event
675    */
676   canvasPointermove(event) {
677     event.preventDefault();
678     this.#draw(event.offsetX, event.offsetY);
679   }
680 
681   /**
682    * onpointerup callback for the canvas we're drawing on.
683    * @param {PointerEvent} event
684    */
685   canvasPointerup(event) {
686     event.preventDefault();
687     this.#endDrawing(event);
688   }
689 
690   /**
691    * onpointerleave callback for the canvas we're drawing on.
692    * @param {PointerEvent} event
693    */
694   canvasPointerleave(event) {
695     this.#endDrawing(event);
696   }
697 
698   /**
699    * End the drawing.
700    * @param {PointerEvent} event
701    */
702   #endDrawing(event) {
703     this.canvas.removeEventListener(
704       "pointerleave",
705       this.#boundCanvasPointerleave
706     );
707     this.canvas.removeEventListener(
708       "pointermove",
709       this.#boundCanvasPointermove
710     );
711     this.canvas.removeEventListener("pointerup", this.#boundCanvasPointerup);
712     this.canvas.addEventListener("pointerdown", this.#boundCanvasPointerdown);
713 
714     // Slight delay to avoid the context menu to appear (it can happen on a long
715     // tap with a pen).
716     if (this.#canvasContextMenuTimeoutId) {
717       clearTimeout(this.#canvasContextMenuTimeoutId);
718     }
719     this.#canvasContextMenuTimeoutId = setTimeout(() => {
720       this.#canvasContextMenuTimeoutId = null;
721       this.canvas.removeEventListener("contextmenu", noContextMenu);
722     }, 10);
723 
724     this.#stopDrawing(event.offsetX, event.offsetY);
725 
726     this.addToAnnotationStorage();
727 
728     // Since the ink editor covers all of the page and we want to be able
729     // to select another editor, we just put this one in the background.
730     this.setInBackground();
731   }
732 
733   /**
734    * Create the canvas element.
735    */
736   #createCanvas() {
737     this.canvas = document.createElement("canvas");
738     this.canvas.width = this.canvas.height = 0;
739     this.canvas.className = "inkEditorCanvas";
740     this.canvas.setAttribute("data-l10n-id", "pdfjs-ink-canvas");
741 
742     this.div.append(this.canvas);
743     this.ctx = this.canvas.getContext("2d");
744   }
745 
746   /**
747    * Create the resize observer.
748    */
749   #createObserver() {
750     this.#observer = new ResizeObserver(entries => {
751       const rect = entries[0].contentRect;
752       if (rect.width && rect.height) {
753         this.setDimensions(rect.width, rect.height);
754       }
755     });
756     this.#observer.observe(this.div);
757   }
758 
759   /** @inheritdoc */
760   get isResizable() {
761     return !this.isEmpty() && this.#disableEditing;
762   }
763 
764   /** @inheritdoc */
765   render() {
766     if (this.div) {
767       return this.div;
768     }
769 
770     let baseX, baseY;
771     if (this.width) {
772       baseX = this.x;
773       baseY = this.y;
774     }
775 
776     super.render();
777 
778     this.div.setAttribute("data-l10n-id", "pdfjs-ink");
779 
780     const [x, y, w, h] = this.#getInitialBBox();
781     this.setAt(x, y, 0, 0);
782     this.setDims(w, h);
783 
784     this.#createCanvas();
785 
786     if (this.width) {
787       // This editor was created in using copy (ctrl+c).
788       const [parentWidth, parentHeight] = this.parentDimensions;
789       this.setAspectRatio(this.width * parentWidth, this.height * parentHeight);
790       this.setAt(
791         baseX * parentWidth,
792         baseY * parentHeight,
793         this.width * parentWidth,
794         this.height * parentHeight
795       );
796       this.#isCanvasInitialized = true;
797       this.#setCanvasDims();
798       this.setDims(this.width * parentWidth, this.height * parentHeight);
799       this.#redraw();
800       this.div.classList.add("disabled");
801     } else {
802       this.div.classList.add("editing");
803       this.enableEditMode();
804     }
805 
806     this.#createObserver();
807 
808     return this.div;
809   }
810 
811   #setCanvasDims() {
812     if (!this.#isCanvasInitialized) {
813       return;
814     }
815     const [parentWidth, parentHeight] = this.parentDimensions;
816     this.canvas.width = Math.ceil(this.width * parentWidth);
817     this.canvas.height = Math.ceil(this.height * parentHeight);
818     this.#updateTransform();
819   }
820 
821   /**
822    * When the dimensions of the div change the inner canvas must
823    * renew its dimensions, hence it must redraw its own contents.
824    * @param {number} width - the new width of the div
825    * @param {number} height - the new height of the div
826    * @returns
827    */
828   setDimensions(width, height) {
829     const roundedWidth = Math.round(width);
830     const roundedHeight = Math.round(height);
831     if (
832       this.#realWidth === roundedWidth &&
833       this.#realHeight === roundedHeight
834     ) {
835       return;
836     }
837 
838     this.#realWidth = roundedWidth;
839     this.#realHeight = roundedHeight;
840 
841     this.canvas.style.visibility = "hidden";
842 
843     const [parentWidth, parentHeight] = this.parentDimensions;
844     this.width = width / parentWidth;
845     this.height = height / parentHeight;
846     this.fixAndSetPosition();
847 
848     if (this.#disableEditing) {
849       this.#setScaleFactor(width, height);
850     }
851 
852     this.#setCanvasDims();
853     this.#redraw();
854 
855     this.canvas.style.visibility = "visible";
856 
857     // For any reason the dimensions couldn't be in percent but in pixels, hence
858     // we must fix them.
859     this.fixDims();
860   }
861 
862   #setScaleFactor(width, height) {
863     const padding = this.#getPadding();
864     const scaleFactorW = (width - padding) / this.#baseWidth;
865     const scaleFactorH = (height - padding) / this.#baseHeight;
866     this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);
867   }
868 
869   /**
870    * Update the canvas transform.
871    */
872   #updateTransform() {
873     const padding = this.#getPadding() / 2;
874     this.ctx.setTransform(
875       this.scaleFactor,
876       0,
877       0,
878       this.scaleFactor,
879       this.translationX * this.scaleFactor + padding,
880       this.translationY * this.scaleFactor + padding
881     );
882   }
883 
884   /**
885    * Convert into a Path2D.
886    * @param {Array<Array<number>>} bezier
887    * @returns {Path2D}
888    */
889   static #buildPath2D(bezier) {
890     const path2D = new Path2D();
891     for (let i = 0, ii = bezier.length; i < ii; i++) {
892       const [first, control1, control2, second] = bezier[i];
893       if (i === 0) {
894         path2D.moveTo(...first);
895       }
896       path2D.bezierCurveTo(
897         control1[0],
898         control1[1],
899         control2[0],
900         control2[1],
901         second[0],
902         second[1]
903       );
904     }
905     return path2D;
906   }
907 
908   static #toPDFCoordinates(points, rect, rotation) {
909     const [blX, blY, trX, trY] = rect;
910 
911     switch (rotation) {
912       case 0:
913         for (let i = 0, ii = points.length; i < ii; i += 2) {
914           points[i] += blX;
915           points[i + 1] = trY - points[i + 1];
916         }
917         break;
918       case 90:
919         for (let i = 0, ii = points.length; i < ii; i += 2) {
920           const x = points[i];
921           points[i] = points[i + 1] + blX;
922           points[i + 1] = x + blY;
923         }
924         break;
925       case 180:
926         for (let i = 0, ii = points.length; i < ii; i += 2) {
927           points[i] = trX - points[i];
928           points[i + 1] += blY;
929         }
930         break;
931       case 270:
932         for (let i = 0, ii = points.length; i < ii; i += 2) {
933           const x = points[i];
934           points[i] = trX - points[i + 1];
935           points[i + 1] = trY - x;
936         }
937         break;
938       default:
939         throw new Error("Invalid rotation");
940     }
941     return points;
942   }
943 
944   static #fromPDFCoordinates(points, rect, rotation) {
945     const [blX, blY, trX, trY] = rect;
946 
947     switch (rotation) {
948       case 0:
949         for (let i = 0, ii = points.length; i < ii; i += 2) {
950           points[i] -= blX;
951           points[i + 1] = trY - points[i + 1];
952         }
953         break;
954       case 90:
955         for (let i = 0, ii = points.length; i < ii; i += 2) {
956           const x = points[i];
957           points[i] = points[i + 1] - blY;
958           points[i + 1] = x - blX;
959         }
960         break;
961       case 180:
962         for (let i = 0, ii = points.length; i < ii; i += 2) {
963           points[i] = trX - points[i];
964           points[i + 1] -= blY;
965         }
966         break;
967       case 270:
968         for (let i = 0, ii = points.length; i < ii; i += 2) {
969           const x = points[i];
970           points[i] = trY - points[i + 1];
971           points[i + 1] = trX - x;
972         }
973         break;
974       default:
975         throw new Error("Invalid rotation");
976     }
977     return points;
978   }
979 
980   /**
981    * Transform and serialize the paths.
982    * @param {number} s - scale factor
983    * @param {number} tx - abscissa of the translation
984    * @param {number} ty - ordinate of the translation
985    * @param {Array<number>} rect - the bounding box of the annotation
986    */
987   #serializePaths(s, tx, ty, rect) {
988     const paths = [];
989     const padding = this.thickness / 2;
990     const shiftX = s * tx + padding;
991     const shiftY = s * ty + padding;
992     for (const bezier of this.paths) {
993       const buffer = [];
994       const points = [];
995       for (let j = 0, jj = bezier.length; j < jj; j++) {
996         const [first, control1, control2, second] = bezier[j];
997         const p10 = s * first[0] + shiftX;
998         const p11 = s * first[1] + shiftY;
999         const p20 = s * control1[0] + shiftX;
1000         const p21 = s * control1[1] + shiftY;
1001         const p30 = s * control2[0] + shiftX;
1002         const p31 = s * control2[1] + shiftY;
1003         const p40 = s * second[0] + shiftX;
1004         const p41 = s * second[1] + shiftY;
1005 
1006         if (j === 0) {
1007           buffer.push(p10, p11);
1008           points.push(p10, p11);
1009         }
1010         buffer.push(p20, p21, p30, p31, p40, p41);
1011         points.push(p20, p21);
1012         if (j === jj - 1) {
1013           points.push(p40, p41);
1014         }
1015       }
1016       paths.push({
1017         bezier: InkEditor.#toPDFCoordinates(buffer, rect, this.rotation),
1018         points: InkEditor.#toPDFCoordinates(points, rect, this.rotation),
1019       });
1020     }
1021 
1022     return paths;
1023   }
1024 
1025   /**
1026    * Get the bounding box containing all the paths.
1027    * @returns {Array<number>}
1028    */
1029   #getBbox() {
1030     let xMin = Infinity;
1031     let xMax = -Infinity;
1032     let yMin = Infinity;
1033     let yMax = -Infinity;
1034 
1035     for (const path of this.paths) {
1036       for (const [first, control1, control2, second] of path) {
1037         const bbox = Util.bezierBoundingBox(
1038           ...first,
1039           ...control1,
1040           ...control2,
1041           ...second
1042         );
1043         xMin = Math.min(xMin, bbox[0]);
1044         yMin = Math.min(yMin, bbox[1]);
1045         xMax = Math.max(xMax, bbox[2]);
1046         yMax = Math.max(yMax, bbox[3]);
1047       }
1048     }
1049 
1050     return [xMin, yMin, xMax, yMax];
1051   }
1052 
1053   /**
1054    * The bounding box is computed with null thickness, so we must take
1055    * it into account for the display.
1056    * It corresponds to the total padding, hence it should be divided by 2
1057    * in order to have left/right paddings.
1058    * @returns {number}
1059    */
1060   #getPadding() {
1061     return this.#disableEditing
1062       ? Math.ceil(this.thickness * this.parentScale)
1063       : 0;
1064   }
1065 
1066   /**
1067    * Set the div position and dimensions in order to fit to
1068    * the bounding box of the contents.
1069    * @returns {undefined}
1070    */
1071   #fitToContent(firstTime = false) {
1072     if (this.isEmpty()) {
1073       return;
1074     }
1075 
1076     if (!this.#disableEditing) {
1077       this.#redraw();
1078       return;
1079     }
1080 
1081     const bbox = this.#getBbox();
1082     const padding = this.#getPadding();
1083     this.#baseWidth = Math.max(AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]);
1084     this.#baseHeight = Math.max(AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]);
1085 
1086     const width = Math.ceil(padding + this.#baseWidth * this.scaleFactor);
1087     const height = Math.ceil(padding + this.#baseHeight * this.scaleFactor);
1088 
1089     const [parentWidth, parentHeight] = this.parentDimensions;
1090     this.width = width / parentWidth;
1091     this.height = height / parentHeight;
1092 
1093     this.setAspectRatio(width, height);
1094 
1095     const prevTranslationX = this.translationX;
1096     const prevTranslationY = this.translationY;
1097 
1098     this.translationX = -bbox[0];
1099     this.translationY = -bbox[1];
1100     this.#setCanvasDims();
1101     this.#redraw();
1102 
1103     this.#realWidth = width;
1104     this.#realHeight = height;
1105 
1106     this.setDims(width, height);
1107     const unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0;
1108     this.translate(
1109       prevTranslationX - this.translationX - unscaledPadding,
1110       prevTranslationY - this.translationY - unscaledPadding
1111     );
1112   }
1113 
1114   /** @inheritdoc */
1115   static deserialize(data, parent, uiManager) {
1116     if (data instanceof InkAnnotationElement) {
1117       return null;
1118     }
1119     const editor = super.deserialize(data, parent, uiManager);
1120 
1121     editor.thickness = data.thickness;
1122     editor.color = Util.makeHexColor(...data.color);
1123     editor.opacity = data.opacity;
1124 
1125     const [pageWidth, pageHeight] = editor.pageDimensions;
1126     const width = editor.width * pageWidth;
1127     const height = editor.height * pageHeight;
1128     const scaleFactor = editor.parentScale;
1129     const padding = data.thickness / 2;
1130 
1131     editor.#disableEditing = true;
1132     editor.#realWidth = Math.round(width);
1133     editor.#realHeight = Math.round(height);
1134 
1135     const { paths, rect, rotation } = data;
1136 
1137     for (let { bezier } of paths) {
1138       bezier = InkEditor.#fromPDFCoordinates(bezier, rect, rotation);
1139       const path = [];
1140       editor.paths.push(path);
1141       let p0 = scaleFactor * (bezier[0] - padding);
1142       let p1 = scaleFactor * (bezier[1] - padding);
1143       for (let i = 2, ii = bezier.length; i < ii; i += 6) {
1144         const p10 = scaleFactor * (bezier[i] - padding);
1145         const p11 = scaleFactor * (bezier[i + 1] - padding);
1146         const p20 = scaleFactor * (bezier[i + 2] - padding);
1147         const p21 = scaleFactor * (bezier[i + 3] - padding);
1148         const p30 = scaleFactor * (bezier[i + 4] - padding);
1149         const p31 = scaleFactor * (bezier[i + 5] - padding);
1150         path.push([
1151           [p0, p1],
1152           [p10, p11],
1153           [p20, p21],
1154           [p30, p31],
1155         ]);
1156         p0 = p30;
1157         p1 = p31;
1158       }
1159       const path2D = this.#buildPath2D(path);
1160       editor.bezierPath2D.push(path2D);
1161     }
1162 
1163     const bbox = editor.#getBbox();
1164     editor.#baseWidth = Math.max(AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]);
1165     editor.#baseHeight = Math.max(AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]);
1166     editor.#setScaleFactor(width, height);
1167 
1168     return editor;
1169   }
1170 
1171   /** @inheritdoc */
1172   serialize() {
1173     if (this.isEmpty()) {
1174       return null;
1175     }
1176 
1177     const rect = this.getRect(0, 0);
1178     const color = AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
1179 
1180     return {
1181       annotationType: AnnotationEditorType.INK,
1182       color,
1183       thickness: this.thickness,
1184       opacity: this.opacity,
1185       paths: this.#serializePaths(
1186         this.scaleFactor / this.parentScale,
1187         this.translationX,
1188         this.translationY,
1189         rect
1190       ),
1191       pageIndex: this.pageIndex,
1192       rect,
1193       rotation: this.rotation,
1194       structTreeParentId: this._structTreeParentId,
1195     };
1196   }
1197 }
1198 
1199 export { InkEditor };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

