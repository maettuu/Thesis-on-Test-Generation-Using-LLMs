Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Transformed fonts display badly in PDF
</issue>

Patch:
<patch>
diff --git a/src/core/fonts.js b/src/core/fonts.js
--- a/src/core/fonts.js
+++ b/src/core/fonts.js
@@ -798,7 +798,9 @@ function createOS2Table(properties, charstrings, override) {
   const bbox = properties.bbox || [0, 0, 0, 0];
   const unitsPerEm =
     override.unitsPerEm ||
-    1 / (properties.fontMatrix || FONT_IDENTITY_MATRIX)[0];
+    (properties.fontMatrix
+      ? 1 / Math.max(...properties.fontMatrix.slice(0, 4))
+      : 1000);
 
   // if the font units differ to the PDF glyph space units
   // then scale up the values
@@ -3196,7 +3198,9 @@ class Font {
       properties.seacMap = seacMap;
     }
 
-    const unitsPerEm = 1 / (properties.fontMatrix || FONT_IDENTITY_MATRIX)[0];
+    const unitsPerEm = properties.fontMatrix
+      ? 1 / Math.max(...properties.fontMatrix.slice(0, 4))
+      : 1000;
 
     const builder = new OpenTypeFileBuilder("\x4F\x54\x54\x4F");
     // PostScript Font Program


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.24.7
- @babel/preset-env: ^7.24.7
- @babel/runtime: ^7.24.7
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.9.0
- @jazzer.js/core: ^2.1.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.3.0
- autoprefixer: ^10.4.19
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001632
- canvas: ^2.11.2
- core-js: ^3.37.1
- cross-env: ^7.0.3
- eslint: ^8.57.0
- eslint-config-prettier: ^9.1.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^8.1.1
- eslint-plugin-import: ^2.29.1
- eslint-plugin-jasmine: ^4.1.3
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.7.4
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.1.3
- eslint-plugin-sort-exports: ^0.9.1
- eslint-plugin-unicorn: ^53.0.0
- globals: ^15.4.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- highlight.js: ^11.9.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.3
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.1
- ordered-read-streams: ^2.0.0
- path2d: ^0.2.0
- pngjs: ^7.0.0
- postcss: ^8.4.38
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^8.0.1
- postcss-discard-comments: ^7.0.0
- postcss-nesting: ^12.1.5
- prettier: ^3.3.2
- puppeteer: ^22.10.1
- streamqueue: ^1.1.2
- stylelint: ^16.6.1
- stylelint-prettier: ^5.0.0
- terser-webpack-plugin: ^5.3.10
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.4.5
- vinyl: ^3.0.0
- webpack: ^5.91.0
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/outliner.js`: Outliner
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodePackages
- `../../src/display/text_layer.js`: TextLayer, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory, createTemporaryNodeServer
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/fonts.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   assert,
18   bytesToString,
19   FONT_IDENTITY_MATRIX,
20   FormatError,
21   info,
22   shadow,
23   string32,
24   warn,
25 } from "../shared/util.js";
26 import { CFFCompiler, CFFParser } from "./cff_parser.js";
27 import {
28   FontFlags,
29   MacStandardGlyphOrdering,
30   normalizeFontName,
31   recoverGlyphName,
32   SEAC_ANALYSIS_ENABLED,
33 } from "./fonts_utils.js";
34 import {
35   getCharUnicodeCategory,
36   getUnicodeForGlyph,
37   getUnicodeRangeFor,
38   mapSpecialUnicodeValues,
39 } from "./unicode.js";
40 import { getDingbatsGlyphsUnicode, getGlyphsUnicode } from "./glyphlist.js";
41 import {
42   getEncoding,
43   MacRomanEncoding,
44   StandardEncoding,
45   SymbolSetEncoding,
46   WinAnsiEncoding,
47   ZapfDingbatsEncoding,
48 } from "./encodings.js";
49 import {
50   getGlyphMapForStandardFonts,
51   getNonStdFontMap,
52   getSerifFonts,
53   getStdFontMap,
54   getSupplementalGlyphMapForArialBlack,
55   getSupplementalGlyphMapForCalibri,
56 } from "./standard_fonts.js";
57 import { IdentityToUnicodeMap, ToUnicodeMap } from "./to_unicode_map.js";
58 import { CFFFont } from "./cff_font.js";
59 import { FontRendererFactory } from "./font_renderer.js";
60 import { getFontBasicMetrics } from "./metrics.js";
61 import { GlyfTable } from "./glyf.js";
62 import { IdentityCMap } from "./cmap.js";
63 import { OpenTypeFileBuilder } from "./opentype_file_builder.js";
64 import { readUint32 } from "./core_utils.js";
65 import { Stream } from "./stream.js";
66 import { Type1Font } from "./type1_font.js";
67 
68 // Unicode Private Use Areas:
69 const PRIVATE_USE_AREAS = [
70   [0xe000, 0xf8ff], // BMP (0)
71   [0x100000, 0x10fffd], // PUP (16)
72 ];
73 
74 // PDF Glyph Space Units are one Thousandth of a TextSpace Unit
75 // except for Type 3 fonts
76 const PDF_GLYPH_SPACE_UNITS = 1000;
77 
78 const EXPORT_DATA_PROPERTIES = [
79   "ascent",
80   "bbox",
81   "black",
82   "bold",
83   "charProcOperatorList",
84   "composite",
85   "cssFontInfo",
86   "data",
87   "defaultVMetrics",
88   "defaultWidth",
89   "descent",
90   "fallbackName",
91   "fontMatrix",
92   "isInvalidPDFjsFont",
93   "isType3Font",
94   "italic",
95   "loadedName",
96   "mimetype",
97   "missingFile",
98   "name",
99   "remeasure",
100   "subtype",
101   "systemFontInfo",
102   "type",
103   "vertical",
104 ];
105 
106 const EXPORT_DATA_EXTRA_PROPERTIES = [
107   "cMap",
108   "defaultEncoding",
109   "differences",
110   "isMonospace",
111   "isSerifFont",
112   "isSymbolicFont",
113   "seacMap",
114   "toFontChar",
115   "toUnicode",
116   "vmetrics",
117   "widths",
118 ];
119 
120 function adjustWidths(properties) {
121   if (!properties.fontMatrix) {
122     return;
123   }
124   if (properties.fontMatrix[0] === FONT_IDENTITY_MATRIX[0]) {
125     return;
126   }
127   // adjusting width to fontMatrix scale
128   const scale = 0.001 / properties.fontMatrix[0];
129   const glyphsWidths = properties.widths;
130   for (const glyph in glyphsWidths) {
131     glyphsWidths[glyph] *= scale;
132   }
133   properties.defaultWidth *= scale;
134 }
135 
136 function adjustTrueTypeToUnicode(properties, isSymbolicFont, nameRecords) {
137   if (properties.isInternalFont) {
138     return;
139   }
140   if (properties.hasIncludedToUnicodeMap) {
141     return; // The font dictionary has a `ToUnicode` entry.
142   }
143   if (properties.hasEncoding) {
144     return; // The font dictionary has an `Encoding` entry.
145   }
146   if (properties.toUnicode instanceof IdentityToUnicodeMap) {
147     return;
148   }
149   if (!isSymbolicFont) {
150     return; // A non-symbolic font should default to `StandardEncoding`.
151   }
152   if (nameRecords.length === 0) {
153     return;
154   }
155 
156   // Try to infer if the fallback encoding should really be `WinAnsiEncoding`.
157   if (properties.defaultEncoding === WinAnsiEncoding) {
158     return;
159   }
160   for (const r of nameRecords) {
161     if (!isWinNameRecord(r)) {
162       return; // Not Windows, hence `WinAnsiEncoding` wouldn't make sense.
163     }
164   }
165   const encoding = WinAnsiEncoding;
166 
167   const toUnicode = [],
168     glyphsUnicodeMap = getGlyphsUnicode();
169   for (const charCode in encoding) {
170     const glyphName = encoding[charCode];
171     if (glyphName === "") {
172       continue;
173     }
174     const unicode = glyphsUnicodeMap[glyphName];
175     if (unicode === undefined) {
176       continue;
177     }
178     toUnicode[charCode] = String.fromCharCode(unicode);
179   }
180   if (toUnicode.length > 0) {
181     properties.toUnicode.amend(toUnicode);
182   }
183 }
184 
185 function adjustType1ToUnicode(properties, builtInEncoding) {
186   if (properties.isInternalFont) {
187     return;
188   }
189   if (properties.hasIncludedToUnicodeMap) {
190     return; // The font dictionary has a `ToUnicode` entry.
191   }
192   if (builtInEncoding === properties.defaultEncoding) {
193     return; // No point in trying to adjust `toUnicode` if the encodings match.
194   }
195   if (properties.toUnicode instanceof IdentityToUnicodeMap) {
196     return;
197   }
198   const toUnicode = [],
199     glyphsUnicodeMap = getGlyphsUnicode();
200   for (const charCode in builtInEncoding) {
201     if (properties.hasEncoding) {
202       if (
203         properties.baseEncodingName ||
204         properties.differences[charCode] !== undefined
205       ) {
206         continue; // The font dictionary has an `Encoding`/`Differences` entry.
207       }
208     }
209     const glyphName = builtInEncoding[charCode];
210     const unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
211     if (unicode !== -1) {
212       toUnicode[charCode] = String.fromCharCode(unicode);
213     }
214   }
215   if (toUnicode.length > 0) {
216     properties.toUnicode.amend(toUnicode);
217   }
218 }
219 
220 /**
221  * NOTE: This function should only be called at the *end* of font-parsing,
222  *       after e.g. `adjustType1ToUnicode` has run, to prevent any issues.
223  */
224 function amendFallbackToUnicode(properties) {
225   if (!properties.fallbackToUnicode) {
226     return;
227   }
228   if (properties.toUnicode instanceof IdentityToUnicodeMap) {
229     return;
230   }
231   const toUnicode = [];
232   for (const charCode in properties.fallbackToUnicode) {
233     if (properties.toUnicode.has(charCode)) {
234       continue; // The font dictionary has a `ToUnicode` entry.
235     }
236     toUnicode[charCode] = properties.fallbackToUnicode[charCode];
237   }
238   if (toUnicode.length > 0) {
239     properties.toUnicode.amend(toUnicode);
240   }
241 }
242 
243 class Glyph {
244   constructor(
245     originalCharCode,
246     fontChar,
247     unicode,
248     accent,
249     width,
250     vmetric,
251     operatorListId,
252     isSpace,
253     isInFont
254   ) {
255     this.originalCharCode = originalCharCode;
256     this.fontChar = fontChar;
257     this.unicode = unicode;
258     this.accent = accent;
259     this.width = width;
260     this.vmetric = vmetric;
261     this.operatorListId = operatorListId;
262     this.isSpace = isSpace;
263     this.isInFont = isInFont;
264   }
265 
266   /**
267    * This property, which is only used by `PartialEvaluator.getTextContent`,
268    * is purposely made non-serializable.
269    * @type {Object}
270    */
271   get category() {
272     return shadow(
273       this,
274       "category",
275       getCharUnicodeCategory(this.unicode),
276       /* nonSerializable = */ true
277     );
278   }
279 }
280 
281 function int16(b0, b1) {
282   return (b0 << 8) + b1;
283 }
284 
285 function writeSignedInt16(bytes, index, value) {
286   bytes[index + 1] = value;
287   bytes[index] = value >>> 8;
288 }
289 
290 function signedInt16(b0, b1) {
291   const value = (b0 << 8) + b1;
292   return value & (1 << 15) ? value - 0x10000 : value;
293 }
294 
295 function writeUint32(bytes, index, value) {
296   bytes[index + 3] = value & 0xff;
297   bytes[index + 2] = value >>> 8;
298   bytes[index + 1] = value >>> 16;
299   bytes[index] = value >>> 24;
300 }
301 
302 function int32(b0, b1, b2, b3) {
303   return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
304 }
305 
306 function string16(value) {
307   if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
308     assert(
309       typeof value === "number" && Math.abs(value) < 2 ** 16,
310       `string16: Unexpected input "${value}".`
311     );
312   }
313   return String.fromCharCode((value >> 8) & 0xff, value & 0xff);
314 }
315 
316 function safeString16(value) {
317   if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
318     assert(
319       typeof value === "number" && !Number.isNaN(value),
320       `safeString16: Unexpected input "${value}".`
321     );
322   }
323   // clamp value to the 16-bit int range
324   if (value > 0x7fff) {
325     value = 0x7fff;
326   } else if (value < -0x8000) {
327     value = -0x8000;
328   }
329   return String.fromCharCode((value >> 8) & 0xff, value & 0xff);
330 }
331 
332 function isTrueTypeFile(file) {
333   const header = file.peekBytes(4);
334   return (
335     readUint32(header, 0) === 0x00010000 || bytesToString(header) === "true"
336   );
337 }
338 
339 function isTrueTypeCollectionFile(file) {
340   const header = file.peekBytes(4);
341   return bytesToString(header) === "ttcf";
342 }
343 
344 function isOpenTypeFile(file) {
345   const header = file.peekBytes(4);
346   return bytesToString(header) === "OTTO";
347 }
348 
349 function isType1File(file) {
350   const header = file.peekBytes(2);
351   // All Type1 font programs must begin with the comment '%!' (0x25 + 0x21).
352   if (header[0] === 0x25 && header[1] === 0x21) {
353     return true;
354   }
355   // ... obviously some fonts violate that part of the specification,
356   // please refer to the comment in |Type1Font| below (pfb file header).
357   if (header[0] === 0x80 && header[1] === 0x01) {
358     return true;
359   }
360   return false;
361 }
362 
363 /**
364  * Compared to other font formats, the header in CFF files is not constant
365  * but contains version numbers. To reduce the possibility of misclassifying
366  * font files as CFF, it's recommended to check for other font formats first.
367  */
368 function isCFFFile(file) {
369   const header = file.peekBytes(4);
370   if (
371     /* major version, [1, 255] */ header[0] >= 1 &&
372     /* minor version, [0, 255]; header[1] */
373     /* header size, [0, 255]; header[2] */
374     /* offset(0) size, [1, 4] */ header[3] >= 1 &&
375     header[3] <= 4
376   ) {
377     return true;
378   }
379   return false;
380 }
381 
382 function getFontFileType(file, { type, subtype, composite }) {
383   let fileType, fileSubtype;
384 
385   if (isTrueTypeFile(file) || isTrueTypeCollectionFile(file)) {
386     fileType = composite ? "CIDFontType2" : "TrueType";
387   } else if (isOpenTypeFile(file)) {
388     fileType = composite ? "CIDFontType2" : "OpenType";
389   } else if (isType1File(file)) {
390     if (composite) {
391       fileType = "CIDFontType0";
392     } else {
393       fileType = type === "MMType1" ? "MMType1" : "Type1";
394     }
395   } else if (isCFFFile(file)) {
396     if (composite) {
397       fileType = "CIDFontType0";
398       fileSubtype = "CIDFontType0C";
399     } else {
400       fileType = type === "MMType1" ? "MMType1" : "Type1";
401       fileSubtype = "Type1C";
402     }
403   } else {
404     warn("getFontFileType: Unable to detect correct font file Type/Subtype.");
405     fileType = type;
406     fileSubtype = subtype;
407   }
408 
409   return [fileType, fileSubtype];
410 }
411 
412 function applyStandardFontGlyphMap(map, glyphMap) {
413   for (const charCode in glyphMap) {
414     map[+charCode] = glyphMap[charCode];
415   }
416 }
417 
418 function buildToFontChar(encoding, glyphsUnicodeMap, differences) {
419   const toFontChar = [];
420   let unicode;
421   for (let i = 0, ii = encoding.length; i < ii; i++) {
422     unicode = getUnicodeForGlyph(encoding[i], glyphsUnicodeMap);
423     if (unicode !== -1) {
424       toFontChar[i] = unicode;
425     }
426   }
427   for (const charCode in differences) {
428     unicode = getUnicodeForGlyph(differences[charCode], glyphsUnicodeMap);
429     if (unicode !== -1) {
430       toFontChar[+charCode] = unicode;
431     }
432   }
433   return toFontChar;
434 }
435 
436 // Please refer to:
437 //  - https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html
438 function isMacNameRecord(r) {
439   return r.platform === 1 && r.encoding === 0 && r.language === 0;
440 }
441 
442 // Please refer to:
443 //  - https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html
444 //  - https://learn.microsoft.com/en-us/typography/opentype/spec/name#windows-language-ids
445 function isWinNameRecord(r) {
446   return r.platform === 3 && r.encoding === 1 && r.language === 0x409;
447 }
448 
449 function convertCidString(charCode, cid, shouldThrow = false) {
450   switch (cid.length) {
451     case 1:
452       return cid.charCodeAt(0);
453     case 2:
454       return (cid.charCodeAt(0) << 8) | cid.charCodeAt(1);
455   }
456   const msg = `Unsupported CID string (charCode ${charCode}): "${cid}".`;
457   if (shouldThrow) {
458     throw new FormatError(msg);
459   }
460   warn(msg);
461   return cid;
462 }
463 
464 /**
465  * Rebuilds the char code to glyph ID map by moving all char codes to the
466  * private use area. This is done to avoid issues with various problematic
467  * unicode areas where either a glyph won't be drawn or is deformed by a
468  * shaper.
469  * @returns {Object} Two properties:
470  * 'toFontChar' - maps original char codes(the value that will be read
471  * from commands such as show text) to the char codes that will be used in the
472  * font that we build
473  * 'charCodeToGlyphId' - maps the new font char codes to glyph ids
474  */
475 function adjustMapping(charCodeToGlyphId, hasGlyph, newGlyphZeroId, toUnicode) {
476   const newMap = Object.create(null);
477   const toUnicodeExtraMap = new Map();
478   const toFontChar = [];
479   const usedGlyphIds = new Set();
480   let privateUseAreaIndex = 0;
481   const privateUseOffetStart = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
482   let nextAvailableFontCharCode = privateUseOffetStart;
483   let privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
484   const isInPrivateArea = code =>
485     (PRIVATE_USE_AREAS[0][0] <= code && code <= PRIVATE_USE_AREAS[0][1]) ||
486     (PRIVATE_USE_AREAS[1][0] <= code && code <= PRIVATE_USE_AREAS[1][1]);
487   for (const originalCharCode in charCodeToGlyphId) {
488     let glyphId = charCodeToGlyphId[originalCharCode];
489     // For missing glyphs don't create the mappings so the glyph isn't
490     // drawn.
491     if (!hasGlyph(glyphId)) {
492       continue;
493     }
494     if (nextAvailableFontCharCode > privateUseOffetEnd) {
495       privateUseAreaIndex++;
496       if (privateUseAreaIndex >= PRIVATE_USE_AREAS.length) {
497         warn("Ran out of space in font private use area.");
498         break;
499       }
500       nextAvailableFontCharCode = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
501       privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
502     }
503     const fontCharCode = nextAvailableFontCharCode++;
504     if (glyphId === 0) {
505       glyphId = newGlyphZeroId;
506     }
507 
508     // Fix for bug 1778484:
509     // The charcodes are moved into a private use area to fix some rendering
510     // issues (https://github.com/mozilla/pdf.js/pull/9340) but when printing
511     // to PDF the generated font will contain wrong chars. We can avoid that by
512     // adding the unicode to the cmap and the print backend will then map the
513     // glyph ids to the correct unicode.
514     let unicode = toUnicode.get(originalCharCode);
515     if (typeof unicode === "string") {
516       unicode = unicode.codePointAt(0);
517     }
518     if (unicode && !isInPrivateArea(unicode) && !usedGlyphIds.has(glyphId)) {
519       toUnicodeExtraMap.set(unicode, glyphId);
520       usedGlyphIds.add(glyphId);
521     }
522 
523     newMap[fontCharCode] = glyphId;
524     toFontChar[originalCharCode] = fontCharCode;
525   }
526   return {
527     toFontChar,
528     charCodeToGlyphId: newMap,
529     toUnicodeExtraMap,
530     nextAvailableFontCharCode,
531   };
532 }
533 
534 function getRanges(glyphs, toUnicodeExtraMap, numGlyphs) {
535   // Array.sort() sorts by characters, not numerically, so convert to an
536   // array of characters.
537   const codes = [];
538   for (const charCode in glyphs) {
539     // Remove an invalid glyph ID mappings to make OTS happy.
540     if (glyphs[charCode] >= numGlyphs) {
541       continue;
542     }
543     codes.push({ fontCharCode: charCode | 0, glyphId: glyphs[charCode] });
544   }
545   if (toUnicodeExtraMap) {
546     for (const [unicode, glyphId] of toUnicodeExtraMap) {
547       if (glyphId >= numGlyphs) {
548         continue;
549       }
550       codes.push({ fontCharCode: unicode, glyphId });
551     }
552   }
553   // Some fonts have zero glyphs and are used only for text selection, but
554   // there needs to be at least one to build a valid cmap table.
555   if (codes.length === 0) {
556     codes.push({ fontCharCode: 0, glyphId: 0 });
557   }
558   codes.sort(function fontGetRangesSort(a, b) {
559     return a.fontCharCode - b.fontCharCode;
560   });
561 
562   // Split the sorted codes into ranges.
563   const ranges = [];
564   const length = codes.length;
565   for (let n = 0; n < length; ) {
566     const start = codes[n].fontCharCode;
567     const codeIndices = [codes[n].glyphId];
568     ++n;
569     let end = start;
570     while (n < length && end + 1 === codes[n].fontCharCode) {
571       codeIndices.push(codes[n].glyphId);
572       ++end;
573       ++n;
574       if (end === 0xffff) {
575         break;
576       }
577     }
578     ranges.push([start, end, codeIndices]);
579   }
580 
581   return ranges;
582 }
583 
584 function createCmapTable(glyphs, toUnicodeExtraMap, numGlyphs) {
585   const ranges = getRanges(glyphs, toUnicodeExtraMap, numGlyphs);
586   const numTables = ranges.at(-1)[1] > 0xffff ? 2 : 1;
587   let cmap =
588     "\x00\x00" + // version
589     string16(numTables) + // numTables
590     "\x00\x03" + // platformID
591     "\x00\x01" + // encodingID
592     string32(4 + numTables * 8); // start of the table record
593 
594   let i, ii, j, jj;
595   for (i = ranges.length - 1; i >= 0; --i) {
596     if (ranges[i][0] <= 0xffff) {
597       break;
598     }
599   }
600   const bmpLength = i + 1;
601 
602   if (ranges[i][0] < 0xffff && ranges[i][1] === 0xffff) {
603     ranges[i][1] = 0xfffe;
604   }
605   const trailingRangesCount = ranges[i][1] < 0xffff ? 1 : 0;
606   const segCount = bmpLength + trailingRangesCount;
607   const searchParams = OpenTypeFileBuilder.getSearchParams(segCount, 2);
608 
609   // Fill up the 4 parallel arrays describing the segments.
610   let startCount = "";
611   let endCount = "";
612   let idDeltas = "";
613   let idRangeOffsets = "";
614   let glyphsIds = "";
615   let bias = 0;
616 
617   let range, start, end, codes;
618   for (i = 0, ii = bmpLength; i < ii; i++) {
619     range = ranges[i];
620     start = range[0];
621     end = range[1];
622     startCount += string16(start);
623     endCount += string16(end);
624     codes = range[2];
625     let contiguous = true;
626     for (j = 1, jj = codes.length; j < jj; ++j) {
627       if (codes[j] !== codes[j - 1] + 1) {
628         contiguous = false;
629         break;
630       }
631     }
632     if (!contiguous) {
633       const offset = (segCount - i) * 2 + bias * 2;
634       bias += end - start + 1;
635 
636       idDeltas += string16(0);
637       idRangeOffsets += string16(offset);
638 
639       for (j = 0, jj = codes.length; j < jj; ++j) {
640         glyphsIds += string16(codes[j]);
641       }
642     } else {
643       const startCode = codes[0];
644 
645       idDeltas += string16((startCode - start) & 0xffff);
646       idRangeOffsets += string16(0);
647     }
648   }
649 
650   if (trailingRangesCount > 0) {
651     endCount += "\xFF\xFF";
652     startCount += "\xFF\xFF";
653     idDeltas += "\x00\x01";
654     idRangeOffsets += "\x00\x00";
655   }
656 
657   const format314 =
658     "\x00\x00" + // language
659     string16(2 * segCount) +
660     string16(searchParams.range) +
661     string16(searchParams.entry) +
662     string16(searchParams.rangeShift) +
663     endCount +
664     "\x00\x00" +
665     startCount +
666     idDeltas +
667     idRangeOffsets +
668     glyphsIds;
669 
670   let format31012 = "";
671   let header31012 = "";
672   if (numTables > 1) {
673     cmap +=
674       "\x00\x03" + // platformID
675       "\x00\x0A" + // encodingID
676       string32(4 + numTables * 8 + 4 + format314.length); // start of the table record
677     format31012 = "";
678     for (i = 0, ii = ranges.length; i < ii; i++) {
679       range = ranges[i];
680       start = range[0];
681       codes = range[2];
682       let code = codes[0];
683       for (j = 1, jj = codes.length; j < jj; ++j) {
684         if (codes[j] !== codes[j - 1] + 1) {
685           end = range[0] + j - 1;
686           format31012 +=
687             string32(start) + // startCharCode
688             string32(end) + // endCharCode
689             string32(code); // startGlyphID
690           start = end + 1;
691           code = codes[j];
692         }
693       }
694       format31012 +=
695         string32(start) + // startCharCode
696         string32(range[1]) + // endCharCode
697         string32(code); // startGlyphID
698     }
699     header31012 =
700       "\x00\x0C" + // format
701       "\x00\x00" + // reserved
702       string32(format31012.length + 16) + // length
703       "\x00\x00\x00\x00" + // language
704       string32(format31012.length / 12); // nGroups
705   }
706 
707   return (
708     cmap +
709     "\x00\x04" + // format
710     string16(format314.length + 4) + // length
711     format314 +
712     header31012 +
713     format31012
714   );
715 }
716 
717 function validateOS2Table(os2, file) {
718   file.pos = (file.start || 0) + os2.offset;
719   const version = file.getUint16();
720   // TODO verify all OS/2 tables fields, but currently we validate only those
721   // that give us issues
722   file.skip(60); // skipping type, misc sizes, panose, unicode ranges
723   const selection = file.getUint16();
724   if (version < 4 && selection & 0x0300) {
725     return false;
726   }
727   const firstChar = file.getUint16();
728   const lastChar = file.getUint16();
729   if (firstChar > lastChar) {
730     return false;
731   }
732   file.skip(6); // skipping sTypoAscender/Descender/LineGap
733   const usWinAscent = file.getUint16();
734   if (usWinAscent === 0) {
735     // makes font unreadable by windows
736     return false;
737   }
738 
739   // OS/2 appears to be valid, resetting some fields
740   os2.data[8] = os2.data[9] = 0; // IE rejects fonts if fsType != 0
741   return true;
742 }
743 
744 function createOS2Table(properties, charstrings, override) {
745   override ||= {
746     unitsPerEm: 0,
747     yMax: 0,
748     yMin: 0,
749     ascent: 0,
750     descent: 0,
751   };
752 
753   let ulUnicodeRange1 = 0;
754   let ulUnicodeRange2 = 0;
755   let ulUnicodeRange3 = 0;
756   let ulUnicodeRange4 = 0;
757 
758   let firstCharIndex = null;
759   let lastCharIndex = 0;
760   let position = -1;
761 
762   if (charstrings) {
763     for (let code in charstrings) {
764       code |= 0;
765       if (firstCharIndex > code || !firstCharIndex) {
766         firstCharIndex = code;
767       }
768       if (lastCharIndex < code) {
769         lastCharIndex = code;
770       }
771 
772       position = getUnicodeRangeFor(code, position);
773       if (position < 32) {
774         ulUnicodeRange1 |= 1 << position;
775       } else if (position < 64) {
776         ulUnicodeRange2 |= 1 << (position - 32);
777       } else if (position < 96) {
778         ulUnicodeRange3 |= 1 << (position - 64);
779       } else if (position < 123) {
780         ulUnicodeRange4 |= 1 << (position - 96);
781       } else {
782         throw new FormatError(
783           "Unicode ranges Bits > 123 are reserved for internal usage"
784         );
785       }
786     }
787     if (lastCharIndex > 0xffff) {
788       // OS2 only supports a 16 bit int. The spec says if supplementary
789       // characters are used the field should just be set to 0xFFFF.
790       lastCharIndex = 0xffff;
791     }
792   } else {
793     // TODO
794     firstCharIndex = 0;
795     lastCharIndex = 255;
796   }
797 
798   const bbox = properties.bbox || [0, 0, 0, 0];
799   const unitsPerEm =
800     override.unitsPerEm ||
801     1 / (properties.fontMatrix || FONT_IDENTITY_MATRIX)[0];
802 
803   // if the font units differ to the PDF glyph space units
804   // then scale up the values
805   const scale = properties.ascentScaled
806     ? 1.0
807     : unitsPerEm / PDF_GLYPH_SPACE_UNITS;
808 
809   const typoAscent =
810     override.ascent || Math.round(scale * (properties.ascent || bbox[3]));
811   let typoDescent =
812     override.descent || Math.round(scale * (properties.descent || bbox[1]));
813   if (typoDescent > 0 && properties.descent > 0 && bbox[1] < 0) {
814     typoDescent = -typoDescent; // fixing incorrect descent
815   }
816   const winAscent = override.yMax || typoAscent;
817   const winDescent = -override.yMin || -typoDescent;
818 
819   return (
820     "\x00\x03" + // version
821     "\x02\x24" + // xAvgCharWidth
822     "\x01\xF4" + // usWeightClass
823     "\x00\x05" + // usWidthClass
824     "\x00\x00" + // fstype (0 to let the font loads via font-face on IE)
825     "\x02\x8A" + // ySubscriptXSize
826     "\x02\xBB" + // ySubscriptYSize
827     "\x00\x00" + // ySubscriptXOffset
828     "\x00\x8C" + // ySubscriptYOffset
829     "\x02\x8A" + // ySuperScriptXSize
830     "\x02\xBB" + // ySuperScriptYSize
831     "\x00\x00" + // ySuperScriptXOffset
832     "\x01\xDF" + // ySuperScriptYOffset
833     "\x00\x31" + // yStrikeOutSize
834     "\x01\x02" + // yStrikeOutPosition
835     "\x00\x00" + // sFamilyClass
836     "\x00\x00\x06" +
837     String.fromCharCode(properties.fixedPitch ? 0x09 : 0x00) +
838     "\x00\x00\x00\x00\x00\x00" + // Panose
839     string32(ulUnicodeRange1) + // ulUnicodeRange1 (Bits 0-31)
840     string32(ulUnicodeRange2) + // ulUnicodeRange2 (Bits 32-63)
841     string32(ulUnicodeRange3) + // ulUnicodeRange3 (Bits 64-95)
842     string32(ulUnicodeRange4) + // ulUnicodeRange4 (Bits 96-127)
843     "\x2A\x32\x31\x2A" + // achVendID
844     string16(properties.italicAngle ? 1 : 0) + // fsSelection
845     string16(firstCharIndex || properties.firstChar) + // usFirstCharIndex
846     string16(lastCharIndex || properties.lastChar) + // usLastCharIndex
847     string16(typoAscent) + // sTypoAscender
848     string16(typoDescent) + // sTypoDescender
849     "\x00\x64" + // sTypoLineGap (7%-10% of the unitsPerEM value)
850     string16(winAscent) + // usWinAscent
851     string16(winDescent) + // usWinDescent
852     "\x00\x00\x00\x00" + // ulCodePageRange1 (Bits 0-31)
853     "\x00\x00\x00\x00" + // ulCodePageRange2 (Bits 32-63)
854     string16(properties.xHeight) + // sxHeight
855     string16(properties.capHeight) + // sCapHeight
856     string16(0) + // usDefaultChar
857     string16(firstCharIndex || properties.firstChar) + // usBreakChar
858     "\x00\x03"
859   ); // usMaxContext
860 }
861 
862 function createPostTable(properties) {
863   const angle = Math.floor(properties.italicAngle * 2 ** 16);
864   return (
865     "\x00\x03\x00\x00" + // Version number
866     string32(angle) + // italicAngle
867     "\x00\x00" + // underlinePosition
868     "\x00\x00" + // underlineThickness
869     string32(properties.fixedPitch ? 1 : 0) + // isFixedPitch
870     "\x00\x00\x00\x00" + // minMemType42
871     "\x00\x00\x00\x00" + // maxMemType42
872     "\x00\x00\x00\x00" + // minMemType1
873     "\x00\x00\x00\x00"
874   ); // maxMemType1
875 }
876 
877 function createPostscriptName(name) {
878   // See https://docs.microsoft.com/en-us/typography/opentype/spec/recom#name.
879   return name.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
880 }
881 
882 function createNameTable(name, proto) {
883   if (!proto) {
884     proto = [[], []]; // no strings and unicode strings
885   }
886 
887   const strings = [
888     proto[0][0] || "Original licence", // 0.Copyright
889     proto[0][1] || name, // 1.Font family
890     proto[0][2] || "Unknown", // 2.Font subfamily (font weight)
891     proto[0][3] || "uniqueID", // 3.Unique ID
892     proto[0][4] || name, // 4.Full font name
893     proto[0][5] || "Version 0.11", // 5.Version
894     proto[0][6] || createPostscriptName(name), // 6.Postscript name
895     proto[0][7] || "Unknown", // 7.Trademark
896     proto[0][8] || "Unknown", // 8.Manufacturer
897     proto[0][9] || "Unknown", // 9.Designer
898   ];
899 
900   // Mac want 1-byte per character strings while Windows want
901   // 2-bytes per character, so duplicate the names table
902   const stringsUnicode = [];
903   let i, ii, j, jj, str;
904   for (i = 0, ii = strings.length; i < ii; i++) {
905     str = proto[1][i] || strings[i];
906 
907     const strBufUnicode = [];
908     for (j = 0, jj = str.length; j < jj; j++) {
909       strBufUnicode.push(string16(str.charCodeAt(j)));
910     }
911     stringsUnicode.push(strBufUnicode.join(""));
912   }
913 
914   const names = [strings, stringsUnicode];
915   const platforms = ["\x00\x01", "\x00\x03"];
916   const encodings = ["\x00\x00", "\x00\x01"];
917   const languages = ["\x00\x00", "\x04\x09"];
918 
919   const namesRecordCount = strings.length * platforms.length;
920   let nameTable =
921     "\x00\x00" + // format
922     string16(namesRecordCount) + // Number of names Record
923     string16(namesRecordCount * 12 + 6); // Storage
924 
925   // Build the name records field
926   let strOffset = 0;
927   for (i = 0, ii = platforms.length; i < ii; i++) {
928     const strs = names[i];
929     for (j = 0, jj = strs.length; j < jj; j++) {
930       str = strs[j];
931       const nameRecord =
932         platforms[i] + // platform ID
933         encodings[i] + // encoding ID
934         languages[i] + // language ID
935         string16(j) + // name ID
936         string16(str.length) +
937         string16(strOffset);
938       nameTable += nameRecord;
939       strOffset += str.length;
940     }
941   }
942 
943   nameTable += strings.join("") + stringsUnicode.join("");
944   return nameTable;
945 }
946 
947 /**
948  * 'Font' is the class the outside world should use, it encapsulate all the font
949  * decoding logics whatever type it is (assuming the font type is supported).
950  */
951 class Font {
952   constructor(name, file, properties) {
953     this.name = name;
954     this.psName = null;
955     this.mimetype = null;
956     this.disableFontFace = false;
957 
958     this.loadedName = properties.loadedName;
959     this.isType3Font = properties.isType3Font;
960     this.missingFile = false;
961     this.cssFontInfo = properties.cssFontInfo;
962 
963     this._charsCache = Object.create(null);
964     this._glyphCache = Object.create(null);
965 
966     let isSerifFont = !!(properties.flags & FontFlags.Serif);
967     // Fallback to checking the font name, in order to improve text-selection,
968     // since the /Flags-entry is often wrong (fixes issue13845.pdf).
969     if (!isSerifFont && !properties.isSimulatedFlags) {
970       const baseName = name.replaceAll(/[,_]/g, "-").split("-", 1)[0],
971         serifFonts = getSerifFonts();
972       for (const namePart of baseName.split("+")) {
973         if (serifFonts[namePart]) {
974           isSerifFont = true;
975           break;
976         }
977       }
978     }
979     this.isSerifFont = isSerifFont;
980 
981     this.isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
982     this.isMonospace = !!(properties.flags & FontFlags.FixedPitch);
983 
984     let { type, subtype } = properties;
985     this.type = type;
986     this.subtype = subtype;
987     this.systemFontInfo = properties.systemFontInfo;
988 
989     const matches = name.match(/^InvalidPDFjsFont_(.*)_\d+$/);
990     this.isInvalidPDFjsFont = !!matches;
991     if (this.isInvalidPDFjsFont) {
992       this.fallbackName = matches[1];
993     } else if (this.isMonospace) {
994       this.fallbackName = "monospace";
995     } else if (this.isSerifFont) {
996       this.fallbackName = "serif";
997     } else {
998       this.fallbackName = "sans-serif";
999     }
1000 
1001     if (this.systemFontInfo?.guessFallback) {
1002       // Once the fallback name is guessed, we don't want to guess it again.
1003       this.systemFontInfo.guessFallback = false;
1004       this.systemFontInfo.css += `,${this.fallbackName}`;
1005     }
1006 
1007     this.differences = properties.differences;
1008     this.widths = properties.widths;
1009     this.defaultWidth = properties.defaultWidth;
1010     this.composite = properties.composite;
1011     this.cMap = properties.cMap;
1012     this.capHeight = properties.capHeight / PDF_GLYPH_SPACE_UNITS;
1013     this.ascent = properties.ascent / PDF_GLYPH_SPACE_UNITS;
1014     this.descent = properties.descent / PDF_GLYPH_SPACE_UNITS;
1015     this.lineHeight = this.ascent - this.descent;
1016     this.fontMatrix = properties.fontMatrix;
1017     this.bbox = properties.bbox;
1018     this.defaultEncoding = properties.defaultEncoding;
1019 
1020     this.toUnicode = properties.toUnicode;
1021     this.toFontChar = [];
1022 
1023     if (properties.type === "Type3") {
1024       for (let charCode = 0; charCode < 256; charCode++) {
1025         this.toFontChar[charCode] =
1026           this.differences[charCode] || properties.defaultEncoding[charCode];
1027       }
1028       return;
1029     }
1030 
1031     this.cidEncoding = properties.cidEncoding || "";
1032     this.vertical = !!properties.vertical;
1033     if (this.vertical) {
1034       this.vmetrics = properties.vmetrics;
1035       this.defaultVMetrics = properties.defaultVMetrics;
1036     }
1037 
1038     if (!file || file.isEmpty) {
1039       if (file) {
1040         // Some bad PDF generators will include empty font files,
1041         // attempting to recover by assuming that no file exists.
1042         warn('Font file is empty in "' + name + '" (' + this.loadedName + ")");
1043       }
1044       this.fallbackToSystemFont(properties);
1045       return;
1046     }
1047 
1048     // Parse the font file to determine the correct type/subtype, rather than
1049     // relying on the (often incorrect) data in the font dictionary; (see e.g.
1050     //  issue6782.pdf, issue7598.pdf, and issue9949.pdf).
1051     [type, subtype] = getFontFileType(file, properties);
1052 
1053     if (type !== this.type || subtype !== this.subtype) {
1054       info(
1055         "Inconsistent font file Type/SubType, expected: " +
1056           `${this.type}/${this.subtype} but found: ${type}/${subtype}.`
1057       );
1058     }
1059 
1060     let data;
1061     try {
1062       switch (type) {
1063         case "MMType1":
1064           info("MMType1 font (" + name + "), falling back to Type1.");
1065         /* falls through */
1066         case "Type1":
1067         case "CIDFontType0":
1068           this.mimetype = "font/opentype";
1069 
1070           const cff =
1071             subtype === "Type1C" || subtype === "CIDFontType0C"
1072               ? new CFFFont(file, properties)
1073               : new Type1Font(name, file, properties);
1074 
1075           adjustWidths(properties);
1076 
1077           // Wrap the CFF data inside an OTF font file
1078           data = this.convert(name, cff, properties);
1079           break;
1080 
1081         case "OpenType":
1082         case "TrueType":
1083         case "CIDFontType2":
1084           this.mimetype = "font/opentype";
1085 
1086           // Repair the TrueType file. It is can be damaged in the point of
1087           // view of the sanitizer
1088           data = this.checkAndRepair(name, file, properties);
1089           if (this.isOpenType) {
1090             adjustWidths(properties);
1091 
1092             type = "OpenType";
1093           }
1094           break;
1095 
1096         default:
1097           throw new FormatError(`Font ${type} is not supported`);
1098       }
1099     } catch (e) {
1100       warn(e);
1101       this.fallbackToSystemFont(properties);
1102       return;
1103     }
1104 
1105     amendFallbackToUnicode(properties);
1106     this.data = data;
1107 
1108     // Transfer some properties again that could change during font conversion
1109     this.type = type;
1110     this.subtype = subtype;
1111     this.fontMatrix = properties.fontMatrix;
1112     this.widths = properties.widths;
1113     this.defaultWidth = properties.defaultWidth;
1114     this.toUnicode = properties.toUnicode;
1115     this.seacMap = properties.seacMap;
1116   }
1117 
1118   get renderer() {
1119     const renderer = FontRendererFactory.create(this, SEAC_ANALYSIS_ENABLED);
1120     return shadow(this, "renderer", renderer);
1121   }
1122 
1123   exportData(extraProperties = false) {
1124     const exportDataProperties = extraProperties
1125       ? [...EXPORT_DATA_PROPERTIES, ...EXPORT_DATA_EXTRA_PROPERTIES]
1126       : EXPORT_DATA_PROPERTIES;
1127 
1128     const data = Object.create(null);
1129     let property, value;
1130     for (property of exportDataProperties) {
1131       value = this[property];
1132       // Ignore properties that haven't been explicitly set.
1133       if (value !== undefined) {
1134         data[property] = value;
1135       }
1136     }
1137     return data;
1138   }
1139 
1140   fallbackToSystemFont(properties) {
1141     this.missingFile = true;
1142     // The file data is not specified. Trying to fix the font name
1143     // to be used with the canvas.font.
1144     const { name, type } = this;
1145     let fontName = normalizeFontName(name);
1146     const stdFontMap = getStdFontMap(),
1147       nonStdFontMap = getNonStdFontMap();
1148     const isStandardFont = !!stdFontMap[fontName];
1149     const isMappedToStandardFont = !!(
1150       nonStdFontMap[fontName] && stdFontMap[nonStdFontMap[fontName]]
1151     );
1152 
1153     fontName = stdFontMap[fontName] || nonStdFontMap[fontName] || fontName;
1154 
1155     const fontBasicMetricsMap = getFontBasicMetrics();
1156     const metrics = fontBasicMetricsMap[fontName];
1157     if (metrics) {
1158       if (isNaN(this.ascent)) {
1159         this.ascent = metrics.ascent / PDF_GLYPH_SPACE_UNITS;
1160       }
1161       if (isNaN(this.descent)) {
1162         this.descent = metrics.descent / PDF_GLYPH_SPACE_UNITS;
1163       }
1164       if (isNaN(this.capHeight)) {
1165         this.capHeight = metrics.capHeight / PDF_GLYPH_SPACE_UNITS;
1166       }
1167     }
1168 
1169     this.bold = /bold/gi.test(fontName);
1170     this.italic = /oblique|italic/gi.test(fontName);
1171 
1172     // Use 'name' instead of 'fontName' here because the original
1173     // name ArialBlack for example will be replaced by Helvetica.
1174     this.black = /Black/g.test(name);
1175 
1176     // Use 'name' instead of 'fontName' here because the original
1177     // name ArialNarrow for example will be replaced by Helvetica.
1178     const isNarrow = /Narrow/g.test(name);
1179 
1180     // if at least one width is present, remeasure all chars when exists
1181     this.remeasure =
1182       (!isStandardFont || isNarrow) && Object.keys(this.widths).length > 0;
1183     if (
1184       (isStandardFont || isMappedToStandardFont) &&
1185       type === "CIDFontType2" &&
1186       this.cidEncoding.startsWith("Identity-")
1187     ) {
1188       const cidToGidMap = properties.cidToGidMap;
1189       // Standard fonts might be embedded as CID font without glyph mapping.
1190       // Building one based on GlyphMapForStandardFonts.
1191       const map = [];
1192       applyStandardFontGlyphMap(map, getGlyphMapForStandardFonts());
1193 
1194       if (/Arial-?Black/i.test(name)) {
1195         applyStandardFontGlyphMap(map, getSupplementalGlyphMapForArialBlack());
1196       } else if (/Calibri/i.test(name)) {
1197         applyStandardFontGlyphMap(map, getSupplementalGlyphMapForCalibri());
1198       }
1199 
1200       // Always update the glyph mapping with the `cidToGidMap` when it exists
1201       // (fixes issue12418_reduced.pdf).
1202       if (cidToGidMap) {
1203         for (const charCode in map) {
1204           const cid = map[charCode];
1205           if (cidToGidMap[cid] !== undefined) {
1206             map[+charCode] = cidToGidMap[cid];
1207           }
1208         }
1209         // When the /CIDToGIDMap is "incomplete", fallback to the included
1210         // /ToUnicode-map regardless of its encoding (fixes issue11915.pdf).
1211         if (
1212           cidToGidMap.length !== this.toUnicode.length &&
1213           properties.hasIncludedToUnicodeMap &&
1214           this.toUnicode instanceof IdentityToUnicodeMap
1215         ) {
1216           this.toUnicode.forEach(function (charCode, unicodeCharCode) {
1217             const cid = map[charCode];
1218             if (cidToGidMap[cid] === undefined) {
1219               map[+charCode] = unicodeCharCode;
1220             }
1221           });
1222         }
1223       }
1224 
1225       if (!(this.toUnicode instanceof IdentityToUnicodeMap)) {
1226         this.toUnicode.forEach(function (charCode, unicodeCharCode) {
1227           map[+charCode] = unicodeCharCode;
1228         });
1229       }
1230       this.toFontChar = map;
1231       this.toUnicode = new ToUnicodeMap(map);
1232     } else if (/Symbol/i.test(fontName)) {
1233       this.toFontChar = buildToFontChar(
1234         SymbolSetEncoding,
1235         getGlyphsUnicode(),
1236         this.differences
1237       );
1238     } else if (/Dingbats/i.test(fontName)) {
1239       this.toFontChar = buildToFontChar(
1240         ZapfDingbatsEncoding,
1241         getDingbatsGlyphsUnicode(),
1242         this.differences
1243       );
1244     } else if (isStandardFont) {
1245       const map = buildToFontChar(
1246         this.defaultEncoding,
1247         getGlyphsUnicode(),
1248         this.differences
1249       );
1250 
1251       if (
1252         type === "CIDFontType2" &&
1253         !this.cidEncoding.startsWith("Identity-") &&
1254         !(this.toUnicode instanceof IdentityToUnicodeMap)
1255       ) {
1256         this.toUnicode.forEach(function (charCode, unicodeCharCode) {
1257           map[+charCode] = unicodeCharCode;
1258         });
1259       }
1260       this.toFontChar = map;
1261     } else {
1262       const glyphsUnicodeMap = getGlyphsUnicode();
1263       const map = [];
1264       this.toUnicode.forEach((charCode, unicodeCharCode) => {
1265         if (!this.composite) {
1266           const glyphName =
1267             this.differences[charCode] || this.defaultEncoding[charCode];
1268           const unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
1269           if (unicode !== -1) {
1270             unicodeCharCode = unicode;
1271           }
1272         }
1273         map[+charCode] = unicodeCharCode;
1274       });
1275 
1276       // Attempt to improve the glyph mapping for (some) composite fonts that
1277       // appear to lack meaningful ToUnicode data.
1278       if (this.composite && this.toUnicode instanceof IdentityToUnicodeMap) {
1279         if (/Tahoma|Verdana/i.test(name)) {
1280           // Fixes issue15719.pdf and issue11242_reduced.pdf.
1281           applyStandardFontGlyphMap(map, getGlyphMapForStandardFonts());
1282         }
1283       }
1284       this.toFontChar = map;
1285     }
1286 
1287     amendFallbackToUnicode(properties);
1288     this.loadedName = fontName.split("-", 1)[0];
1289   }
1290 
1291   checkAndRepair(name, font, properties) {
1292     const VALID_TABLES = [
1293       "OS/2",
1294       "cmap",
1295       "head",
1296       "hhea",
1297       "hmtx",
1298       "maxp",
1299       "name",
1300       "post",
1301       "loca",
1302       "glyf",
1303       "fpgm",
1304       "prep",
1305       "cvt ",
1306       "CFF ",
1307     ];
1308 
1309     function readTables(file, numTables) {
1310       const tables = Object.create(null);
1311       tables["OS/2"] = null;
1312       tables.cmap = null;
1313       tables.head = null;
1314       tables.hhea = null;
1315       tables.hmtx = null;
1316       tables.maxp = null;
1317       tables.name = null;
1318       tables.post = null;
1319 
1320       for (let i = 0; i < numTables; i++) {
1321         const table = readTableEntry(file);
1322         if (!VALID_TABLES.includes(table.tag)) {
1323           continue; // skipping table if it's not a required or optional table
1324         }
1325         if (table.length === 0) {
1326           continue; // skipping empty tables
1327         }
1328         tables[table.tag] = table;
1329       }
1330       return tables;
1331     }
1332 
1333     function readTableEntry(file) {
1334       const tag = file.getString(4);
1335 
1336       const checksum = file.getInt32() >>> 0;
1337       const offset = file.getInt32() >>> 0;
1338       const length = file.getInt32() >>> 0;
1339 
1340       // Read the table associated data
1341       const previousPosition = file.pos;
1342       file.pos = file.start || 0;
1343       file.skip(offset);
1344       const data = file.getBytes(length);
1345       file.pos = previousPosition;
1346 
1347       if (tag === "head") {
1348         // clearing checksum adjustment
1349         data[8] = data[9] = data[10] = data[11] = 0;
1350         data[17] |= 0x20; // Set font optimized for cleartype flag.
1351       }
1352 
1353       return {
1354         tag,
1355         checksum,
1356         length,
1357         offset,
1358         data,
1359       };
1360     }
1361 
1362     function readOpenTypeHeader(ttf) {
1363       return {
1364         version: ttf.getString(4),
1365         numTables: ttf.getUint16(),
1366         searchRange: ttf.getUint16(),
1367         entrySelector: ttf.getUint16(),
1368         rangeShift: ttf.getUint16(),
1369       };
1370     }
1371 
1372     function readTrueTypeCollectionHeader(ttc) {
1373       const ttcTag = ttc.getString(4);
1374       assert(ttcTag === "ttcf", "Must be a TrueType Collection font.");
1375 
1376       const majorVersion = ttc.getUint16();
1377       const minorVersion = ttc.getUint16();
1378       const numFonts = ttc.getInt32() >>> 0;
1379       const offsetTable = [];
1380       for (let i = 0; i < numFonts; i++) {
1381         offsetTable.push(ttc.getInt32() >>> 0);
1382       }
1383 
1384       const header = {
1385         ttcTag,
1386         majorVersion,
1387         minorVersion,
1388         numFonts,
1389         offsetTable,
1390       };
1391       switch (majorVersion) {
1392         case 1:
1393           return header;
1394         case 2:
1395           header.dsigTag = ttc.getInt32() >>> 0;
1396           header.dsigLength = ttc.getInt32() >>> 0;
1397           header.dsigOffset = ttc.getInt32() >>> 0;
1398           return header;
1399       }
1400       throw new FormatError(
1401         `Invalid TrueType Collection majorVersion: ${majorVersion}.`
1402       );
1403     }
1404 
1405     function readTrueTypeCollectionData(ttc, fontName) {
1406       const { numFonts, offsetTable } = readTrueTypeCollectionHeader(ttc);
1407       const fontNameParts = fontName.split("+");
1408       let fallbackData;
1409 
1410       for (let i = 0; i < numFonts; i++) {
1411         ttc.pos = (ttc.start || 0) + offsetTable[i];
1412         const potentialHeader = readOpenTypeHeader(ttc);
1413         const potentialTables = readTables(ttc, potentialHeader.numTables);
1414 
1415         if (!potentialTables.name) {
1416           throw new FormatError(
1417             'TrueType Collection font must contain a "name" table.'
1418           );
1419         }
1420         const [nameTable] = readNameTable(potentialTables.name);
1421 
1422         for (let j = 0, jj = nameTable.length; j < jj; j++) {
1423           for (let k = 0, kk = nameTable[j].length; k < kk; k++) {
1424             const nameEntry = nameTable[j][k]?.replaceAll(/\s/g, "");
1425             if (!nameEntry) {
1426               continue;
1427             }
1428             if (nameEntry === fontName) {
1429               return {
1430                 header: potentialHeader,
1431                 tables: potentialTables,
1432               };
1433             }
1434             if (fontNameParts.length < 2) {
1435               continue;
1436             }
1437             for (const part of fontNameParts) {
1438               if (nameEntry === part) {
1439                 fallbackData = {
1440                   name: part,
1441                   header: potentialHeader,
1442                   tables: potentialTables,
1443                 };
1444               }
1445             }
1446           }
1447         }
1448       }
1449       if (fallbackData) {
1450         warn(
1451           `TrueType Collection does not contain "${fontName}" font, ` +
1452             `falling back to "${fallbackData.name}" font instead.`
1453         );
1454         return {
1455           header: fallbackData.header,
1456           tables: fallbackData.tables,
1457         };
1458       }
1459       throw new FormatError(
1460         `TrueType Collection does not contain "${fontName}" font.`
1461       );
1462     }
1463 
1464     /**
1465      * Read the appropriate subtable from the cmap according to 9.6.6.4 from
1466      * PDF spec
1467      */
1468     function readCmapTable(cmap, file, isSymbolicFont, hasEncoding) {
1469       if (!cmap) {
1470         warn("No cmap table available.");
1471         return {
1472           platformId: -1,
1473           encodingId: -1,
1474           mappings: [],
1475           hasShortCmap: false,
1476         };
1477       }
1478       let segment;
1479       let start = (file.start || 0) + cmap.offset;
1480       file.pos = start;
1481 
1482       file.skip(2); // version
1483       const numTables = file.getUint16();
1484 
1485       let potentialTable;
1486       let canBreak = false;
1487       // There's an order of preference in terms of which cmap subtable to
1488       // use:
1489       // - non-symbolic fonts the preference is a 3,1 table then a 1,0 table
1490       // - symbolic fonts the preference is a 3,0 table then a 1,0 table
1491       // The following takes advantage of the fact that the tables are sorted
1492       // to work.
1493       for (let i = 0; i < numTables; i++) {
1494         const platformId = file.getUint16();
1495         const encodingId = file.getUint16();
1496         const offset = file.getInt32() >>> 0;
1497         let useTable = false;
1498 
1499         // Sometimes there are multiple of the same type of table. Default
1500         // to choosing the first table and skip the rest.
1501         if (
1502           potentialTable?.platformId === platformId &&
1503           potentialTable?.encodingId === encodingId
1504         ) {
1505           continue;
1506         }
1507 
1508         if (
1509           platformId === 0 &&
1510           (encodingId === /* Unicode Default */ 0 ||
1511             encodingId === /* Unicode 1.1 */ 1 ||
1512             encodingId === /* Unicode BMP */ 3)
1513         ) {
1514           useTable = true;
1515           // Continue the loop since there still may be a higher priority
1516           // table.
1517         } else if (platformId === 1 && encodingId === 0) {
1518           useTable = true;
1519           // Continue the loop since there still may be a higher priority
1520           // table.
1521         } else if (
1522           platformId === 3 &&
1523           encodingId === 1 &&
1524           (hasEncoding || !potentialTable)
1525         ) {
1526           useTable = true;
1527           if (!isSymbolicFont) {
1528             canBreak = true;
1529           }
1530         } else if (isSymbolicFont && platformId === 3 && encodingId === 0) {
1531           useTable = true;
1532 
1533           let correctlySorted = true;
1534           if (i < numTables - 1) {
1535             const nextBytes = file.peekBytes(2),
1536               nextPlatformId = int16(nextBytes[0], nextBytes[1]);
1537             if (nextPlatformId < platformId) {
1538               correctlySorted = false;
1539             }
1540           }
1541           if (correctlySorted) {
1542             canBreak = true;
1543           }
1544         }
1545 
1546         if (useTable) {
1547           potentialTable = {
1548             platformId,
1549             encodingId,
1550             offset,
1551           };
1552         }
1553         if (canBreak) {
1554           break;
1555         }
1556       }
1557 
1558       if (potentialTable) {
1559         file.pos = start + potentialTable.offset;
1560       }
1561       if (!potentialTable || file.peekByte() === -1) {
1562         warn("Could not find a preferred cmap table.");
1563         return {
1564           platformId: -1,
1565           encodingId: -1,
1566           mappings: [],
1567           hasShortCmap: false,
1568         };
1569       }
1570 
1571       const format = file.getUint16();
1572       let hasShortCmap = false;
1573       const mappings = [];
1574       let j, glyphId;
1575 
1576       // TODO(mack): refactor this cmap subtable reading logic out
1577       if (format === 0) {
1578         file.skip(2 + 2); // length + language
1579 
1580         for (j = 0; j < 256; j++) {
1581           const index = file.getByte();
1582           if (!index) {
1583             continue;
1584           }
1585           mappings.push({
1586             charCode: j,
1587             glyphId: index,
1588           });
1589         }
1590         hasShortCmap = true;
1591       } else if (format === 2) {
1592         file.skip(2 + 2); // length + language
1593 
1594         const subHeaderKeys = [];
1595         let maxSubHeaderKey = 0;
1596         // Read subHeaderKeys. If subHeaderKeys[i] === 0, then i is a
1597         // single-byte character. Otherwise, i is the first byte of a
1598         // multi-byte character, and the value is 8*index into
1599         // subHeaders.
1600         for (let i = 0; i < 256; i++) {
1601           const subHeaderKey = file.getUint16() >> 3;
1602           subHeaderKeys.push(subHeaderKey);
1603           maxSubHeaderKey = Math.max(subHeaderKey, maxSubHeaderKey);
1604         }
1605         // Read subHeaders. The number of entries is determined
1606         // dynamically based on the subHeaderKeys found above.
1607         const subHeaders = [];
1608         for (let i = 0; i <= maxSubHeaderKey; i++) {
1609           subHeaders.push({
1610             firstCode: file.getUint16(),
1611             entryCount: file.getUint16(),
1612             idDelta: signedInt16(file.getByte(), file.getByte()),
1613             idRangePos: file.pos + file.getUint16(),
1614           });
1615         }
1616         for (let i = 0; i < 256; i++) {
1617           if (subHeaderKeys[i] === 0) {
1618             // i is a single-byte code.
1619             file.pos = subHeaders[0].idRangePos + 2 * i;
1620             glyphId = file.getUint16();
1621             mappings.push({
1622               charCode: i,
1623               glyphId,
1624             });
1625           } else {
1626             // i is the first byte of a two-byte code.
1627             const s = subHeaders[subHeaderKeys[i]];
1628             for (j = 0; j < s.entryCount; j++) {
1629               const charCode = (i << 8) + j + s.firstCode;
1630               file.pos = s.idRangePos + 2 * j;
1631               glyphId = file.getUint16();
1632               if (glyphId !== 0) {
1633                 glyphId = (glyphId + s.idDelta) % 65536;
1634               }
1635               mappings.push({
1636                 charCode,
1637                 glyphId,
1638               });
1639             }
1640           }
1641         }
1642       } else if (format === 4) {
1643         file.skip(2 + 2); // length + language
1644 
1645         // re-creating the table in format 4 since the encoding
1646         // might be changed
1647         const segCount = file.getUint16() >> 1;
1648         file.skip(6); // skipping range fields
1649         const segments = [];
1650         let segIndex;
1651         for (segIndex = 0; segIndex < segCount; segIndex++) {
1652           segments.push({ end: file.getUint16() });
1653         }
1654         file.skip(2);
1655         for (segIndex = 0; segIndex < segCount; segIndex++) {
1656           segments[segIndex].start = file.getUint16();
1657         }
1658 
1659         for (segIndex = 0; segIndex < segCount; segIndex++) {
1660           segments[segIndex].delta = file.getUint16();
1661         }
1662 
1663         let offsetsCount = 0,
1664           offsetIndex;
1665         for (segIndex = 0; segIndex < segCount; segIndex++) {
1666           segment = segments[segIndex];
1667           const rangeOffset = file.getUint16();
1668           if (!rangeOffset) {
1669             segment.offsetIndex = -1;
1670             continue;
1671           }
1672 
1673           offsetIndex = (rangeOffset >> 1) - (segCount - segIndex);
1674           segment.offsetIndex = offsetIndex;
1675           offsetsCount = Math.max(
1676             offsetsCount,
1677             offsetIndex + segment.end - segment.start + 1
1678           );
1679         }
1680 
1681         const offsets = [];
1682         for (j = 0; j < offsetsCount; j++) {
1683           offsets.push(file.getUint16());
1684         }
1685 
1686         for (segIndex = 0; segIndex < segCount; segIndex++) {
1687           segment = segments[segIndex];
1688           start = segment.start;
1689           const end = segment.end;
1690           const delta = segment.delta;
1691           offsetIndex = segment.offsetIndex;
1692 
1693           for (j = start; j <= end; j++) {
1694             if (j === 0xffff) {
1695               continue;
1696             }
1697 
1698             glyphId = offsetIndex < 0 ? j : offsets[offsetIndex + j - start];
1699             glyphId = (glyphId + delta) & 0xffff;
1700             mappings.push({
1701               charCode: j,
1702               glyphId,
1703             });
1704           }
1705         }
1706       } else if (format === 6) {
1707         file.skip(2 + 2); // length + language
1708 
1709         // Format 6 is a 2-bytes dense mapping, which means the font data
1710         // lives glue together even if they are pretty far in the unicode
1711         // table. (This looks weird, so I can have missed something), this
1712         // works on Linux but seems to fails on Mac so let's rewrite the
1713         // cmap table to a 3-1-4 style
1714         const firstCode = file.getUint16();
1715         const entryCount = file.getUint16();
1716 
1717         for (j = 0; j < entryCount; j++) {
1718           glyphId = file.getUint16();
1719           const charCode = firstCode + j;
1720 
1721           mappings.push({
1722             charCode,
1723             glyphId,
1724           });
1725         }
1726       } else if (format === 12) {
1727         file.skip(2 + 4 + 4); // reserved + length + language
1728 
1729         const nGroups = file.getInt32() >>> 0;
1730         for (j = 0; j < nGroups; j++) {
1731           const startCharCode = file.getInt32() >>> 0;
1732           const endCharCode = file.getInt32() >>> 0;
1733           let glyphCode = file.getInt32() >>> 0;
1734 
1735           for (
1736             let charCode = startCharCode;
1737             charCode <= endCharCode;
1738             charCode++
1739           ) {
1740             mappings.push({
1741               charCode,
1742               glyphId: glyphCode++,
1743             });
1744           }
1745         }
1746       } else {
1747         warn("cmap table has unsupported format: " + format);
1748         return {
1749           platformId: -1,
1750           encodingId: -1,
1751           mappings: [],
1752           hasShortCmap: false,
1753         };
1754       }
1755 
1756       // removing duplicate entries
1757       mappings.sort(function (a, b) {
1758         return a.charCode - b.charCode;
1759       });
1760       for (let i = 1; i < mappings.length; i++) {
1761         if (mappings[i - 1].charCode === mappings[i].charCode) {
1762           mappings.splice(i, 1);
1763           i--;
1764         }
1765       }
1766 
1767       return {
1768         platformId: potentialTable.platformId,
1769         encodingId: potentialTable.encodingId,
1770         mappings,
1771         hasShortCmap,
1772       };
1773     }
1774 
1775     function sanitizeMetrics(
1776       file,
1777       header,
1778       metrics,
1779       headTable,
1780       numGlyphs,
1781       dupFirstEntry
1782     ) {
1783       if (!header) {
1784         if (metrics) {
1785           metrics.data = null;
1786         }
1787         return;
1788       }
1789 
1790       file.pos = (file.start || 0) + header.offset;
1791       file.pos += 4; // version
1792       file.pos += 2; // ascent
1793       file.pos += 2; // descent
1794       file.pos += 2; // linegap
1795       file.pos += 2; // adv_width_max
1796       file.pos += 2; // min_sb1
1797       file.pos += 2; // min_sb2
1798       file.pos += 2; // max_extent
1799       file.pos += 2; // caret_slope_rise
1800       file.pos += 2; // caret_slope_run
1801       const caretOffset = file.getUint16();
1802       file.pos += 8; // reserved
1803       file.pos += 2; // format
1804       let numOfMetrics = file.getUint16();
1805 
1806       if (caretOffset !== 0) {
1807         const macStyle = int16(headTable.data[44], headTable.data[45]);
1808         if (!(macStyle & 2)) {
1809           // Suppress OTS warnings about the `caretOffset` in the hhea-table.
1810           header.data[22] = 0;
1811           header.data[23] = 0;
1812         }
1813       }
1814 
1815       if (numOfMetrics > numGlyphs) {
1816         info(
1817           `The numOfMetrics (${numOfMetrics}) should not be ` +
1818             `greater than the numGlyphs (${numGlyphs}).`
1819         );
1820         // Reduce numOfMetrics if it is greater than numGlyphs
1821         numOfMetrics = numGlyphs;
1822         header.data[34] = (numOfMetrics & 0xff00) >> 8;
1823         header.data[35] = numOfMetrics & 0x00ff;
1824       }
1825 
1826       const numOfSidebearings = numGlyphs - numOfMetrics;
1827       const numMissing =
1828         numOfSidebearings - ((metrics.length - numOfMetrics * 4) >> 1);
1829 
1830       if (numMissing > 0) {
1831         // For each missing glyph, we set both the width and lsb to 0 (zero).
1832         // Since we need to add two properties for each glyph, this explains
1833         // the use of |numMissing * 2| when initializing the typed array.
1834         const entries = new Uint8Array(metrics.length + numMissing * 2);
1835         entries.set(metrics.data);
1836         if (dupFirstEntry) {
1837           // Set the sidebearing value of the duplicated glyph.
1838           entries[metrics.length] = metrics.data[2];
1839           entries[metrics.length + 1] = metrics.data[3];
1840         }
1841         metrics.data = entries;
1842       }
1843     }
1844 
1845     function sanitizeGlyph(
1846       source,
1847       sourceStart,
1848       sourceEnd,
1849       dest,
1850       destStart,
1851       hintsValid
1852     ) {
1853       const glyphProfile = {
1854         length: 0,
1855         sizeOfInstructions: 0,
1856       };
1857       if (
1858         sourceStart < 0 ||
1859         sourceStart >= source.length ||
1860         sourceEnd > source.length ||
1861         sourceEnd - sourceStart <= 12
1862       ) {
1863         // If the offsets are wrong or the glyph is too small, remove it.
1864         return glyphProfile;
1865       }
1866       const glyf = source.subarray(sourceStart, sourceEnd);
1867 
1868       // Sanitize the glyph bounding box.
1869       const xMin = signedInt16(glyf[2], glyf[3]);
1870       const yMin = signedInt16(glyf[4], glyf[5]);
1871       const xMax = signedInt16(glyf[6], glyf[7]);
1872       const yMax = signedInt16(glyf[8], glyf[9]);
1873 
1874       if (xMin > xMax) {
1875         writeSignedInt16(glyf, 2, xMax);
1876         writeSignedInt16(glyf, 6, xMin);
1877       }
1878       if (yMin > yMax) {
1879         writeSignedInt16(glyf, 4, yMax);
1880         writeSignedInt16(glyf, 8, yMin);
1881       }
1882 
1883       const contoursCount = signedInt16(glyf[0], glyf[1]);
1884       if (contoursCount < 0) {
1885         if (contoursCount < -1) {
1886           // OTS doesn't like contour count to be less than -1.
1887           // The glyph data offsets are very likely wrong and
1888           // having something lower than -1, very likely, implies
1889           // to have some garbage data.
1890           return glyphProfile;
1891         }
1892         // complex glyph, writing as is
1893         dest.set(glyf, destStart);
1894         glyphProfile.length = glyf.length;
1895         return glyphProfile;
1896       }
1897 
1898       let i,
1899         j = 10,
1900         flagsCount = 0;
1901       for (i = 0; i < contoursCount; i++) {
1902         const endPoint = (glyf[j] << 8) | glyf[j + 1];
1903         flagsCount = endPoint + 1;
1904         j += 2;
1905       }
1906       // skipping instructions
1907       const instructionsStart = j;
1908       const instructionsLength = (glyf[j] << 8) | glyf[j + 1];
1909       glyphProfile.sizeOfInstructions = instructionsLength;
1910       j += 2 + instructionsLength;
1911       const instructionsEnd = j;
1912       // validating flags
1913       let coordinatesLength = 0;
1914       for (i = 0; i < flagsCount; i++) {
1915         const flag = glyf[j++];
1916         if (flag & 0xc0) {
1917           // reserved flags must be zero, cleaning up
1918           glyf[j - 1] = flag & 0x3f;
1919         }
1920         let xLength = 2;
1921         if (flag & 2) {
1922           xLength = 1;
1923         } else if (flag & 16) {
1924           xLength = 0;
1925         }
1926         let yLength = 2;
1927         if (flag & 4) {
1928           yLength = 1;
1929         } else if (flag & 32) {
1930           yLength = 0;
1931         }
1932         const xyLength = xLength + yLength;
1933         coordinatesLength += xyLength;
1934         if (flag & 8) {
1935           const repeat = glyf[j++];
1936           if (repeat === 0) {
1937             // The repeat count should be non-zero when the repeat flag is set.
1938             glyf[j - 1] ^= 8;
1939           }
1940           i += repeat;
1941           coordinatesLength += repeat * xyLength;
1942         }
1943       }
1944       // glyph without coordinates will be rejected
1945       if (coordinatesLength === 0) {
1946         return glyphProfile;
1947       }
1948       let glyphDataLength = j + coordinatesLength;
1949       if (glyphDataLength > glyf.length) {
1950         // not enough data for coordinates
1951         return glyphProfile;
1952       }
1953       if (!hintsValid && instructionsLength > 0) {
1954         dest.set(glyf.subarray(0, instructionsStart), destStart);
1955         dest.set([0, 0], destStart + instructionsStart);
1956         dest.set(
1957           glyf.subarray(instructionsEnd, glyphDataLength),
1958           destStart + instructionsStart + 2
1959         );
1960         glyphDataLength -= instructionsLength;
1961         if (glyf.length - glyphDataLength > 3) {
1962           glyphDataLength = (glyphDataLength + 3) & ~3;
1963         }
1964         glyphProfile.length = glyphDataLength;
1965         return glyphProfile;
1966       }
1967       if (glyf.length - glyphDataLength > 3) {
1968         // truncating and aligning to 4 bytes the long glyph data
1969         glyphDataLength = (glyphDataLength + 3) & ~3;
1970         dest.set(glyf.subarray(0, glyphDataLength), destStart);
1971         glyphProfile.length = glyphDataLength;
1972         return glyphProfile;
1973       }
1974       // glyph data is fine
1975       dest.set(glyf, destStart);
1976       glyphProfile.length = glyf.length;
1977       return glyphProfile;
1978     }
1979 
1980     function sanitizeHead(head, numGlyphs, locaLength) {
1981       const data = head.data;
1982 
1983       // Validate version:
1984       // Should always be 0x00010000
1985       const version = int32(data[0], data[1], data[2], data[3]);
1986       if (version >> 16 !== 1) {
1987         info("Attempting to fix invalid version in head table: " + version);
1988         data[0] = 0;
1989         data[1] = 1;
1990         data[2] = 0;
1991         data[3] = 0;
1992       }
1993 
1994       const indexToLocFormat = int16(data[50], data[51]);
1995       if (indexToLocFormat < 0 || indexToLocFormat > 1) {
1996         info(
1997           "Attempting to fix invalid indexToLocFormat in head table: " +
1998             indexToLocFormat
1999         );
2000 
2001         // The value of indexToLocFormat should be 0 if the loca table
2002         // consists of short offsets, and should be 1 if the loca table
2003         // consists of long offsets.
2004         //
2005         // The number of entries in the loca table should be numGlyphs + 1.
2006         //
2007         // Using this information, we can work backwards to deduce if the
2008         // size of each offset in the loca table, and thus figure out the
2009         // appropriate value for indexToLocFormat.
2010 
2011         const numGlyphsPlusOne = numGlyphs + 1;
2012         if (locaLength === numGlyphsPlusOne << 1) {
2013           // 0x0000 indicates the loca table consists of short offsets
2014           data[50] = 0;
2015           data[51] = 0;
2016         } else if (locaLength === numGlyphsPlusOne << 2) {
2017           // 0x0001 indicates the loca table consists of long offsets
2018           data[50] = 0;
2019           data[51] = 1;
2020         } else {
2021           throw new FormatError(
2022             "Could not fix indexToLocFormat: " + indexToLocFormat
2023           );
2024         }
2025       }
2026     }
2027 
2028     function sanitizeGlyphLocations(
2029       loca,
2030       glyf,
2031       numGlyphs,
2032       isGlyphLocationsLong,
2033       hintsValid,
2034       dupFirstEntry,
2035       maxSizeOfInstructions
2036     ) {
2037       let itemSize, itemDecode, itemEncode;
2038       if (isGlyphLocationsLong) {
2039         itemSize = 4;
2040         itemDecode = function fontItemDecodeLong(data, offset) {
2041           return (
2042             (data[offset] << 24) |
2043             (data[offset + 1] << 16) |
2044             (data[offset + 2] << 8) |
2045             data[offset + 3]
2046           );
2047         };
2048         itemEncode = function fontItemEncodeLong(data, offset, value) {
2049           data[offset] = (value >>> 24) & 0xff;
2050           data[offset + 1] = (value >> 16) & 0xff;
2051           data[offset + 2] = (value >> 8) & 0xff;
2052           data[offset + 3] = value & 0xff;
2053         };
2054       } else {
2055         itemSize = 2;
2056         itemDecode = function fontItemDecode(data, offset) {
2057           return (data[offset] << 9) | (data[offset + 1] << 1);
2058         };
2059         itemEncode = function fontItemEncode(data, offset, value) {
2060           data[offset] = (value >> 9) & 0xff;
2061           data[offset + 1] = (value >> 1) & 0xff;
2062         };
2063       }
2064       // The first glyph is duplicated.
2065       const numGlyphsOut = dupFirstEntry ? numGlyphs + 1 : numGlyphs;
2066       const locaDataSize = itemSize * (1 + numGlyphsOut);
2067       // Resize loca table to account for duplicated glyph.
2068       const locaData = new Uint8Array(locaDataSize);
2069       locaData.set(loca.data.subarray(0, locaDataSize));
2070       loca.data = locaData;
2071       // removing the invalid glyphs
2072       const oldGlyfData = glyf.data;
2073       const oldGlyfDataLength = oldGlyfData.length;
2074       const newGlyfData = new Uint8Array(oldGlyfDataLength);
2075 
2076       // The spec says the offsets should be in ascending order, however
2077       // this is not true for some fonts or they use the offset of 0 to mark a
2078       // glyph as missing. OTS requires the offsets to be in order and not to
2079       // be zero, so we must sort and rebuild the loca table and potentially
2080       // re-arrange the glyf data.
2081       let i, j;
2082       const locaEntries = [];
2083       // There are numGlyphs + 1 loca table entries.
2084       for (i = 0, j = 0; i < numGlyphs + 1; i++, j += itemSize) {
2085         let offset = itemDecode(locaData, j);
2086         if (offset > oldGlyfDataLength) {
2087           offset = oldGlyfDataLength;
2088         }
2089         locaEntries.push({
2090           index: i,
2091           offset,
2092           endOffset: 0,
2093         });
2094       }
2095       locaEntries.sort((a, b) => a.offset - b.offset);
2096       // Now the offsets are sorted, calculate the end offset of each glyph.
2097       // The last loca entry's endOffset is not calculated since it's the end
2098       // of the data and will be stored on the previous entry's endOffset.
2099       for (i = 0; i < numGlyphs; i++) {
2100         locaEntries[i].endOffset = locaEntries[i + 1].offset;
2101       }
2102       // Re-sort so glyphs aren't out of order.
2103       locaEntries.sort((a, b) => a.index - b.index);
2104       // Calculate the endOffset of the "first" glyph correctly when there are
2105       // *multiple* empty ones at the start of the data (fixes issue14618.pdf).
2106       for (i = 0; i < numGlyphs; i++) {
2107         const { offset, endOffset } = locaEntries[i];
2108         if (offset !== 0 || endOffset !== 0) {
2109           break;
2110         }
2111         const nextOffset = locaEntries[i + 1].offset;
2112         if (nextOffset === 0) {
2113           continue;
2114         }
2115         locaEntries[i].endOffset = nextOffset;
2116         break;
2117       }
2118 
2119       // If the last offset is 0 in the loca table then we can't compute the
2120       // endOffset for the last glyph. So in such a case we set the endOffset
2121       // to the end of the data (fixes issue #17671).
2122       const last = locaEntries.at(-2);
2123       if (last.offset !== 0 && last.endOffset === 0) {
2124         last.endOffset = oldGlyfDataLength;
2125       }
2126 
2127       const missingGlyphs = Object.create(null);
2128       let writeOffset = 0;
2129       itemEncode(locaData, 0, writeOffset);
2130       for (i = 0, j = itemSize; i < numGlyphs; i++, j += itemSize) {
2131         const glyphProfile = sanitizeGlyph(
2132           oldGlyfData,
2133           locaEntries[i].offset,
2134           locaEntries[i].endOffset,
2135           newGlyfData,
2136           writeOffset,
2137           hintsValid
2138         );
2139         const newLength = glyphProfile.length;
2140         if (newLength === 0) {
2141           missingGlyphs[i] = true;
2142         }
2143         if (glyphProfile.sizeOfInstructions > maxSizeOfInstructions) {
2144           maxSizeOfInstructions = glyphProfile.sizeOfInstructions;
2145         }
2146         writeOffset += newLength;
2147         itemEncode(locaData, j, writeOffset);
2148       }
2149 
2150       if (writeOffset === 0) {
2151         // glyf table cannot be empty -- redoing the glyf and loca tables
2152         // to have single glyph with one point
2153         const simpleGlyph = new Uint8Array([
2154           0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0,
2155         ]);
2156         for (i = 0, j = itemSize; i < numGlyphsOut; i++, j += itemSize) {
2157           itemEncode(locaData, j, simpleGlyph.length);
2158         }
2159         glyf.data = simpleGlyph;
2160       } else if (dupFirstEntry) {
2161         // Browsers will not display a glyph at position 0. Typically glyph 0
2162         // is notdef, but a number of fonts put a valid glyph there so it must
2163         // be duplicated and appended.
2164         const firstEntryLength = itemDecode(locaData, itemSize);
2165         if (newGlyfData.length > firstEntryLength + writeOffset) {
2166           glyf.data = newGlyfData.subarray(0, firstEntryLength + writeOffset);
2167         } else {
2168           glyf.data = new Uint8Array(firstEntryLength + writeOffset);
2169           glyf.data.set(newGlyfData.subarray(0, writeOffset));
2170         }
2171         glyf.data.set(newGlyfData.subarray(0, firstEntryLength), writeOffset);
2172         itemEncode(
2173           loca.data,
2174           locaData.length - itemSize,
2175           writeOffset + firstEntryLength
2176         );
2177       } else {
2178         glyf.data = newGlyfData.subarray(0, writeOffset);
2179       }
2180       return {
2181         missingGlyphs,
2182         maxSizeOfInstructions,
2183       };
2184     }
2185 
2186     function readPostScriptTable(post, propertiesObj, maxpNumGlyphs) {
2187       const start = (font.start || 0) + post.offset;
2188       font.pos = start;
2189 
2190       const length = post.length,
2191         end = start + length;
2192       const version = font.getInt32();
2193       // skip rest to the tables
2194       font.skip(28);
2195 
2196       let glyphNames;
2197       let valid = true;
2198       let i;
2199 
2200       switch (version) {
2201         case 0x00010000:
2202           glyphNames = MacStandardGlyphOrdering;
2203           break;
2204         case 0x00020000:
2205           const numGlyphs = font.getUint16();
2206           if (numGlyphs !== maxpNumGlyphs) {
2207             valid = false;
2208             break;
2209           }
2210           const glyphNameIndexes = [];
2211           for (i = 0; i < numGlyphs; ++i) {
2212             const index = font.getUint16();
2213             if (index >= 32768) {
2214               valid = false;
2215               break;
2216             }
2217             glyphNameIndexes.push(index);
2218           }
2219           if (!valid) {
2220             break;
2221           }
2222           const customNames = [],
2223             strBuf = [];
2224           while (font.pos < end) {
2225             const stringLength = font.getByte();
2226             strBuf.length = stringLength;
2227             for (i = 0; i < stringLength; ++i) {
2228               strBuf[i] = String.fromCharCode(font.getByte());
2229             }
2230             customNames.push(strBuf.join(""));
2231           }
2232           glyphNames = [];
2233           for (i = 0; i < numGlyphs; ++i) {
2234             const j = glyphNameIndexes[i];
2235             if (j < 258) {
2236               glyphNames.push(MacStandardGlyphOrdering[j]);
2237               continue;
2238             }
2239             glyphNames.push(customNames[j - 258]);
2240           }
2241           break;
2242         case 0x00030000:
2243           break;
2244         default:
2245           warn("Unknown/unsupported post table version " + version);
2246           valid = false;
2247           if (propertiesObj.defaultEncoding) {
2248             glyphNames = propertiesObj.defaultEncoding;
2249           }
2250           break;
2251       }
2252       propertiesObj.glyphNames = glyphNames;
2253       return valid;
2254     }
2255 
2256     function readNameTable(nameTable) {
2257       const start = (font.start || 0) + nameTable.offset;
2258       font.pos = start;
2259 
2260       const names = [[], []],
2261         records = [];
2262       const length = nameTable.length,
2263         end = start + length;
2264       const format = font.getUint16();
2265       const FORMAT_0_HEADER_LENGTH = 6;
2266       if (format !== 0 || length < FORMAT_0_HEADER_LENGTH) {
2267         // unsupported name table format or table "too" small
2268         return [names, records];
2269       }
2270       const numRecords = font.getUint16();
2271       const stringsStart = font.getUint16();
2272       const NAME_RECORD_LENGTH = 12;
2273       let i, ii;
2274 
2275       for (i = 0; i < numRecords && font.pos + NAME_RECORD_LENGTH <= end; i++) {
2276         const r = {
2277           platform: font.getUint16(),
2278           encoding: font.getUint16(),
2279           language: font.getUint16(),
2280           name: font.getUint16(),
2281           length: font.getUint16(),
2282           offset: font.getUint16(),
2283         };
2284         // using only Macintosh and Windows platform/encoding names
2285         if (isMacNameRecord(r) || isWinNameRecord(r)) {
2286           records.push(r);
2287         }
2288       }
2289       for (i = 0, ii = records.length; i < ii; i++) {
2290         const record = records[i];
2291         if (record.length <= 0) {
2292           continue; // Nothing to process, ignoring.
2293         }
2294         const pos = start + stringsStart + record.offset;
2295         if (pos + record.length > end) {
2296           continue; // outside of name table, ignoring
2297         }
2298         font.pos = pos;
2299         const nameIndex = record.name;
2300         if (record.encoding) {
2301           // unicode
2302           let str = "";
2303           for (let j = 0, jj = record.length; j < jj; j += 2) {
2304             str += String.fromCharCode(font.getUint16());
2305           }
2306           names[1][nameIndex] = str;
2307         } else {
2308           names[0][nameIndex] = font.getString(record.length);
2309         }
2310       }
2311       return [names, records];
2312     }
2313 
2314     // prettier-ignore
2315     const TTOpsStackDeltas = [
2316       0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5,
2317       -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1,
2318       1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1,
2319       0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2,
2320       0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1,
2321       -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1,
2322       -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2323       -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1,
2324       -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
2325     // 0xC0-DF == -1 and 0xE0-FF == -2
2326 
2327     function sanitizeTTProgram(table, ttContext) {
2328       let data = table.data;
2329       let i = 0,
2330         j,
2331         n,
2332         b,
2333         funcId,
2334         pc,
2335         lastEndf = 0,
2336         lastDeff = 0;
2337       const stack = [];
2338       const callstack = [];
2339       const functionsCalled = [];
2340       let tooComplexToFollowFunctions = ttContext.tooComplexToFollowFunctions;
2341       let inFDEF = false,
2342         ifLevel = 0,
2343         inELSE = 0;
2344       for (let ii = data.length; i < ii; ) {
2345         const op = data[i++];
2346         // The TrueType instruction set docs can be found at
2347         // https://developer.apple.com/fonts/TTRefMan/RM05/Chap5.html
2348         if (op === 0x40) {
2349           // NPUSHB - pushes n bytes
2350           n = data[i++];
2351           if (inFDEF || inELSE) {
2352             i += n;
2353           } else {
2354             for (j = 0; j < n; j++) {
2355               stack.push(data[i++]);
2356             }
2357           }
2358         } else if (op === 0x41) {
2359           // NPUSHW - pushes n words
2360           n = data[i++];
2361           if (inFDEF || inELSE) {
2362             i += n * 2;
2363           } else {
2364             for (j = 0; j < n; j++) {
2365               b = data[i++];
2366               stack.push((b << 8) | data[i++]);
2367             }
2368           }
2369         } else if ((op & 0xf8) === 0xb0) {
2370           // PUSHB - pushes bytes
2371           n = op - 0xb0 + 1;
2372           if (inFDEF || inELSE) {
2373             i += n;
2374           } else {
2375             for (j = 0; j < n; j++) {
2376               stack.push(data[i++]);
2377             }
2378           }
2379         } else if ((op & 0xf8) === 0xb8) {
2380           // PUSHW - pushes words
2381           n = op - 0xb8 + 1;
2382           if (inFDEF || inELSE) {
2383             i += n * 2;
2384           } else {
2385             for (j = 0; j < n; j++) {
2386               b = data[i++];
2387               stack.push((b << 8) | data[i++]);
2388             }
2389           }
2390         } else if (op === 0x2b && !tooComplexToFollowFunctions) {
2391           // CALL
2392           if (!inFDEF && !inELSE) {
2393             // collecting information about which functions are used
2394             funcId = stack.at(-1);
2395             if (isNaN(funcId)) {
2396               info("TT: CALL empty stack (or invalid entry).");
2397             } else {
2398               ttContext.functionsUsed[funcId] = true;
2399               if (funcId in ttContext.functionsStackDeltas) {
2400                 const newStackLength =
2401                   stack.length + ttContext.functionsStackDeltas[funcId];
2402                 if (newStackLength < 0) {
2403                   warn("TT: CALL invalid functions stack delta.");
2404                   ttContext.hintsValid = false;
2405                   return;
2406                 }
2407                 stack.length = newStackLength;
2408               } else if (
2409                 funcId in ttContext.functionsDefined &&
2410                 !functionsCalled.includes(funcId)
2411               ) {
2412                 callstack.push({ data, i, stackTop: stack.length - 1 });
2413                 functionsCalled.push(funcId);
2414                 pc = ttContext.functionsDefined[funcId];
2415                 if (!pc) {
2416                   warn("TT: CALL non-existent function");
2417                   ttContext.hintsValid = false;
2418                   return;
2419                 }
2420                 data = pc.data;
2421                 i = pc.i;
2422               }
2423             }
2424           }
2425         } else if (op === 0x2c && !tooComplexToFollowFunctions) {
2426           // FDEF
2427           if (inFDEF || inELSE) {
2428             warn("TT: nested FDEFs not allowed");
2429             tooComplexToFollowFunctions = true;
2430           }
2431           inFDEF = true;
2432           // collecting information about which functions are defined
2433           lastDeff = i;
2434           funcId = stack.pop();
2435           ttContext.functionsDefined[funcId] = { data, i };
2436         } else if (op === 0x2d) {
2437           // ENDF - end of function
2438           if (inFDEF) {
2439             inFDEF = false;
2440             lastEndf = i;
2441           } else {
2442             pc = callstack.pop();
2443             if (!pc) {
2444               warn("TT: ENDF bad stack");
2445               ttContext.hintsValid = false;
2446               return;
2447             }
2448             funcId = functionsCalled.pop();
2449             data = pc.data;
2450             i = pc.i;
2451             ttContext.functionsStackDeltas[funcId] = stack.length - pc.stackTop;
2452           }
2453         } else if (op === 0x89) {
2454           // IDEF - instruction definition
2455           if (inFDEF || inELSE) {
2456             warn("TT: nested IDEFs not allowed");
2457             tooComplexToFollowFunctions = true;
2458           }
2459           inFDEF = true;
2460           // recording it as a function to track ENDF
2461           lastDeff = i;
2462         } else if (op === 0x58) {
2463           // IF
2464           ++ifLevel;
2465         } else if (op === 0x1b) {
2466           // ELSE
2467           inELSE = ifLevel;
2468         } else if (op === 0x59) {
2469           // EIF
2470           if (inELSE === ifLevel) {
2471             inELSE = 0;
2472           }
2473           --ifLevel;
2474         } else if (op === 0x1c) {
2475           // JMPR
2476           if (!inFDEF && !inELSE) {
2477             const offset = stack.at(-1);
2478             // only jumping forward to prevent infinite loop
2479             if (offset > 0) {
2480               i += offset - 1;
2481             }
2482           }
2483         }
2484         // Adjusting stack not extactly, but just enough to get function id
2485         if (!inFDEF && !inELSE) {
2486           let stackDelta = 0;
2487           if (op <= 0x8e) {
2488             stackDelta = TTOpsStackDeltas[op];
2489           } else if (op >= 0xc0 && op <= 0xdf) {
2490             stackDelta = -1;
2491           } else if (op >= 0xe0) {
2492             stackDelta = -2;
2493           }
2494           if (op >= 0x71 && op <= 0x75) {
2495             n = stack.pop();
2496             if (!isNaN(n)) {
2497               stackDelta = -n * 2;
2498             }
2499           }
2500           while (stackDelta < 0 && stack.length > 0) {
2501             stack.pop();
2502             stackDelta++;
2503           }
2504           while (stackDelta > 0) {
2505             stack.push(NaN); // pushing any number into stack
2506             stackDelta--;
2507           }
2508         }
2509       }
2510       ttContext.tooComplexToFollowFunctions = tooComplexToFollowFunctions;
2511       const content = [data];
2512       if (i > data.length) {
2513         content.push(new Uint8Array(i - data.length));
2514       }
2515       if (lastDeff > lastEndf) {
2516         warn("TT: complementing a missing function tail");
2517         // new function definition started, but not finished
2518         // complete function by [CLEAR, ENDF]
2519         content.push(new Uint8Array([0x22, 0x2d]));
2520       }
2521       foldTTTable(table, content);
2522     }
2523 
2524     function checkInvalidFunctions(ttContext, maxFunctionDefs) {
2525       if (ttContext.tooComplexToFollowFunctions) {
2526         return;
2527       }
2528       if (ttContext.functionsDefined.length > maxFunctionDefs) {
2529         warn("TT: more functions defined than expected");
2530         ttContext.hintsValid = false;
2531         return;
2532       }
2533       for (let j = 0, jj = ttContext.functionsUsed.length; j < jj; j++) {
2534         if (j > maxFunctionDefs) {
2535           warn("TT: invalid function id: " + j);
2536           ttContext.hintsValid = false;
2537           return;
2538         }
2539         if (ttContext.functionsUsed[j] && !ttContext.functionsDefined[j]) {
2540           warn("TT: undefined function: " + j);
2541           ttContext.hintsValid = false;
2542           return;
2543         }
2544       }
2545     }
2546 
2547     function foldTTTable(table, content) {
2548       if (content.length > 1) {
2549         // concatenating the content items
2550         let newLength = 0;
2551         let j, jj;
2552         for (j = 0, jj = content.length; j < jj; j++) {
2553           newLength += content[j].length;
2554         }
2555         newLength = (newLength + 3) & ~3;
2556         const result = new Uint8Array(newLength);
2557         let pos = 0;
2558         for (j = 0, jj = content.length; j < jj; j++) {
2559           result.set(content[j], pos);
2560           pos += content[j].length;
2561         }
2562         table.data = result;
2563         table.length = newLength;
2564       }
2565     }
2566 
2567     function sanitizeTTPrograms(fpgm, prep, cvt, maxFunctionDefs) {
2568       const ttContext = {
2569         functionsDefined: [],
2570         functionsUsed: [],
2571         functionsStackDeltas: [],
2572         tooComplexToFollowFunctions: false,
2573         hintsValid: true,
2574       };
2575       if (fpgm) {
2576         sanitizeTTProgram(fpgm, ttContext);
2577       }
2578       if (prep) {
2579         sanitizeTTProgram(prep, ttContext);
2580       }
2581       if (fpgm) {
2582         checkInvalidFunctions(ttContext, maxFunctionDefs);
2583       }
2584       if (cvt && cvt.length & 1) {
2585         const cvtData = new Uint8Array(cvt.length + 1);
2586         cvtData.set(cvt.data);
2587         cvt.data = cvtData;
2588       }
2589       return ttContext.hintsValid;
2590     }
2591 
2592     // The following steps modify the original font data, making copy
2593     font = new Stream(new Uint8Array(font.getBytes()));
2594 
2595     let header, tables;
2596     if (isTrueTypeCollectionFile(font)) {
2597       const ttcData = readTrueTypeCollectionData(font, this.name);
2598       header = ttcData.header;
2599       tables = ttcData.tables;
2600     } else {
2601       header = readOpenTypeHeader(font);
2602       tables = readTables(font, header.numTables);
2603     }
2604     let cff, cffFile;
2605 
2606     const isTrueType = !tables["CFF "];
2607     if (!isTrueType) {
2608       const isComposite =
2609         properties.composite &&
2610         (properties.cidToGidMap?.length > 0 ||
2611           !(properties.cMap instanceof IdentityCMap));
2612       // OpenType font (skip composite fonts with non-default glyph mapping).
2613       if (
2614         (header.version === "OTTO" && !isComposite) ||
2615         !tables.head ||
2616         !tables.hhea ||
2617         !tables.maxp ||
2618         !tables.post
2619       ) {
2620         // No major tables: throwing everything at `CFFFont`.
2621         cffFile = new Stream(tables["CFF "].data);
2622         cff = new CFFFont(cffFile, properties);
2623 
2624         adjustWidths(properties);
2625 
2626         return this.convert(name, cff, properties);
2627       }
2628 
2629       delete tables.glyf;
2630       delete tables.loca;
2631       delete tables.fpgm;
2632       delete tables.prep;
2633       delete tables["cvt "];
2634       this.isOpenType = true;
2635     } else {
2636       if (!tables.loca) {
2637         throw new FormatError('Required "loca" table is not found');
2638       }
2639       if (!tables.glyf) {
2640         warn('Required "glyf" table is not found -- trying to recover.');
2641         // Note: We use `sanitizeGlyphLocations` to add dummy glyf data below.
2642         tables.glyf = {
2643           tag: "glyf",
2644           data: new Uint8Array(0),
2645         };
2646       }
2647       this.isOpenType = false;
2648     }
2649 
2650     if (!tables.maxp) {
2651       throw new FormatError('Required "maxp" table is not found');
2652     }
2653 
2654     font.pos = (font.start || 0) + tables.maxp.offset;
2655     let version = font.getInt32();
2656     const numGlyphs = font.getUint16();
2657 
2658     if (version !== 0x00010000 && version !== 0x00005000) {
2659       // https://learn.microsoft.com/en-us/typography/opentype/spec/maxp
2660       if (tables.maxp.length === 6) {
2661         version = 0x0005000;
2662       } else if (tables.maxp.length >= 32) {
2663         version = 0x00010000;
2664       } else {
2665         throw new FormatError(`"maxp" table has a wrong version number`);
2666       }
2667       writeUint32(tables.maxp.data, 0, version);
2668     }
2669 
2670     if (properties.scaleFactors?.length === numGlyphs && isTrueType) {
2671       const { scaleFactors } = properties;
2672       const isGlyphLocationsLong = int16(
2673         tables.head.data[50],
2674         tables.head.data[51]
2675       );
2676 
2677       const glyphs = new GlyfTable({
2678         glyfTable: tables.glyf.data,
2679         isGlyphLocationsLong,
2680         locaTable: tables.loca.data,
2681         numGlyphs,
2682       });
2683       glyphs.scale(scaleFactors);
2684 
2685       const { glyf, loca, isLocationLong } = glyphs.write();
2686       tables.glyf.data = glyf;
2687       tables.loca.data = loca;
2688 
2689       if (isLocationLong !== !!isGlyphLocationsLong) {
2690         tables.head.data[50] = 0;
2691         tables.head.data[51] = isLocationLong ? 1 : 0;
2692       }
2693 
2694       const metrics = tables.hmtx.data;
2695 
2696       for (let i = 0; i < numGlyphs; i++) {
2697         const j = 4 * i;
2698         const advanceWidth = Math.round(
2699           scaleFactors[i] * int16(metrics[j], metrics[j + 1])
2700         );
2701         metrics[j] = (advanceWidth >> 8) & 0xff;
2702         metrics[j + 1] = advanceWidth & 0xff;
2703         const lsb = Math.round(
2704           scaleFactors[i] * signedInt16(metrics[j + 2], metrics[j + 3])
2705         );
2706         writeSignedInt16(metrics, j + 2, lsb);
2707       }
2708     }
2709 
2710     // Glyph 0 is duplicated and appended.
2711     let numGlyphsOut = numGlyphs + 1;
2712     let dupFirstEntry = true;
2713     if (numGlyphsOut > 0xffff) {
2714       dupFirstEntry = false;
2715       numGlyphsOut = numGlyphs;
2716       warn("Not enough space in glyfs to duplicate first glyph.");
2717     }
2718     let maxFunctionDefs = 0;
2719     let maxSizeOfInstructions = 0;
2720     if (version >= 0x00010000 && tables.maxp.length >= 32) {
2721       // maxZones can be invalid
2722       font.pos += 8;
2723       const maxZones = font.getUint16();
2724       if (maxZones > 2) {
2725         // reset to 2 if font has invalid maxZones
2726         tables.maxp.data[14] = 0;
2727         tables.maxp.data[15] = 2;
2728       }
2729       font.pos += 4;
2730       maxFunctionDefs = font.getUint16();
2731       font.pos += 4;
2732       maxSizeOfInstructions = font.getUint16();
2733     }
2734 
2735     tables.maxp.data[4] = numGlyphsOut >> 8;
2736     tables.maxp.data[5] = numGlyphsOut & 255;
2737 
2738     const hintsValid = sanitizeTTPrograms(
2739       tables.fpgm,
2740       tables.prep,
2741       tables["cvt "],
2742       maxFunctionDefs
2743     );
2744     if (!hintsValid) {
2745       delete tables.fpgm;
2746       delete tables.prep;
2747       delete tables["cvt "];
2748     }
2749 
2750     // Ensure the hmtx table contains the advance width and
2751     // sidebearings information for numGlyphs in the maxp table
2752     sanitizeMetrics(
2753       font,
2754       tables.hhea,
2755       tables.hmtx,
2756       tables.head,
2757       numGlyphsOut,
2758       dupFirstEntry
2759     );
2760 
2761     if (!tables.head) {
2762       throw new FormatError('Required "head" table is not found');
2763     }
2764 
2765     sanitizeHead(tables.head, numGlyphs, isTrueType ? tables.loca.length : 0);
2766 
2767     let missingGlyphs = Object.create(null);
2768     if (isTrueType) {
2769       const isGlyphLocationsLong = int16(
2770         tables.head.data[50],
2771         tables.head.data[51]
2772       );
2773       const glyphsInfo = sanitizeGlyphLocations(
2774         tables.loca,
2775         tables.glyf,
2776         numGlyphs,
2777         isGlyphLocationsLong,
2778         hintsValid,
2779         dupFirstEntry,
2780         maxSizeOfInstructions
2781       );
2782       missingGlyphs = glyphsInfo.missingGlyphs;
2783 
2784       // Some fonts have incorrect maxSizeOfInstructions values, so we use
2785       // the computed value instead.
2786       if (version >= 0x00010000 && tables.maxp.length >= 32) {
2787         tables.maxp.data[26] = glyphsInfo.maxSizeOfInstructions >> 8;
2788         tables.maxp.data[27] = glyphsInfo.maxSizeOfInstructions & 255;
2789       }
2790     }
2791     if (!tables.hhea) {
2792       throw new FormatError('Required "hhea" table is not found');
2793     }
2794 
2795     // Sanitizer reduces the glyph advanceWidth to the maxAdvanceWidth
2796     // Sometimes it's 0. That needs to be fixed
2797     if (tables.hhea.data[10] === 0 && tables.hhea.data[11] === 0) {
2798       tables.hhea.data[10] = 0xff;
2799       tables.hhea.data[11] = 0xff;
2800     }
2801 
2802     // Extract some more font properties from the OpenType head and
2803     // hhea tables; yMin and descent value are always negative.
2804     const metricsOverride = {
2805       unitsPerEm: int16(tables.head.data[18], tables.head.data[19]),
2806       yMax: signedInt16(tables.head.data[42], tables.head.data[43]),
2807       yMin: signedInt16(tables.head.data[38], tables.head.data[39]),
2808       ascent: signedInt16(tables.hhea.data[4], tables.hhea.data[5]),
2809       descent: signedInt16(tables.hhea.data[6], tables.hhea.data[7]),
2810       lineGap: signedInt16(tables.hhea.data[8], tables.hhea.data[9]),
2811     };
2812 
2813     // PDF FontDescriptor metrics lie -- using data from actual font.
2814     this.ascent = metricsOverride.ascent / metricsOverride.unitsPerEm;
2815     this.descent = metricsOverride.descent / metricsOverride.unitsPerEm;
2816     this.lineGap = metricsOverride.lineGap / metricsOverride.unitsPerEm;
2817 
2818     if (this.cssFontInfo?.lineHeight) {
2819       this.lineHeight = this.cssFontInfo.metrics.lineHeight;
2820       this.lineGap = this.cssFontInfo.metrics.lineGap;
2821     } else {
2822       this.lineHeight = this.ascent - this.descent + this.lineGap;
2823     }
2824 
2825     // The 'post' table has glyphs names.
2826     if (tables.post) {
2827       readPostScriptTable(tables.post, properties, numGlyphs);
2828     }
2829 
2830     // The original 'post' table is not needed, replace it.
2831     tables.post = {
2832       tag: "post",
2833       data: createPostTable(properties),
2834     };
2835 
2836     const charCodeToGlyphId = Object.create(null);
2837 
2838     // Helper function to try to skip mapping of empty glyphs.
2839     function hasGlyph(glyphId) {
2840       return !missingGlyphs[glyphId];
2841     }
2842 
2843     if (properties.composite) {
2844       const cidToGidMap = properties.cidToGidMap || [];
2845       const isCidToGidMapEmpty = cidToGidMap.length === 0;
2846 
2847       properties.cMap.forEach(function (charCode, cid) {
2848         if (typeof cid === "string") {
2849           cid = convertCidString(charCode, cid, /* shouldThrow = */ true);
2850         }
2851         if (cid > 0xffff) {
2852           throw new FormatError("Max size of CID is 65,535");
2853         }
2854         let glyphId = -1;
2855         if (isCidToGidMapEmpty) {
2856           glyphId = cid;
2857         } else if (cidToGidMap[cid] !== undefined) {
2858           glyphId = cidToGidMap[cid];
2859         }
2860 
2861         if (glyphId >= 0 && glyphId < numGlyphs && hasGlyph(glyphId)) {
2862           charCodeToGlyphId[charCode] = glyphId;
2863         }
2864       });
2865     } else {
2866       // Most of the following logic in this code branch is based on the
2867       // 9.6.6.4 of the PDF spec.
2868       const cmapTable = readCmapTable(
2869         tables.cmap,
2870         font,
2871         this.isSymbolicFont,
2872         properties.hasEncoding
2873       );
2874       const cmapPlatformId = cmapTable.platformId;
2875       const cmapEncodingId = cmapTable.encodingId;
2876       const cmapMappings = cmapTable.mappings;
2877       let baseEncoding = [],
2878         forcePostTable = false;
2879       if (
2880         properties.hasEncoding &&
2881         (properties.baseEncodingName === "MacRomanEncoding" ||
2882           properties.baseEncodingName === "WinAnsiEncoding")
2883       ) {
2884         baseEncoding = getEncoding(properties.baseEncodingName);
2885       }
2886 
2887       // If the font has an encoding and is not symbolic then follow the rules
2888       // in section 9.6.6.4 of the spec on how to map 3,1 and 1,0 cmaps.
2889       if (
2890         properties.hasEncoding &&
2891         !this.isSymbolicFont &&
2892         ((cmapPlatformId === 3 && cmapEncodingId === 1) ||
2893           (cmapPlatformId === 1 && cmapEncodingId === 0))
2894       ) {
2895         const glyphsUnicodeMap = getGlyphsUnicode();
2896         for (let charCode = 0; charCode < 256; charCode++) {
2897           let glyphName;
2898           if (this.differences[charCode] !== undefined) {
2899             glyphName = this.differences[charCode];
2900           } else if (baseEncoding.length && baseEncoding[charCode] !== "") {
2901             glyphName = baseEncoding[charCode];
2902           } else {
2903             glyphName = StandardEncoding[charCode];
2904           }
2905           if (!glyphName) {
2906             continue;
2907           }
2908           // Ensure that non-standard glyph names are resolved to valid ones.
2909           const standardGlyphName = recoverGlyphName(
2910             glyphName,
2911             glyphsUnicodeMap
2912           );
2913 
2914           let unicodeOrCharCode;
2915           if (cmapPlatformId === 3 && cmapEncodingId === 1) {
2916             unicodeOrCharCode = glyphsUnicodeMap[standardGlyphName];
2917           } else if (cmapPlatformId === 1 && cmapEncodingId === 0) {
2918             // TODO: the encoding needs to be updated with mac os table.
2919             unicodeOrCharCode = MacRomanEncoding.indexOf(standardGlyphName);
2920           }
2921 
2922           if (unicodeOrCharCode === undefined) {
2923             // Not a valid glyph name, fallback to using the /ToUnicode map
2924             // when no post-table exists (fixes issue13316_reduced.pdf).
2925             if (
2926               !properties.glyphNames &&
2927               properties.hasIncludedToUnicodeMap &&
2928               !(this.toUnicode instanceof IdentityToUnicodeMap)
2929             ) {
2930               const unicode = this.toUnicode.get(charCode);
2931               if (unicode) {
2932                 unicodeOrCharCode = unicode.codePointAt(0);
2933               }
2934             }
2935 
2936             if (unicodeOrCharCode === undefined) {
2937               continue; // No valid glyph mapping found.
2938             }
2939           }
2940 
2941           for (const mapping of cmapMappings) {
2942             if (mapping.charCode !== unicodeOrCharCode) {
2943               continue;
2944             }
2945             charCodeToGlyphId[charCode] = mapping.glyphId;
2946             break;
2947           }
2948         }
2949       } else if (cmapPlatformId === 0) {
2950         // Default Unicode semantics, use the charcodes as is.
2951         for (const mapping of cmapMappings) {
2952           charCodeToGlyphId[mapping.charCode] = mapping.glyphId;
2953         }
2954         // Always prefer the BaseEncoding/Differences arrays, when they exist
2955         // (fixes issue13433.pdf).
2956         forcePostTable = true;
2957       } else if (cmapPlatformId === 3 && cmapEncodingId === 0) {
2958         // When a (3, 0) cmap table is present, it is used instead but the
2959         // spec has special rules for char codes in the range of 0xF000 to
2960         // 0xF0FF and it says the (3, 0) table should map the values from
2961         // the (1, 0) table by prepending 0xF0 to the char codes. To reverse
2962         // this, the upper bits of the char code are cleared, but only for the
2963         // special range since some PDFs have char codes outside of this range
2964         // (e.g. 0x2013) which when masked would overwrite other values in the
2965         // cmap.
2966         for (const mapping of cmapMappings) {
2967           let charCode = mapping.charCode;
2968           if (charCode >= 0xf000 && charCode <= 0xf0ff) {
2969             charCode &= 0xff;
2970           }
2971           charCodeToGlyphId[charCode] = mapping.glyphId;
2972         }
2973       } else {
2974         // When there is only a (1, 0) cmap table, the char code is a single
2975         // byte and it is used directly as the char code.
2976         for (const mapping of cmapMappings) {
2977           charCodeToGlyphId[mapping.charCode] = mapping.glyphId;
2978         }
2979       }
2980 
2981       // Last, try to map any missing charcodes using the post table.
2982       if (
2983         properties.glyphNames &&
2984         (baseEncoding.length || this.differences.length)
2985       ) {
2986         for (let i = 0; i < 256; ++i) {
2987           if (!forcePostTable && charCodeToGlyphId[i] !== undefined) {
2988             continue;
2989           }
2990           const glyphName = this.differences[i] || baseEncoding[i];
2991           if (!glyphName) {
2992             continue;
2993           }
2994           const glyphId = properties.glyphNames.indexOf(glyphName);
2995           if (glyphId > 0 && hasGlyph(glyphId)) {
2996             charCodeToGlyphId[i] = glyphId;
2997           }
2998         }
2999       }
3000     }
3001 
3002     if (charCodeToGlyphId.length === 0) {
3003       // defines at least one glyph
3004       charCodeToGlyphId[0] = 0;
3005     }
3006 
3007     // Typically glyph 0 is duplicated and the mapping must be updated, but if
3008     // there isn't enough room to duplicate, the glyph id is left the same. In
3009     // this case, glyph 0 may not work correctly, but that is better than
3010     // having the whole font fail.
3011     let glyphZeroId = numGlyphsOut - 1;
3012     if (!dupFirstEntry) {
3013       glyphZeroId = 0;
3014     }
3015 
3016     // When `cssFontInfo` is set, the font is used to render text in the HTML
3017     // view (e.g. with Xfa) so nothing must be moved in the private use area.
3018     if (!properties.cssFontInfo) {
3019       // Converting glyphs and ids into font's cmap table
3020       const newMapping = adjustMapping(
3021         charCodeToGlyphId,
3022         hasGlyph,
3023         glyphZeroId,
3024         this.toUnicode
3025       );
3026       this.toFontChar = newMapping.toFontChar;
3027       tables.cmap = {
3028         tag: "cmap",
3029         data: createCmapTable(
3030           newMapping.charCodeToGlyphId,
3031           newMapping.toUnicodeExtraMap,
3032           numGlyphsOut
3033         ),
3034       };
3035 
3036       if (!tables["OS/2"] || !validateOS2Table(tables["OS/2"], font)) {
3037         tables["OS/2"] = {
3038           tag: "OS/2",
3039           data: createOS2Table(
3040             properties,
3041             newMapping.charCodeToGlyphId,
3042             metricsOverride
3043           ),
3044         };
3045       }
3046     }
3047 
3048     if (!isTrueType) {
3049       try {
3050         // Trying to repair CFF file
3051         cffFile = new Stream(tables["CFF "].data);
3052         const parser = new CFFParser(
3053           cffFile,
3054           properties,
3055           SEAC_ANALYSIS_ENABLED
3056         );
3057         cff = parser.parse();
3058         cff.duplicateFirstGlyph();
3059         const compiler = new CFFCompiler(cff);
3060         tables["CFF "].data = compiler.compile();
3061       } catch {
3062         warn("Failed to compile font " + properties.loadedName);
3063       }
3064     }
3065 
3066     // Re-creating 'name' table
3067     if (!tables.name) {
3068       tables.name = {
3069         tag: "name",
3070         data: createNameTable(this.name),
3071       };
3072     } else {
3073       // ... using existing 'name' table as prototype
3074       const [namePrototype, nameRecords] = readNameTable(tables.name);
3075 
3076       tables.name.data = createNameTable(name, namePrototype);
3077       this.psName = namePrototype[0][6] || null;
3078 
3079       if (!properties.composite) {
3080         // For TrueType fonts that do not include `ToUnicode` or `Encoding`
3081         // data, attempt to use the name-table to improve text selection.
3082         adjustTrueTypeToUnicode(properties, this.isSymbolicFont, nameRecords);
3083       }
3084     }
3085 
3086     const builder = new OpenTypeFileBuilder(header.version);
3087     for (const tableTag in tables) {
3088       builder.addTable(tableTag, tables[tableTag].data);
3089     }
3090     return builder.toArray();
3091   }
3092 
3093   convert(fontName, font, properties) {
3094     // TODO: Check the charstring widths to determine this.
3095     properties.fixedPitch = false;
3096 
3097     if (properties.builtInEncoding) {
3098       // For Type1 fonts that do not include either `ToUnicode` or `Encoding`
3099       // data, attempt to use the `builtInEncoding` to improve text selection.
3100       adjustType1ToUnicode(properties, properties.builtInEncoding);
3101     }
3102 
3103     // Type 1 fonts have a notdef inserted at the beginning, so glyph 0
3104     // becomes glyph 1. In a CFF font glyph 0 is appended to the end of the
3105     // char strings.
3106     let glyphZeroId = 1;
3107     if (font instanceof CFFFont) {
3108       glyphZeroId = font.numGlyphs - 1;
3109     }
3110     const mapping = font.getGlyphMapping(properties);
3111     let newMapping = null;
3112     let newCharCodeToGlyphId = mapping;
3113     let toUnicodeExtraMap = null;
3114 
3115     // When `cssFontInfo` is set, the font is used to render text in the HTML
3116     // view (e.g. with Xfa) so nothing must be moved in the private use area.
3117     if (!properties.cssFontInfo) {
3118       newMapping = adjustMapping(
3119         mapping,
3120         font.hasGlyphId.bind(font),
3121         glyphZeroId,
3122         this.toUnicode
3123       );
3124       this.toFontChar = newMapping.toFontChar;
3125       newCharCodeToGlyphId = newMapping.charCodeToGlyphId;
3126       toUnicodeExtraMap = newMapping.toUnicodeExtraMap;
3127     }
3128     const numGlyphs = font.numGlyphs;
3129 
3130     function getCharCodes(charCodeToGlyphId, glyphId) {
3131       let charCodes = null;
3132       for (const charCode in charCodeToGlyphId) {
3133         if (glyphId === charCodeToGlyphId[charCode]) {
3134           (charCodes ||= []).push(charCode | 0);
3135         }
3136       }
3137       return charCodes;
3138     }
3139 
3140     function createCharCode(charCodeToGlyphId, glyphId) {
3141       for (const charCode in charCodeToGlyphId) {
3142         if (glyphId === charCodeToGlyphId[charCode]) {
3143           return charCode | 0;
3144         }
3145       }
3146       newMapping.charCodeToGlyphId[newMapping.nextAvailableFontCharCode] =
3147         glyphId;
3148       return newMapping.nextAvailableFontCharCode++;
3149     }
3150 
3151     const seacs = font.seacs;
3152     if (newMapping && SEAC_ANALYSIS_ENABLED && seacs?.length) {
3153       const matrix = properties.fontMatrix || FONT_IDENTITY_MATRIX;
3154       const charset = font.getCharset();
3155       const seacMap = Object.create(null);
3156       for (let glyphId in seacs) {
3157         glyphId |= 0;
3158         const seac = seacs[glyphId];
3159         const baseGlyphName = StandardEncoding[seac[2]];
3160         const accentGlyphName = StandardEncoding[seac[3]];
3161         const baseGlyphId = charset.indexOf(baseGlyphName);
3162         const accentGlyphId = charset.indexOf(accentGlyphName);
3163         if (baseGlyphId < 0 || accentGlyphId < 0) {
3164           continue;
3165         }
3166         const accentOffset = {
3167           x: seac[0] * matrix[0] + seac[1] * matrix[2] + matrix[4],
3168           y: seac[0] * matrix[1] + seac[1] * matrix[3] + matrix[5],
3169         };
3170 
3171         const charCodes = getCharCodes(mapping, glyphId);
3172         if (!charCodes) {
3173           // There's no point in mapping it if the char code was never mapped
3174           // to begin with.
3175           continue;
3176         }
3177         for (const charCode of charCodes) {
3178           // Find a fontCharCode that maps to the base and accent glyphs.
3179           // If one doesn't exists, create it.
3180           const charCodeToGlyphId = newMapping.charCodeToGlyphId;
3181           const baseFontCharCode = createCharCode(
3182             charCodeToGlyphId,
3183             baseGlyphId
3184           );
3185           const accentFontCharCode = createCharCode(
3186             charCodeToGlyphId,
3187             accentGlyphId
3188           );
3189           seacMap[charCode] = {
3190             baseFontCharCode,
3191             accentFontCharCode,
3192             accentOffset,
3193           };
3194         }
3195       }
3196       properties.seacMap = seacMap;
3197     }
3198 
3199     const unitsPerEm = 1 / (properties.fontMatrix || FONT_IDENTITY_MATRIX)[0];
3200 
3201     const builder = new OpenTypeFileBuilder("\x4F\x54\x54\x4F");
3202     // PostScript Font Program
3203     builder.addTable("CFF ", font.data);
3204     // OS/2 and Windows Specific metrics
3205     builder.addTable("OS/2", createOS2Table(properties, newCharCodeToGlyphId));
3206     // Character to glyphs mapping
3207     builder.addTable(
3208       "cmap",
3209       createCmapTable(newCharCodeToGlyphId, toUnicodeExtraMap, numGlyphs)
3210     );
3211     // Font header
3212     builder.addTable(
3213       "head",
3214       "\x00\x01\x00\x00" + // Version number
3215         "\x00\x00\x10\x00" + // fontRevision
3216         "\x00\x00\x00\x00" + // checksumAdjustement
3217         "\x5F\x0F\x3C\xF5" + // magicNumber
3218         "\x00\x00" + // Flags
3219         safeString16(unitsPerEm) + // unitsPerEM
3220         "\x00\x00\x00\x00\x9e\x0b\x7e\x27" + // creation date
3221         "\x00\x00\x00\x00\x9e\x0b\x7e\x27" + // modifification date
3222         "\x00\x00" + // xMin
3223         safeString16(properties.descent) + // yMin
3224         "\x0F\xFF" + // xMax
3225         safeString16(properties.ascent) + // yMax
3226         string16(properties.italicAngle ? 2 : 0) + // macStyle
3227         "\x00\x11" + // lowestRecPPEM
3228         "\x00\x00" + // fontDirectionHint
3229         "\x00\x00" + // indexToLocFormat
3230         "\x00\x00"
3231     ); // glyphDataFormat
3232 
3233     // Horizontal header
3234     builder.addTable(
3235       "hhea",
3236       "\x00\x01\x00\x00" + // Version number
3237         safeString16(properties.ascent) + // Typographic Ascent
3238         safeString16(properties.descent) + // Typographic Descent
3239         "\x00\x00" + // Line Gap
3240         "\xFF\xFF" + // advanceWidthMax
3241         "\x00\x00" + // minLeftSidebearing
3242         "\x00\x00" + // minRightSidebearing
3243         "\x00\x00" + // xMaxExtent
3244         safeString16(properties.capHeight) + // caretSlopeRise
3245         safeString16(Math.tan(properties.italicAngle) * properties.xHeight) + // caretSlopeRun
3246         "\x00\x00" + // caretOffset
3247         "\x00\x00" + // -reserved-
3248         "\x00\x00" + // -reserved-
3249         "\x00\x00" + // -reserved-
3250         "\x00\x00" + // -reserved-
3251         "\x00\x00" + // metricDataFormat
3252         string16(numGlyphs)
3253     ); // Number of HMetrics
3254 
3255     // Horizontal metrics
3256     builder.addTable(
3257       "hmtx",
3258       (function fontFieldsHmtx() {
3259         const charstrings = font.charstrings;
3260         const cffWidths = font.cff ? font.cff.widths : null;
3261         let hmtx = "\x00\x00\x00\x00"; // Fake .notdef
3262         for (let i = 1, ii = numGlyphs; i < ii; i++) {
3263           let width = 0;
3264           if (charstrings) {
3265             const charstring = charstrings[i - 1];
3266             width = "width" in charstring ? charstring.width : 0;
3267           } else if (cffWidths) {
3268             width = Math.ceil(cffWidths[i] || 0);
3269           }
3270           hmtx += string16(width) + string16(0);
3271         }
3272         return hmtx;
3273       })()
3274     );
3275 
3276     // Maximum profile
3277     builder.addTable(
3278       "maxp",
3279       "\x00\x00\x50\x00" + string16(numGlyphs) // Version number
3280     ); // Num of glyphs
3281 
3282     // Naming tables
3283     builder.addTable("name", createNameTable(fontName));
3284 
3285     // PostScript information
3286     builder.addTable("post", createPostTable(properties));
3287 
3288     return builder.toArray();
3289   }
3290 
3291   /**
3292    * @private
3293    */
3294   _charToGlyph(charcode, isSpace = false) {
3295     let glyph = this._glyphCache[charcode];
3296     // All `Glyph`-properties, except `isSpace` in multi-byte strings,
3297     // depend indirectly on the `charcode`.
3298     if (glyph?.isSpace === isSpace) {
3299       return glyph;
3300     }
3301     let fontCharCode, width, operatorListId;
3302 
3303     let widthCode = charcode;
3304     if (this.cMap?.contains(charcode)) {
3305       widthCode = this.cMap.lookup(charcode);
3306 
3307       if (typeof widthCode === "string") {
3308         widthCode = convertCidString(charcode, widthCode);
3309       }
3310     }
3311     width = this.widths[widthCode];
3312     if (typeof width !== "number") {
3313       width = this.defaultWidth;
3314     }
3315     const vmetric = this.vmetrics?.[widthCode];
3316 
3317     let unicode = this.toUnicode.get(charcode) || charcode;
3318     if (typeof unicode === "number") {
3319       unicode = String.fromCharCode(unicode);
3320     }
3321 
3322     let isInFont = this.toFontChar[charcode] !== undefined;
3323     // First try the toFontChar map, if it's not there then try falling
3324     // back to the char code.
3325     fontCharCode = this.toFontChar[charcode] || charcode;
3326     if (this.missingFile) {
3327       const glyphName =
3328         this.differences[charcode] || this.defaultEncoding[charcode];
3329       if (
3330         (glyphName === ".notdef" || glyphName === "") &&
3331         this.type === "Type1"
3332       ) {
3333         // .notdef glyphs should be invisible in non-embedded Type1 fonts, so
3334         // replace them with spaces.
3335         fontCharCode = 0x20;
3336       }
3337       fontCharCode = mapSpecialUnicodeValues(fontCharCode);
3338     }
3339 
3340     if (this.isType3Font) {
3341       // Font char code in this case is actually a glyph name.
3342       operatorListId = fontCharCode;
3343     }
3344 
3345     let accent = null;
3346     if (this.seacMap?.[charcode]) {
3347       isInFont = true;
3348       const seac = this.seacMap[charcode];
3349       fontCharCode = seac.baseFontCharCode;
3350       accent = {
3351         fontChar: String.fromCodePoint(seac.accentFontCharCode),
3352         offset: seac.accentOffset,
3353       };
3354     }
3355 
3356     let fontChar = "";
3357     if (typeof fontCharCode === "number") {
3358       if (fontCharCode <= 0x10ffff) {
3359         fontChar = String.fromCodePoint(fontCharCode);
3360       } else {
3361         warn(`charToGlyph - invalid fontCharCode: ${fontCharCode}`);
3362       }
3363     }
3364 
3365     glyph = new Glyph(
3366       charcode,
3367       fontChar,
3368       unicode,
3369       accent,
3370       width,
3371       vmetric,
3372       operatorListId,
3373       isSpace,
3374       isInFont
3375     );
3376     return (this._glyphCache[charcode] = glyph);
3377   }
3378 
3379   charsToGlyphs(chars) {
3380     // If we translated this string before, just grab it from the cache.
3381     let glyphs = this._charsCache[chars];
3382     if (glyphs) {
3383       return glyphs;
3384     }
3385     glyphs = [];
3386 
3387     if (this.cMap) {
3388       // Composite fonts have multi-byte strings, convert the string from
3389       // single-byte to multi-byte.
3390       const c = Object.create(null),
3391         ii = chars.length;
3392       let i = 0;
3393       while (i < ii) {
3394         this.cMap.readCharCode(chars, i, c);
3395         const { charcode, length } = c;
3396         i += length;
3397         // Space is char with code 0x20 and length 1 in multiple-byte codes.
3398         const glyph = this._charToGlyph(
3399           charcode,
3400           length === 1 && chars.charCodeAt(i - 1) === 0x20
3401         );
3402         glyphs.push(glyph);
3403       }
3404     } else {
3405       for (let i = 0, ii = chars.length; i < ii; ++i) {
3406         const charcode = chars.charCodeAt(i);
3407         const glyph = this._charToGlyph(charcode, charcode === 0x20);
3408         glyphs.push(glyph);
3409       }
3410     }
3411 
3412     // Enter the translated string into the cache.
3413     return (this._charsCache[chars] = glyphs);
3414   }
3415 
3416   /**
3417    * Chars can have different sizes (depends on the encoding).
3418    * @param {String} a string encoded with font encoding.
3419    * @returns {Array<Array<number>>} the positions of each char in the string.
3420    */
3421   getCharPositions(chars) {
3422     // This function doesn't use a cache because
3423     // it's called only when saving or printing.
3424     const positions = [];
3425 
3426     if (this.cMap) {
3427       const c = Object.create(null);
3428       let i = 0;
3429       while (i < chars.length) {
3430         this.cMap.readCharCode(chars, i, c);
3431         const length = c.length;
3432         positions.push([i, i + length]);
3433         i += length;
3434       }
3435     } else {
3436       for (let i = 0, ii = chars.length; i < ii; ++i) {
3437         positions.push([i, i + 1]);
3438       }
3439     }
3440 
3441     return positions;
3442   }
3443 
3444   get glyphCacheValues() {
3445     return Object.values(this._glyphCache);
3446   }
3447 
3448   /**
3449    * Encode a js string using font encoding.
3450    * The resulting array contains an encoded string at even positions
3451    * (can be empty) and a non-encoded one at odd positions.
3452    * @param {String} a js string.
3453    * @returns {Array<String>} an array of encoded strings or non-encoded ones.
3454    */
3455   encodeString(str) {
3456     const buffers = [];
3457     const currentBuf = [];
3458 
3459     // buffers will contain: encoded, non-encoded, encoded, ...
3460     // currentBuf is pushed in buffers each time there is a change.
3461     // So when buffers.length is odd then the last string is an encoded one
3462     // and currentBuf contains non-encoded chars.
3463     const hasCurrentBufErrors = () => buffers.length % 2 === 1;
3464 
3465     const getCharCode =
3466       this.toUnicode instanceof IdentityToUnicodeMap
3467         ? unicode => this.toUnicode.charCodeOf(unicode)
3468         : unicode => this.toUnicode.charCodeOf(String.fromCodePoint(unicode));
3469 
3470     for (let i = 0, ii = str.length; i < ii; i++) {
3471       const unicode = str.codePointAt(i);
3472       if (unicode > 0xd7ff && (unicode < 0xe000 || unicode > 0xfffd)) {
3473         // unicode is represented by two uint16
3474         i++;
3475       }
3476       if (this.toUnicode) {
3477         const charCode = getCharCode(unicode);
3478         if (charCode !== -1) {
3479           if (hasCurrentBufErrors()) {
3480             buffers.push(currentBuf.join(""));
3481             currentBuf.length = 0;
3482           }
3483           const charCodeLength = this.cMap
3484             ? this.cMap.getCharCodeLength(charCode)
3485             : 1;
3486           for (let j = charCodeLength - 1; j >= 0; j--) {
3487             currentBuf.push(String.fromCharCode((charCode >> (8 * j)) & 0xff));
3488           }
3489           continue;
3490         }
3491       }
3492 
3493       // unicode can't be encoded
3494       if (!hasCurrentBufErrors()) {
3495         buffers.push(currentBuf.join(""));
3496         currentBuf.length = 0;
3497       }
3498       currentBuf.push(String.fromCodePoint(unicode));
3499     }
3500 
3501     buffers.push(currentBuf.join(""));
3502 
3503     return buffers;
3504   }
3505 }
3506 
3507 class ErrorFont {
3508   constructor(error) {
3509     this.error = error;
3510     this.loadedName = "g_font_error";
3511     this.missingFile = true;
3512   }
3513 
3514   charsToGlyphs() {
3515     return [];
3516   }
3517 
3518   encodeString(chars) {
3519     return [chars];
3520   }
3521 
3522   exportData(extraProperties = false) {
3523     return { error: this.error };
3524   }
3525 }
3526 
3527 export { ErrorFont, Font };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

