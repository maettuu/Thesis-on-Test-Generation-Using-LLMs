Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Transformed fonts display badly in PDF
</issue>

Patch:
<patch>
diff --git a/src/core/fonts.js b/src/core/fonts.js
--- a/src/core/fonts.js
+++ b/src/core/fonts.js
@@ -798,7 +798,9 @@ function createOS2Table(properties, charstrings, override) {
   const bbox = properties.bbox || [0, 0, 0, 0];
   const unitsPerEm =
     override.unitsPerEm ||
-    1 / (properties.fontMatrix || FONT_IDENTITY_MATRIX)[0];
+    (properties.fontMatrix
+      ? 1 / Math.max(...properties.fontMatrix.slice(0, 4))
+      : 1000);
 
   // if the font units differ to the PDF glyph space units
   // then scale up the values
@@ -3196,7 +3198,9 @@ class Font {
       properties.seacMap = seacMap;
     }
 
-    const unitsPerEm = 1 / (properties.fontMatrix || FONT_IDENTITY_MATRIX)[0];
+    const unitsPerEm = properties.fontMatrix
+      ? 1 / Math.max(...properties.fontMatrix.slice(0, 4))
+      : 1000;
 
     const builder = new OpenTypeFileBuilder("\x4F\x54\x54\x4F");
     // PostScript Font Program


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.24.7
- @babel/preset-env: ^7.24.7
- @babel/runtime: ^7.24.7
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.9.0
- @jazzer.js/core: ^2.1.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.3.0
- autoprefixer: ^10.4.19
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001632
- canvas: ^2.11.2
- core-js: ^3.37.1
- cross-env: ^7.0.3
- eslint: ^8.57.0
- eslint-config-prettier: ^9.1.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^8.1.1
- eslint-plugin-import: ^2.29.1
- eslint-plugin-jasmine: ^4.1.3
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.7.4
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.1.3
- eslint-plugin-sort-exports: ^0.9.1
- eslint-plugin-unicorn: ^53.0.0
- globals: ^15.4.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- highlight.js: ^11.9.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.3
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.1
- ordered-read-streams: ^2.0.0
- path2d: ^0.2.0
- pngjs: ^7.0.0
- postcss: ^8.4.38
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^8.0.1
- postcss-discard-comments: ^7.0.0
- postcss-nesting: ^12.1.5
- prettier: ^3.3.2
- puppeteer: ^22.10.1
- streamqueue: ^1.1.2
- stylelint: ^16.6.1
- stylelint-prettier: ^5.0.0
- terser-webpack-plugin: ^5.3.10
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.4.5
- vinyl: ^3.0.0
- webpack: ^5.91.0
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/outliner.js`: Outliner
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodePackages
- `../../src/display/text_layer.js`: TextLayer, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory, createTemporaryNodeServer
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/fonts.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   assert,
18   bytesToString,
19   FONT_IDENTITY_MATRIX,
20   FormatError,
21   info,
22   shadow,
23   string32,
24   warn,
25 } from "../shared/util.js";
26 import { CFFCompiler, CFFParser } from "./cff_parser.js";
27 import {
28   FontFlags,
29   MacStandardGlyphOrdering,
30   normalizeFontName,
31   recoverGlyphName,
32   SEAC_ANALYSIS_ENABLED,
33 } from "./fonts_utils.js";
34 import {
35   getCharUnicodeCategory,
36   getUnicodeForGlyph,
37   getUnicodeRangeFor,
38   mapSpecialUnicodeValues,
39 } from "./unicode.js";
40 import { getDingbatsGlyphsUnicode, getGlyphsUnicode } from "./glyphlist.js";
41 import {
42   getEncoding,
43   MacRomanEncoding,
44   StandardEncoding,
45   SymbolSetEncoding,
46   WinAnsiEncoding,
47   ZapfDingbatsEncoding,
48 } from "./encodings.js";
49 import {
50   getGlyphMapForStandardFonts,
51   getNonStdFontMap,
52   getSerifFonts,
53   getStdFontMap,
54   getSupplementalGlyphMapForArialBlack,
55   getSupplementalGlyphMapForCalibri,
56 } from "./standard_fonts.js";
57 import { IdentityToUnicodeMap, ToUnicodeMap } from "./to_unicode_map.js";
58 import { CFFFont } from "./cff_font.js";
59 import { FontRendererFactory } from "./font_renderer.js";
60 import { getFontBasicMetrics } from "./metrics.js";
61 import { GlyfTable } from "./glyf.js";
62 import { IdentityCMap } from "./cmap.js";
63 import { OpenTypeFileBuilder } from "./opentype_file_builder.js";
64 import { readUint32 } from "./core_utils.js";
65 import { Stream } from "./stream.js";
66 import { Type1Font } from "./type1_font.js";
67 
68 // Unicode Private Use Areas:
69 const PRIVATE_USE_AREAS = [
70   [0xe000, 0xf8ff], // BMP (0)
71   [0x100000, 0x10fffd], // PUP (16)
72 ];
73 
74 // PDF Glyph Space Units are one Thousandth of a TextSpace Unit
75 // except for Type 3 fonts
76 const PDF_GLYPH_SPACE_UNITS = 1000;
77 
78 const EXPORT_DATA_PROPERTIES = [
79   "ascent",
80   "bbox",
81   "black",
82   "bold",
83   "charProcOperatorList",
84   "composite",
85   "cssFontInfo",
86   "data",
87   "defaultVMetrics",
88   "defaultWidth",
89   "descent",
90   "fallbackName",
91   "fontMatrix",
92   "isInvalidPDFjsFont",
93   "isType3Font",
94   "italic",
95   "loadedName",
96   "mimetype",
97   "missingFile",
98   "name",
99   "remeasure",
100   "subtype",
101   "systemFontInfo",
102   "type",
103   "vertical",
104 ];
105 
106 const EXPORT_DATA_EXTRA_PROPERTIES = [
107   "cMap",
108   "defaultEncoding",
109   "differences",
110   "isMonospace",
111   "isSerifFont",
112   "isSymbolicFont",
113   "seacMap",
114   "toFontChar",
115   "toUnicode",
116   "vmetrics",
117   "widths",
118 ];
119 
436 // Please refer to:
437 //  - https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html
441 
442 // Please refer to:
443 //  - https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html
444 //  - https://learn.microsoft.com/en-us/typography/opentype/spec/name#windows-language-ids
448 
744 function createOS2Table(properties, charstrings, override) {
745   override ||= {
746     unitsPerEm: 0,
747     yMax: 0,
748     yMin: 0,
749     ascent: 0,
750     descent: 0,
751   };
752 
753   let ulUnicodeRange1 = 0;
754   let ulUnicodeRange2 = 0;
755   let ulUnicodeRange3 = 0;
756   let ulUnicodeRange4 = 0;
757 
758   let firstCharIndex = null;
759   let lastCharIndex = 0;
760   let position = -1;
761 
762   if (charstrings) {
763     for (let code in charstrings) {
764       code |= 0;
765       if (firstCharIndex > code || !firstCharIndex) {
766         firstCharIndex = code;
767       }
768       if (lastCharIndex < code) {
769         lastCharIndex = code;
770       }
771 
772       position = getUnicodeRangeFor(code, position);
773       if (position < 32) {
774         ulUnicodeRange1 |= 1 << position;
775       } else if (position < 64) {
776         ulUnicodeRange2 |= 1 << (position - 32);
777       } else if (position < 96) {
778         ulUnicodeRange3 |= 1 << (position - 64);
779       } else if (position < 123) {
780         ulUnicodeRange4 |= 1 << (position - 96);
781       } else {
782         throw new FormatError(
783           "Unicode ranges Bits > 123 are reserved for internal usage"
784         );
785       }
786     }
787     if (lastCharIndex > 0xffff) {
788       // OS2 only supports a 16 bit int. The spec says if supplementary
789       // characters are used the field should just be set to 0xFFFF.
790       lastCharIndex = 0xffff;
791     }
792   } else {
793     // TODO
794     firstCharIndex = 0;
795     lastCharIndex = 255;
796   }
797 
798   const bbox = properties.bbox || [0, 0, 0, 0];
799   const unitsPerEm =
800     override.unitsPerEm ||
801     1 / (properties.fontMatrix || FONT_IDENTITY_MATRIX)[0];
802 
803   // if the font units differ to the PDF glyph space units
804   // then scale up the values
805   const scale = properties.ascentScaled
806     ? 1.0
807     : unitsPerEm / PDF_GLYPH_SPACE_UNITS;
808 
809   const typoAscent =
810     override.ascent || Math.round(scale * (properties.ascent || bbox[3]));
811   let typoDescent =
812     override.descent || Math.round(scale * (properties.descent || bbox[1]));
813   if (typoDescent > 0 && properties.descent > 0 && bbox[1] < 0) {
814     typoDescent = -typoDescent; // fixing incorrect descent
815   }
816   const winAscent = override.yMax || typoAscent;
817   const winDescent = -override.yMin || -typoDescent;
818 
819   return (
820     "\x00\x03" + // version
821     "\x02\x24" + // xAvgCharWidth
822     "\x01\xF4" + // usWeightClass
823     "\x00\x05" + // usWidthClass
824     "\x00\x00" + // fstype (0 to let the font loads via font-face on IE)
825     "\x02\x8A" + // ySubscriptXSize
826     "\x02\xBB" + // ySubscriptYSize
827     "\x00\x00" + // ySubscriptXOffset
828     "\x00\x8C" + // ySubscriptYOffset
829     "\x02\x8A" + // ySuperScriptXSize
830     "\x02\xBB" + // ySuperScriptYSize
831     "\x00\x00" + // ySuperScriptXOffset
832     "\x01\xDF" + // ySuperScriptYOffset
833     "\x00\x31" + // yStrikeOutSize
834     "\x01\x02" + // yStrikeOutPosition
835     "\x00\x00" + // sFamilyClass
836     "\x00\x00\x06" +
837     String.fromCharCode(properties.fixedPitch ? 0x09 : 0x00) +
838     "\x00\x00\x00\x00\x00\x00" + // Panose
839     string32(ulUnicodeRange1) + // ulUnicodeRange1 (Bits 0-31)
840     string32(ulUnicodeRange2) + // ulUnicodeRange2 (Bits 32-63)
841     string32(ulUnicodeRange3) + // ulUnicodeRange3 (Bits 64-95)
842     string32(ulUnicodeRange4) + // ulUnicodeRange4 (Bits 96-127)
843     "\x2A\x32\x31\x2A" + // achVendID
844     string16(properties.italicAngle ? 1 : 0) + // fsSelection
845     string16(firstCharIndex || properties.firstChar) + // usFirstCharIndex
846     string16(lastCharIndex || properties.lastChar) + // usLastCharIndex
847     string16(typoAscent) + // sTypoAscender
848     string16(typoDescent) + // sTypoDescender
849     "\x00\x64" + // sTypoLineGap (7%-10% of the unitsPerEM value)
850     string16(winAscent) + // usWinAscent
851     string16(winDescent) + // usWinDescent
852     "\x00\x00\x00\x00" + // ulCodePageRange1 (Bits 0-31)
853     "\x00\x00\x00\x00" + // ulCodePageRange2 (Bits 32-63)
854     string16(properties.xHeight) + // sxHeight
855     string16(properties.capHeight) + // sCapHeight
856     string16(0) + // usDefaultChar
857     string16(firstCharIndex || properties.firstChar) + // usBreakChar
858     "\x00\x03"
859   ); // usMaxContext
860 }
861 
947 /**
948  * 'Font' is the class the outside world should use, it encapsulate all the font
949  * decoding logics whatever type it is (assuming the font type is supported).
950  */
951 class Font {
952   constructor(name, file, properties) {
953     this.name = name;
954     this.psName = null;
955     this.mimetype = null;
956     this.disableFontFace = false;
957 
958     this.loadedName = properties.loadedName;
959     this.isType3Font = properties.isType3Font;
960     this.missingFile = false;
961     this.cssFontInfo = properties.cssFontInfo;
962 
963     this._charsCache = Object.create(null);
964     this._glyphCache = Object.create(null);
965 
966     let isSerifFont = !!(properties.flags & FontFlags.Serif);
967     // Fallback to checking the font name, in order to improve text-selection,
968     // since the /Flags-entry is often wrong (fixes issue13845.pdf).
969     if (!isSerifFont && !properties.isSimulatedFlags) {
970       const baseName = name.replaceAll(/[,_]/g, "-").split("-", 1)[0],
971         serifFonts = getSerifFonts();
972       for (const namePart of baseName.split("+")) {
973         if (serifFonts[namePart]) {
974           isSerifFont = true;
975           break;
976         }
977       }
978     }
979     this.isSerifFont = isSerifFont;
980 
981     this.isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
982     this.isMonospace = !!(properties.flags & FontFlags.FixedPitch);
983 
984     let { type, subtype } = properties;
985     this.type = type;
986     this.subtype = subtype;
987     this.systemFontInfo = properties.systemFontInfo;
988 
989     const matches = name.match(/^InvalidPDFjsFont_(.*)_\d+$/);
990     this.isInvalidPDFjsFont = !!matches;
991     if (this.isInvalidPDFjsFont) {
992       this.fallbackName = matches[1];
993     } else if (this.isMonospace) {
994       this.fallbackName = "monospace";
995     } else if (this.isSerifFont) {
996       this.fallbackName = "serif";
997     } else {
998       this.fallbackName = "sans-serif";
999     }
1000 
1001     if (this.systemFontInfo?.guessFallback) {
1002       // Once the fallback name is guessed, we don't want to guess it again.
1003       this.systemFontInfo.guessFallback = false;
1004       this.systemFontInfo.css += `,${this.fallbackName}`;
1005     }
1006 
1007     this.differences = properties.differences;
1008     this.widths = properties.widths;
1009     this.defaultWidth = properties.defaultWidth;
1010     this.composite = properties.composite;
1011     this.cMap = properties.cMap;
1012     this.capHeight = properties.capHeight / PDF_GLYPH_SPACE_UNITS;
1013     this.ascent = properties.ascent / PDF_GLYPH_SPACE_UNITS;
1014     this.descent = properties.descent / PDF_GLYPH_SPACE_UNITS;
1015     this.lineHeight = this.ascent - this.descent;
1016     this.fontMatrix = properties.fontMatrix;
1017     this.bbox = properties.bbox;
1018     this.defaultEncoding = properties.defaultEncoding;
1019 
1020     this.toUnicode = properties.toUnicode;
1021     this.toFontChar = [];
1022 
1023     if (properties.type === "Type3") {
1024       for (let charCode = 0; charCode < 256; charCode++) {
1025         this.toFontChar[charCode] =
1026           this.differences[charCode] || properties.defaultEncoding[charCode];
1027       }
1028       return;
1029     }
1030 
1031     this.cidEncoding = properties.cidEncoding || "";
1032     this.vertical = !!properties.vertical;
1033     if (this.vertical) {
1034       this.vmetrics = properties.vmetrics;
1035       this.defaultVMetrics = properties.defaultVMetrics;
1036     }
1037 
1038     if (!file || file.isEmpty) {
1039       if (file) {
1040         // Some bad PDF generators will include empty font files,
1041         // attempting to recover by assuming that no file exists.
1042         warn('Font file is empty in "' + name + '" (' + this.loadedName + ")");
1043       }
1044       this.fallbackToSystemFont(properties);
1045       return;
1046     }
1047 
1048     // Parse the font file to determine the correct type/subtype, rather than
1049     // relying on the (often incorrect) data in the font dictionary; (see e.g.
1050     //  issue6782.pdf, issue7598.pdf, and issue9949.pdf).
1051     [type, subtype] = getFontFileType(file, properties);
1052 
1053     if (type !== this.type || subtype !== this.subtype) {
1054       info(
1055         "Inconsistent font file Type/SubType, expected: " +
1056           `${this.type}/${this.subtype} but found: ${type}/${subtype}.`
1057       );
1058     }
1059 
1060     let data;
1061     try {
1062       switch (type) {
1063         case "MMType1":
1064           info("MMType1 font (" + name + "), falling back to Type1.");
1065         /* falls through */
1066         case "Type1":
1067         case "CIDFontType0":
1068           this.mimetype = "font/opentype";
1069 
1070           const cff =
1071             subtype === "Type1C" || subtype === "CIDFontType0C"
1072               ? new CFFFont(file, properties)
1073               : new Type1Font(name, file, properties);
1074 
1075           adjustWidths(properties);
1076 
1077           // Wrap the CFF data inside an OTF font file
1078           data = this.convert(name, cff, properties);
1079           break;
1080 
1081         case "OpenType":
1082         case "TrueType":
1083         case "CIDFontType2":
1084           this.mimetype = "font/opentype";
1085 
1086           // Repair the TrueType file. It is can be damaged in the point of
1087           // view of the sanitizer
1088           data = this.checkAndRepair(name, file, properties);
1089           if (this.isOpenType) {
1090             adjustWidths(properties);
1091 
1092             type = "OpenType";
1093           }
1094           break;
1095 
1096         default:
1097           throw new FormatError(`Font ${type} is not supported`);
1098       }
1099     } catch (e) {
1100       warn(e);
1101       this.fallbackToSystemFont(properties);
1102       return;
1103     }
1104 
1105     amendFallbackToUnicode(properties);
1106     this.data = data;
1107 
1108     // Transfer some properties again that could change during font conversion
1109     this.type = type;
1110     this.subtype = subtype;
1111     this.fontMatrix = properties.fontMatrix;
1112     this.widths = properties.widths;
1113     this.defaultWidth = properties.defaultWidth;
1114     this.toUnicode = properties.toUnicode;
1115     this.seacMap = properties.seacMap;
1116   }
1117 
3093   convert(fontName, font, properties) {
3094     // TODO: Check the charstring widths to determine this.
3095     properties.fixedPitch = false;
3096 
3097     if (properties.builtInEncoding) {
3098       // For Type1 fonts that do not include either `ToUnicode` or `Encoding`
3099       // data, attempt to use the `builtInEncoding` to improve text selection.
3100       adjustType1ToUnicode(properties, properties.builtInEncoding);
3101     }
3102 
3103     // Type 1 fonts have a notdef inserted at the beginning, so glyph 0
3104     // becomes glyph 1. In a CFF font glyph 0 is appended to the end of the
3105     // char strings.
3106     let glyphZeroId = 1;
3107     if (font instanceof CFFFont) {
3108       glyphZeroId = font.numGlyphs - 1;
3109     }
3110     const mapping = font.getGlyphMapping(properties);
3111     let newMapping = null;
3112     let newCharCodeToGlyphId = mapping;
3113     let toUnicodeExtraMap = null;
3114 
3115     // When `cssFontInfo` is set, the font is used to render text in the HTML
3116     // view (e.g. with Xfa) so nothing must be moved in the private use area.
3117     if (!properties.cssFontInfo) {
3118       newMapping = adjustMapping(
3119         mapping,
3120         font.hasGlyphId.bind(font),
3121         glyphZeroId,
3122         this.toUnicode
3123       );
3124       this.toFontChar = newMapping.toFontChar;
3125       newCharCodeToGlyphId = newMapping.charCodeToGlyphId;
3126       toUnicodeExtraMap = newMapping.toUnicodeExtraMap;
3127     }
3128     const numGlyphs = font.numGlyphs;
3129 
3130     function getCharCodes(charCodeToGlyphId, glyphId) {
3131       let charCodes = null;
3132       for (const charCode in charCodeToGlyphId) {
3133         if (glyphId === charCodeToGlyphId[charCode]) {
3134           (charCodes ||= []).push(charCode | 0);
3135         }
3136       }
3137       return charCodes;
3138     }
3139 
3140     function createCharCode(charCodeToGlyphId, glyphId) {
3141       for (const charCode in charCodeToGlyphId) {
3142         if (glyphId === charCodeToGlyphId[charCode]) {
3143           return charCode | 0;
3144         }
3145       }
3146       newMapping.charCodeToGlyphId[newMapping.nextAvailableFontCharCode] =
3147         glyphId;
3148       return newMapping.nextAvailableFontCharCode++;
3149     }
3150 
3151     const seacs = font.seacs;
3152     if (newMapping && SEAC_ANALYSIS_ENABLED && seacs?.length) {
3153       const matrix = properties.fontMatrix || FONT_IDENTITY_MATRIX;
3154       const charset = font.getCharset();
3155       const seacMap = Object.create(null);
3156       for (let glyphId in seacs) {
3157         glyphId |= 0;
3158         const seac = seacs[glyphId];
3159         const baseGlyphName = StandardEncoding[seac[2]];
3160         const accentGlyphName = StandardEncoding[seac[3]];
3161         const baseGlyphId = charset.indexOf(baseGlyphName);
3162         const accentGlyphId = charset.indexOf(accentGlyphName);
3163         if (baseGlyphId < 0 || accentGlyphId < 0) {
3164           continue;
3165         }
3166         const accentOffset = {
3167           x: seac[0] * matrix[0] + seac[1] * matrix[2] + matrix[4],
3168           y: seac[0] * matrix[1] + seac[1] * matrix[3] + matrix[5],
3169         };
3170 
3171         const charCodes = getCharCodes(mapping, glyphId);
3172         if (!charCodes) {
3173           // There's no point in mapping it if the char code was never mapped
3174           // to begin with.
3175           continue;
3176         }
3177         for (const charCode of charCodes) {
3178           // Find a fontCharCode that maps to the base and accent glyphs.
3179           // If one doesn't exists, create it.
3180           const charCodeToGlyphId = newMapping.charCodeToGlyphId;
3181           const baseFontCharCode = createCharCode(
3182             charCodeToGlyphId,
3183             baseGlyphId
3184           );
3185           const accentFontCharCode = createCharCode(
3186             charCodeToGlyphId,
3187             accentGlyphId
3188           );
3189           seacMap[charCode] = {
3190             baseFontCharCode,
3191             accentFontCharCode,
3192             accentOffset,
3193           };
3194         }
3195       }
3196       properties.seacMap = seacMap;
3197     }
3198 
3199     const unitsPerEm = 1 / (properties.fontMatrix || FONT_IDENTITY_MATRIX)[0];
3200 
3201     const builder = new OpenTypeFileBuilder("\x4F\x54\x54\x4F");
3202     // PostScript Font Program
3203     builder.addTable("CFF ", font.data);
3204     // OS/2 and Windows Specific metrics
3205     builder.addTable("OS/2", createOS2Table(properties, newCharCodeToGlyphId));
3206     // Character to glyphs mapping
3207     builder.addTable(
3208       "cmap",
3209       createCmapTable(newCharCodeToGlyphId, toUnicodeExtraMap, numGlyphs)
3210     );
3211     // Font header
3212     builder.addTable(
3213       "head",
3214       "\x00\x01\x00\x00" + // Version number
3215         "\x00\x00\x10\x00" + // fontRevision
3216         "\x00\x00\x00\x00" + // checksumAdjustement
3217         "\x5F\x0F\x3C\xF5" + // magicNumber
3218         "\x00\x00" + // Flags
3219         safeString16(unitsPerEm) + // unitsPerEM
3220         "\x00\x00\x00\x00\x9e\x0b\x7e\x27" + // creation date
3221         "\x00\x00\x00\x00\x9e\x0b\x7e\x27" + // modifification date
3222         "\x00\x00" + // xMin
3223         safeString16(properties.descent) + // yMin
3224         "\x0F\xFF" + // xMax
3225         safeString16(properties.ascent) + // yMax
3226         string16(properties.italicAngle ? 2 : 0) + // macStyle
3227         "\x00\x11" + // lowestRecPPEM
3228         "\x00\x00" + // fontDirectionHint
3229         "\x00\x00" + // indexToLocFormat
3230         "\x00\x00"
3231     ); // glyphDataFormat
3232 
3233     // Horizontal header
3234     builder.addTable(
3235       "hhea",
3236       "\x00\x01\x00\x00" + // Version number
3237         safeString16(properties.ascent) + // Typographic Ascent
3238         safeString16(properties.descent) + // Typographic Descent
3239         "\x00\x00" + // Line Gap
3240         "\xFF\xFF" + // advanceWidthMax
3241         "\x00\x00" + // minLeftSidebearing
3242         "\x00\x00" + // minRightSidebearing
3243         "\x00\x00" + // xMaxExtent
3244         safeString16(properties.capHeight) + // caretSlopeRise
3245         safeString16(Math.tan(properties.italicAngle) * properties.xHeight) + // caretSlopeRun
3246         "\x00\x00" + // caretOffset
3247         "\x00\x00" + // -reserved-
3248         "\x00\x00" + // -reserved-
3249         "\x00\x00" + // -reserved-
3250         "\x00\x00" + // -reserved-
3251         "\x00\x00" + // metricDataFormat
3252         string16(numGlyphs)
3253     ); // Number of HMetrics
3254 
3255     // Horizontal metrics
3256     builder.addTable(
3257       "hmtx",
3258       (function fontFieldsHmtx() {
3259         const charstrings = font.charstrings;
3260         const cffWidths = font.cff ? font.cff.widths : null;
3261         let hmtx = "\x00\x00\x00\x00"; // Fake .notdef
3262         for (let i = 1, ii = numGlyphs; i < ii; i++) {
3263           let width = 0;
3264           if (charstrings) {
3265             const charstring = charstrings[i - 1];
3266             width = "width" in charstring ? charstring.width : 0;
3267           } else if (cffWidths) {
3268             width = Math.ceil(cffWidths[i] || 0);
3269           }
3270           hmtx += string16(width) + string16(0);
3271         }
3272         return hmtx;
3273       })()
3274     );
3275 
3276     // Maximum profile
3277     builder.addTable(
3278       "maxp",
3279       "\x00\x00\x50\x00" + string16(numGlyphs) // Version number
3280     ); // Num of glyphs
3281 
3282     // Naming tables
3283     builder.addTable("name", createNameTable(fontName));
3284 
3285     // PostScript information
3286     builder.addTable("post", createPostTable(properties));
3287 
3288     return builder.toArray();
3289   }
3290 
3505 }
3506 
3526 
</code>

Test file:
<test_file>
File:
test/unit/api_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  AnnotationEditorType,
  AnnotationMode,
  AnnotationType,
  ImageKind,
  InvalidPDFException,
  isNodeJS,
  MissingPDFException,
  objectSize,
  OPS,
  PasswordException,
  PasswordResponses,
  PermissionFlag,
  UnknownErrorException,
} from "../../src/shared/util.js";
import {
  buildGetDocumentParams,
  CMAP_URL,
  createTemporaryNodeServer,
  DefaultFileReaderFactory,
  TEST_PDFS_PATH,
} from "./test_utils.js";
import {
  DefaultCanvasFactory,
  getDocument,
  PDFDataRangeTransport,
  PDFDocumentLoadingTask,
  PDFDocumentProxy,
  PDFPageProxy,
  PDFWorker,
  PDFWorkerUtil,
  RenderTask,
} from "../../src/display/api.js";
import {
  PageViewport,
  RenderingCancelledException,
  StatTimer,
} from "../../src/display/display_utils.js";
import { AutoPrintRegExp } from "../../web/ui_utils.js";
import { GlobalImageCache } from "../../src/core/image_utils.js";
import { GlobalWorkerOptions } from "../../src/display/worker_options.js";
import { Metadata } from "../../src/display/metadata.js";
const WORKER_SRC = "../../build/generic/build/pdf.worker.mjs";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

