Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: Blob URL Error in PDF.js v4.7.76 and Above
### Attach (recommended) or Link to PDF file

I am experiencing an error when trying to read a PDF using a Blob URL with PDF.js version 4.7.76 and above. The error message is as follows:

network.js:276 Uncaught TypeError: Failed to construct 'Headers': Invalid name
    at PDFNetworkStreamFullRequestReader._onHeadersReceived (network.js:276:29)
    at NetworkManager.onStateChange (network.js:119:22)

here is the error i got in version 4.7.76 and latest
![image](https://github.com/user-attachments/assets/cb8e10a1-98fc-4ad7-b758-e74060e3f1fd)

when i using below version its work normally

![image](https://github.com/user-attachments/assets/63c5dffa-6138-4e96-9a95-1c3ccf8c8e3e)


### Web browser and its version

Google Chrome

### Operating system and its version

Windows 11

### PDF.js version

4.7.76 above

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

1. Load a PDF file using a Blob URL with the following code:

`const blob = new Blob([/* PDF data */], { type: 'application/pdf' });
const url = URL.createObjectURL(blob);
pdfjsLib.getDocument(url).promise.then(function(pdf) {
    // Handle PDF loading
});`

2. Observe the console for errors.

### What is the expected behavior?

The PDF should load successfully without any errors.

### What went wrong?

The error message appears in the console, preventing the PDF from loading.

### Link to a viewer

_No response_

### Additional context

_No response_
</issue>

Patch:
<patch>
diff --git a/src/display/network.js b/src/display/network.js
--- a/src/display/network.js
+++ b/src/display/network.js
@@ -288,7 +288,8 @@ class PDFNetworkStreamFullRequestReader {
     const responseHeaders = new Headers(
       rawResponseHeaders
         ? rawResponseHeaders
-            .trim()
+            .trimStart()
+            .replace(/[^\S ]+$/, "") // Not `trimEnd`, to keep regular spaces.
             .split(/[\r\n]+/)
             .map(x => {
               const [key, ...val] = x.split(": ");


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.0
- @babel/preset-env: ^7.26.0
- @babel/runtime: ^7.26.0
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @jazzer.js/core: ^2.1.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.65
- @types/node: ^22.10.1
- autoprefixer: ^10.4.20
- babel-loader: ^9.2.1
- caniuse-lite: ^1.0.30001687
- core-js: ^3.39.0
- eslint: ^9.16.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.2.0
- eslint-plugin-prettier: ^5.2.1
- eslint-plugin-unicorn: ^56.0.1
- globals: ^15.13.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- highlight.js: ^11.10.0
- jasmine: ^5.5.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.4.49
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.4.2
- puppeteer: ^23.10.3
- stylelint: ^16.11.0
- stylelint-prettier: ^5.0.2
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.10
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.7.2
- vinyl: ^3.0.0
- webpack: ^5.97.1
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: fetchData
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/display/network.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import { assert, stringToBytes, warn } from "../shared/util.js";
17 import {
18   createHeaders,
19   createResponseStatusError,
20   extractFilenameFromHeader,
21   getResponseOrigin,
22   validateRangeRequestCapabilities,
23 } from "./network_utils.js";
24 
25 if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) {
26   throw new Error(
27     'Module "./network.js" shall not be used with MOZCENTRAL builds.'
28   );
29 }
30 
31 const OK_RESPONSE = 200;
32 const PARTIAL_CONTENT_RESPONSE = 206;
33 
34 function getArrayBuffer(xhr) {
35   const data = xhr.response;
36   if (typeof data !== "string") {
37     return data;
38   }
39   return stringToBytes(data).buffer;
40 }
41 
42 class NetworkManager {
43   _responseOrigin = null;
44 
45   constructor({ url, httpHeaders, withCredentials }) {
46     this.url = url;
47     this.isHttp = /^https?:/i.test(url);
48     this.headers = createHeaders(this.isHttp, httpHeaders);
49     this.withCredentials = withCredentials || false;
50 
51     this.currXhrId = 0;
52     this.pendingRequests = Object.create(null);
53   }
54 
55   requestRange(begin, end, listeners) {
56     const args = {
57       begin,
58       end,
59     };
60     for (const prop in listeners) {
61       args[prop] = listeners[prop];
62     }
63     return this.request(args);
64   }
65 
66   requestFull(listeners) {
67     return this.request(listeners);
68   }
69 
70   request(args) {
71     const xhr = new XMLHttpRequest();
72     const xhrId = this.currXhrId++;
73     const pendingRequest = (this.pendingRequests[xhrId] = { xhr });
74 
75     xhr.open("GET", this.url);
76     xhr.withCredentials = this.withCredentials;
77     for (const [key, val] of this.headers) {
78       xhr.setRequestHeader(key, val);
79     }
80     if (this.isHttp && "begin" in args && "end" in args) {
81       xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
82       pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
83     } else {
84       pendingRequest.expectedStatus = OK_RESPONSE;
85     }
86     xhr.responseType = "arraybuffer";
87 
88     assert(args.onError, "Expected `onError` callback to be provided.");
89     xhr.onerror = () => {
90       args.onError(xhr.status);
91     };
92     xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
93     xhr.onprogress = this.onProgress.bind(this, xhrId);
94 
95     pendingRequest.onHeadersReceived = args.onHeadersReceived;
96     pendingRequest.onDone = args.onDone;
97     pendingRequest.onError = args.onError;
98     pendingRequest.onProgress = args.onProgress;
99 
100     xhr.send(null);
101 
102     return xhrId;
103   }
104 
105   onProgress(xhrId, evt) {
106     const pendingRequest = this.pendingRequests[xhrId];
107     if (!pendingRequest) {
108       return; // Maybe abortRequest was called...
109     }
110     pendingRequest.onProgress?.(evt);
111   }
112 
113   onStateChange(xhrId, evt) {
114     const pendingRequest = this.pendingRequests[xhrId];
115     if (!pendingRequest) {
116       return; // Maybe abortRequest was called...
117     }
118 
119     const xhr = pendingRequest.xhr;
120     if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
121       pendingRequest.onHeadersReceived();
122       delete pendingRequest.onHeadersReceived;
123     }
124 
125     if (xhr.readyState !== 4) {
126       return;
127     }
128 
129     if (!(xhrId in this.pendingRequests)) {
130       // The XHR request might have been aborted in onHeadersReceived()
131       // callback, in which case we should abort request.
132       return;
133     }
134 
135     delete this.pendingRequests[xhrId];
136 
137     // Success status == 0 can be on ftp, file and other protocols.
138     if (xhr.status === 0 && this.isHttp) {
139       pendingRequest.onError(xhr.status);
140       return;
141     }
142     const xhrStatus = xhr.status || OK_RESPONSE;
143 
144     // From http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.2:
145     // "A server MAY ignore the Range header". This means it's possible to
146     // get a 200 rather than a 206 response from a range request.
147     const ok_response_on_range_request =
148       xhrStatus === OK_RESPONSE &&
149       pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
150 
151     if (
152       !ok_response_on_range_request &&
153       xhrStatus !== pendingRequest.expectedStatus
154     ) {
155       pendingRequest.onError(xhr.status);
156       return;
157     }
158 
159     const chunk = getArrayBuffer(xhr);
160     if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
161       const rangeHeader = xhr.getResponseHeader("Content-Range");
162       const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
163       if (matches) {
164         pendingRequest.onDone({
165           begin: parseInt(matches[1], 10),
166           chunk,
167         });
168       } else {
169         warn(`Missing or invalid "Content-Range" header.`);
170         pendingRequest.onError(0);
171       }
172     } else if (chunk) {
173       pendingRequest.onDone({
174         begin: 0,
175         chunk,
176       });
177     } else {
178       pendingRequest.onError(xhr.status);
179     }
180   }
181 
182   getRequestXhr(xhrId) {
183     return this.pendingRequests[xhrId].xhr;
184   }
185 
186   isPendingRequest(xhrId) {
187     return xhrId in this.pendingRequests;
188   }
189 
190   abortRequest(xhrId) {
191     const xhr = this.pendingRequests[xhrId].xhr;
192     delete this.pendingRequests[xhrId];
193     xhr.abort();
194   }
195 }
196 
197 /** @implements {IPDFStream} */
198 class PDFNetworkStream {
199   constructor(source) {
200     this._source = source;
201     this._manager = new NetworkManager(source);
202     this._rangeChunkSize = source.rangeChunkSize;
203     this._fullRequestReader = null;
204     this._rangeRequestReaders = [];
205   }
206 
207   _onRangeRequestReaderClosed(reader) {
208     const i = this._rangeRequestReaders.indexOf(reader);
209     if (i >= 0) {
210       this._rangeRequestReaders.splice(i, 1);
211     }
212   }
213 
214   getFullReader() {
215     assert(
216       !this._fullRequestReader,
217       "PDFNetworkStream.getFullReader can only be called once."
218     );
219     this._fullRequestReader = new PDFNetworkStreamFullRequestReader(
220       this._manager,
221       this._source
222     );
223     return this._fullRequestReader;
224   }
225 
226   getRangeReader(begin, end) {
227     const reader = new PDFNetworkStreamRangeRequestReader(
228       this._manager,
229       begin,
230       end
231     );
232     reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
233     this._rangeRequestReaders.push(reader);
234     return reader;
235   }
236 
237   cancelAllRequests(reason) {
238     this._fullRequestReader?.cancel(reason);
239 
240     for (const reader of this._rangeRequestReaders.slice(0)) {
241       reader.cancel(reason);
242     }
243   }
244 }
245 
246 /** @implements {IPDFStreamReader} */
247 class PDFNetworkStreamFullRequestReader {
248   constructor(manager, source) {
249     this._manager = manager;
250 
251     const args = {
252       onHeadersReceived: this._onHeadersReceived.bind(this),
253       onDone: this._onDone.bind(this),
254       onError: this._onError.bind(this),
255       onProgress: this._onProgress.bind(this),
256     };
257     this._url = source.url;
258     this._fullRequestId = manager.requestFull(args);
259     this._headersCapability = Promise.withResolvers();
260     this._disableRange = source.disableRange || false;
261     this._contentLength = source.length; // Optional
262     this._rangeChunkSize = source.rangeChunkSize;
263     if (!this._rangeChunkSize && !this._disableRange) {
264       this._disableRange = true;
265     }
266 
267     this._isStreamingSupported = false;
268     this._isRangeSupported = false;
269 
270     this._cachedChunks = [];
271     this._requests = [];
272     this._done = false;
273     this._storedError = undefined;
274     this._filename = null;
275 
276     this.onProgress = null;
277   }
278 
279   _onHeadersReceived() {
280     const fullRequestXhrId = this._fullRequestId;
281     const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
282 
283     this._manager._responseOrigin = getResponseOrigin(
284       fullRequestXhr.responseURL
285     );
286 
287     const rawResponseHeaders = fullRequestXhr.getAllResponseHeaders();
288     const responseHeaders = new Headers(
289       rawResponseHeaders
290         ? rawResponseHeaders
291             .trim()
292             .split(/[\r\n]+/)
293             .map(x => {
294               const [key, ...val] = x.split(": ");
295               return [key, val.join(": ")];
296             })
297         : []
298     );
299 
300     const { allowRangeRequests, suggestedLength } =
301       validateRangeRequestCapabilities({
302         responseHeaders,
303         isHttp: this._manager.isHttp,
304         rangeChunkSize: this._rangeChunkSize,
305         disableRange: this._disableRange,
306       });
307 
308     if (allowRangeRequests) {
309       this._isRangeSupported = true;
310     }
311     // Setting right content length.
312     this._contentLength = suggestedLength || this._contentLength;
313 
314     this._filename = extractFilenameFromHeader(responseHeaders);
315 
316     if (this._isRangeSupported) {
317       // NOTE: by cancelling the full request, and then issuing range
318       // requests, there will be an issue for sites where you can only
319       // request the pdf once. However, if this is the case, then the
320       // server should not be returning that it can support range requests.
321       this._manager.abortRequest(fullRequestXhrId);
322     }
323 
324     this._headersCapability.resolve();
325   }
326 
327   _onDone(data) {
328     if (data) {
329       if (this._requests.length > 0) {
330         const requestCapability = this._requests.shift();
331         requestCapability.resolve({ value: data.chunk, done: false });
332       } else {
333         this._cachedChunks.push(data.chunk);
334       }
335     }
336     this._done = true;
337     if (this._cachedChunks.length > 0) {
338       return;
339     }
340     for (const requestCapability of this._requests) {
341       requestCapability.resolve({ value: undefined, done: true });
342     }
343     this._requests.length = 0;
344   }
345 
346   _onError(status) {
347     this._storedError = createResponseStatusError(status, this._url);
348     this._headersCapability.reject(this._storedError);
349     for (const requestCapability of this._requests) {
350       requestCapability.reject(this._storedError);
351     }
352     this._requests.length = 0;
353     this._cachedChunks.length = 0;
354   }
355 
356   _onProgress(evt) {
357     this.onProgress?.({
358       loaded: evt.loaded,
359       total: evt.lengthComputable ? evt.total : this._contentLength,
360     });
361   }
362 
363   get filename() {
364     return this._filename;
365   }
366 
367   get isRangeSupported() {
368     return this._isRangeSupported;
369   }
370 
371   get isStreamingSupported() {
372     return this._isStreamingSupported;
373   }
374 
375   get contentLength() {
376     return this._contentLength;
377   }
378 
379   get headersReady() {
380     return this._headersCapability.promise;
381   }
382 
383   async read() {
384     await this._headersCapability.promise;
385 
386     if (this._storedError) {
387       throw this._storedError;
388     }
389     if (this._cachedChunks.length > 0) {
390       const chunk = this._cachedChunks.shift();
391       return { value: chunk, done: false };
392     }
393     if (this._done) {
394       return { value: undefined, done: true };
395     }
396     const requestCapability = Promise.withResolvers();
397     this._requests.push(requestCapability);
398     return requestCapability.promise;
399   }
400 
401   cancel(reason) {
402     this._done = true;
403     this._headersCapability.reject(reason);
404     for (const requestCapability of this._requests) {
405       requestCapability.resolve({ value: undefined, done: true });
406     }
407     this._requests.length = 0;
408     if (this._manager.isPendingRequest(this._fullRequestId)) {
409       this._manager.abortRequest(this._fullRequestId);
410     }
411     this._fullRequestReader = null;
412   }
413 }
414 
415 /** @implements {IPDFStreamRangeReader} */
416 class PDFNetworkStreamRangeRequestReader {
417   constructor(manager, begin, end) {
418     this._manager = manager;
419 
420     const args = {
421       onHeadersReceived: this._onHeadersReceived.bind(this),
422       onDone: this._onDone.bind(this),
423       onError: this._onError.bind(this),
424       onProgress: this._onProgress.bind(this),
425     };
426     this._url = manager.url;
427     this._requestId = manager.requestRange(begin, end, args);
428     this._requests = [];
429     this._queuedChunk = null;
430     this._done = false;
431     this._storedError = undefined;
432 
433     this.onProgress = null;
434     this.onClosed = null;
435   }
436 
437   _onHeadersReceived() {
438     const responseOrigin = getResponseOrigin(
439       this._manager.getRequestXhr(this._requestId)?.responseURL
440     );
441 
442     if (responseOrigin !== this._manager._responseOrigin) {
443       this._storedError = new Error(
444         `Expected range response-origin "${responseOrigin}" to match "${this._manager._responseOrigin}".`
445       );
446       this._onError(0);
447     }
448   }
449 
450   _close() {
451     this.onClosed?.(this);
452   }
453 
454   _onDone(data) {
455     const chunk = data.chunk;
456     if (this._requests.length > 0) {
457       const requestCapability = this._requests.shift();
458       requestCapability.resolve({ value: chunk, done: false });
459     } else {
460       this._queuedChunk = chunk;
461     }
462     this._done = true;
463     for (const requestCapability of this._requests) {
464       requestCapability.resolve({ value: undefined, done: true });
465     }
466     this._requests.length = 0;
467     this._close();
468   }
469 
470   _onError(status) {
471     this._storedError ??= createResponseStatusError(status, this._url);
472     for (const requestCapability of this._requests) {
473       requestCapability.reject(this._storedError);
474     }
475     this._requests.length = 0;
476     this._queuedChunk = null;
477   }
478 
479   _onProgress(evt) {
480     if (!this.isStreamingSupported) {
481       this.onProgress?.({ loaded: evt.loaded });
482     }
483   }
484 
485   get isStreamingSupported() {
486     return false;
487   }
488 
489   async read() {
490     if (this._storedError) {
491       throw this._storedError;
492     }
493     if (this._queuedChunk !== null) {
494       const chunk = this._queuedChunk;
495       this._queuedChunk = null;
496       return { value: chunk, done: false };
497     }
498     if (this._done) {
499       return { value: undefined, done: true };
500     }
501     const requestCapability = Promise.withResolvers();
502     this._requests.push(requestCapability);
503     return requestCapability.promise;
504   }
505 
506   cancel(reason) {
507     this._done = true;
508     for (const requestCapability of this._requests) {
509       requestCapability.resolve({ value: undefined, done: true });
510     }
511     this._requests.length = 0;
512     if (this._manager.isPendingRequest(this._requestId)) {
513       this._manager.abortRequest(this._requestId);
514     }
515     this._close();
516   }
517 }
518 
519 export { PDFNetworkStream };
</code>

Test file:
<test_file>
File:
test/unit/network_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  AbortException,
  UnexpectedResponseException,
} from "../../src/shared/util.js";
import { PDFNetworkStream } from "../../src/display/network.js";
import { testCrossOriginRedirects } from "./common_pdfstream_tests.js";
import { TestPdfsServer } from "./test_utils.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

