Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: Text not shown, as browser.display.use_document_fonts is set to 0
### Attach (recommended) or Link to PDF file

https://www.jma.go.jp/jma/press/2507/04a/20250704_asosan.pdf

### Web browser and its version

Firefox 140.0.4 (64bit)

### Operating system and its version

Windows 10 (version 22H2) (64bit)

### PDF.js version

v5.3.93

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

1. Launch Firefox.
2. Open `about:config` and change `browser.display.use_document_fonts` to 0.
3. Open link of PDF file.

### What is the expected behavior?

All texts are visible.

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/99101deb-866b-4b08-adad-1dfe4d3ddf84" />

### What went wrong?

Some texts are hidden, only letter spaces are visible.

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/e3291465-86ed-439c-8b49-226fbde5cc80" />

### Link to a viewer

_No response_

### Additional context

Error message is here.
```
Web fonts are disabled: unable to use embedded PDF fonts. viewer.mjs:13745:17
分離された Cookie またはストレージアクセスが “https://www.jma.go.jp/jma/press/2507/04a/20250704_asosan.pdf” に提供されました。これはサードパーティのコンテキスト内で読み込まれ、動的状態分離が有効なためです。 pdf.mjs:10872:22
(In English, Isolated cookie or storage access was provided to “https://www.jma.go.jp/jma/press/2507/04a/20250704_asosan.pdf” because it is loaded within a third-party context and dynamic state isolation is enabled. pdf.mjs:10872:22)
PDF c8e728554e650f243ca1e325387ebd45 [1.4 JUST PDF 4 / -] (PDF.js: 5.2.183 [3f1ecc1ba]) viewer.mjs:14280:13
Warning: getPathGenerator - ignoring character: "Error: Requesting object that isn't resolved yet BIZUD�S�V�b�N_path_阿.". pdf.mjs:323:13
Warning: getPathGenerator - ignoring character: "Error: Requesting object that isn't resolved yet BIZUD�S�V�b�N_path_蘇.". pdf.mjs:323:13
Warning: getPathGenerator - ignoring character: "Error: Requesting object that isn't resolved yet BIZUD�S�V�b�N_path_山.". pdf.mjs:323:13
continued...
```
Continued are same mean messages, that fonts (example above "BIZUD�S�V�b�N"(mojibake)) and last letters (example above "阿","蘇","山") are different.
</issue>

Patch:
<patch>
diff --git a/src/display/canvas.js b/src/display/canvas.js
--- a/src/display/canvas.js
+++ b/src/display/canvas.js
@@ -1625,6 +1625,9 @@ class CanvasGraphics {
     const newPath = new Path2D();
     const invTransf = ctx.getTransform().invertSelf();
     for (const { transform, x, y, fontSize, path } of paths) {
+      if (!path) {
+        continue; // Skip empty paths.
+      }
       newPath.addPath(
         path,
         new DOMMatrix(transform)
@@ -1768,15 +1771,16 @@ class CanvasGraphics {
 
     let path;
     if (
-      font.disableFontFace ||
-      isAddToPathSet ||
-      patternFill ||
-      patternStroke
+      (font.disableFontFace ||
+        isAddToPathSet ||
+        patternFill ||
+        patternStroke) &&
+      !font.missingFile
     ) {
       path = font.getPathGenerator(this.commonObjs, character);
     }
 
-    if (font.disableFontFace || patternFill || patternStroke) {
+    if (path && (font.disableFontFace || patternFill || patternStroke)) {
       ctx.save();
       ctx.translate(x, y);
       ctx.scale(fontSize, -fontSize);


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.28.0
- @babel/preset-env: ^7.28.0
- @babel/runtime: ^7.27.6
- @csstools/postcss-light-dark-function: ^2.0.9
- @fluent/bundle: ^0.19.1
- @fluent/dom: ^0.10.1
- @metalsmith/layouts: ^3.0.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.73
- @types/node: ^24.0.13
- autoprefixer: ^10.4.21
- babel-loader: ^10.0.0
- caniuse-lite: ^1.0.30001727
- core-js: ^3.44.0
- eslint: ^9.31.0
- eslint-plugin-import: ^2.32.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.15.0
- eslint-plugin-prettier: ^5.5.1
- eslint-plugin-unicorn: ^59.0.1
- globals: ^16.3.0
- gulp: ^5.0.1
- gulp-cli: ^3.1.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.1.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.8.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.7
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.5.6
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.4
- postcss-nesting: ^13.0.2
- prettier: ^3.6.2
- puppeteer: ^24.12.1
- stylelint: ^16.21.1
- stylelint-prettier: ^5.0.3
- svglint: ^4.1.0
- terser-webpack-plugin: ^5.3.14
- tsc-alias: ^1.8.16
- ttest: ^4.0.0
- typescript: ^5.8.3
- vinyl: ^3.0.1
- webpack: ^5.100.1
- webpack-stream: ^7.0.0
- yargs: ^18.0.0

Engines:
- node: >=20.16.0 || >=22.3.0

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/calculate_md5.js`: calculateMD5
- `../../src/core/calculate_sha256.js`: calculateSHA256
- `../../src/core/calculate_sha_other.js`: calculateSHA384, calculateSHA512
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/colorspace_utils.js`: ColorSpaceUtils
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalColorSpaceCache, GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, version
- `../../src/display/api_utils.js`: LoopbackPort, isValidExplicitDest
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/cmap_reader_factory.js`: DOMCMapReaderFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, SupportedImageMimeTypes, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getRGB, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/drawers/signaturedraw.js`: SignatureExtractor
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodeCMapReaderFactory, NodeStandardFontDataFactory, fetchData
- `../../src/display/standard_fontdata_factory.js`: DOMStandardFontDataFactory
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, DrawOPS, FeatureTest, FormatError, ImageKind, InvalidPDFException, MathClamp, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, ResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util, updateUrlHash
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/autolinker.js`: Autolinker
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultCMapReaderFactory, DefaultFileReaderFactory, DefaultStandardFontDataFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/display/canvas.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   DrawOPS,
18   FeatureTest,
19   FONT_IDENTITY_MATRIX,
20   ImageKind,
21   info,
22   OPS,
23   shadow,
24   TextRenderingMode,
25   unreachable,
26   Util,
27   warn,
28 } from "../shared/util.js";
29 import {
30   getCurrentTransform,
31   getCurrentTransformInverse,
32   OutputScale,
33   PixelsPerInch,
34 } from "./display_utils.js";
35 import {
36   getShadingPattern,
37   PathType,
38   TilingPattern,
39 } from "./pattern_helper.js";
40 import { convertBlackAndWhiteToRGBA } from "../shared/image_utils.js";
41 
42 // <canvas> contexts store most of the state we need natively.
43 // However, PDF needs a bit more state, which we store here.
44 // Minimal font size that would be used during canvas fillText operations.
45 const MIN_FONT_SIZE = 16;
46 // Maximum font size that would be used during canvas fillText operations.
47 const MAX_FONT_SIZE = 100;
48 
49 // Defines the time the `executeOperatorList`-method is going to be executing
50 // before it stops and schedules a continue of execution.
51 const EXECUTION_TIME = 15; // ms
52 // Defines the number of steps before checking the execution time.
53 const EXECUTION_STEPS = 10;
54 
55 const FULL_CHUNK_HEIGHT = 16;
56 
57 // Only used in rescaleAndStroke. The goal is to avoid
58 // creating a new DOMMatrix object each time we need it.
59 const SCALE_MATRIX = new DOMMatrix();
60 
61 // Used to get some coordinates.
62 const XY = new Float32Array(2);
63 
64 // Initial rectangle values for the minMax array.
65 const MIN_MAX_INIT = new Float32Array([
66   Infinity,
67   Infinity,
68   -Infinity,
69   -Infinity,
70 ]);
71 
72 /**
73  * Overrides certain methods on a 2d ctx so that when they are called they
74  * will also call the same method on the destCtx. The methods that are
75  * overridden are all the transformation state modifiers, path creation, and
76  * save/restore. We only forward these specific methods because they are the
77  * only state modifiers that we cannot copy over when we switch contexts.
78  *
79  * To remove mirroring call `ctx._removeMirroring()`.
80  *
81  * @param {Object} ctx - The 2d canvas context that will duplicate its calls on
82  *   the destCtx.
83  * @param {Object} destCtx - The 2d canvas context that will receive the
84  *   forwarded calls.
85  */
86 function mirrorContextOperations(ctx, destCtx) {
87   if (ctx._removeMirroring) {
88     throw new Error("Context is already forwarding operations.");
89   }
90   ctx.__originalSave = ctx.save;
91   ctx.__originalRestore = ctx.restore;
92   ctx.__originalRotate = ctx.rotate;
93   ctx.__originalScale = ctx.scale;
94   ctx.__originalTranslate = ctx.translate;
95   ctx.__originalTransform = ctx.transform;
96   ctx.__originalSetTransform = ctx.setTransform;
97   ctx.__originalResetTransform = ctx.resetTransform;
98   ctx.__originalClip = ctx.clip;
99   ctx.__originalMoveTo = ctx.moveTo;
100   ctx.__originalLineTo = ctx.lineTo;
101   ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
102   ctx.__originalRect = ctx.rect;
103   ctx.__originalClosePath = ctx.closePath;
104   ctx.__originalBeginPath = ctx.beginPath;
105 
106   ctx._removeMirroring = () => {
107     ctx.save = ctx.__originalSave;
108     ctx.restore = ctx.__originalRestore;
109     ctx.rotate = ctx.__originalRotate;
110     ctx.scale = ctx.__originalScale;
111     ctx.translate = ctx.__originalTranslate;
112     ctx.transform = ctx.__originalTransform;
113     ctx.setTransform = ctx.__originalSetTransform;
114     ctx.resetTransform = ctx.__originalResetTransform;
115 
116     ctx.clip = ctx.__originalClip;
117     ctx.moveTo = ctx.__originalMoveTo;
118     ctx.lineTo = ctx.__originalLineTo;
119     ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
120     ctx.rect = ctx.__originalRect;
121     ctx.closePath = ctx.__originalClosePath;
122     ctx.beginPath = ctx.__originalBeginPath;
123     delete ctx._removeMirroring;
124   };
125 
126   ctx.save = function () {
127     destCtx.save();
128     this.__originalSave();
129   };
130 
131   ctx.restore = function () {
132     destCtx.restore();
133     this.__originalRestore();
134   };
135 
136   ctx.translate = function (x, y) {
137     destCtx.translate(x, y);
138     this.__originalTranslate(x, y);
139   };
140 
141   ctx.scale = function (x, y) {
142     destCtx.scale(x, y);
143     this.__originalScale(x, y);
144   };
145 
146   ctx.transform = function (a, b, c, d, e, f) {
147     destCtx.transform(a, b, c, d, e, f);
148     this.__originalTransform(a, b, c, d, e, f);
149   };
150 
151   ctx.setTransform = function (a, b, c, d, e, f) {
152     destCtx.setTransform(a, b, c, d, e, f);
153     this.__originalSetTransform(a, b, c, d, e, f);
154   };
155 
156   ctx.resetTransform = function () {
157     destCtx.resetTransform();
158     this.__originalResetTransform();
159   };
160 
161   ctx.rotate = function (angle) {
162     destCtx.rotate(angle);
163     this.__originalRotate(angle);
164   };
165 
166   ctx.clip = function (rule) {
167     destCtx.clip(rule);
168     this.__originalClip(rule);
169   };
170 
171   ctx.moveTo = function (x, y) {
172     destCtx.moveTo(x, y);
173     this.__originalMoveTo(x, y);
174   };
175 
176   ctx.lineTo = function (x, y) {
177     destCtx.lineTo(x, y);
178     this.__originalLineTo(x, y);
179   };
180 
181   ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
182     destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
183     this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
184   };
185 
186   ctx.rect = function (x, y, width, height) {
187     destCtx.rect(x, y, width, height);
188     this.__originalRect(x, y, width, height);
189   };
190 
191   ctx.closePath = function () {
192     destCtx.closePath();
193     this.__originalClosePath();
194   };
195 
196   ctx.beginPath = function () {
197     destCtx.beginPath();
198     this.__originalBeginPath();
199   };
200 }
201 
202 class CachedCanvases {
203   constructor(canvasFactory) {
204     this.canvasFactory = canvasFactory;
205     this.cache = Object.create(null);
206   }
207 
208   getCanvas(id, width, height) {
209     let canvasEntry;
210     if (this.cache[id] !== undefined) {
211       canvasEntry = this.cache[id];
212       this.canvasFactory.reset(canvasEntry, width, height);
213     } else {
214       canvasEntry = this.canvasFactory.create(width, height);
215       this.cache[id] = canvasEntry;
216     }
217     return canvasEntry;
218   }
219 
220   delete(id) {
221     delete this.cache[id];
222   }
223 
224   clear() {
225     for (const id in this.cache) {
226       const canvasEntry = this.cache[id];
227       this.canvasFactory.destroy(canvasEntry);
228       delete this.cache[id];
229     }
230   }
231 }
232 
233 function drawImageAtIntegerCoords(
234   ctx,
235   srcImg,
236   srcX,
237   srcY,
238   srcW,
239   srcH,
240   destX,
241   destY,
242   destW,
243   destH
244 ) {
245   const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);
246   if (b === 0 && c === 0) {
247     // top-left corner is at (X, Y) and
248     // bottom-right one is at (X + width, Y + height).
249 
250     // If leftX is 4.321 then it's rounded to 4.
251     // If width is 10.432 then it's rounded to 11 because
252     // rightX = leftX + width = 14.753 which is rounded to 15
253     // so after rounding the total width is 11 (15 - 4).
254     // It's why we can't just floor/ceil uniformly, it just depends
255     // on the values we've.
256 
257     const tlX = destX * a + tx;
258     const rTlX = Math.round(tlX);
259     const tlY = destY * d + ty;
260     const rTlY = Math.round(tlY);
261     const brX = (destX + destW) * a + tx;
262 
263     // Some pdf contains images with 1x1 images so in case of 0-width after
264     // scaling we must fallback on 1 to be sure there is something.
265     const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
266     const brY = (destY + destH) * d + ty;
267     const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
268 
269     // We must apply a transformation in order to apply it on the image itself.
270     // For example if a == 1 && d == -1, it means that the image itself is
271     // mirrored w.r.t. the x-axis.
272     ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
273     ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
274     ctx.setTransform(a, b, c, d, tx, ty);
275 
276     return [rWidth, rHeight];
277   }
278 
279   if (a === 0 && d === 0) {
280     // This path is taken in issue9462.pdf (page 3).
281     const tlX = destY * c + tx;
282     const rTlX = Math.round(tlX);
283     const tlY = destX * b + ty;
284     const rTlY = Math.round(tlY);
285     const brX = (destY + destH) * c + tx;
286     const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
287     const brY = (destX + destW) * b + ty;
288     const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
289 
290     ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
291     ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
292     ctx.setTransform(a, b, c, d, tx, ty);
293 
294     return [rHeight, rWidth];
295   }
296 
297   // Not a scale matrix so let the render handle the case without rounding.
298   ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
299 
300   const scaleX = Math.hypot(a, b);
301   const scaleY = Math.hypot(c, d);
302   return [scaleX * destW, scaleY * destH];
303 }
304 
305 class CanvasExtraState {
306   // Are soft masks and alpha values shapes or opacities?
307   alphaIsShape = false;
308 
309   fontSize = 0;
310 
311   fontSizeScale = 1;
312 
313   textMatrix = null;
314 
315   textMatrixScale = 1;
316 
317   fontMatrix = FONT_IDENTITY_MATRIX;
318 
319   leading = 0;
320 
321   // Current point (in user coordinates)
322   x = 0;
323 
324   y = 0;
325 
326   // Start of text line (in text coordinates)
327   lineX = 0;
328 
329   lineY = 0;
330 
331   // Character and word spacing
332   charSpacing = 0;
333 
334   wordSpacing = 0;
335 
336   textHScale = 1;
337 
338   textRenderingMode = TextRenderingMode.FILL;
339 
340   textRise = 0;
341 
342   // Default fore and background colors
343   fillColor = "#000000";
344 
345   strokeColor = "#000000";
346 
347   patternFill = false;
348 
349   patternStroke = false;
350 
351   // Note: fill alpha applies to all non-stroking operations
352   fillAlpha = 1;
353 
354   strokeAlpha = 1;
355 
356   lineWidth = 1;
357 
358   activeSMask = null;
359 
360   transferMaps = "none";
361 
362   constructor(width, height) {
363     this.clipBox = new Float32Array([0, 0, width, height]);
364     this.minMax = MIN_MAX_INIT.slice();
365   }
366 
367   clone() {
368     const clone = Object.create(this);
369     clone.clipBox = this.clipBox.slice();
370     clone.minMax = this.minMax.slice();
371     return clone;
372   }
373 
374   getPathBoundingBox(pathType = PathType.FILL, transform = null) {
375     const box = this.minMax.slice();
376     if (pathType === PathType.STROKE) {
377       if (!transform) {
378         unreachable("Stroke bounding box must include transform.");
379       }
380       // Stroked paths can be outside of the path bounding box by 1/2 the line
381       // width.
382       Util.singularValueDecompose2dScale(transform, XY);
383       const xStrokePad = (XY[0] * this.lineWidth) / 2;
384       const yStrokePad = (XY[1] * this.lineWidth) / 2;
385       box[0] -= xStrokePad;
386       box[1] -= yStrokePad;
387       box[2] += xStrokePad;
388       box[3] += yStrokePad;
389     }
390     return box;
391   }
392 
393   updateClipFromPath() {
394     const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());
395     this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
396   }
397 
398   isEmptyClip() {
399     return this.minMax[0] === Infinity;
400   }
401 
402   startNewPathAndClipBox(box) {
403     this.clipBox.set(box, 0);
404     this.minMax.set(MIN_MAX_INIT, 0);
405   }
406 
407   getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {
408     return Util.intersect(
409       this.clipBox,
410       this.getPathBoundingBox(pathType, transform)
411     );
412   }
413 }
414 
415 function putBinaryImageData(ctx, imgData) {
416   if (imgData instanceof ImageData) {
417     ctx.putImageData(imgData, 0, 0);
418     return;
419   }
420 
421   // Put the image data to the canvas in chunks, rather than putting the
422   // whole image at once.  This saves JS memory, because the ImageData object
423   // is smaller. It also possibly saves C++ memory within the implementation
424   // of putImageData(). (E.g. in Firefox we make two short-lived copies of
425   // the data passed to putImageData()). |n| shouldn't be too small, however,
426   // because too many putImageData() calls will slow things down.
427   //
428   // Note: as written, if the last chunk is partial, the putImageData() call
429   // will (conceptually) put pixels past the bounds of the canvas.  But
430   // that's ok; any such pixels are ignored.
431 
432   const height = imgData.height,
433     width = imgData.width;
434   const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
435   const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
436   const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
437 
438   const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
439   let srcPos = 0,
440     destPos;
441   const src = imgData.data;
442   const dest = chunkImgData.data;
443   let i, j, thisChunkHeight, elemsInThisChunk;
444 
445   // There are multiple forms in which the pixel data can be passed, and
446   // imgData.kind tells us which one this is.
447   if (imgData.kind === ImageKind.GRAYSCALE_1BPP) {
448     // Grayscale, 1 bit per pixel (i.e. black-and-white).
449     const srcLength = src.byteLength;
450     const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
451     const dest32DataLength = dest32.length;
452     const fullSrcDiff = (width + 7) >> 3;
453     const white = 0xffffffff;
454     const black = FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;
455 
456     for (i = 0; i < totalChunks; i++) {
457       thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
458       destPos = 0;
459       for (j = 0; j < thisChunkHeight; j++) {
460         const srcDiff = srcLength - srcPos;
461         let k = 0;
462         const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
463         const kEndUnrolled = kEnd & ~7;
464         let mask = 0;
465         let srcByte = 0;
466         for (; k < kEndUnrolled; k += 8) {
467           srcByte = src[srcPos++];
468           dest32[destPos++] = srcByte & 128 ? white : black;
469           dest32[destPos++] = srcByte & 64 ? white : black;
470           dest32[destPos++] = srcByte & 32 ? white : black;
471           dest32[destPos++] = srcByte & 16 ? white : black;
472           dest32[destPos++] = srcByte & 8 ? white : black;
473           dest32[destPos++] = srcByte & 4 ? white : black;
474           dest32[destPos++] = srcByte & 2 ? white : black;
475           dest32[destPos++] = srcByte & 1 ? white : black;
476         }
477         for (; k < kEnd; k++) {
478           if (mask === 0) {
479             srcByte = src[srcPos++];
480             mask = 128;
481           }
482 
483           dest32[destPos++] = srcByte & mask ? white : black;
484           mask >>= 1;
485         }
486       }
487       // We ran out of input. Make all remaining pixels transparent.
488       while (destPos < dest32DataLength) {
489         dest32[destPos++] = 0;
490       }
491 
492       ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
493     }
494   } else if (imgData.kind === ImageKind.RGBA_32BPP) {
495     // RGBA, 32-bits per pixel.
496     j = 0;
497     elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
498     for (i = 0; i < fullChunks; i++) {
499       dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
500       srcPos += elemsInThisChunk;
501 
502       ctx.putImageData(chunkImgData, 0, j);
503       j += FULL_CHUNK_HEIGHT;
504     }
505     if (i < totalChunks) {
506       elemsInThisChunk = width * partialChunkHeight * 4;
507       dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
508 
509       ctx.putImageData(chunkImgData, 0, j);
510     }
511   } else if (imgData.kind === ImageKind.RGB_24BPP) {
512     // RGB, 24-bits per pixel.
513     thisChunkHeight = FULL_CHUNK_HEIGHT;
514     elemsInThisChunk = width * thisChunkHeight;
515     for (i = 0; i < totalChunks; i++) {
516       if (i >= fullChunks) {
517         thisChunkHeight = partialChunkHeight;
518         elemsInThisChunk = width * thisChunkHeight;
519       }
520 
521       destPos = 0;
522       for (j = elemsInThisChunk; j--; ) {
523         dest[destPos++] = src[srcPos++];
524         dest[destPos++] = src[srcPos++];
525         dest[destPos++] = src[srcPos++];
526         dest[destPos++] = 255;
527       }
528 
529       ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
530     }
531   } else {
532     throw new Error(`bad image kind: ${imgData.kind}`);
533   }
534 }
535 
536 function putBinaryImageMask(ctx, imgData) {
537   if (imgData.bitmap) {
538     // The bitmap has been created in the worker.
539     ctx.drawImage(imgData.bitmap, 0, 0);
540     return;
541   }
542 
543   // Slow path: OffscreenCanvas isn't available in the worker.
544   const height = imgData.height,
545     width = imgData.width;
546   const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
547   const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
548   const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
549 
550   const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
551   let srcPos = 0;
552   const src = imgData.data;
553   const dest = chunkImgData.data;
554 
555   for (let i = 0; i < totalChunks; i++) {
556     const thisChunkHeight =
557       i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
558 
559     // Expand the mask so it can be used by the canvas.  Any required
560     // inversion has already been handled.
561 
562     ({ srcPos } = convertBlackAndWhiteToRGBA({
563       src,
564       srcPos,
565       dest,
566       width,
567       height: thisChunkHeight,
568       nonBlackColor: 0,
569     }));
570 
571     ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
572   }
573 }
574 
575 function copyCtxState(sourceCtx, destCtx) {
576   const properties = [
577     "strokeStyle",
578     "fillStyle",
579     "fillRule",
580     "globalAlpha",
581     "lineWidth",
582     "lineCap",
583     "lineJoin",
584     "miterLimit",
585     "globalCompositeOperation",
586     "font",
587     "filter",
588   ];
589   for (const property of properties) {
590     if (sourceCtx[property] !== undefined) {
591       destCtx[property] = sourceCtx[property];
592     }
593   }
594   if (sourceCtx.setLineDash !== undefined) {
595     destCtx.setLineDash(sourceCtx.getLineDash());
596     destCtx.lineDashOffset = sourceCtx.lineDashOffset;
597   }
598 }
599 
600 function resetCtxToDefault(ctx) {
601   ctx.strokeStyle = ctx.fillStyle = "#000000";
602   ctx.fillRule = "nonzero";
603   ctx.globalAlpha = 1;
604   ctx.lineWidth = 1;
605   ctx.lineCap = "butt";
606   ctx.lineJoin = "miter";
607   ctx.miterLimit = 10;
608   ctx.globalCompositeOperation = "source-over";
609   ctx.font = "10px sans-serif";
610   if (ctx.setLineDash !== undefined) {
611     ctx.setLineDash([]);
612     ctx.lineDashOffset = 0;
613   }
614   const { filter } = ctx;
615   if (filter !== "none" && filter !== "") {
616     ctx.filter = "none";
617   }
618 }
619 
620 function getImageSmoothingEnabled(transform, interpolate) {
621   // In section 8.9.5.3 of the PDF spec, it's mentioned that the interpolate
622   // flag should be used when the image is upscaled.
623   // In Firefox, smoothing is always used when downscaling images (bug 1360415).
624 
625   if (interpolate) {
626     return true;
627   }
628 
629   Util.singularValueDecompose2dScale(transform, XY);
630   // Round to a 32bit float so that `<=` check below will pass for numbers that
631   // are very close, but not exactly the same 64bit floats.
632   const actualScale = Math.fround(
633     OutputScale.pixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS
634   );
635   // `XY` is a Float32Array.
636   return XY[0] <= actualScale && XY[1] <= actualScale;
637 }
638 
639 const LINE_CAP_STYLES = ["butt", "round", "square"];
640 const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
641 const NORMAL_CLIP = {};
642 const EO_CLIP = {};
643 
644 class CanvasGraphics {
645   constructor(
646     canvasCtx,
647     commonObjs,
648     objs,
649     canvasFactory,
650     filterFactory,
651     { optionalContentConfig, markedContentStack = null },
652     annotationCanvasMap,
653     pageColors
654   ) {
655     this.ctx = canvasCtx;
656     this.current = new CanvasExtraState(
657       this.ctx.canvas.width,
658       this.ctx.canvas.height
659     );
660     this.stateStack = [];
661     this.pendingClip = null;
662     this.pendingEOFill = false;
663     this.res = null;
664     this.xobjs = null;
665     this.commonObjs = commonObjs;
666     this.objs = objs;
667     this.canvasFactory = canvasFactory;
668     this.filterFactory = filterFactory;
669     this.groupStack = [];
670     // Patterns are painted relative to the initial page/form transform, see
671     // PDF spec 8.7.2 NOTE 1.
672     this.baseTransform = null;
673     this.baseTransformStack = [];
674     this.groupLevel = 0;
675     this.smaskStack = [];
676     this.smaskCounter = 0;
677     this.tempSMask = null;
678     this.suspendedCtx = null;
679     this.contentVisible = true;
680     this.markedContentStack = markedContentStack || [];
681     this.optionalContentConfig = optionalContentConfig;
682     this.cachedCanvases = new CachedCanvases(this.canvasFactory);
683     this.cachedPatterns = new Map();
684     this.annotationCanvasMap = annotationCanvasMap;
685     this.viewportScale = 1;
686     this.outputScaleX = 1;
687     this.outputScaleY = 1;
688     this.pageColors = pageColors;
689 
690     this._cachedScaleForStroking = [-1, 0];
691     this._cachedGetSinglePixelWidth = null;
692     this._cachedBitmapsMap = new Map();
693   }
694 
695   getObject(data, fallback = null) {
696     if (typeof data === "string") {
697       return data.startsWith("g_")
698         ? this.commonObjs.get(data)
699         : this.objs.get(data);
700     }
701     return fallback;
702   }
703 
704   beginDrawing({
705     transform,
706     viewport,
707     transparency = false,
708     background = null,
709   }) {
710     // For pdfs that use blend modes we have to clear the canvas else certain
711     // blend modes can look wrong since we'd be blending with a white
712     // backdrop. The problem with a transparent backdrop though is we then
713     // don't get sub pixel anti aliasing on text, creating temporary
714     // transparent canvas when we have blend modes.
715     const width = this.ctx.canvas.width;
716     const height = this.ctx.canvas.height;
717 
718     const savedFillStyle = this.ctx.fillStyle;
719     this.ctx.fillStyle = background || "#ffffff";
720     this.ctx.fillRect(0, 0, width, height);
721     this.ctx.fillStyle = savedFillStyle;
722 
723     if (transparency) {
724       const transparentCanvas = this.cachedCanvases.getCanvas(
725         "transparent",
726         width,
727         height
728       );
729       this.compositeCtx = this.ctx;
730       this.transparentCanvas = transparentCanvas.canvas;
731       this.ctx = transparentCanvas.context;
732       this.ctx.save();
733       // The transform can be applied before rendering, transferring it to
734       // the new canvas.
735       this.ctx.transform(...getCurrentTransform(this.compositeCtx));
736     }
737 
738     this.ctx.save();
739     resetCtxToDefault(this.ctx);
740     if (transform) {
741       this.ctx.transform(...transform);
742       this.outputScaleX = transform[0];
743       this.outputScaleY = transform[0];
744     }
745     this.ctx.transform(...viewport.transform);
746     this.viewportScale = viewport.scale;
747 
748     this.baseTransform = getCurrentTransform(this.ctx);
749   }
750 
751   executeOperatorList(
752     operatorList,
753     executionStartIdx,
754     continueCallback,
755     stepper
756   ) {
757     const argsArray = operatorList.argsArray;
758     const fnArray = operatorList.fnArray;
759     let i = executionStartIdx || 0;
760     const argsArrayLen = argsArray.length;
761 
762     // Sometimes the OperatorList to execute is empty.
763     if (argsArrayLen === i) {
764       return i;
765     }
766 
767     const chunkOperations =
768       argsArrayLen - i > EXECUTION_STEPS &&
769       typeof continueCallback === "function";
770     const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
771     let steps = 0;
772 
773     const commonObjs = this.commonObjs;
774     const objs = this.objs;
775     let fnId;
776 
777     while (true) {
778       if (stepper !== undefined && i === stepper.nextBreakPoint) {
779         stepper.breakIt(i, continueCallback);
780         return i;
781       }
782 
783       fnId = fnArray[i];
784 
785       if (fnId !== OPS.dependency) {
786         // eslint-disable-next-line prefer-spread
787         this[fnId].apply(this, argsArray[i]);
788       } else {
789         for (const depObjId of argsArray[i]) {
790           const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
791 
792           // If the promise isn't resolved yet, add the continueCallback
793           // to the promise and bail out.
794           if (!objsPool.has(depObjId)) {
795             objsPool.get(depObjId, continueCallback);
796             return i;
797           }
798         }
799       }
800 
801       i++;
802 
803       // If the entire operatorList was executed, stop as were done.
804       if (i === argsArrayLen) {
805         return i;
806       }
807 
808       // If the execution took longer then a certain amount of time and
809       // `continueCallback` is specified, interrupt the execution.
810       if (chunkOperations && ++steps > EXECUTION_STEPS) {
811         if (Date.now() > endTime) {
812           continueCallback();
813           return i;
814         }
815         steps = 0;
816       }
817 
818       // If the operatorList isn't executed completely yet OR the execution
819       // time was short enough, do another execution round.
820     }
821   }
822 
823   #restoreInitialState() {
824     // Finishing all opened operations such as SMask group painting.
825     while (this.stateStack.length || this.inSMaskMode) {
826       this.restore();
827     }
828 
829     this.current.activeSMask = null;
830     this.ctx.restore();
831 
832     if (this.transparentCanvas) {
833       this.ctx = this.compositeCtx;
834       this.ctx.save();
835       this.ctx.setTransform(1, 0, 0, 1, 0, 0); // Avoid apply transform twice
836       this.ctx.drawImage(this.transparentCanvas, 0, 0);
837       this.ctx.restore();
838       this.transparentCanvas = null;
839     }
840   }
841 
842   endDrawing() {
843     this.#restoreInitialState();
844 
845     this.cachedCanvases.clear();
846     this.cachedPatterns.clear();
847 
848     for (const cache of this._cachedBitmapsMap.values()) {
849       for (const canvas of cache.values()) {
850         if (
851           typeof HTMLCanvasElement !== "undefined" &&
852           canvas instanceof HTMLCanvasElement
853         ) {
854           canvas.width = canvas.height = 0;
855         }
856       }
857       cache.clear();
858     }
859     this._cachedBitmapsMap.clear();
860     this.#drawFilter();
861   }
862 
863   #drawFilter() {
864     if (this.pageColors) {
865       const hcmFilterId = this.filterFactory.addHCMFilter(
866         this.pageColors.foreground,
867         this.pageColors.background
868       );
869       if (hcmFilterId !== "none") {
870         const savedFilter = this.ctx.filter;
871         this.ctx.filter = hcmFilterId;
872         this.ctx.drawImage(this.ctx.canvas, 0, 0);
873         this.ctx.filter = savedFilter;
874       }
875     }
876   }
877 
878   _scaleImage(img, inverseTransform) {
879     // Vertical or horizontal scaling shall not be more than 2 to not lose the
880     // pixels during drawImage operation, painting on the temporary canvas(es)
881     // that are twice smaller in size.
882 
883     // displayWidth and displayHeight are used for VideoFrame.
884     const width = img.width ?? img.displayWidth;
885     const height = img.height ?? img.displayHeight;
886     let widthScale = Math.max(
887       Math.hypot(inverseTransform[0], inverseTransform[1]),
888       1
889     );
890     let heightScale = Math.max(
891       Math.hypot(inverseTransform[2], inverseTransform[3]),
892       1
893     );
894 
895     let paintWidth = width,
896       paintHeight = height;
897     let tmpCanvasId = "prescale1";
898     let tmpCanvas, tmpCtx;
899     while (
900       (widthScale > 2 && paintWidth > 1) ||
901       (heightScale > 2 && paintHeight > 1)
902     ) {
903       let newWidth = paintWidth,
904         newHeight = paintHeight;
905       if (widthScale > 2 && paintWidth > 1) {
906         // See bug 1820511 (Windows specific bug).
907         // TODO: once the above bug is fixed we could revert to:
908         // newWidth = Math.ceil(paintWidth / 2);
909         newWidth =
910           paintWidth >= 16384
911             ? Math.floor(paintWidth / 2) - 1 || 1
912             : Math.ceil(paintWidth / 2);
913         widthScale /= paintWidth / newWidth;
914       }
915       if (heightScale > 2 && paintHeight > 1) {
916         // TODO: see the comment above.
917         newHeight =
918           paintHeight >= 16384
919             ? Math.floor(paintHeight / 2) - 1 || 1
920             : Math.ceil(paintHeight) / 2;
921         heightScale /= paintHeight / newHeight;
922       }
923       tmpCanvas = this.cachedCanvases.getCanvas(
924         tmpCanvasId,
925         newWidth,
926         newHeight
927       );
928       tmpCtx = tmpCanvas.context;
929       tmpCtx.clearRect(0, 0, newWidth, newHeight);
930       tmpCtx.drawImage(
931         img,
932         0,
933         0,
934         paintWidth,
935         paintHeight,
936         0,
937         0,
938         newWidth,
939         newHeight
940       );
941       img = tmpCanvas.canvas;
942       paintWidth = newWidth;
943       paintHeight = newHeight;
944       tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
945     }
946     return {
947       img,
948       paintWidth,
949       paintHeight,
950     };
951   }
952 
953   _createMaskCanvas(img) {
954     const ctx = this.ctx;
955     const { width, height } = img;
956     const fillColor = this.current.fillColor;
957     const isPatternFill = this.current.patternFill;
958     const currentTransform = getCurrentTransform(ctx);
959 
960     let cache, cacheKey, scaled, maskCanvas;
961     if ((img.bitmap || img.data) && img.count > 1) {
962       const mainKey = img.bitmap || img.data.buffer;
963       // We're reusing the same image several times, so we can cache it.
964       // In case we've a pattern fill we just keep the scaled version of
965       // the image.
966       // Only the scaling part matters, the translation part is just used
967       // to compute offsets (but not when filling patterns see #15573).
968       // TODO: handle the case of a pattern fill if it's possible.
969       cacheKey = JSON.stringify(
970         isPatternFill
971           ? currentTransform
972           : [currentTransform.slice(0, 4), fillColor]
973       );
974 
975       cache = this._cachedBitmapsMap.get(mainKey);
976       if (!cache) {
977         cache = new Map();
978         this._cachedBitmapsMap.set(mainKey, cache);
979       }
980       const cachedImage = cache.get(cacheKey);
981       if (cachedImage && !isPatternFill) {
982         const offsetX = Math.round(
983           Math.min(currentTransform[0], currentTransform[2]) +
984             currentTransform[4]
985         );
986         const offsetY = Math.round(
987           Math.min(currentTransform[1], currentTransform[3]) +
988             currentTransform[5]
989         );
990         return {
991           canvas: cachedImage,
992           offsetX,
993           offsetY,
994         };
995       }
996       scaled = cachedImage;
997     }
998 
999     if (!scaled) {
1000       maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
1001       putBinaryImageMask(maskCanvas.context, img);
1002     }
1003 
1004     // Create the mask canvas at the size it will be drawn at and also set
1005     // its transform to match the current transform so if there are any
1006     // patterns applied they will be applied relative to the correct
1007     // transform.
1008 
1009     let maskToCanvas = Util.transform(currentTransform, [
1010       1 / width,
1011       0,
1012       0,
1013       -1 / height,
1014       0,
1015       0,
1016     ]);
1017     maskToCanvas = Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
1018     const minMax = MIN_MAX_INIT.slice();
1019     Util.axialAlignedBoundingBox([0, 0, width, height], maskToCanvas, minMax);
1020     const [minX, minY, maxX, maxY] = minMax;
1021     const drawnWidth = Math.round(maxX - minX) || 1;
1022     const drawnHeight = Math.round(maxY - minY) || 1;
1023     const fillCanvas = this.cachedCanvases.getCanvas(
1024       "fillCanvas",
1025       drawnWidth,
1026       drawnHeight
1027     );
1028     const fillCtx = fillCanvas.context;
1029 
1030     // The offset will be the top-left coordinate mask.
1031     // If objToCanvas is [a,b,c,d,e,f] then:
1032     //   - offsetX = min(a, c) + e
1033     //   - offsetY = min(b, d) + f
1034     const offsetX = minX;
1035     const offsetY = minY;
1036     fillCtx.translate(-offsetX, -offsetY);
1037     fillCtx.transform(...maskToCanvas);
1038 
1039     if (!scaled) {
1040       // Pre-scale if needed to improve image smoothing.
1041       scaled = this._scaleImage(
1042         maskCanvas.canvas,
1043         getCurrentTransformInverse(fillCtx)
1044       );
1045       scaled = scaled.img;
1046       if (cache && isPatternFill) {
1047         cache.set(cacheKey, scaled);
1048       }
1049     }
1050 
1051     fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(
1052       getCurrentTransform(fillCtx),
1053       img.interpolate
1054     );
1055 
1056     drawImageAtIntegerCoords(
1057       fillCtx,
1058       scaled,
1059       0,
1060       0,
1061       scaled.width,
1062       scaled.height,
1063       0,
1064       0,
1065       width,
1066       height
1067     );
1068     fillCtx.globalCompositeOperation = "source-in";
1069 
1070     const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [
1071       1,
1072       0,
1073       0,
1074       1,
1075       -offsetX,
1076       -offsetY,
1077     ]);
1078     fillCtx.fillStyle = isPatternFill
1079       ? fillColor.getPattern(ctx, this, inverse, PathType.FILL)
1080       : fillColor;
1081 
1082     fillCtx.fillRect(0, 0, width, height);
1083 
1084     if (cache && !isPatternFill) {
1085       // The fill canvas is put in the cache associated to the mask image
1086       // so we must remove from the cached canvas: it mustn't be used again.
1087       this.cachedCanvases.delete("fillCanvas");
1088       cache.set(cacheKey, fillCanvas.canvas);
1089     }
1090 
1091     // Round the offsets to avoid drawing fractional pixels.
1092     return {
1093       canvas: fillCanvas.canvas,
1094       offsetX: Math.round(offsetX),
1095       offsetY: Math.round(offsetY),
1096     };
1097   }
1098 
1099   // Graphics state
1100   setLineWidth(width) {
1101     if (width !== this.current.lineWidth) {
1102       this._cachedScaleForStroking[0] = -1;
1103     }
1104     this.current.lineWidth = width;
1105     this.ctx.lineWidth = width;
1106   }
1107 
1108   setLineCap(style) {
1109     this.ctx.lineCap = LINE_CAP_STYLES[style];
1110   }
1111 
1112   setLineJoin(style) {
1113     this.ctx.lineJoin = LINE_JOIN_STYLES[style];
1114   }
1115 
1116   setMiterLimit(limit) {
1117     this.ctx.miterLimit = limit;
1118   }
1119 
1120   setDash(dashArray, dashPhase) {
1121     const ctx = this.ctx;
1122     if (ctx.setLineDash !== undefined) {
1123       ctx.setLineDash(dashArray);
1124       ctx.lineDashOffset = dashPhase;
1125     }
1126   }
1127 
1128   setRenderingIntent(intent) {
1129     // This operation is ignored since we haven't found a use case for it yet.
1130   }
1131 
1132   setFlatness(flatness) {
1133     // This operation is ignored since we haven't found a use case for it yet.
1134   }
1135 
1136   setGState(states) {
1137     for (const [key, value] of states) {
1138       switch (key) {
1139         case "LW":
1140           this.setLineWidth(value);
1141           break;
1142         case "LC":
1143           this.setLineCap(value);
1144           break;
1145         case "LJ":
1146           this.setLineJoin(value);
1147           break;
1148         case "ML":
1149           this.setMiterLimit(value);
1150           break;
1151         case "D":
1152           this.setDash(value[0], value[1]);
1153           break;
1154         case "RI":
1155           this.setRenderingIntent(value);
1156           break;
1157         case "FL":
1158           this.setFlatness(value);
1159           break;
1160         case "Font":
1161           this.setFont(value[0], value[1]);
1162           break;
1163         case "CA":
1164           this.current.strokeAlpha = value;
1165           break;
1166         case "ca":
1167           this.ctx.globalAlpha = this.current.fillAlpha = value;
1168           break;
1169         case "BM":
1170           this.ctx.globalCompositeOperation = value;
1171           break;
1172         case "SMask":
1173           this.current.activeSMask = value ? this.tempSMask : null;
1174           this.tempSMask = null;
1175           this.checkSMaskState();
1176           break;
1177         case "TR":
1178           this.ctx.filter = this.current.transferMaps =
1179             this.filterFactory.addFilter(value);
1180           break;
1181       }
1182     }
1183   }
1184 
1185   get inSMaskMode() {
1186     return !!this.suspendedCtx;
1187   }
1188 
1189   checkSMaskState() {
1190     const inSMaskMode = this.inSMaskMode;
1191     if (this.current.activeSMask && !inSMaskMode) {
1192       this.beginSMaskMode();
1193     } else if (!this.current.activeSMask && inSMaskMode) {
1194       this.endSMaskMode();
1195     }
1196     // Else, the state is okay and nothing needs to be done.
1197   }
1198 
1199   /**
1200    * Soft mask mode takes the current main drawing canvas and replaces it with
1201    * a temporary canvas. Any drawing operations that happen on the temporary
1202    * canvas need to be composed with the main canvas that was suspended (see
1203    * `compose()`). The temporary canvas also duplicates many of its operations
1204    * on the suspended canvas to keep them in sync, so that when the soft mask
1205    * mode ends any clipping paths or transformations will still be active and in
1206    * the right order on the canvas' graphics state stack.
1207    */
1208   beginSMaskMode() {
1209     if (this.inSMaskMode) {
1210       throw new Error("beginSMaskMode called while already in smask mode");
1211     }
1212     const drawnWidth = this.ctx.canvas.width;
1213     const drawnHeight = this.ctx.canvas.height;
1214     const cacheId = "smaskGroupAt" + this.groupLevel;
1215     const scratchCanvas = this.cachedCanvases.getCanvas(
1216       cacheId,
1217       drawnWidth,
1218       drawnHeight
1219     );
1220     this.suspendedCtx = this.ctx;
1221     const ctx = (this.ctx = scratchCanvas.context);
1222     ctx.setTransform(this.suspendedCtx.getTransform());
1223     copyCtxState(this.suspendedCtx, ctx);
1224     mirrorContextOperations(ctx, this.suspendedCtx);
1225 
1226     this.setGState([["BM", "source-over"]]);
1227   }
1228 
1229   endSMaskMode() {
1230     if (!this.inSMaskMode) {
1231       throw new Error("endSMaskMode called while not in smask mode");
1232     }
1233     // The soft mask is done, now restore the suspended canvas as the main
1234     // drawing canvas.
1235     this.ctx._removeMirroring();
1236     copyCtxState(this.ctx, this.suspendedCtx);
1237     this.ctx = this.suspendedCtx;
1238 
1239     this.suspendedCtx = null;
1240   }
1241 
1242   compose(dirtyBox) {
1243     if (!this.current.activeSMask) {
1244       return;
1245     }
1246 
1247     if (!dirtyBox) {
1248       dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
1249     } else {
1250       dirtyBox[0] = Math.floor(dirtyBox[0]);
1251       dirtyBox[1] = Math.floor(dirtyBox[1]);
1252       dirtyBox[2] = Math.ceil(dirtyBox[2]);
1253       dirtyBox[3] = Math.ceil(dirtyBox[3]);
1254     }
1255     const smask = this.current.activeSMask;
1256     const suspendedCtx = this.suspendedCtx;
1257 
1258     this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
1259     // Whatever was drawn has been moved to the suspended canvas, now clear it
1260     // out of the current canvas.
1261     this.ctx.save();
1262     this.ctx.setTransform(1, 0, 0, 1, 0, 0);
1263     this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
1264     this.ctx.restore();
1265   }
1266 
1267   composeSMask(ctx, smask, layerCtx, layerBox) {
1268     const layerOffsetX = layerBox[0];
1269     const layerOffsetY = layerBox[1];
1270     const layerWidth = layerBox[2] - layerOffsetX;
1271     const layerHeight = layerBox[3] - layerOffsetY;
1272     if (layerWidth === 0 || layerHeight === 0) {
1273       return;
1274     }
1275     this.genericComposeSMask(
1276       smask.context,
1277       layerCtx,
1278       layerWidth,
1279       layerHeight,
1280       smask.subtype,
1281       smask.backdrop,
1282       smask.transferMap,
1283       layerOffsetX,
1284       layerOffsetY,
1285       smask.offsetX,
1286       smask.offsetY
1287     );
1288     ctx.save();
1289     ctx.globalAlpha = 1;
1290     ctx.globalCompositeOperation = "source-over";
1291     ctx.setTransform(1, 0, 0, 1, 0, 0);
1292     ctx.drawImage(layerCtx.canvas, 0, 0);
1293     ctx.restore();
1294   }
1295 
1296   genericComposeSMask(
1297     maskCtx,
1298     layerCtx,
1299     width,
1300     height,
1301     subtype,
1302     backdrop,
1303     transferMap,
1304     layerOffsetX,
1305     layerOffsetY,
1306     maskOffsetX,
1307     maskOffsetY
1308   ) {
1309     let maskCanvas = maskCtx.canvas;
1310     let maskX = layerOffsetX - maskOffsetX;
1311     let maskY = layerOffsetY - maskOffsetY;
1312 
1313     if (backdrop) {
1314       if (
1315         maskX < 0 ||
1316         maskY < 0 ||
1317         maskX + width > maskCanvas.width ||
1318         maskY + height > maskCanvas.height
1319       ) {
1320         const canvas = this.cachedCanvases.getCanvas(
1321           "maskExtension",
1322           width,
1323           height
1324         );
1325         const ctx = canvas.context;
1326         ctx.drawImage(maskCanvas, -maskX, -maskY);
1327         ctx.globalCompositeOperation = "destination-atop";
1328         ctx.fillStyle = backdrop;
1329         ctx.fillRect(0, 0, width, height);
1330         ctx.globalCompositeOperation = "source-over";
1331 
1332         maskCanvas = canvas.canvas;
1333         maskX = maskY = 0;
1334       } else {
1335         maskCtx.save();
1336         maskCtx.globalAlpha = 1;
1337         maskCtx.setTransform(1, 0, 0, 1, 0, 0);
1338         const clip = new Path2D();
1339         clip.rect(maskX, maskY, width, height);
1340         maskCtx.clip(clip);
1341         maskCtx.globalCompositeOperation = "destination-atop";
1342         maskCtx.fillStyle = backdrop;
1343         maskCtx.fillRect(maskX, maskY, width, height);
1344         maskCtx.restore();
1345       }
1346     }
1347 
1348     layerCtx.save();
1349     layerCtx.globalAlpha = 1;
1350     layerCtx.setTransform(1, 0, 0, 1, 0, 0);
1351 
1352     if (subtype === "Alpha" && transferMap) {
1353       layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);
1354     } else if (subtype === "Luminosity") {
1355       layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);
1356     }
1357 
1358     const clip = new Path2D();
1359     clip.rect(layerOffsetX, layerOffsetY, width, height);
1360     layerCtx.clip(clip);
1361     layerCtx.globalCompositeOperation = "destination-in";
1362     layerCtx.drawImage(
1363       maskCanvas,
1364       maskX,
1365       maskY,
1366       width,
1367       height,
1368       layerOffsetX,
1369       layerOffsetY,
1370       width,
1371       height
1372     );
1373     layerCtx.restore();
1374   }
1375 
1376   save() {
1377     if (this.inSMaskMode) {
1378       // SMask mode may be turned on/off causing us to lose graphics state.
1379       // Copy the temporary canvas state to the main(suspended) canvas to keep
1380       // it in sync.
1381       copyCtxState(this.ctx, this.suspendedCtx);
1382     }
1383     this.ctx.save();
1384     const old = this.current;
1385     this.stateStack.push(old);
1386     this.current = old.clone();
1387   }
1388 
1389   restore() {
1390     if (this.stateStack.length === 0) {
1391       if (this.inSMaskMode) {
1392         this.endSMaskMode();
1393       }
1394       return;
1395     }
1396 
1397     this.current = this.stateStack.pop();
1398     this.ctx.restore();
1399     if (this.inSMaskMode) {
1400       // Graphics state is stored on the main(suspended) canvas. Restore its
1401       // state then copy it over to the temporary canvas.
1402       copyCtxState(this.suspendedCtx, this.ctx);
1403     }
1404     this.checkSMaskState();
1405 
1406     // Ensure that the clipping path is reset (fixes issue6413.pdf).
1407     this.pendingClip = null;
1408 
1409     this._cachedScaleForStroking[0] = -1;
1410     this._cachedGetSinglePixelWidth = null;
1411   }
1412 
1413   transform(a, b, c, d, e, f) {
1414     this.ctx.transform(a, b, c, d, e, f);
1415 
1416     this._cachedScaleForStroking[0] = -1;
1417     this._cachedGetSinglePixelWidth = null;
1418   }
1419 
1420   // Path
1421   constructPath(op, data, minMax) {
1422     let [path] = data;
1423     if (!minMax) {
1424       // The path is empty, so no need to update the current minMax.
1425       path ||= data[0] = new Path2D();
1426       this[op](path);
1427       return;
1428     }
1429     if (!(path instanceof Path2D)) {
1430       // Using a SVG string is slightly slower than using the following loop.
1431       const path2d = (data[0] = new Path2D());
1432       for (let i = 0, ii = path.length; i < ii; ) {
1433         switch (path[i++]) {
1434           case DrawOPS.moveTo:
1435             path2d.moveTo(path[i++], path[i++]);
1436             break;
1437           case DrawOPS.lineTo:
1438             path2d.lineTo(path[i++], path[i++]);
1439             break;
1440           case DrawOPS.curveTo:
1441             path2d.bezierCurveTo(
1442               path[i++],
1443               path[i++],
1444               path[i++],
1445               path[i++],
1446               path[i++],
1447               path[i++]
1448             );
1449             break;
1450           case DrawOPS.closePath:
1451             path2d.closePath();
1452             break;
1453           default:
1454             warn(`Unrecognized drawing path operator: ${path[i - 1]}`);
1455             break;
1456         }
1457       }
1458       path = path2d;
1459     }
1460     Util.axialAlignedBoundingBox(
1461       minMax,
1462       getCurrentTransform(this.ctx),
1463       this.current.minMax
1464     );
1465     this[op](path);
1466   }
1467 
1468   closePath() {
1469     this.ctx.closePath();
1470   }
1471 
1472   stroke(path, consumePath = true) {
1473     const ctx = this.ctx;
1474     const strokeColor = this.current.strokeColor;
1475     // For stroke we want to temporarily change the global alpha to the
1476     // stroking alpha.
1477     ctx.globalAlpha = this.current.strokeAlpha;
1478     if (this.contentVisible) {
1479       if (typeof strokeColor === "object" && strokeColor?.getPattern) {
1480         const baseTransform = strokeColor.isModifyingCurrentTransform()
1481           ? ctx.getTransform()
1482           : null;
1483         ctx.save();
1484         ctx.strokeStyle = strokeColor.getPattern(
1485           ctx,
1486           this,
1487           getCurrentTransformInverse(ctx),
1488           PathType.STROKE
1489         );
1490         if (baseTransform) {
1491           const newPath = new Path2D();
1492           newPath.addPath(
1493             path,
1494             ctx.getTransform().invertSelf().multiplySelf(baseTransform)
1495           );
1496           path = newPath;
1497         }
1498         this.rescaleAndStroke(path, /* saveRestore */ false);
1499         ctx.restore();
1500       } else {
1501         this.rescaleAndStroke(path, /* saveRestore */ true);
1502       }
1503     }
1504     if (consumePath) {
1505       this.consumePath(
1506         path,
1507         this.current.getClippedPathBoundingBox(
1508           PathType.STROKE,
1509           getCurrentTransform(this.ctx)
1510         )
1511       );
1512     }
1513     // Restore the global alpha to the fill alpha
1514     ctx.globalAlpha = this.current.fillAlpha;
1515   }
1516 
1517   closeStroke(path) {
1518     this.stroke(path);
1519   }
1520 
1521   fill(path, consumePath = true) {
1522     const ctx = this.ctx;
1523     const fillColor = this.current.fillColor;
1524     const isPatternFill = this.current.patternFill;
1525     let needRestore = false;
1526 
1527     if (isPatternFill) {
1528       const baseTransform = fillColor.isModifyingCurrentTransform()
1529         ? ctx.getTransform()
1530         : null;
1531       ctx.save();
1532       ctx.fillStyle = fillColor.getPattern(
1533         ctx,
1534         this,
1535         getCurrentTransformInverse(ctx),
1536         PathType.FILL
1537       );
1538       if (baseTransform) {
1539         const newPath = new Path2D();
1540         newPath.addPath(
1541           path,
1542           ctx.getTransform().invertSelf().multiplySelf(baseTransform)
1543         );
1544         path = newPath;
1545       }
1546       needRestore = true;
1547     }
1548 
1549     const intersect = this.current.getClippedPathBoundingBox();
1550     if (this.contentVisible && intersect !== null) {
1551       if (this.pendingEOFill) {
1552         ctx.fill(path, "evenodd");
1553         this.pendingEOFill = false;
1554       } else {
1555         ctx.fill(path);
1556       }
1557     }
1558 
1559     if (needRestore) {
1560       ctx.restore();
1561     }
1562     if (consumePath) {
1563       this.consumePath(path, intersect);
1564     }
1565   }
1566 
1567   eoFill(path) {
1568     this.pendingEOFill = true;
1569     this.fill(path);
1570   }
1571 
1572   fillStroke(path) {
1573     this.fill(path, false);
1574     this.stroke(path, false);
1575 
1576     this.consumePath(path);
1577   }
1578 
1579   eoFillStroke(path) {
1580     this.pendingEOFill = true;
1581     this.fillStroke(path);
1582   }
1583 
1584   closeFillStroke(path) {
1585     this.fillStroke(path);
1586   }
1587 
1588   closeEOFillStroke(path) {
1589     this.pendingEOFill = true;
1590     this.fillStroke(path);
1591   }
1592 
1593   endPath(path) {
1594     this.consumePath(path);
1595   }
1596 
1597   rawFillPath(path) {
1598     this.ctx.fill(path);
1599   }
1600 
1601   // Clipping
1602   clip() {
1603     this.pendingClip = NORMAL_CLIP;
1604   }
1605 
1606   eoClip() {
1607     this.pendingClip = EO_CLIP;
1608   }
1609 
1610   // Text
1611   beginText() {
1612     this.current.textMatrix = null;
1613     this.current.textMatrixScale = 1;
1614     this.current.x = this.current.lineX = 0;
1615     this.current.y = this.current.lineY = 0;
1616   }
1617 
1618   endText() {
1619     const paths = this.pendingTextPaths;
1620     const ctx = this.ctx;
1621     if (paths === undefined) {
1622       return;
1623     }
1624 
1625     const newPath = new Path2D();
1626     const invTransf = ctx.getTransform().invertSelf();
1627     for (const { transform, x, y, fontSize, path } of paths) {
1628       newPath.addPath(
1629         path,
1630         new DOMMatrix(transform)
1631           .preMultiplySelf(invTransf)
1632           .translate(x, y)
1633           .scale(fontSize, -fontSize)
1634       );
1635     }
1636 
1637     ctx.clip(newPath);
1638     delete this.pendingTextPaths;
1639   }
1640 
1641   setCharSpacing(spacing) {
1642     this.current.charSpacing = spacing;
1643   }
1644 
1645   setWordSpacing(spacing) {
1646     this.current.wordSpacing = spacing;
1647   }
1648 
1649   setHScale(scale) {
1650     this.current.textHScale = scale / 100;
1651   }
1652 
1653   setLeading(leading) {
1654     this.current.leading = -leading;
1655   }
1656 
1657   setFont(fontRefName, size) {
1658     const fontObj = this.commonObjs.get(fontRefName);
1659     const current = this.current;
1660 
1661     if (!fontObj) {
1662       throw new Error(`Can't find font for ${fontRefName}`);
1663     }
1664     current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;
1665 
1666     // A valid matrix needs all main diagonal elements to be non-zero
1667     // This also ensures we bypass FF bugzilla bug #719844.
1668     if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
1669       warn("Invalid font matrix for font " + fontRefName);
1670     }
1671 
1672     // The spec for Tf (setFont) says that 'size' specifies the font 'scale',
1673     // and in some docs this can be negative (inverted x-y axes).
1674     if (size < 0) {
1675       size = -size;
1676       current.fontDirection = -1;
1677     } else {
1678       current.fontDirection = 1;
1679     }
1680 
1681     this.current.font = fontObj;
1682     this.current.fontSize = size;
1683 
1684     if (fontObj.isType3Font) {
1685       return; // we don't need ctx.font for Type3 fonts
1686     }
1687 
1688     const name = fontObj.loadedName || "sans-serif";
1689     const typeface =
1690       fontObj.systemFontInfo?.css || `"${name}", ${fontObj.fallbackName}`;
1691 
1692     let bold = "normal";
1693     if (fontObj.black) {
1694       bold = "900";
1695     } else if (fontObj.bold) {
1696       bold = "bold";
1697     }
1698     const italic = fontObj.italic ? "italic" : "normal";
1699 
1700     // Some font backends cannot handle fonts below certain size.
1701     // Keeping the font at minimal size and using the fontSizeScale to change
1702     // the current transformation matrix before the fillText/strokeText.
1703     // See https://bugzilla.mozilla.org/show_bug.cgi?id=726227
1704     let browserFontSize = size;
1705     if (size < MIN_FONT_SIZE) {
1706       browserFontSize = MIN_FONT_SIZE;
1707     } else if (size > MAX_FONT_SIZE) {
1708       browserFontSize = MAX_FONT_SIZE;
1709     }
1710     this.current.fontSizeScale = size / browserFontSize;
1711 
1712     this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
1713   }
1714 
1715   setTextRenderingMode(mode) {
1716     this.current.textRenderingMode = mode;
1717   }
1718 
1719   setTextRise(rise) {
1720     this.current.textRise = rise;
1721   }
1722 
1723   moveText(x, y) {
1724     this.current.x = this.current.lineX += x;
1725     this.current.y = this.current.lineY += y;
1726   }
1727 
1728   setLeadingMoveText(x, y) {
1729     this.setLeading(-y);
1730     this.moveText(x, y);
1731   }
1732 
1733   setTextMatrix(matrix) {
1734     const { current } = this;
1735     current.textMatrix = matrix;
1736     current.textMatrixScale = Math.hypot(matrix[0], matrix[1]);
1737 
1738     current.x = current.lineX = 0;
1739     current.y = current.lineY = 0;
1740   }
1741 
1742   nextLine() {
1743     this.moveText(0, this.current.leading);
1744   }
1745 
1746   #getScaledPath(path, currentTransform, transform) {
1747     const newPath = new Path2D();
1748     newPath.addPath(
1749       path,
1750       new DOMMatrix(transform).invertSelf().multiplySelf(currentTransform)
1751     );
1752     return newPath;
1753   }
1754 
1755   paintChar(character, x, y, patternFillTransform, patternStrokeTransform) {
1756     const ctx = this.ctx;
1757     const current = this.current;
1758     const font = current.font;
1759     const textRenderingMode = current.textRenderingMode;
1760     const fontSize = current.fontSize / current.fontSizeScale;
1761     const fillStrokeMode =
1762       textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
1763     const isAddToPathSet = !!(
1764       textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG
1765     );
1766     const patternFill = current.patternFill && !font.missingFile;
1767     const patternStroke = current.patternStroke && !font.missingFile;
1768 
1769     let path;
1770     if (
1771       font.disableFontFace ||
1772       isAddToPathSet ||
1773       patternFill ||
1774       patternStroke
1775     ) {
1776       path = font.getPathGenerator(this.commonObjs, character);
1777     }
1778 
1779     if (font.disableFontFace || patternFill || patternStroke) {
1780       ctx.save();
1781       ctx.translate(x, y);
1782       ctx.scale(fontSize, -fontSize);
1783       let currentTransform;
1784       if (
1785         fillStrokeMode === TextRenderingMode.FILL ||
1786         fillStrokeMode === TextRenderingMode.FILL_STROKE
1787       ) {
1788         if (patternFillTransform) {
1789           currentTransform = ctx.getTransform();
1790           ctx.setTransform(...patternFillTransform);
1791           ctx.fill(
1792             this.#getScaledPath(path, currentTransform, patternFillTransform)
1793           );
1794         } else {
1795           ctx.fill(path);
1796         }
1797       }
1798       if (
1799         fillStrokeMode === TextRenderingMode.STROKE ||
1800         fillStrokeMode === TextRenderingMode.FILL_STROKE
1801       ) {
1802         if (patternStrokeTransform) {
1803           currentTransform ||= ctx.getTransform();
1804           ctx.setTransform(...patternStrokeTransform);
1805           const { a, b, c, d } = currentTransform;
1806           const invPatternTransform = Util.inverseTransform(
1807             patternStrokeTransform
1808           );
1809           const transf = Util.transform(
1810             [a, b, c, d, 0, 0],
1811             invPatternTransform
1812           );
1813           Util.singularValueDecompose2dScale(transf, XY);
1814 
1815           // Cancel the pattern scaling of the line width.
1816           // If sx and sy are different, unfortunately we can't do anything and
1817           // we'll have a rendering bug.
1818           ctx.lineWidth *= Math.max(XY[0], XY[1]) / fontSize;
1819           ctx.stroke(
1820             this.#getScaledPath(path, currentTransform, patternStrokeTransform)
1821           );
1822         } else {
1823           ctx.lineWidth /= fontSize;
1824           ctx.stroke(path);
1825         }
1826       }
1827       ctx.restore();
1828     } else {
1829       if (
1830         fillStrokeMode === TextRenderingMode.FILL ||
1831         fillStrokeMode === TextRenderingMode.FILL_STROKE
1832       ) {
1833         ctx.fillText(character, x, y);
1834       }
1835       if (
1836         fillStrokeMode === TextRenderingMode.STROKE ||
1837         fillStrokeMode === TextRenderingMode.FILL_STROKE
1838       ) {
1839         ctx.strokeText(character, x, y);
1840       }
1841     }
1842 
1843     if (isAddToPathSet) {
1844       const paths = (this.pendingTextPaths ||= []);
1845       paths.push({
1846         transform: getCurrentTransform(ctx),
1847         x,
1848         y,
1849         fontSize,
1850         path,
1851       });
1852     }
1853   }
1854 
1855   get isFontSubpixelAAEnabled() {
1856     // Checks if anti-aliasing is enabled when scaled text is painted.
1857     // On Windows GDI scaled fonts looks bad.
1858     const { context: ctx } = this.cachedCanvases.getCanvas(
1859       "isFontSubpixelAAEnabled",
1860       10,
1861       10
1862     );
1863     ctx.scale(1.5, 1);
1864     ctx.fillText("I", 0, 10);
1865     const data = ctx.getImageData(0, 0, 10, 10).data;
1866     let enabled = false;
1867     for (let i = 3; i < data.length; i += 4) {
1868       if (data[i] > 0 && data[i] < 255) {
1869         enabled = true;
1870         break;
1871       }
1872     }
1873     return shadow(this, "isFontSubpixelAAEnabled", enabled);
1874   }
1875 
1876   showText(glyphs) {
1877     const current = this.current;
1878     const font = current.font;
1879     if (font.isType3Font) {
1880       return this.showType3Text(glyphs);
1881     }
1882 
1883     const fontSize = current.fontSize;
1884     if (fontSize === 0) {
1885       return undefined;
1886     }
1887 
1888     const ctx = this.ctx;
1889     const fontSizeScale = current.fontSizeScale;
1890     const charSpacing = current.charSpacing;
1891     const wordSpacing = current.wordSpacing;
1892     const fontDirection = current.fontDirection;
1893     const textHScale = current.textHScale * fontDirection;
1894     const glyphsLength = glyphs.length;
1895     const vertical = font.vertical;
1896     const spacingDir = vertical ? 1 : -1;
1897     const defaultVMetrics = font.defaultVMetrics;
1898     const widthAdvanceScale = fontSize * current.fontMatrix[0];
1899 
1900     const simpleFillText =
1901       current.textRenderingMode === TextRenderingMode.FILL &&
1902       !font.disableFontFace &&
1903       !current.patternFill;
1904 
1905     ctx.save();
1906     if (current.textMatrix) {
1907       ctx.transform(...current.textMatrix);
1908     }
1909     ctx.translate(current.x, current.y + current.textRise);
1910 
1911     if (fontDirection > 0) {
1912       ctx.scale(textHScale, -1);
1913     } else {
1914       ctx.scale(textHScale, 1);
1915     }
1916 
1917     let patternFillTransform, patternStrokeTransform;
1918     if (current.patternFill) {
1919       ctx.save();
1920       const pattern = current.fillColor.getPattern(
1921         ctx,
1922         this,
1923         getCurrentTransformInverse(ctx),
1924         PathType.FILL
1925       );
1926       patternFillTransform = getCurrentTransform(ctx);
1927       ctx.restore();
1928       ctx.fillStyle = pattern;
1929     }
1930 
1931     if (current.patternStroke) {
1932       ctx.save();
1933       const pattern = current.strokeColor.getPattern(
1934         ctx,
1935         this,
1936         getCurrentTransformInverse(ctx),
1937         PathType.STROKE
1938       );
1939       patternStrokeTransform = getCurrentTransform(ctx);
1940       ctx.restore();
1941       ctx.strokeStyle = pattern;
1942     }
1943 
1944     let lineWidth = current.lineWidth;
1945     const scale = current.textMatrixScale;
1946     if (scale === 0 || lineWidth === 0) {
1947       const fillStrokeMode =
1948         current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
1949       if (
1950         fillStrokeMode === TextRenderingMode.STROKE ||
1951         fillStrokeMode === TextRenderingMode.FILL_STROKE
1952       ) {
1953         lineWidth = this.getSinglePixelWidth();
1954       }
1955     } else {
1956       lineWidth /= scale;
1957     }
1958 
1959     if (fontSizeScale !== 1.0) {
1960       ctx.scale(fontSizeScale, fontSizeScale);
1961       lineWidth /= fontSizeScale;
1962     }
1963 
1964     ctx.lineWidth = lineWidth;
1965 
1966     if (font.isInvalidPDFjsFont) {
1967       const chars = [];
1968       let width = 0;
1969       for (const glyph of glyphs) {
1970         chars.push(glyph.unicode);
1971         width += glyph.width;
1972       }
1973       ctx.fillText(chars.join(""), 0, 0);
1974       current.x += width * widthAdvanceScale * textHScale;
1975       ctx.restore();
1976       this.compose();
1977 
1978       return undefined;
1979     }
1980 
1981     let x = 0,
1982       i;
1983     for (i = 0; i < glyphsLength; ++i) {
1984       const glyph = glyphs[i];
1985       if (typeof glyph === "number") {
1986         x += (spacingDir * glyph * fontSize) / 1000;
1987         continue;
1988       }
1989 
1990       let restoreNeeded = false;
1991       const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
1992       const character = glyph.fontChar;
1993       const accent = glyph.accent;
1994       let scaledX, scaledY;
1995       let width = glyph.width;
1996       if (vertical) {
1997         const vmetric = glyph.vmetric || defaultVMetrics;
1998         const vx =
1999           -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
2000         const vy = vmetric[2] * widthAdvanceScale;
2001 
2002         width = vmetric ? -vmetric[0] : width;
2003         scaledX = vx / fontSizeScale;
2004         scaledY = (x + vy) / fontSizeScale;
2005       } else {
2006         scaledX = x / fontSizeScale;
2007         scaledY = 0;
2008       }
2009 
2010       if (font.remeasure && width > 0) {
2011         // Some standard fonts may not have the exact width: rescale per
2012         // character if measured width is greater than expected glyph width
2013         // and subpixel-aa is enabled, otherwise just center the glyph.
2014         const measuredWidth =
2015           ((ctx.measureText(character).width * 1000) / fontSize) *
2016           fontSizeScale;
2017         if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
2018           const characterScaleX = width / measuredWidth;
2019           restoreNeeded = true;
2020           ctx.save();
2021           ctx.scale(characterScaleX, 1);
2022           scaledX /= characterScaleX;
2023         } else if (width !== measuredWidth) {
2024           scaledX +=
2025             (((width - measuredWidth) / 2000) * fontSize) / fontSizeScale;
2026         }
2027       }
2028 
2029       // Only attempt to draw the glyph if it is actually in the embedded font
2030       // file or if there isn't a font file so the fallback font is shown.
2031       if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
2032         if (simpleFillText && !accent) {
2033           // common case
2034           ctx.fillText(character, scaledX, scaledY);
2035         } else {
2036           this.paintChar(
2037             character,
2038             scaledX,
2039             scaledY,
2040             patternFillTransform,
2041             patternStrokeTransform
2042           );
2043           if (accent) {
2044             const scaledAccentX =
2045               scaledX + (fontSize * accent.offset.x) / fontSizeScale;
2046             const scaledAccentY =
2047               scaledY - (fontSize * accent.offset.y) / fontSizeScale;
2048             this.paintChar(
2049               accent.fontChar,
2050               scaledAccentX,
2051               scaledAccentY,
2052               patternFillTransform,
2053               patternStrokeTransform
2054             );
2055           }
2056         }
2057       }
2058 
2059       const charWidth = vertical
2060         ? width * widthAdvanceScale - spacing * fontDirection
2061         : width * widthAdvanceScale + spacing * fontDirection;
2062       x += charWidth;
2063 
2064       if (restoreNeeded) {
2065         ctx.restore();
2066       }
2067     }
2068     if (vertical) {
2069       current.y -= x;
2070     } else {
2071       current.x += x * textHScale;
2072     }
2073     ctx.restore();
2074     this.compose();
2075 
2076     return undefined;
2077   }
2078 
2079   showType3Text(glyphs) {
2080     // Type3 fonts - each glyph is a "mini-PDF"
2081     const ctx = this.ctx;
2082     const current = this.current;
2083     const font = current.font;
2084     const fontSize = current.fontSize;
2085     const fontDirection = current.fontDirection;
2086     const spacingDir = font.vertical ? 1 : -1;
2087     const charSpacing = current.charSpacing;
2088     const wordSpacing = current.wordSpacing;
2089     const textHScale = current.textHScale * fontDirection;
2090     const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;
2091     const glyphsLength = glyphs.length;
2092     const isTextInvisible =
2093       current.textRenderingMode === TextRenderingMode.INVISIBLE;
2094     let i, glyph, width, spacingLength;
2095 
2096     if (isTextInvisible || fontSize === 0) {
2097       return;
2098     }
2099     this._cachedScaleForStroking[0] = -1;
2100     this._cachedGetSinglePixelWidth = null;
2101 
2102     ctx.save();
2103     if (current.textMatrix) {
2104       ctx.transform(...current.textMatrix);
2105     }
2106     ctx.translate(current.x, current.y + current.textRise);
2107 
2108     ctx.scale(textHScale, fontDirection);
2109 
2110     for (i = 0; i < glyphsLength; ++i) {
2111       glyph = glyphs[i];
2112       if (typeof glyph === "number") {
2113         spacingLength = (spacingDir * glyph * fontSize) / 1000;
2114         this.ctx.translate(spacingLength, 0);
2115         current.x += spacingLength * textHScale;
2116         continue;
2117       }
2118 
2119       const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
2120       const operatorList = font.charProcOperatorList[glyph.operatorListId];
2121       if (!operatorList) {
2122         warn(`Type3 character "${glyph.operatorListId}" is not available.`);
2123       } else if (this.contentVisible) {
2124         this.save();
2125         ctx.scale(fontSize, fontSize);
2126         ctx.transform(...fontMatrix);
2127         this.executeOperatorList(operatorList);
2128         this.restore();
2129       }
2130 
2131       const p = [glyph.width, 0];
2132       Util.applyTransform(p, fontMatrix);
2133       width = p[0] * fontSize + spacing;
2134 
2135       ctx.translate(width, 0);
2136       current.x += width * textHScale;
2137     }
2138     ctx.restore();
2139   }
2140 
2141   // Type3 fonts
2142   setCharWidth(xWidth, yWidth) {
2143     // We can safely ignore this since the width should be the same
2144     // as the width in the Widths array.
2145   }
2146 
2147   setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
2148     const clip = new Path2D();
2149     clip.rect(llx, lly, urx - llx, ury - lly);
2150     this.ctx.clip(clip);
2151     this.endPath();
2152   }
2153 
2154   // Color
2155   getColorN_Pattern(IR) {
2156     let pattern;
2157     if (IR[0] === "TilingPattern") {
2158       const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);
2159       const canvasGraphicsFactory = {
2160         createCanvasGraphics: ctx =>
2161           new CanvasGraphics(
2162             ctx,
2163             this.commonObjs,
2164             this.objs,
2165             this.canvasFactory,
2166             this.filterFactory,
2167             {
2168               optionalContentConfig: this.optionalContentConfig,
2169               markedContentStack: this.markedContentStack,
2170             }
2171           ),
2172       };
2173       pattern = new TilingPattern(
2174         IR,
2175         this.ctx,
2176         canvasGraphicsFactory,
2177         baseTransform
2178       );
2179     } else {
2180       pattern = this._getPattern(IR[1], IR[2]);
2181     }
2182     return pattern;
2183   }
2184 
2185   setStrokeColorN() {
2186     this.current.strokeColor = this.getColorN_Pattern(arguments);
2187     this.current.patternStroke = true;
2188   }
2189 
2190   setFillColorN() {
2191     this.current.fillColor = this.getColorN_Pattern(arguments);
2192     this.current.patternFill = true;
2193   }
2194 
2195   setStrokeRGBColor(color) {
2196     this.ctx.strokeStyle = this.current.strokeColor = color;
2197     this.current.patternStroke = false;
2198   }
2199 
2200   setStrokeTransparent() {
2201     this.ctx.strokeStyle = this.current.strokeColor = "transparent";
2202     this.current.patternStroke = false;
2203   }
2204 
2205   setFillRGBColor(color) {
2206     this.ctx.fillStyle = this.current.fillColor = color;
2207     this.current.patternFill = false;
2208   }
2209 
2210   setFillTransparent() {
2211     this.ctx.fillStyle = this.current.fillColor = "transparent";
2212     this.current.patternFill = false;
2213   }
2214 
2215   _getPattern(objId, matrix = null) {
2216     let pattern;
2217     if (this.cachedPatterns.has(objId)) {
2218       pattern = this.cachedPatterns.get(objId);
2219     } else {
2220       pattern = getShadingPattern(this.getObject(objId));
2221       this.cachedPatterns.set(objId, pattern);
2222     }
2223     if (matrix) {
2224       pattern.matrix = matrix;
2225     }
2226     return pattern;
2227   }
2228 
2229   shadingFill(objId) {
2230     if (!this.contentVisible) {
2231       return;
2232     }
2233     const ctx = this.ctx;
2234 
2235     this.save();
2236     const pattern = this._getPattern(objId);
2237     ctx.fillStyle = pattern.getPattern(
2238       ctx,
2239       this,
2240       getCurrentTransformInverse(ctx),
2241       PathType.SHADING
2242     );
2243 
2244     const inv = getCurrentTransformInverse(ctx);
2245     if (inv) {
2246       const { width, height } = ctx.canvas;
2247       const minMax = MIN_MAX_INIT.slice();
2248       Util.axialAlignedBoundingBox([0, 0, width, height], inv, minMax);
2249       const [x0, y0, x1, y1] = minMax;
2250 
2251       this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
2252     } else {
2253       // HACK to draw the gradient onto an infinite rectangle.
2254       // PDF gradients are drawn across the entire image while
2255       // Canvas only allows gradients to be drawn in a rectangle
2256       // The following bug should allow us to remove this.
2257       // https://bugzilla.mozilla.org/show_bug.cgi?id=664884
2258 
2259       this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
2260     }
2261 
2262     this.compose(this.current.getClippedPathBoundingBox());
2263     this.restore();
2264   }
2265 
2266   // Images
2267   beginInlineImage() {
2268     unreachable("Should not call beginInlineImage");
2269   }
2270 
2271   beginImageData() {
2272     unreachable("Should not call beginImageData");
2273   }
2274 
2275   paintFormXObjectBegin(matrix, bbox) {
2276     if (!this.contentVisible) {
2277       return;
2278     }
2279     this.save();
2280     this.baseTransformStack.push(this.baseTransform);
2281 
2282     if (matrix) {
2283       this.transform(...matrix);
2284     }
2285     this.baseTransform = getCurrentTransform(this.ctx);
2286 
2287     if (bbox) {
2288       Util.axialAlignedBoundingBox(
2289         bbox,
2290         this.baseTransform,
2291         this.current.minMax
2292       );
2293       const [x0, y0, x1, y1] = bbox;
2294       const clip = new Path2D();
2295       clip.rect(x0, y0, x1 - x0, y1 - y0);
2296       this.ctx.clip(clip);
2297       this.endPath();
2298     }
2299   }
2300 
2301   paintFormXObjectEnd() {
2302     if (!this.contentVisible) {
2303       return;
2304     }
2305     this.restore();
2306     this.baseTransform = this.baseTransformStack.pop();
2307   }
2308 
2309   beginGroup(group) {
2310     if (!this.contentVisible) {
2311       return;
2312     }
2313 
2314     this.save();
2315     // If there's an active soft mask we don't want it enabled for the group, so
2316     // clear it out. The mask and suspended canvas will be restored in endGroup.
2317     if (this.inSMaskMode) {
2318       this.endSMaskMode();
2319       this.current.activeSMask = null;
2320     }
2321 
2322     const currentCtx = this.ctx;
2323     // TODO non-isolated groups - according to Rik at adobe non-isolated
2324     // group results aren't usually that different and they even have tools
2325     // that ignore this setting. Notes from Rik on implementing:
2326     // - When you encounter an transparency group, create a new canvas with
2327     // the dimensions of the bbox
2328     // - copy the content from the previous canvas to the new canvas
2329     // - draw as usual
2330     // - remove the backdrop alpha:
2331     // alphaNew = 1 - (1 - alpha)/(1 - alphaBackdrop) with 'alpha' the alpha
2332     // value of your transparency group and 'alphaBackdrop' the alpha of the
2333     // backdrop
2334     // - remove background color:
2335     // colorNew = color - alphaNew *colorBackdrop /(1 - alphaNew)
2336     if (!group.isolated) {
2337       info("TODO: Support non-isolated groups.");
2338     }
2339 
2340     // TODO knockout - supposedly possible with the clever use of compositing
2341     // modes.
2342     if (group.knockout) {
2343       warn("Knockout groups not supported.");
2344     }
2345 
2346     const currentTransform = getCurrentTransform(currentCtx);
2347     if (group.matrix) {
2348       currentCtx.transform(...group.matrix);
2349     }
2350     if (!group.bbox) {
2351       throw new Error("Bounding box is required.");
2352     }
2353 
2354     // Based on the current transform figure out how big the bounding box
2355     // will actually be.
2356     let bounds = MIN_MAX_INIT.slice();
2357     Util.axialAlignedBoundingBox(
2358       group.bbox,
2359       getCurrentTransform(currentCtx),
2360       bounds
2361     );
2362 
2363     // Clip the bounding box to the current canvas.
2364     const canvasBounds = [
2365       0,
2366       0,
2367       currentCtx.canvas.width,
2368       currentCtx.canvas.height,
2369     ];
2370     bounds = Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
2371     // Use ceil in case we're between sizes so we don't create canvas that is
2372     // too small and make the canvas at least 1x1 pixels.
2373     const offsetX = Math.floor(bounds[0]);
2374     const offsetY = Math.floor(bounds[1]);
2375     const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
2376     const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
2377 
2378     this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
2379 
2380     let cacheId = "groupAt" + this.groupLevel;
2381     if (group.smask) {
2382       // Using two cache entries is case if masks are used one after another.
2383       cacheId += "_smask_" + (this.smaskCounter++ % 2);
2384     }
2385     const scratchCanvas = this.cachedCanvases.getCanvas(
2386       cacheId,
2387       drawnWidth,
2388       drawnHeight
2389     );
2390     const groupCtx = scratchCanvas.context;
2391 
2392     // Since we created a new canvas that is just the size of the bounding box
2393     // we have to translate the group ctx.
2394     groupCtx.translate(-offsetX, -offsetY);
2395     groupCtx.transform(...currentTransform);
2396 
2397     // Apply the bbox to the group context.
2398     let clip = new Path2D();
2399     const [x0, y0, x1, y1] = group.bbox;
2400     clip.rect(x0, y0, x1 - x0, y1 - y0);
2401     if (group.matrix) {
2402       const path = new Path2D();
2403       path.addPath(clip, new DOMMatrix(group.matrix));
2404       clip = path;
2405     }
2406     groupCtx.clip(clip);
2407 
2408     if (group.smask) {
2409       // Saving state and cached mask to be used in setGState.
2410       this.smaskStack.push({
2411         canvas: scratchCanvas.canvas,
2412         context: groupCtx,
2413         offsetX,
2414         offsetY,
2415         subtype: group.smask.subtype,
2416         backdrop: group.smask.backdrop,
2417         transferMap: group.smask.transferMap || null,
2418         startTransformInverse: null, // used during suspend operation
2419       });
2420     } else {
2421       // Setup the current ctx so when the group is popped we draw it at the
2422       // right location.
2423       currentCtx.setTransform(1, 0, 0, 1, 0, 0);
2424       currentCtx.translate(offsetX, offsetY);
2425       currentCtx.save();
2426     }
2427     // The transparency group inherits all off the current graphics state
2428     // except the blend mode, soft mask, and alpha constants.
2429     copyCtxState(currentCtx, groupCtx);
2430     this.ctx = groupCtx;
2431     this.setGState([
2432       ["BM", "source-over"],
2433       ["ca", 1],
2434       ["CA", 1],
2435     ]);
2436     this.groupStack.push(currentCtx);
2437     this.groupLevel++;
2438   }
2439 
2440   endGroup(group) {
2441     if (!this.contentVisible) {
2442       return;
2443     }
2444     this.groupLevel--;
2445     const groupCtx = this.ctx;
2446     const ctx = this.groupStack.pop();
2447     this.ctx = ctx;
2448     // Turn off image smoothing to avoid sub pixel interpolation which can
2449     // look kind of blurry for some pdfs.
2450     this.ctx.imageSmoothingEnabled = false;
2451 
2452     if (group.smask) {
2453       this.tempSMask = this.smaskStack.pop();
2454       this.restore();
2455     } else {
2456       this.ctx.restore();
2457       const currentMtx = getCurrentTransform(this.ctx);
2458       this.restore();
2459       this.ctx.save();
2460       this.ctx.setTransform(...currentMtx);
2461       const dirtyBox = MIN_MAX_INIT.slice();
2462       Util.axialAlignedBoundingBox(
2463         [0, 0, groupCtx.canvas.width, groupCtx.canvas.height],
2464         currentMtx,
2465         dirtyBox
2466       );
2467       this.ctx.drawImage(groupCtx.canvas, 0, 0);
2468       this.ctx.restore();
2469       this.compose(dirtyBox);
2470     }
2471   }
2472 
2473   beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {
2474     // The annotations are drawn just after the page content.
2475     // The page content drawing can potentially have set a transform,
2476     // a clipping path, whatever...
2477     // So in order to have something clean, we restore the initial state.
2478     this.#restoreInitialState();
2479     resetCtxToDefault(this.ctx);
2480 
2481     this.ctx.save();
2482     this.save();
2483 
2484     if (this.baseTransform) {
2485       this.ctx.setTransform(...this.baseTransform);
2486     }
2487 
2488     if (rect) {
2489       const width = rect[2] - rect[0];
2490       const height = rect[3] - rect[1];
2491 
2492       if (hasOwnCanvas && this.annotationCanvasMap) {
2493         transform = transform.slice();
2494         transform[4] -= rect[0];
2495         transform[5] -= rect[1];
2496 
2497         rect = rect.slice();
2498         rect[0] = rect[1] = 0;
2499         rect[2] = width;
2500         rect[3] = height;
2501 
2502         Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx), XY);
2503         const { viewportScale } = this;
2504         const canvasWidth = Math.ceil(
2505           width * this.outputScaleX * viewportScale
2506         );
2507         const canvasHeight = Math.ceil(
2508           height * this.outputScaleY * viewportScale
2509         );
2510 
2511         this.annotationCanvas = this.canvasFactory.create(
2512           canvasWidth,
2513           canvasHeight
2514         );
2515         const { canvas, context } = this.annotationCanvas;
2516         this.annotationCanvasMap.set(id, canvas);
2517         this.annotationCanvas.savedCtx = this.ctx;
2518         this.ctx = context;
2519         this.ctx.save();
2520         this.ctx.setTransform(XY[0], 0, 0, -XY[1], 0, height * XY[1]);
2521 
2522         resetCtxToDefault(this.ctx);
2523       } else {
2524         resetCtxToDefault(this.ctx);
2525 
2526         // Consume a potential path before clipping.
2527         this.endPath();
2528 
2529         const clip = new Path2D();
2530         clip.rect(rect[0], rect[1], width, height);
2531         this.ctx.clip(clip);
2532       }
2533     }
2534 
2535     this.current = new CanvasExtraState(
2536       this.ctx.canvas.width,
2537       this.ctx.canvas.height
2538     );
2539 
2540     this.transform(...transform);
2541     this.transform(...matrix);
2542   }
2543 
2544   endAnnotation() {
2545     if (this.annotationCanvas) {
2546       this.ctx.restore();
2547       this.#drawFilter();
2548 
2549       this.ctx = this.annotationCanvas.savedCtx;
2550       delete this.annotationCanvas.savedCtx;
2551       delete this.annotationCanvas;
2552     }
2553   }
2554 
2555   paintImageMaskXObject(img) {
2556     if (!this.contentVisible) {
2557       return;
2558     }
2559     const count = img.count;
2560     img = this.getObject(img.data, img);
2561     img.count = count;
2562 
2563     const ctx = this.ctx;
2564     const mask = this._createMaskCanvas(img);
2565     const maskCanvas = mask.canvas;
2566 
2567     ctx.save();
2568     // The mask is drawn with the transform applied. Reset the current
2569     // transform to draw to the identity.
2570     ctx.setTransform(1, 0, 0, 1, 0, 0);
2571     ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
2572     ctx.restore();
2573     this.compose();
2574   }
2575 
2576   paintImageMaskXObjectRepeat(
2577     img,
2578     scaleX,
2579     skewX = 0,
2580     skewY = 0,
2581     scaleY,
2582     positions
2583   ) {
2584     if (!this.contentVisible) {
2585       return;
2586     }
2587 
2588     img = this.getObject(img.data, img);
2589 
2590     const ctx = this.ctx;
2591     ctx.save();
2592     const currentTransform = getCurrentTransform(ctx);
2593     ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
2594     const mask = this._createMaskCanvas(img);
2595 
2596     ctx.setTransform(
2597       1,
2598       0,
2599       0,
2600       1,
2601       mask.offsetX - currentTransform[4],
2602       mask.offsetY - currentTransform[5]
2603     );
2604     for (let i = 0, ii = positions.length; i < ii; i += 2) {
2605       const trans = Util.transform(currentTransform, [
2606         scaleX,
2607         skewX,
2608         skewY,
2609         scaleY,
2610         positions[i],
2611         positions[i + 1],
2612       ]);
2613 
2614       // Here we want to apply the transform at the origin,
2615       // hence no additional computation is necessary.
2616       ctx.drawImage(mask.canvas, trans[4], trans[5]);
2617     }
2618     ctx.restore();
2619     this.compose();
2620   }
2621 
2622   paintImageMaskXObjectGroup(images) {
2623     if (!this.contentVisible) {
2624       return;
2625     }
2626     const ctx = this.ctx;
2627 
2628     const fillColor = this.current.fillColor;
2629     const isPatternFill = this.current.patternFill;
2630 
2631     for (const image of images) {
2632       const { data, width, height, transform } = image;
2633 
2634       const maskCanvas = this.cachedCanvases.getCanvas(
2635         "maskCanvas",
2636         width,
2637         height
2638       );
2639       const maskCtx = maskCanvas.context;
2640       maskCtx.save();
2641 
2642       const img = this.getObject(data, image);
2643       putBinaryImageMask(maskCtx, img);
2644 
2645       maskCtx.globalCompositeOperation = "source-in";
2646 
2647       maskCtx.fillStyle = isPatternFill
2648         ? fillColor.getPattern(
2649             maskCtx,
2650             this,
2651             getCurrentTransformInverse(ctx),
2652             PathType.FILL
2653           )
2654         : fillColor;
2655       maskCtx.fillRect(0, 0, width, height);
2656 
2657       maskCtx.restore();
2658 
2659       ctx.save();
2660       ctx.transform(...transform);
2661       ctx.scale(1, -1);
2662       drawImageAtIntegerCoords(
2663         ctx,
2664         maskCanvas.canvas,
2665         0,
2666         0,
2667         width,
2668         height,
2669         0,
2670         -1,
2671         1,
2672         1
2673       );
2674       ctx.restore();
2675     }
2676     this.compose();
2677   }
2678 
2679   paintImageXObject(objId) {
2680     if (!this.contentVisible) {
2681       return;
2682     }
2683     const imgData = this.getObject(objId);
2684     if (!imgData) {
2685       warn("Dependent image isn't ready yet");
2686       return;
2687     }
2688 
2689     this.paintInlineImageXObject(imgData);
2690   }
2691 
2692   paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
2693     if (!this.contentVisible) {
2694       return;
2695     }
2696     const imgData = this.getObject(objId);
2697     if (!imgData) {
2698       warn("Dependent image isn't ready yet");
2699       return;
2700     }
2701 
2702     const width = imgData.width;
2703     const height = imgData.height;
2704     const map = [];
2705     for (let i = 0, ii = positions.length; i < ii; i += 2) {
2706       map.push({
2707         transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
2708         x: 0,
2709         y: 0,
2710         w: width,
2711         h: height,
2712       });
2713     }
2714     this.paintInlineImageXObjectGroup(imgData, map);
2715   }
2716 
2717   applyTransferMapsToCanvas(ctx) {
2718     if (this.current.transferMaps !== "none") {
2719       ctx.filter = this.current.transferMaps;
2720       ctx.drawImage(ctx.canvas, 0, 0);
2721       ctx.filter = "none";
2722     }
2723     return ctx.canvas;
2724   }
2725 
2726   applyTransferMapsToBitmap(imgData) {
2727     if (this.current.transferMaps === "none") {
2728       return imgData.bitmap;
2729     }
2730     const { bitmap, width, height } = imgData;
2731     const tmpCanvas = this.cachedCanvases.getCanvas(
2732       "inlineImage",
2733       width,
2734       height
2735     );
2736     const tmpCtx = tmpCanvas.context;
2737     tmpCtx.filter = this.current.transferMaps;
2738     tmpCtx.drawImage(bitmap, 0, 0);
2739     tmpCtx.filter = "none";
2740 
2741     return tmpCanvas.canvas;
2742   }
2743 
2744   paintInlineImageXObject(imgData) {
2745     if (!this.contentVisible) {
2746       return;
2747     }
2748     const width = imgData.width;
2749     const height = imgData.height;
2750     const ctx = this.ctx;
2751 
2752     this.save();
2753 
2754     // The filter, if any, will be applied in applyTransferMapsToBitmap.
2755     // It must be applied to the image before rescaling else some artifacts
2756     // could appear.
2757     // The final restore will reset it to its value.
2758     const { filter } = ctx;
2759     if (filter !== "none" && filter !== "") {
2760       ctx.filter = "none";
2761     }
2762 
2763     // scale the image to the unit square
2764     ctx.scale(1 / width, -1 / height);
2765 
2766     let imgToPaint;
2767     if (imgData.bitmap) {
2768       imgToPaint = this.applyTransferMapsToBitmap(imgData);
2769     } else if (
2770       (typeof HTMLElement === "function" && imgData instanceof HTMLElement) ||
2771       !imgData.data
2772     ) {
2773       // typeof check is needed due to node.js support, see issue #8489
2774       imgToPaint = imgData;
2775     } else {
2776       const tmpCanvas = this.cachedCanvases.getCanvas(
2777         "inlineImage",
2778         width,
2779         height
2780       );
2781       const tmpCtx = tmpCanvas.context;
2782       putBinaryImageData(tmpCtx, imgData);
2783       imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
2784     }
2785 
2786     const scaled = this._scaleImage(
2787       imgToPaint,
2788       getCurrentTransformInverse(ctx)
2789     );
2790     ctx.imageSmoothingEnabled = getImageSmoothingEnabled(
2791       getCurrentTransform(ctx),
2792       imgData.interpolate
2793     );
2794 
2795     drawImageAtIntegerCoords(
2796       ctx,
2797       scaled.img,
2798       0,
2799       0,
2800       scaled.paintWidth,
2801       scaled.paintHeight,
2802       0,
2803       -height,
2804       width,
2805       height
2806     );
2807     this.compose();
2808     this.restore();
2809   }
2810 
2811   paintInlineImageXObjectGroup(imgData, map) {
2812     if (!this.contentVisible) {
2813       return;
2814     }
2815     const ctx = this.ctx;
2816     let imgToPaint;
2817     if (imgData.bitmap) {
2818       imgToPaint = imgData.bitmap;
2819     } else {
2820       const w = imgData.width;
2821       const h = imgData.height;
2822 
2823       const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
2824       const tmpCtx = tmpCanvas.context;
2825       putBinaryImageData(tmpCtx, imgData);
2826       imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
2827     }
2828 
2829     for (const entry of map) {
2830       ctx.save();
2831       ctx.transform(...entry.transform);
2832       ctx.scale(1, -1);
2833       drawImageAtIntegerCoords(
2834         ctx,
2835         imgToPaint,
2836         entry.x,
2837         entry.y,
2838         entry.w,
2839         entry.h,
2840         0,
2841         -1,
2842         1,
2843         1
2844       );
2845       ctx.restore();
2846     }
2847     this.compose();
2848   }
2849 
2850   paintSolidColorImageMask() {
2851     if (!this.contentVisible) {
2852       return;
2853     }
2854     this.ctx.fillRect(0, 0, 1, 1);
2855     this.compose();
2856   }
2857 
2858   // Marked content
2859 
2860   markPoint(tag) {
2861     // TODO Marked content.
2862   }
2863 
2864   markPointProps(tag, properties) {
2865     // TODO Marked content.
2866   }
2867 
2868   beginMarkedContent(tag) {
2869     this.markedContentStack.push({
2870       visible: true,
2871     });
2872   }
2873 
2874   beginMarkedContentProps(tag, properties) {
2875     if (tag === "OC") {
2876       this.markedContentStack.push({
2877         visible: this.optionalContentConfig.isVisible(properties),
2878       });
2879     } else {
2880       this.markedContentStack.push({
2881         visible: true,
2882       });
2883     }
2884     this.contentVisible = this.isContentVisible();
2885   }
2886 
2887   endMarkedContent() {
2888     this.markedContentStack.pop();
2889     this.contentVisible = this.isContentVisible();
2890   }
2891 
2892   // Compatibility
2893 
2894   beginCompat() {
2895     // TODO ignore undefined operators (should we do that anyway?)
2896   }
2897 
2898   endCompat() {
2899     // TODO stop ignoring undefined operators
2900   }
2901 
2902   // Helper functions
2903 
2904   consumePath(path, clipBox) {
2905     const isEmpty = this.current.isEmptyClip();
2906     if (this.pendingClip) {
2907       this.current.updateClipFromPath();
2908     }
2909     if (!this.pendingClip) {
2910       this.compose(clipBox);
2911     }
2912     const ctx = this.ctx;
2913     if (this.pendingClip) {
2914       if (!isEmpty) {
2915         if (this.pendingClip === EO_CLIP) {
2916           ctx.clip(path, "evenodd");
2917         } else {
2918           ctx.clip(path);
2919         }
2920       }
2921       this.pendingClip = null;
2922     }
2923     this.current.startNewPathAndClipBox(this.current.clipBox);
2924   }
2925 
2926   getSinglePixelWidth() {
2927     if (!this._cachedGetSinglePixelWidth) {
2928       const m = getCurrentTransform(this.ctx);
2929       if (m[1] === 0 && m[2] === 0) {
2930         // Fast path
2931         this._cachedGetSinglePixelWidth =
2932           1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
2933       } else {
2934         const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
2935         const normX = Math.hypot(m[0], m[2]);
2936         const normY = Math.hypot(m[1], m[3]);
2937         this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
2938       }
2939     }
2940     return this._cachedGetSinglePixelWidth;
2941   }
2942 
2943   getScaleForStroking() {
2944     // A pixel has thicknessX = thicknessY = 1;
2945     // A transformed pixel is a parallelogram and the thicknesses
2946     // corresponds to the heights.
2947     // The goal of this function is to rescale before setting the
2948     // lineWidth in order to have both thicknesses greater or equal
2949     // to 1 after transform.
2950     if (this._cachedScaleForStroking[0] === -1) {
2951       const { lineWidth } = this.current;
2952       const { a, b, c, d } = this.ctx.getTransform();
2953       let scaleX, scaleY;
2954 
2955       if (b === 0 && c === 0) {
2956         // Fast path
2957         const normX = Math.abs(a);
2958         const normY = Math.abs(d);
2959         if (normX === normY) {
2960           if (lineWidth === 0) {
2961             scaleX = scaleY = 1 / normX;
2962           } else {
2963             const scaledLineWidth = normX * lineWidth;
2964             scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;
2965           }
2966         } else if (lineWidth === 0) {
2967           scaleX = 1 / normX;
2968           scaleY = 1 / normY;
2969         } else {
2970           const scaledXLineWidth = normX * lineWidth;
2971           const scaledYLineWidth = normY * lineWidth;
2972           scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
2973           scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
2974         }
2975       } else {
2976         // A pixel (base (x, y)) is transformed by M into a parallelogram:
2977         //  - its area is |det(M)|;
2978         //  - heightY (orthogonal to Mx) has a length: |det(M)| / norm(Mx);
2979         //  - heightX (orthogonal to My) has a length: |det(M)| / norm(My).
2980         // heightX and heightY are the thicknesses of the transformed pixel
2981         // and they must be both greater or equal to 1.
2982         const absDet = Math.abs(a * d - b * c);
2983         const normX = Math.hypot(a, b);
2984         const normY = Math.hypot(c, d);
2985         if (lineWidth === 0) {
2986           scaleX = normY / absDet;
2987           scaleY = normX / absDet;
2988         } else {
2989           const baseArea = lineWidth * absDet;
2990           scaleX = normY > baseArea ? normY / baseArea : 1;
2991           scaleY = normX > baseArea ? normX / baseArea : 1;
2992         }
2993       }
2994       this._cachedScaleForStroking[0] = scaleX;
2995       this._cachedScaleForStroking[1] = scaleY;
2996     }
2997     return this._cachedScaleForStroking;
2998   }
2999 
3000   // Rescale before stroking in order to have a final lineWidth
3001   // with both thicknesses greater or equal to 1.
3002   rescaleAndStroke(path, saveRestore) {
3003     const {
3004       ctx,
3005       current: { lineWidth },
3006     } = this;
3007     const [scaleX, scaleY] = this.getScaleForStroking();
3008 
3009     if (scaleX === scaleY) {
3010       ctx.lineWidth = (lineWidth || 1) * scaleX;
3011       ctx.stroke(path);
3012       return;
3013     }
3014 
3015     const dashes = ctx.getLineDash();
3016     if (saveRestore) {
3017       ctx.save();
3018     }
3019 
3020     ctx.scale(scaleX, scaleY);
3021     SCALE_MATRIX.a = 1 / scaleX;
3022     SCALE_MATRIX.d = 1 / scaleY;
3023     const newPath = new Path2D();
3024     newPath.addPath(path, SCALE_MATRIX);
3025 
3026     // How the dashed line is rendered depends on the current transform...
3027     // so we added a rescale to handle too thin lines and consequently
3028     // the way the line is dashed will be modified.
3029     // If scaleX === scaleY, the dashed lines will be rendered correctly
3030     // else we'll have some bugs (but only with too thin lines).
3031     // Here we take the max... why not taking the min... or something else.
3032     // Anyway, as said it's buggy when scaleX !== scaleY.
3033     if (dashes.length > 0) {
3034       const scale = Math.max(scaleX, scaleY);
3035       ctx.setLineDash(dashes.map(x => x / scale));
3036       ctx.lineDashOffset /= scale;
3037     }
3038 
3039     ctx.lineWidth = lineWidth || 1;
3040     ctx.stroke(newPath);
3041 
3042     if (saveRestore) {
3043       ctx.restore();
3044     }
3045   }
3046 
3047   isContentVisible() {
3048     for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
3049       if (!this.markedContentStack[i].visible) {
3050         return false;
3051       }
3052     }
3053     return true;
3054   }
3055 }
3056 
3057 for (const op in OPS) {
3058   if (CanvasGraphics.prototype[op] !== undefined) {
3059     CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];
3060   }
3061 }
3062 
3063 export { CanvasGraphics };
</code>

Test file:
<test_file>
File:
test/unit/annotation_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  Annotation,
  AnnotationBorderStyle,
  AnnotationFactory,
  getQuadPoints,
  MarkupAnnotation,
} from "../../src/core/annotation.js";
import {
  AnnotationBorderStyleType,
  AnnotationEditorType,
  AnnotationFieldFlag,
  AnnotationFlag,
  AnnotationType,
  DrawOPS,
  OPS,
  RenderingIntentFlag,
  stringToBytes,
  stringToUTF8String,
} from "../../src/shared/util.js";
import {
  CMAP_URL,
  createIdFactory,
  DefaultCMapReaderFactory,
  DefaultStandardFontDataFactory,
  STANDARD_FONT_DATA_URL,
  XRefMock,
} from "./test_utils.js";
import { Dict, Name, Ref, RefSetCache } from "../../src/core/primitives.js";
import { Lexer, Parser } from "../../src/core/parser.js";
import { FlateStream } from "../../src/core/flate_stream.js";
import { PartialEvaluator } from "../../src/core/evaluator.js";
import { StringStream } from "../../src/core/stream.js";
import { WorkerTask } from "../../src/core/worker.js";
import { writeChanges } from "../../src/core/writer.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

