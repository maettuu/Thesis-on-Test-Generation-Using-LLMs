Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: Diamond gradient not displayed
### Attach (recommended) or Link to PDF file

[test.pdf](https://github.com/user-attachments/files/17175755/test.pdf)





### Web browser and its version

Both Firefox 130.0.1 and Nightly

### Operating system and its version

Arch Linux

### PDF.js version

v4.6.82

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

Yes

### Steps to reproduce the problem

Attached PDF created by Scribus does not render correctly in Firefox or using the online demo of pdf.js. No warnings or errors displayed in console.


### What is the expected behavior?

Expected result:
![image](https://github.com/user-attachments/assets/c02401c5-6073-46e8-bdc8-d656d82f02fe)

### What went wrong?

Actual result:
![image](https://github.com/user-attachments/assets/539bf9c3-7e0d-4aca-af21-49dd252344e6)


### Link to a viewer

_No response_

### Additional context

_No response_
</issue>

Patch:
<patch>
diff --git a/src/display/pattern_helper.js b/src/display/pattern_helper.js
--- a/src/display/pattern_helper.js
+++ b/src/display/pattern_helper.js
@@ -313,8 +313,8 @@ class MeshShadingPattern extends BaseShadingPattern {
     this._colors = IR[3];
     this._figures = IR[4];
     this._bounds = IR[5];
-    this._bbox = IR[7];
-    this._background = IR[8];
+    this._bbox = IR[6];
+    this._background = IR[7];
     this.matrix = null;
   }


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.0
- @babel/preset-env: ^7.26.0
- @babel/runtime: ^7.26.0
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.65
- @types/node: ^22.10.2
- autoprefixer: ^10.4.20
- babel-loader: ^9.2.1
- caniuse-lite: ^1.0.30001690
- core-js: ^3.39.0
- eslint: ^9.17.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.3.0
- eslint-plugin-prettier: ^5.2.1
- eslint-plugin-unicorn: ^56.0.1
- globals: ^15.14.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- highlight.js: ^11.11.0
- jasmine: ^5.5.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.4.49
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.4.2
- puppeteer: ^23.11.1
- stylelint: ^16.12.0
- stylelint-prettier: ^5.0.2
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.11
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.7.2
- vinyl: ^3.0.0
- webpack: ^5.97.1
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: fetchData
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/display/pattern_helper.js
1 /* Copyright 2014 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import { FormatError, info, unreachable, Util } from "../shared/util.js";
17 import { getCurrentTransform } from "./display_utils.js";
18 
19 const PathType = {
20   FILL: "Fill",
21   STROKE: "Stroke",
22   SHADING: "Shading",
23 };
24 
25 function applyBoundingBox(ctx, bbox) {
26   if (!bbox) {
27     return;
28   }
29   const width = bbox[2] - bbox[0];
30   const height = bbox[3] - bbox[1];
31   const region = new Path2D();
32   region.rect(bbox[0], bbox[1], width, height);
33   ctx.clip(region);
34 }
35 
36 class BaseShadingPattern {
37   constructor() {
38     if (
39       (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) &&
40       this.constructor === BaseShadingPattern
41     ) {
42       unreachable("Cannot initialize BaseShadingPattern.");
43     }
44   }
45 
46   getPattern() {
47     unreachable("Abstract method `getPattern` called.");
48   }
49 }
50 
51 class RadialAxialShadingPattern extends BaseShadingPattern {
52   constructor(IR) {
53     super();
54     this._type = IR[1];
55     this._bbox = IR[2];
56     this._colorStops = IR[3];
57     this._p0 = IR[4];
58     this._p1 = IR[5];
59     this._r0 = IR[6];
60     this._r1 = IR[7];
61     this.matrix = null;
62   }
63 
64   _createGradient(ctx) {
65     let grad;
66     if (this._type === "axial") {
67       grad = ctx.createLinearGradient(
68         this._p0[0],
69         this._p0[1],
70         this._p1[0],
71         this._p1[1]
72       );
73     } else if (this._type === "radial") {
74       grad = ctx.createRadialGradient(
75         this._p0[0],
76         this._p0[1],
77         this._r0,
78         this._p1[0],
79         this._p1[1],
80         this._r1
81       );
82     }
83 
84     for (const colorStop of this._colorStops) {
85       grad.addColorStop(colorStop[0], colorStop[1]);
86     }
87     return grad;
88   }
89 
90   getPattern(ctx, owner, inverse, pathType) {
91     let pattern;
92     if (pathType === PathType.STROKE || pathType === PathType.FILL) {
93       const ownerBBox = owner.current.getClippedPathBoundingBox(
94         pathType,
95         getCurrentTransform(ctx)
96       ) || [0, 0, 0, 0];
97       // Create a canvas that is only as big as the current path. This doesn't
98       // allow us to cache the pattern, but it generally creates much smaller
99       // canvases and saves memory use. See bug 1722807 for an example.
100       const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
101       const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
102 
103       const tmpCanvas = owner.cachedCanvases.getCanvas(
104         "pattern",
105         width,
106         height
107       );
108 
109       const tmpCtx = tmpCanvas.context;
110       tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
111       tmpCtx.beginPath();
112       tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
113       // Non shading fill patterns are positioned relative to the base transform
114       // (usually the page's initial transform), but we may have created a
115       // smaller canvas based on the path, so we must account for the shift.
116       tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
117       inverse = Util.transform(inverse, [
118         1,
119         0,
120         0,
121         1,
122         ownerBBox[0],
123         ownerBBox[1],
124       ]);
125 
126       tmpCtx.transform(...owner.baseTransform);
127       if (this.matrix) {
128         tmpCtx.transform(...this.matrix);
129       }
130       applyBoundingBox(tmpCtx, this._bbox);
131 
132       tmpCtx.fillStyle = this._createGradient(tmpCtx);
133       tmpCtx.fill();
134 
135       pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
136       const domMatrix = new DOMMatrix(inverse);
137       pattern.setTransform(domMatrix);
138     } else {
139       // Shading fills are applied relative to the current matrix which is also
140       // how canvas gradients work, so there's no need to do anything special
141       // here.
142       applyBoundingBox(ctx, this._bbox);
143       pattern = this._createGradient(ctx);
144     }
145     return pattern;
146   }
147 }
148 
149 function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
150   // Very basic Gouraud-shaded triangle rasterization algorithm.
151   const coords = context.coords,
152     colors = context.colors;
153   const bytes = data.data,
154     rowSize = data.width * 4;
155   let tmp;
156   if (coords[p1 + 1] > coords[p2 + 1]) {
157     tmp = p1;
158     p1 = p2;
159     p2 = tmp;
160     tmp = c1;
161     c1 = c2;
162     c2 = tmp;
163   }
164   if (coords[p2 + 1] > coords[p3 + 1]) {
165     tmp = p2;
166     p2 = p3;
167     p3 = tmp;
168     tmp = c2;
169     c2 = c3;
170     c3 = tmp;
171   }
172   if (coords[p1 + 1] > coords[p2 + 1]) {
173     tmp = p1;
174     p1 = p2;
175     p2 = tmp;
176     tmp = c1;
177     c1 = c2;
178     c2 = tmp;
179   }
180   const x1 = (coords[p1] + context.offsetX) * context.scaleX;
181   const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
182   const x2 = (coords[p2] + context.offsetX) * context.scaleX;
183   const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
184   const x3 = (coords[p3] + context.offsetX) * context.scaleX;
185   const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
186   if (y1 >= y3) {
187     return;
188   }
189   const c1r = colors[c1],
190     c1g = colors[c1 + 1],
191     c1b = colors[c1 + 2];
192   const c2r = colors[c2],
193     c2g = colors[c2 + 1],
194     c2b = colors[c2 + 2];
195   const c3r = colors[c3],
196     c3g = colors[c3 + 1],
197     c3b = colors[c3 + 2];
198 
199   const minY = Math.round(y1),
200     maxY = Math.round(y3);
201   let xa, car, cag, cab;
202   let xb, cbr, cbg, cbb;
203   for (let y = minY; y <= maxY; y++) {
204     if (y < y2) {
205       const k = y < y1 ? 0 : (y1 - y) / (y1 - y2);
206       xa = x1 - (x1 - x2) * k;
207       car = c1r - (c1r - c2r) * k;
208       cag = c1g - (c1g - c2g) * k;
209       cab = c1b - (c1b - c2b) * k;
210     } else {
211       let k;
212       if (y > y3) {
213         k = 1;
214       } else if (y2 === y3) {
215         k = 0;
216       } else {
217         k = (y2 - y) / (y2 - y3);
218       }
219       xa = x2 - (x2 - x3) * k;
220       car = c2r - (c2r - c3r) * k;
221       cag = c2g - (c2g - c3g) * k;
222       cab = c2b - (c2b - c3b) * k;
223     }
224 
225     let k;
226     if (y < y1) {
227       k = 0;
228     } else if (y > y3) {
229       k = 1;
230     } else {
231       k = (y1 - y) / (y1 - y3);
232     }
233     xb = x1 - (x1 - x3) * k;
234     cbr = c1r - (c1r - c3r) * k;
235     cbg = c1g - (c1g - c3g) * k;
236     cbb = c1b - (c1b - c3b) * k;
237     const x1_ = Math.round(Math.min(xa, xb));
238     const x2_ = Math.round(Math.max(xa, xb));
239     let j = rowSize * y + x1_ * 4;
240     for (let x = x1_; x <= x2_; x++) {
241       k = (xa - x) / (xa - xb);
242       if (k < 0) {
243         k = 0;
244       } else if (k > 1) {
245         k = 1;
246       }
247       bytes[j++] = (car - (car - cbr) * k) | 0;
248       bytes[j++] = (cag - (cag - cbg) * k) | 0;
249       bytes[j++] = (cab - (cab - cbb) * k) | 0;
250       bytes[j++] = 255;
251     }
252   }
253 }
254 
255 function drawFigure(data, figure, context) {
256   const ps = figure.coords;
257   const cs = figure.colors;
258   let i, ii;
259   switch (figure.type) {
260     case "lattice":
261       const verticesPerRow = figure.verticesPerRow;
262       const rows = Math.floor(ps.length / verticesPerRow) - 1;
263       const cols = verticesPerRow - 1;
264       for (i = 0; i < rows; i++) {
265         let q = i * verticesPerRow;
266         for (let j = 0; j < cols; j++, q++) {
267           drawTriangle(
268             data,
269             context,
270             ps[q],
271             ps[q + 1],
272             ps[q + verticesPerRow],
273             cs[q],
274             cs[q + 1],
275             cs[q + verticesPerRow]
276           );
277           drawTriangle(
278             data,
279             context,
280             ps[q + verticesPerRow + 1],
281             ps[q + 1],
282             ps[q + verticesPerRow],
283             cs[q + verticesPerRow + 1],
284             cs[q + 1],
285             cs[q + verticesPerRow]
286           );
287         }
288       }
289       break;
290     case "triangles":
291       for (i = 0, ii = ps.length; i < ii; i += 3) {
292         drawTriangle(
293           data,
294           context,
295           ps[i],
296           ps[i + 1],
297           ps[i + 2],
298           cs[i],
299           cs[i + 1],
300           cs[i + 2]
301         );
302       }
303       break;
304     default:
305       throw new Error("illegal figure");
306   }
307 }
308 
309 class MeshShadingPattern extends BaseShadingPattern {
310   constructor(IR) {
311     super();
312     this._coords = IR[2];
313     this._colors = IR[3];
314     this._figures = IR[4];
315     this._bounds = IR[5];
316     this._bbox = IR[7];
317     this._background = IR[8];
318     this.matrix = null;
319   }
320 
321   _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
322     // we will increase scale on some weird factor to let antialiasing take
323     // care of "rough" edges
324     const EXPECTED_SCALE = 1.1;
325     // MAX_PATTERN_SIZE is used to avoid OOM situation.
326     const MAX_PATTERN_SIZE = 3000; // 10in @ 300dpi shall be enough
327     // We need to keep transparent border around our pattern for fill():
328     // createPattern with 'no-repeat' will bleed edges across entire area.
329     const BORDER_SIZE = 2;
330 
331     const offsetX = Math.floor(this._bounds[0]);
332     const offsetY = Math.floor(this._bounds[1]);
333     const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
334     const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
335 
336     const width = Math.min(
337       Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)),
338       MAX_PATTERN_SIZE
339     );
340     const height = Math.min(
341       Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)),
342       MAX_PATTERN_SIZE
343     );
344     const scaleX = boundsWidth / width;
345     const scaleY = boundsHeight / height;
346 
347     const context = {
348       coords: this._coords,
349       colors: this._colors,
350       offsetX: -offsetX,
351       offsetY: -offsetY,
352       scaleX: 1 / scaleX,
353       scaleY: 1 / scaleY,
354     };
355 
356     const paddedWidth = width + BORDER_SIZE * 2;
357     const paddedHeight = height + BORDER_SIZE * 2;
358 
359     const tmpCanvas = cachedCanvases.getCanvas(
360       "mesh",
361       paddedWidth,
362       paddedHeight
363     );
364     const tmpCtx = tmpCanvas.context;
365 
366     const data = tmpCtx.createImageData(width, height);
367     if (backgroundColor) {
368       const bytes = data.data;
369       for (let i = 0, ii = bytes.length; i < ii; i += 4) {
370         bytes[i] = backgroundColor[0];
371         bytes[i + 1] = backgroundColor[1];
372         bytes[i + 2] = backgroundColor[2];
373         bytes[i + 3] = 255;
374       }
375     }
376     for (const figure of this._figures) {
377       drawFigure(data, figure, context);
378     }
379     tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
380     const canvas = tmpCanvas.canvas;
381 
382     return {
383       canvas,
384       offsetX: offsetX - BORDER_SIZE * scaleX,
385       offsetY: offsetY - BORDER_SIZE * scaleY,
386       scaleX,
387       scaleY,
388     };
389   }
390 
391   getPattern(ctx, owner, inverse, pathType) {
392     applyBoundingBox(ctx, this._bbox);
393     let scale;
394     if (pathType === PathType.SHADING) {
395       scale = Util.singularValueDecompose2dScale(getCurrentTransform(ctx));
396     } else {
397       // Obtain scale from matrix and current transformation matrix.
398       scale = Util.singularValueDecompose2dScale(owner.baseTransform);
399       if (this.matrix) {
400         const matrixScale = Util.singularValueDecompose2dScale(this.matrix);
401         scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
402       }
403     }
404 
405     // Rasterizing on the main thread since sending/queue large canvases
406     // might cause OOM.
407     const temporaryPatternCanvas = this._createMeshCanvas(
408       scale,
409       pathType === PathType.SHADING ? null : this._background,
410       owner.cachedCanvases
411     );
412 
413     if (pathType !== PathType.SHADING) {
414       ctx.setTransform(...owner.baseTransform);
415       if (this.matrix) {
416         ctx.transform(...this.matrix);
417       }
418     }
419 
420     ctx.translate(
421       temporaryPatternCanvas.offsetX,
422       temporaryPatternCanvas.offsetY
423     );
424     ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
425 
426     return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
427   }
428 }
429 
430 class DummyShadingPattern extends BaseShadingPattern {
431   getPattern() {
432     return "hotpink";
433   }
434 }
435 
436 function getShadingPattern(IR) {
437   switch (IR[0]) {
438     case "RadialAxial":
439       return new RadialAxialShadingPattern(IR);
440     case "Mesh":
441       return new MeshShadingPattern(IR);
442     case "Dummy":
443       return new DummyShadingPattern();
444   }
445   throw new Error(`Unknown IR type: ${IR[0]}`);
446 }
447 
448 const PaintType = {
449   COLORED: 1,
450   UNCOLORED: 2,
451 };
452 
453 class TilingPattern {
454   // 10in @ 300dpi shall be enough.
455   static MAX_PATTERN_SIZE = 3000;
456 
457   constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
458     this.operatorList = IR[2];
459     this.matrix = IR[3];
460     this.bbox = IR[4];
461     this.xstep = IR[5];
462     this.ystep = IR[6];
463     this.paintType = IR[7];
464     this.tilingType = IR[8];
465     this.color = color;
466     this.ctx = ctx;
467     this.canvasGraphicsFactory = canvasGraphicsFactory;
468     this.baseTransform = baseTransform;
469   }
470 
471   createPatternCanvas(owner) {
472     const {
473       bbox,
474       operatorList,
475       paintType,
476       tilingType,
477       color,
478       canvasGraphicsFactory,
479     } = this;
480     let { xstep, ystep } = this;
481     xstep = Math.abs(xstep);
482     ystep = Math.abs(ystep);
483 
484     info("TilingType: " + tilingType);
485 
486     // A tiling pattern as defined by PDF spec 8.7.2 is a cell whose size is
487     // described by bbox, and may repeat regularly by shifting the cell by
488     // xstep and ystep.
489     // Because the HTML5 canvas API does not support pattern repetition with
490     // gaps in between, we use the xstep/ystep instead of the bbox's size.
491     //
492     // This has the following consequences (similarly for ystep):
493     //
494     // - If xstep is the same as bbox, then there is no observable difference.
495     //
496     // - If xstep is larger than bbox, then the pattern canvas is partially
497     //   empty: the area bounded by bbox is painted, the outside area is void.
498     //
499     // - If xstep is smaller than bbox, then the pixels between xstep and the
500     //   bbox boundary will be missing. This is INCORRECT behavior.
501     //   "Figures on adjacent tiles should not overlap" (PDF spec 8.7.3.1),
502     //   but overlapping cells without common pixels are still valid.
503 
504     const x0 = bbox[0],
505       y0 = bbox[1],
506       x1 = bbox[2],
507       y1 = bbox[3];
508     const width = x1 - x0;
509     const height = y1 - y0;
510 
511     // Obtain scale from matrix and current transformation matrix.
512     const matrixScale = Util.singularValueDecompose2dScale(this.matrix);
513     const curMatrixScale = Util.singularValueDecompose2dScale(
514       this.baseTransform
515     );
516     const combinedScaleX = matrixScale[0] * curMatrixScale[0];
517     const combinedScaleY = matrixScale[1] * curMatrixScale[1];
518 
519     let canvasWidth = width,
520       canvasHeight = height,
521       redrawHorizontally = false,
522       redrawVertically = false;
523 
524     const xScaledStep = Math.ceil(xstep * combinedScaleX);
525     const yScaledStep = Math.ceil(ystep * combinedScaleY);
526     const xScaledWidth = Math.ceil(width * combinedScaleX);
527     const yScaledHeight = Math.ceil(height * combinedScaleY);
528 
529     if (xScaledStep >= xScaledWidth) {
530       canvasWidth = xstep;
531     } else {
532       redrawHorizontally = true;
533     }
534     if (yScaledStep >= yScaledHeight) {
535       canvasHeight = ystep;
536     } else {
537       redrawVertically = true;
538     }
539 
540     // Use width and height values that are as close as possible to the end
541     // result when the pattern is used. Too low value makes the pattern look
542     // blurry. Too large value makes it look too crispy.
543     const dimx = this.getSizeAndScale(
544       canvasWidth,
545       this.ctx.canvas.width,
546       combinedScaleX
547     );
548     const dimy = this.getSizeAndScale(
549       canvasHeight,
550       this.ctx.canvas.height,
551       combinedScaleY
552     );
553 
554     const tmpCanvas = owner.cachedCanvases.getCanvas(
555       "pattern",
556       dimx.size,
557       dimy.size
558     );
559     const tmpCtx = tmpCanvas.context;
560     const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
561     graphics.groupLevel = owner.groupLevel;
562 
563     this.setFillAndStrokeStyleToContext(graphics, paintType, color);
564 
565     tmpCtx.translate(-dimx.scale * x0, -dimy.scale * y0);
566     graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
567 
568     // To match CanvasGraphics beginDrawing we must save the context here or
569     // else we end up with unbalanced save/restores.
570     tmpCtx.save();
571 
572     this.clipBbox(graphics, x0, y0, x1, y1);
573 
574     graphics.baseTransform = getCurrentTransform(graphics.ctx);
575 
576     graphics.executeOperatorList(operatorList);
577 
578     graphics.endDrawing();
579 
580     tmpCtx.restore();
581 
582     if (redrawHorizontally || redrawVertically) {
583       // The tile is overlapping itself, so we create a new tile with
584       // dimensions xstep * ystep.
585       // Then we draw the overlapping parts of the original tile on the new
586       // tile.
587       // Just as a side note, the code here works correctly even if we don't
588       // have to redraw the tile horizontally or vertically. In that case, the
589       // original tile is drawn on the new tile only once, but it's useless.
590       const image = tmpCanvas.canvas;
591       if (redrawHorizontally) {
592         canvasWidth = xstep;
593       }
594       if (redrawVertically) {
595         canvasHeight = ystep;
596       }
597 
598       const dimx2 = this.getSizeAndScale(
599         canvasWidth,
600         this.ctx.canvas.width,
601         combinedScaleX
602       );
603       const dimy2 = this.getSizeAndScale(
604         canvasHeight,
605         this.ctx.canvas.height,
606         combinedScaleY
607       );
608 
609       const xSize = dimx2.size;
610       const ySize = dimy2.size;
611       const tmpCanvas2 = owner.cachedCanvases.getCanvas(
612         "pattern-workaround",
613         xSize,
614         ySize
615       );
616       const tmpCtx2 = tmpCanvas2.context;
617       const ii = redrawHorizontally ? Math.floor(width / xstep) : 0;
618       const jj = redrawVertically ? Math.floor(height / ystep) : 0;
619 
620       // Draw the overlapping parts of the original tile on the new tile.
621       for (let i = 0; i <= ii; i++) {
622         for (let j = 0; j <= jj; j++) {
623           tmpCtx2.drawImage(
624             image,
625             xSize * i,
626             ySize * j,
627             xSize,
628             ySize,
629             0,
630             0,
631             xSize,
632             ySize
633           );
634         }
635       }
636       return {
637         canvas: tmpCanvas2.canvas,
638         scaleX: dimx2.scale,
639         scaleY: dimy2.scale,
640         offsetX: x0,
641         offsetY: y0,
642       };
643     }
644 
645     return {
646       canvas: tmpCanvas.canvas,
647       scaleX: dimx.scale,
648       scaleY: dimy.scale,
649       offsetX: x0,
650       offsetY: y0,
651     };
652   }
653 
654   getSizeAndScale(step, realOutputSize, scale) {
655     // MAX_PATTERN_SIZE is used to avoid OOM situation.
656     // Use the destination canvas's size if it is bigger than the hard-coded
657     // limit of MAX_PATTERN_SIZE to avoid clipping patterns that cover the
658     // whole canvas.
659     const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
660     let size = Math.ceil(step * scale);
661     if (size >= maxSize) {
662       size = maxSize;
663     } else {
664       scale = size / step;
665     }
666     return { scale, size };
667   }
668 
669   clipBbox(graphics, x0, y0, x1, y1) {
670     const bboxWidth = x1 - x0;
671     const bboxHeight = y1 - y0;
672     graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
673     graphics.current.updateRectMinMax(getCurrentTransform(graphics.ctx), [
674       x0,
675       y0,
676       x1,
677       y1,
678     ]);
679     graphics.clip();
680     graphics.endPath();
681   }
682 
683   setFillAndStrokeStyleToContext(graphics, paintType, color) {
684     const context = graphics.ctx,
685       current = graphics.current;
686     switch (paintType) {
687       case PaintType.COLORED:
688         const ctx = this.ctx;
689         context.fillStyle = ctx.fillStyle;
690         context.strokeStyle = ctx.strokeStyle;
691         current.fillColor = ctx.fillStyle;
692         current.strokeColor = ctx.strokeStyle;
693         break;
694       case PaintType.UNCOLORED:
695         const cssColor = Util.makeHexColor(color[0], color[1], color[2]);
696         context.fillStyle = cssColor;
697         context.strokeStyle = cssColor;
698         // Set color needed by image masks (fixes issues 3226 and 8741).
699         current.fillColor = cssColor;
700         current.strokeColor = cssColor;
701         break;
702       default:
703         throw new FormatError(`Unsupported paint type: ${paintType}`);
704     }
705   }
706 
707   getPattern(ctx, owner, inverse, pathType) {
708     // PDF spec 8.7.2 NOTE 1: pattern's matrix is relative to initial matrix.
709     let matrix = inverse;
710     if (pathType !== PathType.SHADING) {
711       matrix = Util.transform(matrix, owner.baseTransform);
712       if (this.matrix) {
713         matrix = Util.transform(matrix, this.matrix);
714       }
715     }
716 
717     const temporaryPatternCanvas = this.createPatternCanvas(owner);
718 
719     let domMatrix = new DOMMatrix(matrix);
720     // Rescale and so that the ctx.createPattern call generates a pattern with
721     // the desired size.
722     domMatrix = domMatrix.translate(
723       temporaryPatternCanvas.offsetX,
724       temporaryPatternCanvas.offsetY
725     );
726     domMatrix = domMatrix.scale(
727       1 / temporaryPatternCanvas.scaleX,
728       1 / temporaryPatternCanvas.scaleY
729     );
730 
731     const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");
732     pattern.setTransform(domMatrix);
733 
734     return pattern;
735   }
736 }
737 
738 export { getShadingPattern, PathType, TilingPattern };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

