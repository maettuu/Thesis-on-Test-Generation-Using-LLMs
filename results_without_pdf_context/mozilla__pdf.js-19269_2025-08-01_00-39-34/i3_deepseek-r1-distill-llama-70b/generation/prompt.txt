Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Top and bottom images are not displayed in pdf file
</issue>

Patch:
<patch>
diff --git a/src/core/evaluator.js b/src/core/evaluator.js
--- a/src/core/evaluator.js
+++ b/src/core/evaluator.js
@@ -175,7 +175,7 @@ function addLocallyCachedImageOps(opList, data) {
   if (data.objId) {
     opList.addDependency(data.objId);
   }
-  opList.addImageOps(data.fn, data.args, data.optionalContent);
+  opList.addImageOps(data.fn, data.args, data.optionalContent, data.hasMask);
 
   if (data.fn === OPS.paintImageMaskXObject && data.args[0]?.count > 0) {
     data.args[0].count++;
@@ -730,13 +730,9 @@ class PartialEvaluator {
     }
 
     const SMALL_IMAGE_DIMENSIONS = 200;
+    const hasMask = dict.has("SMask") || dict.has("Mask");
     // Inlining small images into the queue as RGB data
-    if (
-      isInline &&
-      w + h < SMALL_IMAGE_DIMENSIONS &&
-      !dict.has("SMask") &&
-      !dict.has("Mask")
-    ) {
+    if (isInline && w + h < SMALL_IMAGE_DIMENSIONS && !hasMask) {
       try {
         const imageObj = new PDFImage({
           xref: this.xref,
@@ -793,7 +789,12 @@ class PartialEvaluator {
     // Ensure that the dependency is added before the image is decoded.
     operatorList.addDependency(objId);
     args = [objId, w, h];
-    operatorList.addImageOps(OPS.paintImageXObject, args, optionalContent);
+    operatorList.addImageOps(
+      OPS.paintImageXObject,
+      args,
+      optionalContent,
+      hasMask
+    );
 
     if (cacheGlobally) {
       if (this.globalImageCache.hasDecodeFailed(imageRef)) {
@@ -802,6 +803,7 @@ class PartialEvaluator {
           fn: OPS.paintImageXObject,
           args,
           optionalContent,
+          hasMask,
           byteSize: 0, // Data is `null`, since decoding failed previously.
         });
 
@@ -812,7 +814,7 @@ class PartialEvaluator {
       // For large (at least 500x500) or more complex images that we'll cache
       // globally, check if the image is still cached locally on the main-thread
       // to avoid having to re-parse the image (since that can be slow).
-      if (w * h > 250000 || dict.has("SMask") || dict.has("Mask")) {
+      if (w * h > 250000 || hasMask) {
         const localLength = await this.handler.sendWithPromise("commonobj", [
           objId,
           "CopyLocalImage",
@@ -825,6 +827,7 @@ class PartialEvaluator {
             fn: OPS.paintImageXObject,
             args,
             optionalContent,
+            hasMask,
             byteSize: 0, // Temporary entry, to avoid `setData` returning early.
           });
           this.globalImageCache.addByteSize(imageRef, localLength);
@@ -872,6 +875,7 @@ class PartialEvaluator {
         fn: OPS.paintImageXObject,
         args,
         optionalContent,
+        hasMask,
       };
       localImageCache.set(cacheKey, imageRef, cacheData);
 
@@ -884,6 +888,7 @@ class PartialEvaluator {
             fn: OPS.paintImageXObject,
             args,
             optionalContent,
+            hasMask,
             byteSize: 0, // Temporary entry, note `addByteSize` above.
           });
         }
@@ -1814,7 +1819,8 @@ class PartialEvaluator {
                     operatorList.addImageOps(
                       globalImage.fn,
                       globalImage.args,
-                      globalImage.optionalContent
+                      globalImage.optionalContent,
+                      globalImage.hasMask
                     );
 
                     resolveXObject();

diff --git a/src/core/operator_list.js b/src/core/operator_list.js
--- a/src/core/operator_list.js
+++ b/src/core/operator_list.js
@@ -636,7 +636,11 @@ class OperatorList {
     }
   }
 
-  addImageOps(fn, args, optionalContent) {
+  addImageOps(fn, args, optionalContent, hasMask = false) {
+    if (hasMask) {
+      this.addOp(OPS.save);
+      this.addOp(OPS.setGState, [[["SMask", false]]]);
+    }
     if (optionalContent !== undefined) {
       this.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
     }
@@ -646,6 +650,9 @@ class OperatorList {
     if (optionalContent !== undefined) {
       this.addOp(OPS.endMarkedContent, []);
     }
+    if (hasMask) {
+      this.addOp(OPS.restore);
+    }
   }
 
   addDependency(dependency) {


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.0
- @babel/preset-env: ^7.26.0
- @babel/runtime: ^7.26.0
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @jazzer.js/core: ^2.1.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.65
- @types/node: ^22.10.2
- autoprefixer: ^10.4.20
- babel-loader: ^9.2.1
- caniuse-lite: ^1.0.30001690
- core-js: ^3.39.0
- eslint: ^9.17.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.3.0
- eslint-plugin-prettier: ^5.2.1
- eslint-plugin-unicorn: ^56.0.1
- globals: ^15.14.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- highlight.js: ^11.11.0
- jasmine: ^5.5.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.4.49
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.4.2
- puppeteer: ^23.11.1
- stylelint: ^16.12.0
- stylelint-prettier: ^5.0.2
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.11
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.7.2
- vinyl: ^3.0.0
- webpack: ^5.97.1
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: fetchData
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/core/evaluator.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AbortException,
18   assert,
19   FONT_IDENTITY_MATRIX,
20   FormatError,
21   IDENTITY_MATRIX,
22   info,
23   isArrayEqual,
24   normalizeUnicode,
25   OPS,
26   shadow,
27   stringToPDFString,
28   TextRenderingMode,
29   Util,
30   warn,
31 } from "../shared/util.js";
32 import { CMapFactory, IdentityCMap } from "./cmap.js";
33 import { Cmd, Dict, EOF, isName, Name, Ref, RefSet } from "./primitives.js";
34 import { ErrorFont, Font } from "./fonts.js";
35 import {
36   getEncoding,
37   MacRomanEncoding,
38   StandardEncoding,
39   SymbolSetEncoding,
40   WinAnsiEncoding,
41   ZapfDingbatsEncoding,
42 } from "./encodings.js";
43 import {
44   getFontNameToFileMap,
45   getSerifFonts,
46   getStandardFontName,
47   getStdFontMap,
48   getSymbolsFonts,
49   isKnownFontName,
50 } from "./standard_fonts.js";
51 import { getTilingPatternIR, Pattern } from "./pattern.js";
52 import { getXfaFontDict, getXfaFontName } from "./xfa_fonts.js";
53 import { IdentityToUnicodeMap, ToUnicodeMap } from "./to_unicode_map.js";
54 import { isNumberArray, lookupMatrix, lookupNormalRect } from "./core_utils.js";
55 import { isPDFFunction, PDFFunctionFactory } from "./function.js";
56 import { Lexer, Parser } from "./parser.js";
57 import {
58   LocalColorSpaceCache,
59   LocalGStateCache,
60   LocalImageCache,
61   LocalTilingPatternCache,
62   RegionalImageCache,
63 } from "./image_utils.js";
64 import { BaseStream } from "./base_stream.js";
65 import { bidi } from "./bidi.js";
66 import { ColorSpace } from "./colorspace.js";
67 import { DecodeStream } from "./decode_stream.js";
68 import { FontFlags } from "./fonts_utils.js";
69 import { getFontSubstitution } from "./font_substitutions.js";
70 import { getGlyphsUnicode } from "./glyphlist.js";
71 import { getMetrics } from "./metrics.js";
72 import { getUnicodeForGlyph } from "./unicode.js";
73 import { ImageResizer } from "./image_resizer.js";
74 import { JpegStream } from "./jpeg_stream.js";
75 import { MurmurHash3_64 } from "../shared/murmurhash3.js";
76 import { OperatorList } from "./operator_list.js";
77 import { PDFImage } from "./image.js";
78 import { Stream } from "./stream.js";
79 
80 const DefaultPartialEvaluatorOptions = Object.freeze({
81   maxImageSize: -1,
82   disableFontFace: false,
83   ignoreErrors: false,
84   isEvalSupported: true,
85   isOffscreenCanvasSupported: false,
86   isImageDecoderSupported: false,
87   canvasMaxAreaInBytes: -1,
88   fontExtraProperties: false,
89   useSystemFonts: true,
90   cMapUrl: null,
91   standardFontDataUrl: null,
92 });
93 
94 const PatternType = {
95   TILING: 1,
96   SHADING: 2,
97 };
98 
99 // Optionally avoid sending individual, or very few, text chunks to reduce
100 // `postMessage` overhead with ReadableStream (see issue 13962).
101 //
102 // PLEASE NOTE: This value should *not* be too large (it's used as a lower limit
103 // in `enqueueChunk`), since that would cause streaming of textContent to become
104 // essentially useless in practice by sending all (or most) chunks at once.
105 // Also, a too large value would (indirectly) affect the main-thread `textLayer`
106 // building negatively by forcing all textContent to be handled at once, which
107 // could easily end up hurting *overall* performance (e.g. rendering as well).
108 const TEXT_CHUNK_BATCH_SIZE = 10;
109 
110 const deferred = Promise.resolve();
111 
112 // Convert PDF blend mode names to HTML5 blend mode names.
113 function normalizeBlendMode(value, parsingArray = false) {
114   if (Array.isArray(value)) {
115     // Use the first *supported* BM value in the Array (fixes issue11279.pdf).
116     for (const val of value) {
117       const maybeBM = normalizeBlendMode(val, /* parsingArray = */ true);
118       if (maybeBM) {
119         return maybeBM;
120       }
121     }
122     warn(`Unsupported blend mode Array: ${value}`);
123     return "source-over";
124   }
125 
126   if (!(value instanceof Name)) {
127     if (parsingArray) {
128       return null;
129     }
130     return "source-over";
131   }
132   switch (value.name) {
133     case "Normal":
134     case "Compatible":
135       return "source-over";
136     case "Multiply":
137       return "multiply";
138     case "Screen":
139       return "screen";
140     case "Overlay":
141       return "overlay";
142     case "Darken":
143       return "darken";
144     case "Lighten":
145       return "lighten";
146     case "ColorDodge":
147       return "color-dodge";
148     case "ColorBurn":
149       return "color-burn";
150     case "HardLight":
151       return "hard-light";
152     case "SoftLight":
153       return "soft-light";
154     case "Difference":
155       return "difference";
156     case "Exclusion":
157       return "exclusion";
158     case "Hue":
159       return "hue";
160     case "Saturation":
161       return "saturation";
162     case "Color":
163       return "color";
164     case "Luminosity":
165       return "luminosity";
166   }
167   if (parsingArray) {
168     return null;
169   }
170   warn(`Unsupported blend mode: ${value.name}`);
171   return "source-over";
172 }
173 
174 function addLocallyCachedImageOps(opList, data) {
175   if (data.objId) {
176     opList.addDependency(data.objId);
177   }
178   opList.addImageOps(data.fn, data.args, data.optionalContent);
179 
180   if (data.fn === OPS.paintImageMaskXObject && data.args[0]?.count > 0) {
181     data.args[0].count++;
182   }
183 }
184 
185 // Trying to minimize Date.now() usage and check every 100 time.
186 class TimeSlotManager {
187   static TIME_SLOT_DURATION_MS = 20;
188 
189   static CHECK_TIME_EVERY = 100;
190 
191   constructor() {
192     this.reset();
193   }
194 
195   check() {
196     if (++this.checked < TimeSlotManager.CHECK_TIME_EVERY) {
197       return false;
198     }
199     this.checked = 0;
200     return this.endTime <= Date.now();
201   }
202 
203   reset() {
204     this.endTime = Date.now() + TimeSlotManager.TIME_SLOT_DURATION_MS;
205     this.checked = 0;
206   }
207 }
208 
209 class PartialEvaluator {
210   constructor({
211     xref,
212     handler,
213     pageIndex,
214     idFactory,
215     fontCache,
216     builtInCMapCache,
217     standardFontDataCache,
218     globalImageCache,
219     systemFontCache,
220     options = null,
221   }) {
222     this.xref = xref;
223     this.handler = handler;
224     this.pageIndex = pageIndex;
225     this.idFactory = idFactory;
226     this.fontCache = fontCache;
227     this.builtInCMapCache = builtInCMapCache;
228     this.standardFontDataCache = standardFontDataCache;
229     this.globalImageCache = globalImageCache;
230     this.systemFontCache = systemFontCache;
231     this.options = options || DefaultPartialEvaluatorOptions;
232     this.type3FontRefs = null;
233 
234     this._regionalImageCache = new RegionalImageCache();
235     this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
236 
237     ImageResizer.setOptions(this.options);
238     JpegStream.setOptions(this.options);
239   }
240 
241   /**
242    * Since Functions are only cached (locally) by reference, we can share one
243    * `PDFFunctionFactory` instance within this `PartialEvaluator` instance.
244    */
245   get _pdfFunctionFactory() {
246     const pdfFunctionFactory = new PDFFunctionFactory({
247       xref: this.xref,
248       isEvalSupported: this.options.isEvalSupported,
249     });
250     return shadow(this, "_pdfFunctionFactory", pdfFunctionFactory);
251   }
252 
253   get parsingType3Font() {
254     return !!this.type3FontRefs;
255   }
256 
257   clone(newOptions = null) {
258     const newEvaluator = Object.create(this);
259     newEvaluator.options = Object.assign(
260       Object.create(null),
261       this.options,
262       newOptions
263     );
264     return newEvaluator;
265   }
266 
267   hasBlendModes(resources, nonBlendModesSet) {
268     if (!(resources instanceof Dict)) {
269       return false;
270     }
271     if (resources.objId && nonBlendModesSet.has(resources.objId)) {
272       return false;
273     }
274 
275     const processed = new RefSet(nonBlendModesSet);
276     if (resources.objId) {
277       processed.put(resources.objId);
278     }
279 
280     const nodes = [resources],
281       xref = this.xref;
282     while (nodes.length) {
283       const node = nodes.shift();
284       // First check the current resources for blend modes.
285       const graphicStates = node.get("ExtGState");
286       if (graphicStates instanceof Dict) {
287         for (let graphicState of graphicStates.getRawValues()) {
288           if (graphicState instanceof Ref) {
289             if (processed.has(graphicState)) {
290               continue; // The ExtGState has already been processed.
291             }
292             try {
293               graphicState = xref.fetch(graphicState);
294             } catch (ex) {
295               // Avoid parsing a corrupt ExtGState more than once.
296               processed.put(graphicState);
297 
298               info(`hasBlendModes - ignoring ExtGState: "${ex}".`);
299               continue;
300             }
301           }
302           if (!(graphicState instanceof Dict)) {
303             continue;
304           }
305           if (graphicState.objId) {
306             processed.put(graphicState.objId);
307           }
308 
309           const bm = graphicState.get("BM");
310           if (bm instanceof Name) {
311             if (bm.name !== "Normal") {
312               return true;
313             }
314             continue;
315           }
316           if (bm !== undefined && Array.isArray(bm)) {
317             for (const element of bm) {
318               if (element instanceof Name && element.name !== "Normal") {
319                 return true;
320               }
321             }
322           }
323         }
324       }
325       // Descend into the XObjects to look for more resources and blend modes.
326       const xObjects = node.get("XObject");
327       if (!(xObjects instanceof Dict)) {
328         continue;
329       }
330       for (let xObject of xObjects.getRawValues()) {
331         if (xObject instanceof Ref) {
332           if (processed.has(xObject)) {
333             // The XObject has already been processed, and by avoiding a
334             // redundant `xref.fetch` we can *significantly* reduce the load
335             // time for badly generated PDF files (fixes issue6961.pdf).
336             continue;
337           }
338           try {
339             xObject = xref.fetch(xObject);
340           } catch (ex) {
341             // Avoid parsing a corrupt XObject more than once.
342             processed.put(xObject);
343 
344             info(`hasBlendModes - ignoring XObject: "${ex}".`);
345             continue;
346           }
347         }
348         if (!(xObject instanceof BaseStream)) {
349           continue;
350         }
351         if (xObject.dict.objId) {
352           processed.put(xObject.dict.objId);
353         }
354         const xResources = xObject.dict.get("Resources");
355         if (!(xResources instanceof Dict)) {
356           continue;
357         }
358         // Checking objId to detect an infinite loop.
359         if (xResources.objId && processed.has(xResources.objId)) {
360           continue;
361         }
362 
363         nodes.push(xResources);
364         if (xResources.objId) {
365           processed.put(xResources.objId);
366         }
367       }
368     }
369 
370     // When no blend modes exist, there's no need re-fetch/re-parse any of the
371     // processed `Ref`s again for subsequent pages. This helps reduce redundant
372     // `XRef.fetch` calls for some documents (e.g. issue6961.pdf).
373     for (const ref of processed) {
374       nonBlendModesSet.put(ref);
375     }
376     return false;
377   }
378 
379   async #fetchData(url) {
380     const response = await fetch(url);
381     if (!response.ok) {
382       throw new Error(
383         `Failed to fetch file "${url}" with "${response.statusText}".`
384       );
385     }
386     return new Uint8Array(await response.arrayBuffer());
387   }
388 
389   async fetchBuiltInCMap(name) {
390     const cachedData = this.builtInCMapCache.get(name);
391     if (cachedData) {
392       return cachedData;
393     }
394     let data;
395 
396     if (this.options.cMapUrl !== null) {
397       // Only compressed CMaps are (currently) supported here.
398       const cMapData = await this.#fetchData(
399         `${this.options.cMapUrl}${name}.bcmap`
400       );
401       data = { cMapData, isCompressed: true };
402     } else {
403       // Get the data on the main-thread instead.
404       data = await this.handler.sendWithPromise("FetchBuiltInCMap", { name });
405     }
406     // Cache the CMap data, to avoid fetching it repeatedly.
407     this.builtInCMapCache.set(name, data);
408 
409     return data;
410   }
411 
412   async fetchStandardFontData(name) {
413     const cachedData = this.standardFontDataCache.get(name);
414     if (cachedData) {
415       return new Stream(cachedData);
416     }
417 
418     // The symbol fonts are not consistent across platforms, always load the
419     // standard font data for them.
420     if (
421       this.options.useSystemFonts &&
422       name !== "Symbol" &&
423       name !== "ZapfDingbats"
424     ) {
425       return null;
426     }
427 
428     const standardFontNameToFileName = getFontNameToFileMap(),
429       filename = standardFontNameToFileName[name];
430     let data;
431 
432     try {
433       if (this.options.standardFontDataUrl !== null) {
434         data = await this.#fetchData(
435           `${this.options.standardFontDataUrl}${filename}`
436         );
437       } else {
438         // Get the data on the main-thread instead.
439         data = await this.handler.sendWithPromise("FetchStandardFontData", {
440           filename,
441         });
442       }
443     } catch (ex) {
444       warn(ex);
445       return null;
446     }
447     // Cache the "raw" standard font data, to avoid fetching it repeatedly
448     // (see e.g. issue 11399).
449     this.standardFontDataCache.set(name, data);
450 
451     return new Stream(data);
452   }
453 
454   async buildFormXObject(
455     resources,
456     xobj,
457     smask,
458     operatorList,
459     task,
460     initialState,
461     localColorSpaceCache
462   ) {
463     const dict = xobj.dict;
464     const matrix = lookupMatrix(dict.getArray("Matrix"), null);
465     const bbox = lookupNormalRect(dict.getArray("BBox"), null);
466 
467     let optionalContent, groupOptions;
468     if (dict.has("OC")) {
469       optionalContent = await this.parseMarkedContentProps(
470         dict.get("OC"),
471         resources
472       );
473     }
474     if (optionalContent !== undefined) {
475       operatorList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
476     }
477     const group = dict.get("Group");
478     if (group) {
479       groupOptions = {
480         matrix,
481         bbox,
482         smask,
483         isolated: false,
484         knockout: false,
485       };
486 
487       const groupSubtype = group.get("S");
488       let colorSpace = null;
489       if (isName(groupSubtype, "Transparency")) {
490         groupOptions.isolated = group.get("I") || false;
491         groupOptions.knockout = group.get("K") || false;
492         if (group.has("CS")) {
493           const cs = group.getRaw("CS");
494 
495           const cachedColorSpace = ColorSpace.getCached(
496             cs,
497             this.xref,
498             localColorSpaceCache
499           );
500           if (cachedColorSpace) {
501             colorSpace = cachedColorSpace;
502           } else {
503             colorSpace = await this.parseColorSpace({
504               cs,
505               resources,
506               localColorSpaceCache,
507             });
508           }
509         }
510       }
511 
512       if (smask?.backdrop) {
513         colorSpace ||= ColorSpace.singletons.rgb;
514         smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
515       }
516 
517       operatorList.addOp(OPS.beginGroup, [groupOptions]);
518     }
519 
520     // If it's a group, a new canvas will be created that is the size of the
521     // bounding box and translated to the correct position so we don't need to
522     // apply the bounding box to it.
523     const args = group ? [matrix, null] : [matrix, bbox];
524     operatorList.addOp(OPS.paintFormXObjectBegin, args);
525 
526     await this.getOperatorList({
527       stream: xobj,
528       task,
529       resources: dict.get("Resources") || resources,
530       operatorList,
531       initialState,
532     });
533     operatorList.addOp(OPS.paintFormXObjectEnd, []);
534 
535     if (group) {
536       operatorList.addOp(OPS.endGroup, [groupOptions]);
537     }
538 
539     if (optionalContent !== undefined) {
540       operatorList.addOp(OPS.endMarkedContent, []);
541     }
542   }
543 
544   _sendImgData(objId, imgData, cacheGlobally = false) {
545     if (
546       (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) &&
547       imgData
548     ) {
549       assert(Number.isInteger(imgData.dataLen), "Expected dataLen to be set.");
550     }
551     const transfers = imgData ? [imgData.bitmap || imgData.data.buffer] : null;
552 
553     if (this.parsingType3Font || cacheGlobally) {
554       return this.handler.send(
555         "commonobj",
556         [objId, "Image", imgData],
557         transfers
558       );
559     }
560     return this.handler.send(
561       "obj",
562       [objId, this.pageIndex, "Image", imgData],
563       transfers
564     );
565   }
566 
567   async buildPaintImageXObject({
568     resources,
569     image,
570     isInline = false,
571     operatorList,
572     cacheKey,
573     localImageCache,
574     localColorSpaceCache,
575   }) {
576     const dict = image.dict;
577     const imageRef = dict.objId;
578     const w = dict.get("W", "Width");
579     const h = dict.get("H", "Height");
580 
581     if (!(w && typeof w === "number") || !(h && typeof h === "number")) {
582       warn("Image dimensions are missing, or not numbers.");
583       return;
584     }
585     const maxImageSize = this.options.maxImageSize;
586     if (maxImageSize !== -1 && w * h > maxImageSize) {
587       const msg = "Image exceeded maximum allowed size and was removed.";
588 
589       if (this.options.ignoreErrors) {
590         warn(msg);
591         return;
592       }
593       throw new Error(msg);
594     }
595 
596     let optionalContent;
597     if (dict.has("OC")) {
598       optionalContent = await this.parseMarkedContentProps(
599         dict.get("OC"),
600         resources
601       );
602     }
603 
604     const imageMask = dict.get("IM", "ImageMask") || false;
605     let imgData, args;
606     if (imageMask) {
607       // This depends on a tmpCanvas being filled with the
608       // current fillStyle, such that processing the pixel
609       // data can't be done here. Instead of creating a
610       // complete PDFImage, only read the information needed
611       // for later.
612       const interpolate = dict.get("I", "Interpolate");
613       const bitStrideLength = (w + 7) >> 3;
614       const imgArray = image.getBytes(bitStrideLength * h);
615       const decode = dict.getArray("D", "Decode");
616 
617       if (this.parsingType3Font) {
618         imgData = PDFImage.createRawMask({
619           imgArray,
620           width: w,
621           height: h,
622           imageIsFromDecodeStream: image instanceof DecodeStream,
623           inverseDecode: decode?.[0] > 0,
624           interpolate,
625         });
626 
627         imgData.cached = !!cacheKey;
628         args = [imgData];
629 
630         operatorList.addImageOps(
631           OPS.paintImageMaskXObject,
632           args,
633           optionalContent
634         );
635 
636         if (cacheKey) {
637           const cacheData = {
638             fn: OPS.paintImageMaskXObject,
639             args,
640             optionalContent,
641           };
642           localImageCache.set(cacheKey, imageRef, cacheData);
643 
644           if (imageRef) {
645             this._regionalImageCache.set(
646               /* name = */ null,
647               imageRef,
648               cacheData
649             );
650           }
651         }
652         return;
653       }
654 
655       imgData = await PDFImage.createMask({
656         imgArray,
657         width: w,
658         height: h,
659         imageIsFromDecodeStream: image instanceof DecodeStream,
660         inverseDecode: decode?.[0] > 0,
661         interpolate,
662         isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported,
663       });
664 
665       if (imgData.isSingleOpaquePixel) {
666         // Handles special case of mainly LaTeX documents which use image
667         // masks to draw lines with the current fill style.
668         operatorList.addImageOps(
669           OPS.paintSolidColorImageMask,
670           [],
671           optionalContent
672         );
673 
674         if (cacheKey) {
675           const cacheData = {
676             fn: OPS.paintSolidColorImageMask,
677             args: [],
678             optionalContent,
679           };
680           localImageCache.set(cacheKey, imageRef, cacheData);
681 
682           if (imageRef) {
683             this._regionalImageCache.set(
684               /* name = */ null,
685               imageRef,
686               cacheData
687             );
688           }
689         }
690         return;
691       }
692 
693       const objId = `mask_${this.idFactory.createObjId()}`;
694       operatorList.addDependency(objId);
695 
696       imgData.dataLen = imgData.bitmap
697         ? imgData.width * imgData.height * 4
698         : imgData.data.length;
699       this._sendImgData(objId, imgData);
700 
701       args = [
702         {
703           data: objId,
704           width: imgData.width,
705           height: imgData.height,
706           interpolate: imgData.interpolate,
707           count: 1,
708         },
709       ];
710       operatorList.addImageOps(
711         OPS.paintImageMaskXObject,
712         args,
713         optionalContent
714       );
715 
716       if (cacheKey) {
717         const cacheData = {
718           objId,
719           fn: OPS.paintImageMaskXObject,
720           args,
721           optionalContent,
722         };
723         localImageCache.set(cacheKey, imageRef, cacheData);
724 
725         if (imageRef) {
726           this._regionalImageCache.set(/* name = */ null, imageRef, cacheData);
727         }
728       }
729       return;
730     }
731 
732     const SMALL_IMAGE_DIMENSIONS = 200;
733     // Inlining small images into the queue as RGB data
734     if (
735       isInline &&
736       w + h < SMALL_IMAGE_DIMENSIONS &&
737       !dict.has("SMask") &&
738       !dict.has("Mask")
739     ) {
740       try {
741         const imageObj = new PDFImage({
742           xref: this.xref,
743           res: resources,
744           image,
745           isInline,
746           pdfFunctionFactory: this._pdfFunctionFactory,
747           localColorSpaceCache,
748         });
749         // We force the use of RGBA_32BPP images here, because we can't handle
750         // any other kind.
751         imgData = await imageObj.createImageData(
752           /* forceRGBA = */ true,
753           /* isOffscreenCanvasSupported = */ false
754         );
755         operatorList.isOffscreenCanvasSupported =
756           this.options.isOffscreenCanvasSupported;
757         operatorList.addImageOps(
758           OPS.paintInlineImageXObject,
759           [imgData],
760           optionalContent
761         );
762       } catch (reason) {
763         const msg = `Unable to decode inline image: "${reason}".`;
764 
765         if (!this.options.ignoreErrors) {
766           throw new Error(msg);
767         }
768         warn(msg);
769       }
770       return;
771     }
772 
773     // If there is no imageMask, create the PDFImage and a lot
774     // of image processing can be done here.
775     let objId = `img_${this.idFactory.createObjId()}`,
776       cacheGlobally = false;
777 
778     if (this.parsingType3Font) {
779       objId = `${this.idFactory.getDocId()}_type3_${objId}`;
780     } else if (cacheKey && imageRef) {
781       cacheGlobally = this.globalImageCache.shouldCache(
782         imageRef,
783         this.pageIndex
784       );
785 
786       if (cacheGlobally) {
787         assert(!isInline, "Cannot cache an inline image globally.");
788 
789         objId = `${this.idFactory.getDocId()}_${objId}`;
790       }
791     }
792 
793     // Ensure that the dependency is added before the image is decoded.
794     operatorList.addDependency(objId);
795     args = [objId, w, h];
796     operatorList.addImageOps(OPS.paintImageXObject, args, optionalContent);
797 
798     if (cacheGlobally) {
799       if (this.globalImageCache.hasDecodeFailed(imageRef)) {
800         this.globalImageCache.setData(imageRef, {
801           objId,
802           fn: OPS.paintImageXObject,
803           args,
804           optionalContent,
805           byteSize: 0, // Data is `null`, since decoding failed previously.
806         });
807 
808         this._sendImgData(objId, /* imgData = */ null, cacheGlobally);
809         return;
810       }
811 
812       // For large (at least 500x500) or more complex images that we'll cache
813       // globally, check if the image is still cached locally on the main-thread
814       // to avoid having to re-parse the image (since that can be slow).
815       if (w * h > 250000 || dict.has("SMask") || dict.has("Mask")) {
816         const localLength = await this.handler.sendWithPromise("commonobj", [
817           objId,
818           "CopyLocalImage",
819           { imageRef },
820         ]);
821 
822         if (localLength) {
823           this.globalImageCache.setData(imageRef, {
824             objId,
825             fn: OPS.paintImageXObject,
826             args,
827             optionalContent,
828             byteSize: 0, // Temporary entry, to avoid `setData` returning early.
829           });
830           this.globalImageCache.addByteSize(imageRef, localLength);
831           return;
832         }
833       }
834     }
835 
836     PDFImage.buildImage({
837       xref: this.xref,
838       res: resources,
839       image,
840       isInline,
841       pdfFunctionFactory: this._pdfFunctionFactory,
842       localColorSpaceCache,
843     })
844       .then(async imageObj => {
845         imgData = await imageObj.createImageData(
846           /* forceRGBA = */ false,
847           /* isOffscreenCanvasSupported = */ this.options
848             .isOffscreenCanvasSupported
849         );
850         imgData.dataLen = imgData.bitmap
851           ? imgData.width * imgData.height * 4
852           : imgData.data.length;
853         imgData.ref = imageRef;
854 
855         if (cacheGlobally) {
856           this.globalImageCache.addByteSize(imageRef, imgData.dataLen);
857         }
858         return this._sendImgData(objId, imgData, cacheGlobally);
859       })
860       .catch(reason => {
861         warn(`Unable to decode image "${objId}": "${reason}".`);
862 
863         if (imageRef) {
864           this.globalImageCache.addDecodeFailed(imageRef);
865         }
866         return this._sendImgData(objId, /* imgData = */ null, cacheGlobally);
867       });
868 
869     if (cacheKey) {
870       const cacheData = {
871         objId,
872         fn: OPS.paintImageXObject,
873         args,
874         optionalContent,
875       };
876       localImageCache.set(cacheKey, imageRef, cacheData);
877 
878       if (imageRef) {
879         this._regionalImageCache.set(/* name = */ null, imageRef, cacheData);
880 
881         if (cacheGlobally) {
882           this.globalImageCache.setData(imageRef, {
883             objId,
884             fn: OPS.paintImageXObject,
885             args,
886             optionalContent,
887             byteSize: 0, // Temporary entry, note `addByteSize` above.
888           });
889         }
890       }
891     }
892   }
893 
894   handleSMask(
895     smask,
896     resources,
897     operatorList,
898     task,
899     stateManager,
900     localColorSpaceCache
901   ) {
902     const smaskContent = smask.get("G");
903     const smaskOptions = {
904       subtype: smask.get("S").name,
905       backdrop: smask.get("BC"),
906     };
907 
908     // The SMask might have a alpha/luminosity value transfer function --
909     // we will build a map of integer values in range 0..255 to be fast.
910     const transferObj = smask.get("TR");
911     if (isPDFFunction(transferObj)) {
912       const transferFn = this._pdfFunctionFactory.create(transferObj);
913       const transferMap = new Uint8Array(256);
914       const tmp = new Float32Array(1);
915       for (let i = 0; i < 256; i++) {
916         tmp[0] = i / 255;
917         transferFn(tmp, 0, tmp, 0);
918         transferMap[i] = (tmp[0] * 255) | 0;
919       }
920       smaskOptions.transferMap = transferMap;
921     }
922 
923     return this.buildFormXObject(
924       resources,
925       smaskContent,
926       smaskOptions,
927       operatorList,
928       task,
929       stateManager.state.clone(),
930       localColorSpaceCache
931     );
932   }
933 
934   handleTransferFunction(tr) {
935     let transferArray;
936     if (Array.isArray(tr)) {
937       transferArray = tr;
938     } else if (isPDFFunction(tr)) {
939       transferArray = [tr];
940     } else {
941       return null; // Not a valid transfer function entry.
942     }
943 
944     const transferMaps = [];
945     let numFns = 0,
946       numEffectfulFns = 0;
947     for (const entry of transferArray) {
948       const transferObj = this.xref.fetchIfRef(entry);
949       numFns++;
950 
951       if (isName(transferObj, "Identity")) {
952         transferMaps.push(null);
953         continue;
954       } else if (!isPDFFunction(transferObj)) {
955         return null; // Not a valid transfer function object.
956       }
957 
958       const transferFn = this._pdfFunctionFactory.create(transferObj);
959       const transferMap = new Uint8Array(256),
960         tmp = new Float32Array(1);
961       for (let j = 0; j < 256; j++) {
962         tmp[0] = j / 255;
963         transferFn(tmp, 0, tmp, 0);
964         transferMap[j] = (tmp[0] * 255) | 0;
965       }
966       transferMaps.push(transferMap);
967       numEffectfulFns++;
968     }
969 
970     if (!(numFns === 1 || numFns === 4)) {
971       return null; // Only 1 or 4 functions are supported, by the specification.
972     }
973     if (numEffectfulFns === 0) {
974       return null; // Only /Identity transfer functions found, which are no-ops.
975     }
976     return transferMaps;
977   }
978 
979   handleTilingType(
980     fn,
981     color,
982     resources,
983     pattern,
984     patternDict,
985     operatorList,
986     task,
987     localTilingPatternCache
988   ) {
989     // Create an IR of the pattern code.
990     const tilingOpList = new OperatorList();
991     // Merge the available resources, to prevent issues when the patternDict
992     // is missing some /Resources entries (fixes issue6541.pdf).
993     const patternResources = Dict.merge({
994       xref: this.xref,
995       dictArray: [patternDict.get("Resources"), resources],
996     });
997 
998     return this.getOperatorList({
999       stream: pattern,
1000       task,
1001       resources: patternResources,
1002       operatorList: tilingOpList,
1003     })
1004       .then(function () {
1005         const operatorListIR = tilingOpList.getIR();
1006         const tilingPatternIR = getTilingPatternIR(
1007           operatorListIR,
1008           patternDict,
1009           color
1010         );
1011         // Add the dependencies to the parent operator list so they are
1012         // resolved before the sub operator list is executed synchronously.
1013         operatorList.addDependencies(tilingOpList.dependencies);
1014         operatorList.addOp(fn, tilingPatternIR);
1015 
1016         if (patternDict.objId) {
1017           localTilingPatternCache.set(/* name = */ null, patternDict.objId, {
1018             operatorListIR,
1019             dict: patternDict,
1020           });
1021         }
1022       })
1023       .catch(reason => {
1024         if (reason instanceof AbortException) {
1025           return;
1026         }
1027         if (this.options.ignoreErrors) {
1028           warn(`handleTilingType - ignoring pattern: "${reason}".`);
1029           return;
1030         }
1031         throw reason;
1032       });
1033   }
1034 
1035   async handleSetFont(
1036     resources,
1037     fontArgs,
1038     fontRef,
1039     operatorList,
1040     task,
1041     state,
1042     fallbackFontDict = null,
1043     cssFontInfo = null
1044   ) {
1045     const fontName = fontArgs?.[0] instanceof Name ? fontArgs[0].name : null;
1046 
1047     let translated = await this.loadFont(
1048       fontName,
1049       fontRef,
1050       resources,
1051       fallbackFontDict,
1052       cssFontInfo
1053     );
1054 
1055     if (translated.font.isType3Font) {
1056       try {
1057         await translated.loadType3Data(this, resources, task);
1058         // Add the dependencies to the parent operatorList so they are
1059         // resolved before Type3 operatorLists are executed synchronously.
1060         operatorList.addDependencies(translated.type3Dependencies);
1061       } catch (reason) {
1062         translated = new TranslatedFont({
1063           loadedName: "g_font_error",
1064           font: new ErrorFont(`Type3 font load error: ${reason}`),
1065           dict: translated.font,
1066           evaluatorOptions: this.options,
1067         });
1068       }
1069     }
1070 
1071     state.font = translated.font;
1072     translated.send(this.handler);
1073     return translated.loadedName;
1074   }
1075 
1076   handleText(chars, state) {
1077     const font = state.font;
1078     const glyphs = font.charsToGlyphs(chars);
1079 
1080     if (font.data) {
1081       const isAddToPathSet = !!(
1082         state.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG
1083       );
1084       if (
1085         isAddToPathSet ||
1086         state.fillColorSpace.name === "Pattern" ||
1087         font.disableFontFace ||
1088         this.options.disableFontFace
1089       ) {
1090         PartialEvaluator.buildFontPaths(
1091           font,
1092           glyphs,
1093           this.handler,
1094           this.options
1095         );
1096       }
1097     }
1098     return glyphs;
1099   }
1100 
1101   ensureStateFont(state) {
1102     if (state.font) {
1103       return;
1104     }
1105     const reason = new FormatError(
1106       "Missing setFont (Tf) operator before text rendering operator."
1107     );
1108 
1109     if (this.options.ignoreErrors) {
1110       warn(`ensureStateFont: "${reason}".`);
1111       return;
1112     }
1113     throw reason;
1114   }
1115 
1116   async setGState({
1117     resources,
1118     gState,
1119     operatorList,
1120     cacheKey,
1121     task,
1122     stateManager,
1123     localGStateCache,
1124     localColorSpaceCache,
1125   }) {
1126     const gStateRef = gState.objId;
1127     let isSimpleGState = true;
1128     // This array holds the converted/processed state data.
1129     const gStateObj = [];
1130     let promise = Promise.resolve();
1131     for (const key of gState.getKeys()) {
1132       const value = gState.get(key);
1133       switch (key) {
1134         case "Type":
1135           break;
1136         case "LW":
1137         case "LC":
1138         case "LJ":
1139         case "ML":
1140         case "D":
1141         case "RI":
1142         case "FL":
1143         case "CA":
1144         case "ca":
1145           gStateObj.push([key, value]);
1146           break;
1147         case "Font":
1148           isSimpleGState = false;
1149 
1150           promise = promise.then(() =>
1151             this.handleSetFont(
1152               resources,
1153               null,
1154               value[0],
1155               operatorList,
1156               task,
1157               stateManager.state
1158             ).then(function (loadedName) {
1159               operatorList.addDependency(loadedName);
1160               gStateObj.push([key, [loadedName, value[1]]]);
1161             })
1162           );
1163           break;
1164         case "BM":
1165           gStateObj.push([key, normalizeBlendMode(value)]);
1166           break;
1167         case "SMask":
1168           if (isName(value, "None")) {
1169             gStateObj.push([key, false]);
1170             break;
1171           }
1172           if (value instanceof Dict) {
1173             isSimpleGState = false;
1174 
1175             promise = promise.then(() =>
1176               this.handleSMask(
1177                 value,
1178                 resources,
1179                 operatorList,
1180                 task,
1181                 stateManager,
1182                 localColorSpaceCache
1183               )
1184             );
1185             gStateObj.push([key, true]);
1186           } else {
1187             warn("Unsupported SMask type");
1188           }
1189           break;
1190         case "TR":
1191           const transferMaps = this.handleTransferFunction(value);
1192           gStateObj.push([key, transferMaps]);
1193           break;
1194         // Only generate info log messages for the following since
1195         // they are unlikely to have a big impact on the rendering.
1196         case "OP":
1197         case "op":
1198         case "OPM":
1199         case "BG":
1200         case "BG2":
1201         case "UCR":
1202         case "UCR2":
1203         case "TR2":
1204         case "HT":
1205         case "SM":
1206         case "SA":
1207         case "AIS":
1208         case "TK":
1209           // TODO implement these operators.
1210           info("graphic state operator " + key);
1211           break;
1212         default:
1213           info("Unknown graphic state operator " + key);
1214           break;
1215       }
1216     }
1217     await promise;
1218 
1219     if (gStateObj.length > 0) {
1220       operatorList.addOp(OPS.setGState, [gStateObj]);
1221     }
1222 
1223     if (isSimpleGState) {
1224       localGStateCache.set(cacheKey, gStateRef, gStateObj);
1225     }
1226   }
1227 
1228   loadFont(
1229     fontName,
1230     font,
1231     resources,
1232     fallbackFontDict = null,
1233     cssFontInfo = null
1234   ) {
1235     // eslint-disable-next-line arrow-body-style
1236     const errorFont = async () => {
1237       return new TranslatedFont({
1238         loadedName: "g_font_error",
1239         font: new ErrorFont(`Font "${fontName}" is not available.`),
1240         dict: font,
1241         evaluatorOptions: this.options,
1242       });
1243     };
1244 
1245     let fontRef;
1246     if (font) {
1247       // Loading by ref.
1248       if (font instanceof Ref) {
1249         fontRef = font;
1250       }
1251     } else {
1252       // Loading by name.
1253       const fontRes = resources.get("Font");
1254       if (fontRes) {
1255         fontRef = fontRes.getRaw(fontName);
1256       }
1257     }
1258     if (fontRef) {
1259       if (this.type3FontRefs?.has(fontRef)) {
1260         return errorFont();
1261       }
1262 
1263       if (this.fontCache.has(fontRef)) {
1264         return this.fontCache.get(fontRef);
1265       }
1266 
1267       try {
1268         font = this.xref.fetchIfRef(fontRef);
1269       } catch (ex) {
1270         warn(`loadFont - lookup failed: "${ex}".`);
1271       }
1272     }
1273 
1274     if (!(font instanceof Dict)) {
1275       if (!this.options.ignoreErrors && !this.parsingType3Font) {
1276         warn(`Font "${fontName}" is not available.`);
1277         return errorFont();
1278       }
1279       warn(
1280         `Font "${fontName}" is not available -- attempting to fallback to a default font.`
1281       );
1282 
1283       // Falling back to a default font to avoid completely broken rendering,
1284       // but note that there're no guarantees that things will look "correct".
1285       font = fallbackFontDict || PartialEvaluator.fallbackFontDict;
1286     }
1287 
1288     // We are holding `font.cacheKey` references only for `fontRef`s that
1289     // are not actually `Ref`s, but rather `Dict`s. See explanation below.
1290     if (font.cacheKey && this.fontCache.has(font.cacheKey)) {
1291       return this.fontCache.get(font.cacheKey);
1292     }
1293 
1294     const { promise, resolve } = Promise.withResolvers();
1295 
1296     let preEvaluatedFont;
1297     try {
1298       preEvaluatedFont = this.preEvaluateFont(font);
1299       preEvaluatedFont.cssFontInfo = cssFontInfo;
1300     } catch (reason) {
1301       warn(`loadFont - preEvaluateFont failed: "${reason}".`);
1302       return errorFont();
1303     }
1304     const { descriptor, hash } = preEvaluatedFont;
1305 
1306     const fontRefIsRef = fontRef instanceof Ref;
1307     let fontID;
1308 
1309     if (hash && descriptor instanceof Dict) {
1310       const fontAliases = (descriptor.fontAliases ||= Object.create(null));
1311 
1312       if (fontAliases[hash]) {
1313         const aliasFontRef = fontAliases[hash].aliasRef;
1314         if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
1315           this.fontCache.putAlias(fontRef, aliasFontRef);
1316           return this.fontCache.get(fontRef);
1317         }
1318       } else {
1319         fontAliases[hash] = {
1320           fontID: this.idFactory.createFontId(),
1321         };
1322       }
1323 
1324       if (fontRefIsRef) {
1325         fontAliases[hash].aliasRef = fontRef;
1326       }
1327       fontID = fontAliases[hash].fontID;
1328     } else {
1329       fontID = this.idFactory.createFontId();
1330     }
1331     assert(
1332       fontID?.startsWith("f"),
1333       'The "fontID" must be (correctly) defined.'
1334     );
1335 
1336     // Workaround for bad PDF generators that reference fonts incorrectly,
1337     // where `fontRef` is a `Dict` rather than a `Ref` (fixes bug946506.pdf).
1338     // In this case we cannot put the font into `this.fontCache` (which is
1339     // a `RefSetCache`), since it's not possible to use a `Dict` as a key.
1340     //
1341     // However, if we don't cache the font it's not possible to remove it
1342     // when `cleanup` is triggered from the API, which causes issues on
1343     // subsequent rendering operations (see issue7403.pdf) and would force us
1344     // to unnecessarily load the same fonts over and over.
1345     //
1346     // Instead, we cheat a bit by using a modified `fontID` as a key in
1347     // `this.fontCache`, to allow the font to be cached.
1348     // NOTE: This works because `RefSetCache` calls `toString()` on provided
1349     //       keys. Also, since `fontRef` is used when getting cached fonts,
1350     //       we'll not accidentally match fonts cached with the `fontID`.
1351     if (fontRefIsRef) {
1352       this.fontCache.put(fontRef, promise);
1353     } else {
1354       font.cacheKey = `cacheKey_${fontID}`;
1355       this.fontCache.put(font.cacheKey, promise);
1356     }
1357 
1358     // Keep track of each font we translated so the caller can
1359     // load them asynchronously before calling display on a page.
1360     font.loadedName = `${this.idFactory.getDocId()}_${fontID}`;
1361 
1362     this.translateFont(preEvaluatedFont)
1363       .then(translatedFont => {
1364         resolve(
1365           new TranslatedFont({
1366             loadedName: font.loadedName,
1367             font: translatedFont,
1368             dict: font,
1369             evaluatorOptions: this.options,
1370           })
1371         );
1372       })
1373       .catch(reason => {
1374         // TODO reject?
1375         warn(`loadFont - translateFont failed: "${reason}".`);
1376 
1377         resolve(
1378           new TranslatedFont({
1379             loadedName: font.loadedName,
1380             font: new ErrorFont(
1381               reason instanceof Error ? reason.message : reason
1382             ),
1383             dict: font,
1384             evaluatorOptions: this.options,
1385           })
1386         );
1387       });
1388     return promise;
1389   }
1390 
1391   buildPath(operatorList, fn, args, parsingText = false) {
1392     const lastIndex = operatorList.length - 1;
1393     if (!args) {
1394       args = [];
1395     }
1396     if (
1397       lastIndex < 0 ||
1398       operatorList.fnArray[lastIndex] !== OPS.constructPath
1399     ) {
1400       // Handle corrupt PDF documents that contains path operators inside of
1401       // text objects, which may shift subsequent text, by enclosing the path
1402       // operator in save/restore operators (fixes issue10542_reduced.pdf).
1403       //
1404       // Note that this will effectively disable the optimization in the
1405       // `else` branch below, but given that this type of corruption is
1406       // *extremely* rare that shouldn't really matter much in practice.
1407       if (parsingText) {
1408         warn(`Encountered path operator "${fn}" inside of a text object.`);
1409         operatorList.addOp(OPS.save, null);
1410       }
1411 
1412       let minMax;
1413       switch (fn) {
1414         case OPS.rectangle:
1415           const x = args[0] + args[2];
1416           const y = args[1] + args[3];
1417           minMax = [
1418             Math.min(args[0], x),
1419             Math.min(args[1], y),
1420             Math.max(args[0], x),
1421             Math.max(args[1], y),
1422           ];
1423           break;
1424         case OPS.moveTo:
1425         case OPS.lineTo:
1426           minMax = [args[0], args[1], args[0], args[1]];
1427           break;
1428         default:
1429           minMax = [Infinity, Infinity, -Infinity, -Infinity];
1430           break;
1431       }
1432       operatorList.addOp(OPS.constructPath, [[fn], args, minMax]);
1433 
1434       if (parsingText) {
1435         operatorList.addOp(OPS.restore, null);
1436       }
1437     } else {
1438       const opArgs = operatorList.argsArray[lastIndex];
1439       opArgs[0].push(fn);
1440       opArgs[1].push(...args);
1441       const minMax = opArgs[2];
1442 
1443       // Compute min/max in the worker instead of the main thread.
1444       // If the current matrix (when drawing) is a scaling one
1445       // then min/max can be easily computed in using those values.
1446       // Only rectangle, lineTo and moveTo are handled here since
1447       // Bezier stuff requires to have the starting point.
1448       switch (fn) {
1449         case OPS.rectangle:
1450           const x = args[0] + args[2];
1451           const y = args[1] + args[3];
1452           minMax[0] = Math.min(minMax[0], args[0], x);
1453           minMax[1] = Math.min(minMax[1], args[1], y);
1454           minMax[2] = Math.max(minMax[2], args[0], x);
1455           minMax[3] = Math.max(minMax[3], args[1], y);
1456           break;
1457         case OPS.moveTo:
1458         case OPS.lineTo:
1459           minMax[0] = Math.min(minMax[0], args[0]);
1460           minMax[1] = Math.min(minMax[1], args[1]);
1461           minMax[2] = Math.max(minMax[2], args[0]);
1462           minMax[3] = Math.max(minMax[3], args[1]);
1463           break;
1464       }
1465     }
1466   }
1467 
1468   parseColorSpace({ cs, resources, localColorSpaceCache }) {
1469     return ColorSpace.parseAsync({
1470       cs,
1471       xref: this.xref,
1472       resources,
1473       pdfFunctionFactory: this._pdfFunctionFactory,
1474       localColorSpaceCache,
1475     }).catch(reason => {
1476       if (reason instanceof AbortException) {
1477         return null;
1478       }
1479       if (this.options.ignoreErrors) {
1480         warn(`parseColorSpace - ignoring ColorSpace: "${reason}".`);
1481         return null;
1482       }
1483       throw reason;
1484     });
1485   }
1486 
1487   parseShading({
1488     shading,
1489     resources,
1490     localColorSpaceCache,
1491     localShadingPatternCache,
1492   }) {
1493     // Shadings and patterns may be referenced by the same name but the resource
1494     // dictionary could be different so we can't use the name for the cache key.
1495     let id = localShadingPatternCache.get(shading);
1496     if (id) {
1497       return id;
1498     }
1499     let patternIR;
1500 
1501     try {
1502       const shadingFill = Pattern.parseShading(
1503         shading,
1504         this.xref,
1505         resources,
1506         this._pdfFunctionFactory,
1507         localColorSpaceCache
1508       );
1509       patternIR = shadingFill.getIR();
1510     } catch (reason) {
1511       if (reason instanceof AbortException) {
1512         return null;
1513       }
1514       if (this.options.ignoreErrors) {
1515         warn(`parseShading - ignoring shading: "${reason}".`);
1516 
1517         localShadingPatternCache.set(shading, null);
1518         return null;
1519       }
1520       throw reason;
1521     }
1522 
1523     id = `pattern_${this.idFactory.createObjId()}`;
1524     if (this.parsingType3Font) {
1525       id = `${this.idFactory.getDocId()}_type3_${id}`;
1526     }
1527     localShadingPatternCache.set(shading, id);
1528 
1529     if (this.parsingType3Font) {
1530       this.handler.send("commonobj", [id, "Pattern", patternIR]);
1531     } else {
1532       this.handler.send("obj", [id, this.pageIndex, "Pattern", patternIR]);
1533     }
1534     return id;
1535   }
1536 
1537   handleColorN(
1538     operatorList,
1539     fn,
1540     args,
1541     cs,
1542     patterns,
1543     resources,
1544     task,
1545     localColorSpaceCache,
1546     localTilingPatternCache,
1547     localShadingPatternCache
1548   ) {
1549     // compile tiling patterns
1550     const patternName = args.pop();
1551     // SCN/scn applies patterns along with normal colors
1552     if (patternName instanceof Name) {
1553       const rawPattern = patterns.getRaw(patternName.name);
1554 
1555       const localTilingPattern =
1556         rawPattern instanceof Ref &&
1557         localTilingPatternCache.getByRef(rawPattern);
1558       if (localTilingPattern) {
1559         try {
1560           const color = cs.base ? cs.base.getRgb(args, 0) : null;
1561           const tilingPatternIR = getTilingPatternIR(
1562             localTilingPattern.operatorListIR,
1563             localTilingPattern.dict,
1564             color
1565           );
1566           operatorList.addOp(fn, tilingPatternIR);
1567           return undefined;
1568         } catch {
1569           // Handle any errors during normal TilingPattern parsing.
1570         }
1571       }
1572 
1573       const pattern = this.xref.fetchIfRef(rawPattern);
1574       if (pattern) {
1575         const dict = pattern instanceof BaseStream ? pattern.dict : pattern;
1576         const typeNum = dict.get("PatternType");
1577 
1578         if (typeNum === PatternType.TILING) {
1579           const color = cs.base ? cs.base.getRgb(args, 0) : null;
1580           return this.handleTilingType(
1581             fn,
1582             color,
1583             resources,
1584             pattern,
1585             dict,
1586             operatorList,
1587             task,
1588             localTilingPatternCache
1589           );
1590         } else if (typeNum === PatternType.SHADING) {
1591           const shading = dict.get("Shading");
1592           const objId = this.parseShading({
1593             shading,
1594             resources,
1595             localColorSpaceCache,
1596             localShadingPatternCache,
1597           });
1598           if (objId) {
1599             const matrix = lookupMatrix(dict.getArray("Matrix"), null);
1600             operatorList.addOp(fn, ["Shading", objId, matrix]);
1601           }
1602           return undefined;
1603         }
1604         throw new FormatError(`Unknown PatternType: ${typeNum}`);
1605       }
1606     }
1607     throw new FormatError(`Unknown PatternName: ${patternName}`);
1608   }
1609 
1610   _parseVisibilityExpression(array, nestingCounter, currentResult) {
1611     const MAX_NESTING = 10;
1612     if (++nestingCounter > MAX_NESTING) {
1613       warn("Visibility expression is too deeply nested");
1614       return;
1615     }
1616     const length = array.length;
1617     const operator = this.xref.fetchIfRef(array[0]);
1618     if (length < 2 || !(operator instanceof Name)) {
1619       warn("Invalid visibility expression");
1620       return;
1621     }
1622     switch (operator.name) {
1623       case "And":
1624       case "Or":
1625       case "Not":
1626         currentResult.push(operator.name);
1627         break;
1628       default:
1629         warn(`Invalid operator ${operator.name} in visibility expression`);
1630         return;
1631     }
1632     for (let i = 1; i < length; i++) {
1633       const raw = array[i];
1634       const object = this.xref.fetchIfRef(raw);
1635       if (Array.isArray(object)) {
1636         const nestedResult = [];
1637         currentResult.push(nestedResult);
1638         // Recursively parse a subarray.
1639         this._parseVisibilityExpression(object, nestingCounter, nestedResult);
1640       } else if (raw instanceof Ref) {
1641         // Reference to an OCG dictionary.
1642         currentResult.push(raw.toString());
1643       }
1644     }
1645   }
1646 
1647   async parseMarkedContentProps(contentProperties, resources) {
1648     let optionalContent;
1649     if (contentProperties instanceof Name) {
1650       const properties = resources.get("Properties");
1651       optionalContent = properties.get(contentProperties.name);
1652     } else if (contentProperties instanceof Dict) {
1653       optionalContent = contentProperties;
1654     } else {
1655       throw new FormatError("Optional content properties malformed.");
1656     }
1657 
1658     const optionalContentType = optionalContent.get("Type")?.name;
1659     if (optionalContentType === "OCG") {
1660       return {
1661         type: optionalContentType,
1662         id: optionalContent.objId,
1663       };
1664     } else if (optionalContentType === "OCMD") {
1665       const expression = optionalContent.get("VE");
1666       if (Array.isArray(expression)) {
1667         const result = [];
1668         this._parseVisibilityExpression(expression, 0, result);
1669         if (result.length > 0) {
1670           return {
1671             type: "OCMD",
1672             expression: result,
1673           };
1674         }
1675       }
1676 
1677       const optionalContentGroups = optionalContent.get("OCGs");
1678       if (
1679         Array.isArray(optionalContentGroups) ||
1680         optionalContentGroups instanceof Dict
1681       ) {
1682         const groupIds = [];
1683         if (Array.isArray(optionalContentGroups)) {
1684           for (const ocg of optionalContentGroups) {
1685             groupIds.push(ocg.toString());
1686           }
1687         } else {
1688           // Dictionary, just use the obj id.
1689           groupIds.push(optionalContentGroups.objId);
1690         }
1691 
1692         return {
1693           type: optionalContentType,
1694           ids: groupIds,
1695           policy:
1696             optionalContent.get("P") instanceof Name
1697               ? optionalContent.get("P").name
1698               : null,
1699           expression: null,
1700         };
1701       } else if (optionalContentGroups instanceof Ref) {
1702         return {
1703           type: optionalContentType,
1704           id: optionalContentGroups.toString(),
1705         };
1706       }
1707     }
1708     return null;
1709   }
1710 
1711   getOperatorList({
1712     stream,
1713     task,
1714     resources,
1715     operatorList,
1716     initialState = null,
1717     fallbackFontDict = null,
1718   }) {
1719     // Ensure that `resources`/`initialState` is correctly initialized,
1720     // even if the provided parameter is e.g. `null`.
1721     resources ||= Dict.empty;
1722     initialState ||= new EvalState();
1723 
1724     if (!operatorList) {
1725       throw new Error('getOperatorList: missing "operatorList" parameter');
1726     }
1727 
1728     const self = this;
1729     const xref = this.xref;
1730     let parsingText = false;
1731     const localImageCache = new LocalImageCache();
1732     const localColorSpaceCache = new LocalColorSpaceCache();
1733     const localGStateCache = new LocalGStateCache();
1734     const localTilingPatternCache = new LocalTilingPatternCache();
1735     const localShadingPatternCache = new Map();
1736 
1737     const xobjs = resources.get("XObject") || Dict.empty;
1738     const patterns = resources.get("Pattern") || Dict.empty;
1739     const stateManager = new StateManager(initialState);
1740     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
1741     const timeSlotManager = new TimeSlotManager();
1742 
1743     function closePendingRestoreOPS(argument) {
1744       for (let i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
1745         operatorList.addOp(OPS.restore, []);
1746       }
1747     }
1748 
1749     return new Promise(function promiseBody(resolve, reject) {
1750       const next = function (promise) {
1751         Promise.all([promise, operatorList.ready]).then(function () {
1752           try {
1753             promiseBody(resolve, reject);
1754           } catch (ex) {
1755             reject(ex);
1756           }
1757         }, reject);
1758       };
1759       task.ensureNotTerminated();
1760       timeSlotManager.reset();
1761 
1762       const operation = {};
1763       let stop, i, ii, cs, name, isValidName;
1764       while (!(stop = timeSlotManager.check())) {
1765         // The arguments parsed by read() are used beyond this loop, so we
1766         // cannot reuse the same array on each iteration. Therefore we pass
1767         // in |null| as the initial value (see the comment on
1768         // EvaluatorPreprocessor_read() for why).
1769         operation.args = null;
1770         if (!preprocessor.read(operation)) {
1771           break;
1772         }
1773         let args = operation.args;
1774         let fn = operation.fn;
1775 
1776         switch (fn | 0) {
1777           case OPS.paintXObject:
1778             // eagerly compile XForm objects
1779             isValidName = args[0] instanceof Name;
1780             name = args[0].name;
1781 
1782             if (isValidName) {
1783               const localImage = localImageCache.getByName(name);
1784               if (localImage) {
1785                 addLocallyCachedImageOps(operatorList, localImage);
1786                 args = null;
1787                 continue;
1788               }
1789             }
1790 
1791             next(
1792               new Promise(function (resolveXObject, rejectXObject) {
1793                 if (!isValidName) {
1794                   throw new FormatError("XObject must be referred to by name.");
1795                 }
1796 
1797                 let xobj = xobjs.getRaw(name);
1798                 if (xobj instanceof Ref) {
1799                   const localImage =
1800                     localImageCache.getByRef(xobj) ||
1801                     self._regionalImageCache.getByRef(xobj);
1802                   if (localImage) {
1803                     addLocallyCachedImageOps(operatorList, localImage);
1804                     resolveXObject();
1805                     return;
1806                   }
1807 
1808                   const globalImage = self.globalImageCache.getData(
1809                     xobj,
1810                     self.pageIndex
1811                   );
1812                   if (globalImage) {
1813                     operatorList.addDependency(globalImage.objId);
1814                     operatorList.addImageOps(
1815                       globalImage.fn,
1816                       globalImage.args,
1817                       globalImage.optionalContent
1818                     );
1819 
1820                     resolveXObject();
1821                     return;
1822                   }
1823 
1824                   xobj = xref.fetch(xobj);
1825                 }
1826 
1827                 if (!(xobj instanceof BaseStream)) {
1828                   throw new FormatError("XObject should be a stream");
1829                 }
1830 
1831                 const type = xobj.dict.get("Subtype");
1832                 if (!(type instanceof Name)) {
1833                   throw new FormatError("XObject should have a Name subtype");
1834                 }
1835 
1836                 if (type.name === "Form") {
1837                   stateManager.save();
1838                   self
1839                     .buildFormXObject(
1840                       resources,
1841                       xobj,
1842                       null,
1843                       operatorList,
1844                       task,
1845                       stateManager.state.clone(),
1846                       localColorSpaceCache
1847                     )
1848                     .then(function () {
1849                       stateManager.restore();
1850                       resolveXObject();
1851                     }, rejectXObject);
1852                   return;
1853                 } else if (type.name === "Image") {
1854                   self
1855                     .buildPaintImageXObject({
1856                       resources,
1857                       image: xobj,
1858                       operatorList,
1859                       cacheKey: name,
1860                       localImageCache,
1861                       localColorSpaceCache,
1862                     })
1863                     .then(resolveXObject, rejectXObject);
1864                   return;
1865                 } else if (type.name === "PS") {
1866                   // PostScript XObjects are unused when viewing documents.
1867                   // See section 4.7.1 of Adobe's PDF reference.
1868                   info("Ignored XObject subtype PS");
1869                 } else {
1870                   throw new FormatError(
1871                     `Unhandled XObject subtype ${type.name}`
1872                   );
1873                 }
1874                 resolveXObject();
1875               }).catch(function (reason) {
1876                 if (reason instanceof AbortException) {
1877                   return;
1878                 }
1879                 if (self.options.ignoreErrors) {
1880                   warn(`getOperatorList - ignoring XObject: "${reason}".`);
1881                   return;
1882                 }
1883                 throw reason;
1884               })
1885             );
1886             return;
1887           case OPS.setFont:
1888             const fontSize = args[1];
1889             // eagerly collect all fonts
1890             next(
1891               self
1892                 .handleSetFont(
1893                   resources,
1894                   args,
1895                   null,
1896                   operatorList,
1897                   task,
1898                   stateManager.state,
1899                   fallbackFontDict
1900                 )
1901                 .then(function (loadedName) {
1902                   operatorList.addDependency(loadedName);
1903                   operatorList.addOp(OPS.setFont, [loadedName, fontSize]);
1904                 })
1905             );
1906             return;
1907           case OPS.beginText:
1908             parsingText = true;
1909             break;
1910           case OPS.endText:
1911             parsingText = false;
1912             break;
1913           case OPS.endInlineImage:
1914             const cacheKey = args[0].cacheKey;
1915             if (cacheKey) {
1916               const localImage = localImageCache.getByName(cacheKey);
1917               if (localImage) {
1918                 addLocallyCachedImageOps(operatorList, localImage);
1919                 args = null;
1920                 continue;
1921               }
1922             }
1923             next(
1924               self.buildPaintImageXObject({
1925                 resources,
1926                 image: args[0],
1927                 isInline: true,
1928                 operatorList,
1929                 cacheKey,
1930                 localImageCache,
1931                 localColorSpaceCache,
1932               })
1933             );
1934             return;
1935           case OPS.showText:
1936             if (!stateManager.state.font) {
1937               self.ensureStateFont(stateManager.state);
1938               continue;
1939             }
1940             args[0] = self.handleText(args[0], stateManager.state);
1941             break;
1942           case OPS.showSpacedText:
1943             if (!stateManager.state.font) {
1944               self.ensureStateFont(stateManager.state);
1945               continue;
1946             }
1947             const combinedGlyphs = [],
1948               state = stateManager.state;
1949             for (const arrItem of args[0]) {
1950               if (typeof arrItem === "string") {
1951                 combinedGlyphs.push(...self.handleText(arrItem, state));
1952               } else if (typeof arrItem === "number") {
1953                 combinedGlyphs.push(arrItem);
1954               }
1955             }
1956             args[0] = combinedGlyphs;
1957             fn = OPS.showText;
1958             break;
1959           case OPS.nextLineShowText:
1960             if (!stateManager.state.font) {
1961               self.ensureStateFont(stateManager.state);
1962               continue;
1963             }
1964             operatorList.addOp(OPS.nextLine);
1965             args[0] = self.handleText(args[0], stateManager.state);
1966             fn = OPS.showText;
1967             break;
1968           case OPS.nextLineSetSpacingShowText:
1969             if (!stateManager.state.font) {
1970               self.ensureStateFont(stateManager.state);
1971               continue;
1972             }
1973             operatorList.addOp(OPS.nextLine);
1974             operatorList.addOp(OPS.setWordSpacing, [args.shift()]);
1975             operatorList.addOp(OPS.setCharSpacing, [args.shift()]);
1976             args[0] = self.handleText(args[0], stateManager.state);
1977             fn = OPS.showText;
1978             break;
1979           case OPS.setTextRenderingMode:
1980             stateManager.state.textRenderingMode = args[0];
1981             break;
1982 
1983           case OPS.setFillColorSpace: {
1984             const cachedColorSpace = ColorSpace.getCached(
1985               args[0],
1986               xref,
1987               localColorSpaceCache
1988             );
1989             if (cachedColorSpace) {
1990               stateManager.state.fillColorSpace = cachedColorSpace;
1991               continue;
1992             }
1993 
1994             next(
1995               self
1996                 .parseColorSpace({
1997                   cs: args[0],
1998                   resources,
1999                   localColorSpaceCache,
2000                 })
2001                 .then(function (colorSpace) {
2002                   stateManager.state.fillColorSpace =
2003                     colorSpace || ColorSpace.singletons.gray;
2004                 })
2005             );
2006             return;
2007           }
2008           case OPS.setStrokeColorSpace: {
2009             const cachedColorSpace = ColorSpace.getCached(
2010               args[0],
2011               xref,
2012               localColorSpaceCache
2013             );
2014             if (cachedColorSpace) {
2015               stateManager.state.strokeColorSpace = cachedColorSpace;
2016               continue;
2017             }
2018 
2019             next(
2020               self
2021                 .parseColorSpace({
2022                   cs: args[0],
2023                   resources,
2024                   localColorSpaceCache,
2025                 })
2026                 .then(function (colorSpace) {
2027                   stateManager.state.strokeColorSpace =
2028                     colorSpace || ColorSpace.singletons.gray;
2029                 })
2030             );
2031             return;
2032           }
2033           case OPS.setFillColor:
2034             cs = stateManager.state.fillColorSpace;
2035             args = cs.getRgb(args, 0);
2036             fn = OPS.setFillRGBColor;
2037             break;
2038           case OPS.setStrokeColor:
2039             cs = stateManager.state.strokeColorSpace;
2040             args = cs.getRgb(args, 0);
2041             fn = OPS.setStrokeRGBColor;
2042             break;
2043           case OPS.setFillGray:
2044             stateManager.state.fillColorSpace = ColorSpace.singletons.gray;
2045             args = ColorSpace.singletons.gray.getRgb(args, 0);
2046             fn = OPS.setFillRGBColor;
2047             break;
2048           case OPS.setStrokeGray:
2049             stateManager.state.strokeColorSpace = ColorSpace.singletons.gray;
2050             args = ColorSpace.singletons.gray.getRgb(args, 0);
2051             fn = OPS.setStrokeRGBColor;
2052             break;
2053           case OPS.setFillCMYKColor:
2054             stateManager.state.fillColorSpace = ColorSpace.singletons.cmyk;
2055             args = ColorSpace.singletons.cmyk.getRgb(args, 0);
2056             fn = OPS.setFillRGBColor;
2057             break;
2058           case OPS.setStrokeCMYKColor:
2059             stateManager.state.strokeColorSpace = ColorSpace.singletons.cmyk;
2060             args = ColorSpace.singletons.cmyk.getRgb(args, 0);
2061             fn = OPS.setStrokeRGBColor;
2062             break;
2063           case OPS.setFillRGBColor:
2064             stateManager.state.fillColorSpace = ColorSpace.singletons.rgb;
2065             args = ColorSpace.singletons.rgb.getRgb(args, 0);
2066             break;
2067           case OPS.setStrokeRGBColor:
2068             stateManager.state.strokeColorSpace = ColorSpace.singletons.rgb;
2069             args = ColorSpace.singletons.rgb.getRgb(args, 0);
2070             break;
2071           case OPS.setFillColorN:
2072             cs = stateManager.state.patternFillColorSpace;
2073             if (!cs) {
2074               if (isNumberArray(args, null)) {
2075                 args = ColorSpace.singletons.gray.getRgb(args, 0);
2076                 fn = OPS.setFillRGBColor;
2077                 break;
2078               }
2079               args = [];
2080               fn = OPS.setFillTransparent;
2081               break;
2082             }
2083             if (cs.name === "Pattern") {
2084               next(
2085                 self.handleColorN(
2086                   operatorList,
2087                   OPS.setFillColorN,
2088                   args,
2089                   cs,
2090                   patterns,
2091                   resources,
2092                   task,
2093                   localColorSpaceCache,
2094                   localTilingPatternCache,
2095                   localShadingPatternCache
2096                 )
2097               );
2098               return;
2099             }
2100             args = cs.getRgb(args, 0);
2101             fn = OPS.setFillRGBColor;
2102             break;
2103           case OPS.setStrokeColorN:
2104             cs = stateManager.state.patternStrokeColorSpace;
2105             if (!cs) {
2106               if (isNumberArray(args, null)) {
2107                 args = ColorSpace.singletons.gray.getRgb(args, 0);
2108                 fn = OPS.setStrokeRGBColor;
2109                 break;
2110               }
2111               args = [];
2112               fn = OPS.setStrokeTransparent;
2113               break;
2114             }
2115             if (cs.name === "Pattern") {
2116               next(
2117                 self.handleColorN(
2118                   operatorList,
2119                   OPS.setStrokeColorN,
2120                   args,
2121                   cs,
2122                   patterns,
2123                   resources,
2124                   task,
2125                   localColorSpaceCache,
2126                   localTilingPatternCache,
2127                   localShadingPatternCache
2128                 )
2129               );
2130               return;
2131             }
2132             args = cs.getRgb(args, 0);
2133             fn = OPS.setStrokeRGBColor;
2134             break;
2135 
2136           case OPS.shadingFill:
2137             let shading;
2138             try {
2139               const shadingRes = resources.get("Shading");
2140               if (!shadingRes) {
2141                 throw new FormatError("No shading resource found");
2142               }
2143 
2144               shading = shadingRes.get(args[0].name);
2145               if (!shading) {
2146                 throw new FormatError("No shading object found");
2147               }
2148             } catch (reason) {
2149               if (reason instanceof AbortException) {
2150                 continue;
2151               }
2152               if (self.options.ignoreErrors) {
2153                 warn(`getOperatorList - ignoring Shading: "${reason}".`);
2154                 continue;
2155               }
2156               throw reason;
2157             }
2158             const patternId = self.parseShading({
2159               shading,
2160               resources,
2161               localColorSpaceCache,
2162               localShadingPatternCache,
2163             });
2164             if (!patternId) {
2165               continue;
2166             }
2167             args = [patternId];
2168             fn = OPS.shadingFill;
2169             break;
2170           case OPS.setGState:
2171             isValidName = args[0] instanceof Name;
2172             name = args[0].name;
2173 
2174             if (isValidName) {
2175               const localGStateObj = localGStateCache.getByName(name);
2176               if (localGStateObj) {
2177                 if (localGStateObj.length > 0) {
2178                   operatorList.addOp(OPS.setGState, [localGStateObj]);
2179                 }
2180                 args = null;
2181                 continue;
2182               }
2183             }
2184 
2185             next(
2186               new Promise(function (resolveGState, rejectGState) {
2187                 if (!isValidName) {
2188                   throw new FormatError("GState must be referred to by name.");
2189                 }
2190 
2191                 const extGState = resources.get("ExtGState");
2192                 if (!(extGState instanceof Dict)) {
2193                   throw new FormatError("ExtGState should be a dictionary.");
2194                 }
2195 
2196                 const gState = extGState.get(name);
2197                 // TODO: Attempt to lookup cached GStates by reference as well,
2198                 //       if and only if there are PDF documents where doing so
2199                 //       would significantly improve performance.
2200                 if (!(gState instanceof Dict)) {
2201                   throw new FormatError("GState should be a dictionary.");
2202                 }
2203 
2204                 self
2205                   .setGState({
2206                     resources,
2207                     gState,
2208                     operatorList,
2209                     cacheKey: name,
2210                     task,
2211                     stateManager,
2212                     localGStateCache,
2213                     localColorSpaceCache,
2214                   })
2215                   .then(resolveGState, rejectGState);
2216               }).catch(function (reason) {
2217                 if (reason instanceof AbortException) {
2218                   return;
2219                 }
2220                 if (self.options.ignoreErrors) {
2221                   warn(`getOperatorList - ignoring ExtGState: "${reason}".`);
2222                   return;
2223                 }
2224                 throw reason;
2225               })
2226             );
2227             return;
2228           case OPS.moveTo:
2229           case OPS.lineTo:
2230           case OPS.curveTo:
2231           case OPS.curveTo2:
2232           case OPS.curveTo3:
2233           case OPS.closePath:
2234           case OPS.rectangle:
2235             self.buildPath(operatorList, fn, args, parsingText);
2236             continue;
2237           case OPS.markPoint:
2238           case OPS.markPointProps:
2239           case OPS.beginCompat:
2240           case OPS.endCompat:
2241             // Ignore operators where the corresponding handlers are known to
2242             // be no-op in CanvasGraphics (display/canvas.js). This prevents
2243             // serialization errors and is also a bit more efficient.
2244             // We could also try to serialize all objects in a general way,
2245             // e.g. as done in https://github.com/mozilla/pdf.js/pull/6266,
2246             // but doing so is meaningless without knowing the semantics.
2247             continue;
2248           case OPS.beginMarkedContentProps:
2249             if (!(args[0] instanceof Name)) {
2250               warn(`Expected name for beginMarkedContentProps arg0=${args[0]}`);
2251               operatorList.addOp(OPS.beginMarkedContentProps, ["OC", null]);
2252               continue;
2253             }
2254             if (args[0].name === "OC") {
2255               next(
2256                 self
2257                   .parseMarkedContentProps(args[1], resources)
2258                   .then(data => {
2259                     operatorList.addOp(OPS.beginMarkedContentProps, [
2260                       "OC",
2261                       data,
2262                     ]);
2263                   })
2264                   .catch(reason => {
2265                     if (reason instanceof AbortException) {
2266                       return;
2267                     }
2268                     if (self.options.ignoreErrors) {
2269                       warn(
2270                         `getOperatorList - ignoring beginMarkedContentProps: "${reason}".`
2271                       );
2272                       operatorList.addOp(OPS.beginMarkedContentProps, [
2273                         "OC",
2274                         null,
2275                       ]);
2276                       return;
2277                     }
2278                     throw reason;
2279                   })
2280               );
2281               return;
2282             }
2283             // Other marked content types aren't supported yet.
2284             args = [
2285               args[0].name,
2286               args[1] instanceof Dict ? args[1].get("MCID") : null,
2287             ];
2288 
2289             break;
2290           case OPS.beginMarkedContent:
2291           case OPS.endMarkedContent:
2292           default:
2293             // Note: Ignore the operator if it has `Dict` arguments, since
2294             // those are non-serializable, otherwise postMessage will throw
2295             // "An object could not be cloned.".
2296             if (args !== null) {
2297               for (i = 0, ii = args.length; i < ii; i++) {
2298                 if (args[i] instanceof Dict) {
2299                   break;
2300                 }
2301               }
2302               if (i < ii) {
2303                 warn("getOperatorList - ignoring operator: " + fn);
2304                 continue;
2305               }
2306             }
2307         }
2308         operatorList.addOp(fn, args);
2309       }
2310       if (stop) {
2311         next(deferred);
2312         return;
2313       }
2314       // Some PDFs don't close all restores inside object/form.
2315       // Closing those for them.
2316       closePendingRestoreOPS();
2317       resolve();
2318     }).catch(reason => {
2319       if (reason instanceof AbortException) {
2320         return;
2321       }
2322       if (this.options.ignoreErrors) {
2323         warn(
2324           `getOperatorList - ignoring errors during "${task.name}" ` +
2325             `task: "${reason}".`
2326         );
2327 
2328         closePendingRestoreOPS();
2329         return;
2330       }
2331       throw reason;
2332     });
2333   }
2334 
2335   getTextContent({
2336     stream,
2337     task,
2338     resources,
2339     stateManager = null,
2340     includeMarkedContent = false,
2341     sink,
2342     seenStyles = new Set(),
2343     viewBox,
2344     lang = null,
2345     markedContentData = null,
2346     disableNormalization = false,
2347     keepWhiteSpace = false,
2348   }) {
2349     // Ensure that `resources`/`stateManager` is correctly initialized,
2350     // even if the provided parameter is e.g. `null`.
2351     resources ||= Dict.empty;
2352     stateManager ||= new StateManager(new TextState());
2353 
2354     if (includeMarkedContent) {
2355       markedContentData ||= { level: 0 };
2356     }
2357 
2358     const textContent = {
2359       items: [],
2360       styles: Object.create(null),
2361       lang,
2362     };
2363     const textContentItem = {
2364       initialized: false,
2365       str: [],
2366       totalWidth: 0,
2367       totalHeight: 0,
2368       width: 0,
2369       height: 0,
2370       vertical: false,
2371       prevTransform: null,
2372       textAdvanceScale: 0,
2373       spaceInFlowMin: 0,
2374       spaceInFlowMax: 0,
2375       trackingSpaceMin: Infinity,
2376       negativeSpaceMax: -Infinity,
2377       notASpace: -Infinity,
2378       transform: null,
2379       fontName: null,
2380       hasEOL: false,
2381     };
2382 
2383     // Use a circular buffer (length === 2) to save the last chars in the
2384     // text stream.
2385     // This implementation of the circular buffer is using a fixed array
2386     // and the position of the next element:
2387     // function addElement(x) {
2388     //   buffer[pos] = x;
2389     //   pos = (pos + 1) % buffer.length;
2390     // }
2391     // It's a way faster than:
2392     // function addElement(x) {
2393     //   buffer.push(x);
2394     //   buffer.shift();
2395     // }
2396     //
2397     // It's useful to know when we need to add a whitespace in the
2398     // text chunk.
2399     const twoLastChars = [" ", " "];
2400     let twoLastCharsPos = 0;
2401 
2402     /**
2403      * Save the last char.
2404      * @param {string} char
2405      * @returns {boolean} true when the two last chars before adding the new one
2406      * are a non-whitespace followed by a whitespace.
2407      */
2408     function saveLastChar(char) {
2409       const nextPos = (twoLastCharsPos + 1) % 2;
2410       const ret =
2411         twoLastChars[twoLastCharsPos] !== " " && twoLastChars[nextPos] === " ";
2412       twoLastChars[twoLastCharsPos] = char;
2413       twoLastCharsPos = nextPos;
2414 
2415       return !keepWhiteSpace && ret;
2416     }
2417 
2418     function shouldAddWhitepsace() {
2419       return (
2420         !keepWhiteSpace &&
2421         twoLastChars[twoLastCharsPos] !== " " &&
2422         twoLastChars[(twoLastCharsPos + 1) % 2] === " "
2423       );
2424     }
2425 
2426     function resetLastChars() {
2427       twoLastChars[0] = twoLastChars[1] = " ";
2428       twoLastCharsPos = 0;
2429     }
2430 
2431     // Used in addFakeSpaces.
2432 
2433     // A white <= fontSize * TRACKING_SPACE_FACTOR is a tracking space
2434     // so it doesn't count as a space.
2435     const TRACKING_SPACE_FACTOR = 0.102;
2436 
2437     // When a white <= fontSize * NOT_A_SPACE_FACTOR, there is no space
2438     // even if one is present in the text stream.
2439     const NOT_A_SPACE_FACTOR = 0.03;
2440 
2441     // A negative white < fontSize * NEGATIVE_SPACE_FACTOR induces
2442     // a break (a new chunk of text is created).
2443     // It doesn't change anything when the text is copied but
2444     // it improves potential mismatch between text layer and canvas.
2445     const NEGATIVE_SPACE_FACTOR = -0.2;
2446 
2447     // A white with a width in [fontSize * MIN_FACTOR; fontSize * MAX_FACTOR]
2448     // is a space which will be inserted in the current flow of words.
2449     // If the width is outside of this range then the flow is broken
2450     // (which means a new span in the text layer).
2451     // It's useful to adjust the best as possible the span in the layer
2452     // to what is displayed in the canvas.
2453     const SPACE_IN_FLOW_MIN_FACTOR = 0.102;
2454     const SPACE_IN_FLOW_MAX_FACTOR = 0.6;
2455 
2456     // If a char is too high/too low compared to the previous we just create
2457     // a new chunk.
2458     // If the advance isn't in the +/-VERTICAL_SHIFT_RATIO * height range then
2459     // a new chunk is created.
2460     const VERTICAL_SHIFT_RATIO = 0.25;
2461 
2462     const self = this;
2463     const xref = this.xref;
2464     const showSpacedTextBuffer = [];
2465 
2466     // The xobj is parsed iff it's needed, e.g. if there is a `DO` cmd.
2467     let xobjs = null;
2468     const emptyXObjectCache = new LocalImageCache();
2469     const emptyGStateCache = new LocalGStateCache();
2470 
2471     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
2472 
2473     let textState;
2474 
2475     function pushWhitespace({
2476       width = 0,
2477       height = 0,
2478       transform = textContentItem.prevTransform,
2479       fontName = textContentItem.fontName,
2480     }) {
2481       textContent.items.push({
2482         str: " ",
2483         dir: "ltr",
2484         width,
2485         height,
2486         transform,
2487         fontName,
2488         hasEOL: false,
2489       });
2490     }
2491 
2492     function getCurrentTextTransform() {
2493       // 9.4.4 Text Space Details
2494       const font = textState.font;
2495       const tsm = [
2496         textState.fontSize * textState.textHScale,
2497         0,
2498         0,
2499         textState.fontSize,
2500         0,
2501         textState.textRise,
2502       ];
2503 
2504       if (
2505         font.isType3Font &&
2506         (textState.fontSize <= 1 || font.isCharBBox) &&
2507         !isArrayEqual(textState.fontMatrix, FONT_IDENTITY_MATRIX)
2508       ) {
2509         const glyphHeight = font.bbox[3] - font.bbox[1];
2510         if (glyphHeight > 0) {
2511           tsm[3] *= glyphHeight * textState.fontMatrix[3];
2512         }
2513       }
2514 
2515       return Util.transform(
2516         textState.ctm,
2517         Util.transform(textState.textMatrix, tsm)
2518       );
2519     }
2520 
2521     function ensureTextContentItem() {
2522       if (textContentItem.initialized) {
2523         return textContentItem;
2524       }
2525       const { font, loadedName } = textState;
2526       if (!seenStyles.has(loadedName)) {
2527         seenStyles.add(loadedName);
2528         textContent.styles[loadedName] = {
2529           fontFamily: font.fallbackName,
2530           ascent: font.ascent,
2531           descent: font.descent,
2532           vertical: font.vertical,
2533         };
2534         if (self.options.fontExtraProperties && font.systemFontInfo) {
2535           const style = textContent.styles[loadedName];
2536           style.fontSubstitution = font.systemFontInfo.css;
2537           style.fontSubstitutionLoadedName = font.systemFontInfo.loadedName;
2538         }
2539       }
2540       textContentItem.fontName = loadedName;
2541 
2542       const trm = (textContentItem.transform = getCurrentTextTransform());
2543       if (!font.vertical) {
2544         textContentItem.width = textContentItem.totalWidth = 0;
2545         textContentItem.height = textContentItem.totalHeight = Math.hypot(
2546           trm[2],
2547           trm[3]
2548         );
2549         textContentItem.vertical = false;
2550       } else {
2551         textContentItem.width = textContentItem.totalWidth = Math.hypot(
2552           trm[0],
2553           trm[1]
2554         );
2555         textContentItem.height = textContentItem.totalHeight = 0;
2556         textContentItem.vertical = true;
2557       }
2558 
2559       const scaleLineX = Math.hypot(
2560         textState.textLineMatrix[0],
2561         textState.textLineMatrix[1]
2562       );
2563       const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
2564       textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
2565 
2566       const { fontSize } = textState;
2567       textContentItem.trackingSpaceMin = fontSize * TRACKING_SPACE_FACTOR;
2568       textContentItem.notASpace = fontSize * NOT_A_SPACE_FACTOR;
2569       textContentItem.negativeSpaceMax = fontSize * NEGATIVE_SPACE_FACTOR;
2570       textContentItem.spaceInFlowMin = fontSize * SPACE_IN_FLOW_MIN_FACTOR;
2571       textContentItem.spaceInFlowMax = fontSize * SPACE_IN_FLOW_MAX_FACTOR;
2572       textContentItem.hasEOL = false;
2573 
2574       textContentItem.initialized = true;
2575       return textContentItem;
2576     }
2577 
2578     function updateAdvanceScale() {
2579       if (!textContentItem.initialized) {
2580         return;
2581       }
2582 
2583       const scaleLineX = Math.hypot(
2584         textState.textLineMatrix[0],
2585         textState.textLineMatrix[1]
2586       );
2587       const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
2588       const scaleFactor = scaleCtmX * scaleLineX;
2589       if (scaleFactor === textContentItem.textAdvanceScale) {
2590         return;
2591       }
2592 
2593       if (!textContentItem.vertical) {
2594         textContentItem.totalWidth +=
2595           textContentItem.width * textContentItem.textAdvanceScale;
2596         textContentItem.width = 0;
2597       } else {
2598         textContentItem.totalHeight +=
2599           textContentItem.height * textContentItem.textAdvanceScale;
2600         textContentItem.height = 0;
2601       }
2602 
2603       textContentItem.textAdvanceScale = scaleFactor;
2604     }
2605 
2606     function runBidiTransform(textChunk) {
2607       let text = textChunk.str.join("");
2608       if (!disableNormalization) {
2609         text = normalizeUnicode(text);
2610       }
2611       const bidiResult = bidi(text, -1, textChunk.vertical);
2612       return {
2613         str: bidiResult.str,
2614         dir: bidiResult.dir,
2615         width: Math.abs(textChunk.totalWidth),
2616         height: Math.abs(textChunk.totalHeight),
2617         transform: textChunk.transform,
2618         fontName: textChunk.fontName,
2619         hasEOL: textChunk.hasEOL,
2620       };
2621     }
2622 
2623     async function handleSetFont(fontName, fontRef) {
2624       const translated = await self.loadFont(fontName, fontRef, resources);
2625 
2626       if (translated.font.isType3Font) {
2627         try {
2628           await translated.loadType3Data(self, resources, task);
2629         } catch {
2630           // Ignore Type3-parsing errors, since we only use `loadType3Data`
2631           // here to ensure that we'll always obtain a useful /FontBBox.
2632         }
2633       }
2634 
2635       textState.loadedName = translated.loadedName;
2636       textState.font = translated.font;
2637       textState.fontMatrix = translated.font.fontMatrix || FONT_IDENTITY_MATRIX;
2638     }
2639 
2640     function applyInverseRotation(x, y, matrix) {
2641       const scale = Math.hypot(matrix[0], matrix[1]);
2642       return [
2643         (matrix[0] * x + matrix[1] * y) / scale,
2644         (matrix[2] * x + matrix[3] * y) / scale,
2645       ];
2646     }
2647 
2648     function compareWithLastPosition(glyphWidth) {
2649       const currentTransform = getCurrentTextTransform();
2650       let posX = currentTransform[4];
2651       let posY = currentTransform[5];
2652 
2653       // Check if the glyph is in the viewbox.
2654       if (textState.font?.vertical) {
2655         if (
2656           posX < viewBox[0] ||
2657           posX > viewBox[2] ||
2658           posY + glyphWidth < viewBox[1] ||
2659           posY > viewBox[3]
2660         ) {
2661           return false;
2662         }
2663       } else if (
2664         posX + glyphWidth < viewBox[0] ||
2665         posX > viewBox[2] ||
2666         posY < viewBox[1] ||
2667         posY > viewBox[3]
2668       ) {
2669         return false;
2670       }
2671 
2672       if (!textState.font || !textContentItem.prevTransform) {
2673         return true;
2674       }
2675 
2676       let lastPosX = textContentItem.prevTransform[4];
2677       let lastPosY = textContentItem.prevTransform[5];
2678 
2679       if (lastPosX === posX && lastPosY === posY) {
2680         return true;
2681       }
2682 
2683       let rotate = -1;
2684       // Take into account the rotation is the current transform.
2685       if (
2686         currentTransform[0] &&
2687         currentTransform[1] === 0 &&
2688         currentTransform[2] === 0
2689       ) {
2690         rotate = currentTransform[0] > 0 ? 0 : 180;
2691       } else if (
2692         currentTransform[1] &&
2693         currentTransform[0] === 0 &&
2694         currentTransform[3] === 0
2695       ) {
2696         rotate = currentTransform[1] > 0 ? 90 : 270;
2697       }
2698 
2699       switch (rotate) {
2700         case 0:
2701           break;
2702         case 90:
2703           [posX, posY] = [posY, posX];
2704           [lastPosX, lastPosY] = [lastPosY, lastPosX];
2705           break;
2706         case 180:
2707           [posX, posY, lastPosX, lastPosY] = [
2708             -posX,
2709             -posY,
2710             -lastPosX,
2711             -lastPosY,
2712           ];
2713           break;
2714         case 270:
2715           [posX, posY] = [-posY, -posX];
2716           [lastPosX, lastPosY] = [-lastPosY, -lastPosX];
2717           break;
2718         default:
2719           // This is not a 0, 90, 180, 270 rotation so:
2720           //  - remove the scale factor from the matrix to get a rotation matrix
2721           //  - apply the inverse (which is the transposed) to the positions
2722           // and we can then compare positions of the glyphes to detect
2723           // a whitespace.
2724           [posX, posY] = applyInverseRotation(posX, posY, currentTransform);
2725           [lastPosX, lastPosY] = applyInverseRotation(
2726             lastPosX,
2727             lastPosY,
2728             textContentItem.prevTransform
2729           );
2730       }
2731 
2732       if (textState.font.vertical) {
2733         const advanceY = (lastPosY - posY) / textContentItem.textAdvanceScale;
2734         const advanceX = posX - lastPosX;
2735 
2736         // When the total height of the current chunk is negative
2737         // then we're writing from bottom to top.
2738         const textOrientation = Math.sign(textContentItem.height);
2739         if (advanceY < textOrientation * textContentItem.negativeSpaceMax) {
2740           if (
2741             Math.abs(advanceX) >
2742             0.5 * textContentItem.width /* not the same column */
2743           ) {
2744             appendEOL();
2745             return true;
2746           }
2747 
2748           resetLastChars();
2749           flushTextContentItem();
2750           return true;
2751         }
2752 
2753         if (Math.abs(advanceX) > textContentItem.width) {
2754           appendEOL();
2755           return true;
2756         }
2757 
2758         if (advanceY <= textOrientation * textContentItem.notASpace) {
2759           // The real spacing between 2 consecutive chars is thin enough to be
2760           // considered a non-space.
2761           resetLastChars();
2762         }
2763 
2764         if (advanceY <= textOrientation * textContentItem.trackingSpaceMin) {
2765           if (shouldAddWhitepsace()) {
2766             // The space is very thin, hence it deserves to have its own span in
2767             // order to avoid too much shift between the canvas and the text
2768             // layer.
2769             resetLastChars();
2770             flushTextContentItem();
2771             pushWhitespace({ height: Math.abs(advanceY) });
2772           } else {
2773             textContentItem.height += advanceY;
2774           }
2775         } else if (
2776           !addFakeSpaces(
2777             advanceY,
2778             textContentItem.prevTransform,
2779             textOrientation
2780           )
2781         ) {
2782           if (textContentItem.str.length === 0) {
2783             resetLastChars();
2784             pushWhitespace({ height: Math.abs(advanceY) });
2785           } else {
2786             textContentItem.height += advanceY;
2787           }
2788         }
2789 
2790         if (Math.abs(advanceX) > textContentItem.width * VERTICAL_SHIFT_RATIO) {
2791           flushTextContentItem();
2792         }
2793 
2794         return true;
2795       }
2796 
2797       const advanceX = (posX - lastPosX) / textContentItem.textAdvanceScale;
2798       const advanceY = posY - lastPosY;
2799 
2800       // When the total width of the current chunk is negative
2801       // then we're writing from right to left.
2802       const textOrientation = Math.sign(textContentItem.width);
2803       if (advanceX < textOrientation * textContentItem.negativeSpaceMax) {
2804         if (
2805           Math.abs(advanceY) >
2806           0.5 * textContentItem.height /* not the same line */
2807         ) {
2808           appendEOL();
2809           return true;
2810         }
2811 
2812         // We're moving back so in case the last char was a whitespace
2813         // we cancel it: it doesn't make sense to insert it.
2814         resetLastChars();
2815         flushTextContentItem();
2816         return true;
2817       }
2818 
2819       if (Math.abs(advanceY) > textContentItem.height) {
2820         appendEOL();
2821         return true;
2822       }
2823 
2824       if (advanceX <= textOrientation * textContentItem.notASpace) {
2825         // The real spacing between 2 consecutive chars is thin enough to be
2826         // considered a non-space.
2827         resetLastChars();
2828       }
2829 
2830       if (advanceX <= textOrientation * textContentItem.trackingSpaceMin) {
2831         if (shouldAddWhitepsace()) {
2832           // The space is very thin, hence it deserves to have its own span in
2833           // order to avoid too much shift between the canvas and the text
2834           // layer.
2835           resetLastChars();
2836           flushTextContentItem();
2837           pushWhitespace({ width: Math.abs(advanceX) });
2838         } else {
2839           textContentItem.width += advanceX;
2840         }
2841       } else if (
2842         !addFakeSpaces(advanceX, textContentItem.prevTransform, textOrientation)
2843       ) {
2844         if (textContentItem.str.length === 0) {
2845           resetLastChars();
2846           pushWhitespace({ width: Math.abs(advanceX) });
2847         } else {
2848           textContentItem.width += advanceX;
2849         }
2850       }
2851 
2852       if (Math.abs(advanceY) > textContentItem.height * VERTICAL_SHIFT_RATIO) {
2853         flushTextContentItem();
2854       }
2855 
2856       return true;
2857     }
2858 
2859     function buildTextContentItem({ chars, extraSpacing }) {
2860       const font = textState.font;
2861       if (!chars) {
2862         // Just move according to the space we have.
2863         const charSpacing = textState.charSpacing + extraSpacing;
2864         if (charSpacing) {
2865           if (!font.vertical) {
2866             textState.translateTextMatrix(
2867               charSpacing * textState.textHScale,
2868               0
2869             );
2870           } else {
2871             textState.translateTextMatrix(0, -charSpacing);
2872           }
2873         }
2874 
2875         if (keepWhiteSpace) {
2876           compareWithLastPosition(0);
2877         }
2878 
2879         return;
2880       }
2881 
2882       const glyphs = font.charsToGlyphs(chars);
2883       const scale = textState.fontMatrix[0] * textState.fontSize;
2884 
2885       for (let i = 0, ii = glyphs.length; i < ii; i++) {
2886         const glyph = glyphs[i];
2887         const { category } = glyph;
2888 
2889         if (category.isInvisibleFormatMark) {
2890           continue;
2891         }
2892         let charSpacing =
2893           textState.charSpacing + (i + 1 === ii ? extraSpacing : 0);
2894 
2895         let glyphWidth = glyph.width;
2896         if (font.vertical) {
2897           glyphWidth = glyph.vmetric ? glyph.vmetric[0] : -glyphWidth;
2898         }
2899         let scaledDim = glyphWidth * scale;
2900 
2901         if (!keepWhiteSpace && category.isWhitespace) {
2902           // Don't push a " " in the textContentItem
2903           // (except when it's between two non-spaces chars),
2904           // it will be done (if required) in next call to
2905           // compareWithLastPosition.
2906           // This way we can merge real spaces and spaces due to cursor moves.
2907           if (!font.vertical) {
2908             charSpacing += scaledDim + textState.wordSpacing;
2909             textState.translateTextMatrix(
2910               charSpacing * textState.textHScale,
2911               0
2912             );
2913           } else {
2914             charSpacing += -scaledDim + textState.wordSpacing;
2915             textState.translateTextMatrix(0, -charSpacing);
2916           }
2917           saveLastChar(" ");
2918           continue;
2919         }
2920 
2921         if (
2922           !category.isZeroWidthDiacritic &&
2923           !compareWithLastPosition(scaledDim)
2924         ) {
2925           // The glyph is not in page so just skip it but move the cursor.
2926           if (!font.vertical) {
2927             textState.translateTextMatrix(scaledDim * textState.textHScale, 0);
2928           } else {
2929             textState.translateTextMatrix(0, scaledDim);
2930           }
2931           continue;
2932         }
2933 
2934         // Must be called after compareWithLastPosition because
2935         // the textContentItem could have been flushed.
2936         const textChunk = ensureTextContentItem();
2937         if (category.isZeroWidthDiacritic) {
2938           scaledDim = 0;
2939         }
2940 
2941         if (!font.vertical) {
2942           scaledDim *= textState.textHScale;
2943           textState.translateTextMatrix(scaledDim, 0);
2944           textChunk.width += scaledDim;
2945         } else {
2946           textState.translateTextMatrix(0, scaledDim);
2947           scaledDim = Math.abs(scaledDim);
2948           textChunk.height += scaledDim;
2949         }
2950 
2951         if (scaledDim) {
2952           // Save the position of the last visible character.
2953           textChunk.prevTransform = getCurrentTextTransform();
2954         }
2955 
2956         const glyphUnicode = glyph.unicode;
2957         if (saveLastChar(glyphUnicode)) {
2958           // The two last chars are a non-whitespace followed by a whitespace
2959           // and then this non-whitespace, so we insert a whitespace here.
2960           // Replaces all whitespaces with standard spaces (0x20), to avoid
2961           // alignment issues between the textLayer and the canvas if the text
2962           // contains e.g. tabs (fixes issue6612.pdf).
2963           textChunk.str.push(" ");
2964         }
2965         textChunk.str.push(glyphUnicode);
2966 
2967         if (charSpacing) {
2968           if (!font.vertical) {
2969             textState.translateTextMatrix(
2970               charSpacing * textState.textHScale,
2971               0
2972             );
2973           } else {
2974             textState.translateTextMatrix(0, -charSpacing);
2975           }
2976         }
2977       }
2978     }
2979 
2980     function appendEOL() {
2981       resetLastChars();
2982       if (textContentItem.initialized) {
2983         textContentItem.hasEOL = true;
2984         flushTextContentItem();
2985       } else {
2986         textContent.items.push({
2987           str: "",
2988           dir: "ltr",
2989           width: 0,
2990           height: 0,
2991           transform: getCurrentTextTransform(),
2992           fontName: textState.loadedName,
2993           hasEOL: true,
2994         });
2995       }
2996     }
2997 
2998     function addFakeSpaces(width, transf, textOrientation) {
2999       if (
3000         textOrientation * textContentItem.spaceInFlowMin <= width &&
3001         width <= textOrientation * textContentItem.spaceInFlowMax
3002       ) {
3003         if (textContentItem.initialized) {
3004           resetLastChars();
3005           textContentItem.str.push(" ");
3006         }
3007         return false;
3008       }
3009 
3010       const fontName = textContentItem.fontName;
3011 
3012       let height = 0;
3013       if (textContentItem.vertical) {
3014         height = width;
3015         width = 0;
3016       }
3017 
3018       flushTextContentItem();
3019       resetLastChars();
3020       pushWhitespace({
3021         width: Math.abs(width),
3022         height: Math.abs(height),
3023         transform: transf || getCurrentTextTransform(),
3024         fontName,
3025       });
3026 
3027       return true;
3028     }
3029 
3030     function flushTextContentItem() {
3031       if (!textContentItem.initialized || !textContentItem.str) {
3032         return;
3033       }
3034 
3035       // Do final text scaling.
3036       if (!textContentItem.vertical) {
3037         textContentItem.totalWidth +=
3038           textContentItem.width * textContentItem.textAdvanceScale;
3039       } else {
3040         textContentItem.totalHeight +=
3041           textContentItem.height * textContentItem.textAdvanceScale;
3042       }
3043 
3044       textContent.items.push(runBidiTransform(textContentItem));
3045       textContentItem.initialized = false;
3046       textContentItem.str.length = 0;
3047     }
3048 
3049     function enqueueChunk(batch = false) {
3050       const length = textContent.items.length;
3051       if (length === 0) {
3052         return;
3053       }
3054       if (batch && length < TEXT_CHUNK_BATCH_SIZE) {
3055         return;
3056       }
3057       sink.enqueue(textContent, length);
3058       textContent.items = [];
3059       textContent.styles = Object.create(null);
3060     }
3061 
3062     const timeSlotManager = new TimeSlotManager();
3063 
3064     return new Promise(function promiseBody(resolve, reject) {
3065       const next = function (promise) {
3066         enqueueChunk(/* batch = */ true);
3067         Promise.all([promise, sink.ready]).then(function () {
3068           try {
3069             promiseBody(resolve, reject);
3070           } catch (ex) {
3071             reject(ex);
3072           }
3073         }, reject);
3074       };
3075       task.ensureNotTerminated();
3076       timeSlotManager.reset();
3077 
3078       const operation = {};
3079       let stop,
3080         name,
3081         isValidName,
3082         args = [];
3083       while (!(stop = timeSlotManager.check())) {
3084         // The arguments parsed by read() are not used beyond this loop, so
3085         // we can reuse the same array on every iteration, thus avoiding
3086         // unnecessary allocations.
3087         args.length = 0;
3088         operation.args = args;
3089         if (!preprocessor.read(operation)) {
3090           break;
3091         }
3092 
3093         const previousState = textState;
3094         textState = stateManager.state;
3095         const fn = operation.fn;
3096         args = operation.args;
3097 
3098         switch (fn | 0) {
3099           case OPS.setFont:
3100             // Optimization to ignore multiple identical Tf commands.
3101             const fontNameArg = args[0].name,
3102               fontSizeArg = args[1];
3103             if (
3104               textState.font &&
3105               fontNameArg === textState.fontName &&
3106               fontSizeArg === textState.fontSize
3107             ) {
3108               break;
3109             }
3110 
3111             flushTextContentItem();
3112             textState.fontName = fontNameArg;
3113             textState.fontSize = fontSizeArg;
3114             next(handleSetFont(fontNameArg, null));
3115             return;
3116           case OPS.setTextRise:
3117             textState.textRise = args[0];
3118             break;
3119           case OPS.setHScale:
3120             textState.textHScale = args[0] / 100;
3121             break;
3122           case OPS.setLeading:
3123             textState.leading = args[0];
3124             break;
3125           case OPS.moveText:
3126             textState.translateTextLineMatrix(args[0], args[1]);
3127             textState.textMatrix = textState.textLineMatrix.slice();
3128             break;
3129           case OPS.setLeadingMoveText:
3130             textState.leading = -args[1];
3131             textState.translateTextLineMatrix(args[0], args[1]);
3132             textState.textMatrix = textState.textLineMatrix.slice();
3133             break;
3134           case OPS.nextLine:
3135             textState.carriageReturn();
3136             break;
3137           case OPS.setTextMatrix:
3138             textState.setTextMatrix(
3139               args[0],
3140               args[1],
3141               args[2],
3142               args[3],
3143               args[4],
3144               args[5]
3145             );
3146             textState.setTextLineMatrix(
3147               args[0],
3148               args[1],
3149               args[2],
3150               args[3],
3151               args[4],
3152               args[5]
3153             );
3154             updateAdvanceScale();
3155             break;
3156           case OPS.setCharSpacing:
3157             textState.charSpacing = args[0];
3158             break;
3159           case OPS.setWordSpacing:
3160             textState.wordSpacing = args[0];
3161             break;
3162           case OPS.beginText:
3163             textState.textMatrix = IDENTITY_MATRIX.slice();
3164             textState.textLineMatrix = IDENTITY_MATRIX.slice();
3165             break;
3166           case OPS.showSpacedText:
3167             if (!stateManager.state.font) {
3168               self.ensureStateFont(stateManager.state);
3169               continue;
3170             }
3171 
3172             const spaceFactor =
3173               ((textState.font.vertical ? 1 : -1) * textState.fontSize) / 1000;
3174             const elements = args[0];
3175             for (let i = 0, ii = elements.length; i < ii; i++) {
3176               const item = elements[i];
3177               if (typeof item === "string") {
3178                 showSpacedTextBuffer.push(item);
3179               } else if (typeof item === "number" && item !== 0) {
3180                 // PDF Specification 5.3.2 states:
3181                 // The number is expressed in thousandths of a unit of text
3182                 // space.
3183                 // This amount is subtracted from the current horizontal or
3184                 // vertical coordinate, depending on the writing mode.
3185                 // In the default coordinate system, a positive adjustment
3186                 // has the effect of moving the next glyph painted either to
3187                 // the left or down by the given amount.
3188                 const str = showSpacedTextBuffer.join("");
3189                 showSpacedTextBuffer.length = 0;
3190                 buildTextContentItem({
3191                   chars: str,
3192                   extraSpacing: item * spaceFactor,
3193                 });
3194               }
3195             }
3196 
3197             if (showSpacedTextBuffer.length > 0) {
3198               const str = showSpacedTextBuffer.join("");
3199               showSpacedTextBuffer.length = 0;
3200               buildTextContentItem({
3201                 chars: str,
3202                 extraSpacing: 0,
3203               });
3204             }
3205             break;
3206           case OPS.showText:
3207             if (!stateManager.state.font) {
3208               self.ensureStateFont(stateManager.state);
3209               continue;
3210             }
3211             buildTextContentItem({
3212               chars: args[0],
3213               extraSpacing: 0,
3214             });
3215             break;
3216           case OPS.nextLineShowText:
3217             if (!stateManager.state.font) {
3218               self.ensureStateFont(stateManager.state);
3219               continue;
3220             }
3221             textState.carriageReturn();
3222             buildTextContentItem({
3223               chars: args[0],
3224               extraSpacing: 0,
3225             });
3226             break;
3227           case OPS.nextLineSetSpacingShowText:
3228             if (!stateManager.state.font) {
3229               self.ensureStateFont(stateManager.state);
3230               continue;
3231             }
3232             textState.wordSpacing = args[0];
3233             textState.charSpacing = args[1];
3234             textState.carriageReturn();
3235             buildTextContentItem({
3236               chars: args[2],
3237               extraSpacing: 0,
3238             });
3239             break;
3240           case OPS.paintXObject:
3241             flushTextContentItem();
3242             xobjs ??= resources.get("XObject") || Dict.empty;
3243 
3244             isValidName = args[0] instanceof Name;
3245             name = args[0].name;
3246 
3247             if (isValidName && emptyXObjectCache.getByName(name)) {
3248               break;
3249             }
3250 
3251             next(
3252               new Promise(function (resolveXObject, rejectXObject) {
3253                 if (!isValidName) {
3254                   throw new FormatError("XObject must be referred to by name.");
3255                 }
3256 
3257                 let xobj = xobjs.getRaw(name);
3258                 if (xobj instanceof Ref) {
3259                   if (emptyXObjectCache.getByRef(xobj)) {
3260                     resolveXObject();
3261                     return;
3262                   }
3263 
3264                   const globalImage = self.globalImageCache.getData(
3265                     xobj,
3266                     self.pageIndex
3267                   );
3268                   if (globalImage) {
3269                     resolveXObject();
3270                     return;
3271                   }
3272 
3273                   xobj = xref.fetch(xobj);
3274                 }
3275 
3276                 if (!(xobj instanceof BaseStream)) {
3277                   throw new FormatError("XObject should be a stream");
3278                 }
3279 
3280                 const type = xobj.dict.get("Subtype");
3281                 if (!(type instanceof Name)) {
3282                   throw new FormatError("XObject should have a Name subtype");
3283                 }
3284 
3285                 if (type.name !== "Form") {
3286                   emptyXObjectCache.set(name, xobj.dict.objId, true);
3287 
3288                   resolveXObject();
3289                   return;
3290                 }
3291 
3292                 // Use a new `StateManager` to prevent incorrect positioning
3293                 // of textItems *after* the Form XObject, since errors in the
3294                 // data can otherwise prevent `restore` operators from
3295                 // executing.
3296                 // NOTE: Only an issue when `options.ignoreErrors === true`.
3297                 const currentState = stateManager.state.clone();
3298                 const xObjStateManager = new StateManager(currentState);
3299 
3300                 const matrix = lookupMatrix(xobj.dict.getArray("Matrix"), null);
3301                 if (matrix) {
3302                   xObjStateManager.transform(matrix);
3303                 }
3304 
3305                 // Enqueue the `textContent` chunk before parsing the /Form
3306                 // XObject.
3307                 enqueueChunk();
3308                 const sinkWrapper = {
3309                   enqueueInvoked: false,
3310 
3311                   enqueue(chunk, size) {
3312                     this.enqueueInvoked = true;
3313                     sink.enqueue(chunk, size);
3314                   },
3315 
3316                   get desiredSize() {
3317                     return sink.desiredSize;
3318                   },
3319 
3320                   get ready() {
3321                     return sink.ready;
3322                   },
3323                 };
3324 
3325                 self
3326                   .getTextContent({
3327                     stream: xobj,
3328                     task,
3329                     resources: xobj.dict.get("Resources") || resources,
3330                     stateManager: xObjStateManager,
3331                     includeMarkedContent,
3332                     sink: sinkWrapper,
3333                     seenStyles,
3334                     viewBox,
3335                     lang,
3336                     markedContentData,
3337                     disableNormalization,
3338                     keepWhiteSpace,
3339                   })
3340                   .then(function () {
3341                     if (!sinkWrapper.enqueueInvoked) {
3342                       emptyXObjectCache.set(name, xobj.dict.objId, true);
3343                     }
3344                     resolveXObject();
3345                   }, rejectXObject);
3346               }).catch(function (reason) {
3347                 if (reason instanceof AbortException) {
3348                   return;
3349                 }
3350                 if (self.options.ignoreErrors) {
3351                   // Error(s) in the XObject -- allow text-extraction to
3352                   // continue.
3353                   warn(`getTextContent - ignoring XObject: "${reason}".`);
3354                   return;
3355                 }
3356                 throw reason;
3357               })
3358             );
3359             return;
3360           case OPS.setGState:
3361             isValidName = args[0] instanceof Name;
3362             name = args[0].name;
3363 
3364             if (isValidName && emptyGStateCache.getByName(name)) {
3365               break;
3366             }
3367 
3368             next(
3369               new Promise(function (resolveGState, rejectGState) {
3370                 if (!isValidName) {
3371                   throw new FormatError("GState must be referred to by name.");
3372                 }
3373 
3374                 const extGState = resources.get("ExtGState");
3375                 if (!(extGState instanceof Dict)) {
3376                   throw new FormatError("ExtGState should be a dictionary.");
3377                 }
3378 
3379                 const gState = extGState.get(name);
3380                 // TODO: Attempt to lookup cached GStates by reference as well,
3381                 //       if and only if there are PDF documents where doing so
3382                 //       would significantly improve performance.
3383                 if (!(gState instanceof Dict)) {
3384                   throw new FormatError("GState should be a dictionary.");
3385                 }
3386 
3387                 const gStateFont = gState.get("Font");
3388                 if (!gStateFont) {
3389                   emptyGStateCache.set(name, gState.objId, true);
3390 
3391                   resolveGState();
3392                   return;
3393                 }
3394                 flushTextContentItem();
3395 
3396                 textState.fontName = null;
3397                 textState.fontSize = gStateFont[1];
3398                 handleSetFont(null, gStateFont[0]).then(
3399                   resolveGState,
3400                   rejectGState
3401                 );
3402               }).catch(function (reason) {
3403                 if (reason instanceof AbortException) {
3404                   return;
3405                 }
3406                 if (self.options.ignoreErrors) {
3407                   // Error(s) in the ExtGState -- allow text-extraction to
3408                   // continue.
3409                   warn(`getTextContent - ignoring ExtGState: "${reason}".`);
3410                   return;
3411                 }
3412                 throw reason;
3413               })
3414             );
3415             return;
3416           case OPS.beginMarkedContent:
3417             flushTextContentItem();
3418             if (includeMarkedContent) {
3419               markedContentData.level++;
3420 
3421               textContent.items.push({
3422                 type: "beginMarkedContent",
3423                 tag: args[0] instanceof Name ? args[0].name : null,
3424               });
3425             }
3426             break;
3427           case OPS.beginMarkedContentProps:
3428             flushTextContentItem();
3429             if (includeMarkedContent) {
3430               markedContentData.level++;
3431 
3432               let mcid = null;
3433               if (args[1] instanceof Dict) {
3434                 mcid = args[1].get("MCID");
3435               }
3436               textContent.items.push({
3437                 type: "beginMarkedContentProps",
3438                 id: Number.isInteger(mcid)
3439                   ? `${self.idFactory.getPageObjId()}_mc${mcid}`
3440                   : null,
3441                 tag: args[0] instanceof Name ? args[0].name : null,
3442               });
3443             }
3444             break;
3445           case OPS.endMarkedContent:
3446             flushTextContentItem();
3447             if (includeMarkedContent) {
3448               if (markedContentData.level === 0) {
3449                 // Handle unbalanced beginMarkedContent/endMarkedContent
3450                 // operators (fixes issue15629.pdf).
3451                 break;
3452               }
3453               markedContentData.level--;
3454 
3455               textContent.items.push({
3456                 type: "endMarkedContent",
3457               });
3458             }
3459             break;
3460           case OPS.restore:
3461             if (
3462               previousState &&
3463               (previousState.font !== textState.font ||
3464                 previousState.fontSize !== textState.fontSize ||
3465                 previousState.fontName !== textState.fontName)
3466             ) {
3467               flushTextContentItem();
3468             }
3469             break;
3470         } // switch
3471         if (textContent.items.length >= sink.desiredSize) {
3472           // Wait for ready, if we reach highWaterMark.
3473           stop = true;
3474           break;
3475         }
3476       } // while
3477       if (stop) {
3478         next(deferred);
3479         return;
3480       }
3481       flushTextContentItem();
3482       enqueueChunk();
3483       resolve();
3484     }).catch(reason => {
3485       if (reason instanceof AbortException) {
3486         return;
3487       }
3488       if (this.options.ignoreErrors) {
3489         // Error(s) in the TextContent -- allow text-extraction to continue.
3490         warn(
3491           `getTextContent - ignoring errors during "${task.name}" ` +
3492             `task: "${reason}".`
3493         );
3494 
3495         flushTextContentItem();
3496         enqueueChunk();
3497         return;
3498       }
3499       throw reason;
3500     });
3501   }
3502 
3503   async extractDataStructures(dict, properties) {
3504     const xref = this.xref;
3505     let cidToGidBytes;
3506     // 9.10.2
3507     const toUnicodePromise = this.readToUnicode(properties.toUnicode);
3508 
3509     if (properties.composite) {
3510       // CIDSystemInfo helps to match CID to glyphs
3511       const cidSystemInfo = dict.get("CIDSystemInfo");
3512       if (cidSystemInfo instanceof Dict) {
3513         properties.cidSystemInfo = {
3514           registry: stringToPDFString(cidSystemInfo.get("Registry")),
3515           ordering: stringToPDFString(cidSystemInfo.get("Ordering")),
3516           supplement: cidSystemInfo.get("Supplement"),
3517         };
3518       }
3519 
3520       try {
3521         const cidToGidMap = dict.get("CIDToGIDMap");
3522         if (cidToGidMap instanceof BaseStream) {
3523           cidToGidBytes = cidToGidMap.getBytes();
3524         }
3525       } catch (ex) {
3526         if (!this.options.ignoreErrors) {
3527           throw ex;
3528         }
3529         warn(`extractDataStructures - ignoring CIDToGIDMap data: "${ex}".`);
3530       }
3531     }
3532 
3533     // Based on 9.6.6 of the spec the encoding can come from multiple places
3534     // and depends on the font type. The base encoding and differences are
3535     // read here, but the encoding that is actually used is chosen during
3536     // glyph mapping in the font.
3537     // TODO: Loading the built in encoding in the font would allow the
3538     // differences to be merged in here not require us to hold on to it.
3539     const differences = [];
3540     let baseEncodingName = null;
3541     let encoding;
3542     if (dict.has("Encoding")) {
3543       encoding = dict.get("Encoding");
3544       if (encoding instanceof Dict) {
3545         baseEncodingName = encoding.get("BaseEncoding");
3546         baseEncodingName =
3547           baseEncodingName instanceof Name ? baseEncodingName.name : null;
3548         // Load the differences between the base and original
3549         if (encoding.has("Differences")) {
3550           const diffEncoding = encoding.get("Differences");
3551           let index = 0;
3552           for (const entry of diffEncoding) {
3553             const data = xref.fetchIfRef(entry);
3554             if (typeof data === "number") {
3555               index = data;
3556             } else if (data instanceof Name) {
3557               differences[index++] = data.name;
3558             } else {
3559               throw new FormatError(
3560                 `Invalid entry in 'Differences' array: ${data}`
3561               );
3562             }
3563           }
3564         }
3565       } else if (encoding instanceof Name) {
3566         baseEncodingName = encoding.name;
3567       } else {
3568         const msg = "Encoding is not a Name nor a Dict";
3569 
3570         if (!this.options.ignoreErrors) {
3571           throw new FormatError(msg);
3572         }
3573         warn(msg);
3574       }
3575       // According to table 114 if the encoding is a named encoding it must be
3576       // one of these predefined encodings.
3577       if (
3578         baseEncodingName !== "MacRomanEncoding" &&
3579         baseEncodingName !== "MacExpertEncoding" &&
3580         baseEncodingName !== "WinAnsiEncoding"
3581       ) {
3582         baseEncodingName = null;
3583       }
3584     }
3585 
3586     const nonEmbeddedFont = !properties.file || properties.isInternalFont,
3587       isSymbolsFontName = getSymbolsFonts()[properties.name];
3588     // Ignore an incorrectly specified named encoding for non-embedded
3589     // symbol fonts (fixes issue16464.pdf).
3590     if (baseEncodingName && nonEmbeddedFont && isSymbolsFontName) {
3591       baseEncodingName = null;
3592     }
3593 
3594     if (baseEncodingName) {
3595       properties.defaultEncoding = getEncoding(baseEncodingName);
3596     } else {
3597       const isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
3598       const isNonsymbolicFont = !!(properties.flags & FontFlags.Nonsymbolic);
3599       // According to "Table 114" in section "9.6.6.1 General" (under
3600       // "9.6.6 Character Encoding") of the PDF specification, a Nonsymbolic
3601       // font should use the `StandardEncoding` if no encoding is specified.
3602       encoding = StandardEncoding;
3603       if (properties.type === "TrueType" && !isNonsymbolicFont) {
3604         encoding = WinAnsiEncoding;
3605       }
3606       // The Symbolic attribute can be misused for regular fonts
3607       // Heuristic: we have to check if the font is a standard one also
3608       if (isSymbolicFont || isSymbolsFontName) {
3609         encoding = MacRomanEncoding;
3610         if (nonEmbeddedFont) {
3611           if (/Symbol/i.test(properties.name)) {
3612             encoding = SymbolSetEncoding;
3613           } else if (/Dingbats/i.test(properties.name)) {
3614             encoding = ZapfDingbatsEncoding;
3615           } else if (/Wingdings/i.test(properties.name)) {
3616             encoding = WinAnsiEncoding;
3617           }
3618         }
3619       }
3620       properties.defaultEncoding = encoding;
3621     }
3622 
3623     properties.differences = differences;
3624     properties.baseEncodingName = baseEncodingName;
3625     properties.hasEncoding = !!baseEncodingName || differences.length > 0;
3626     properties.dict = dict;
3627 
3628     properties.toUnicode = await toUnicodePromise;
3629 
3630     const builtToUnicode = await this.buildToUnicode(properties);
3631     properties.toUnicode = builtToUnicode;
3632 
3633     if (cidToGidBytes) {
3634       properties.cidToGidMap = this.readCidToGidMap(
3635         cidToGidBytes,
3636         builtToUnicode
3637       );
3638     }
3639     return properties;
3640   }
3641 
3642   /**
3643    * @returns {Array}
3644    * @private
3645    */
3646   _simpleFontToUnicode(properties, forceGlyphs = false) {
3647     assert(!properties.composite, "Must be a simple font.");
3648 
3649     const toUnicode = [];
3650     const encoding = properties.defaultEncoding.slice();
3651     const baseEncodingName = properties.baseEncodingName;
3652     // Merge in the differences array.
3653     const differences = properties.differences;
3654     for (const charcode in differences) {
3655       const glyphName = differences[charcode];
3656       if (glyphName === ".notdef") {
3657         // Skip .notdef to prevent rendering errors, e.g. boxes appearing
3658         // where there should be spaces (fixes issue5256.pdf).
3659         continue;
3660       }
3661       encoding[charcode] = glyphName;
3662     }
3663     const glyphsUnicodeMap = getGlyphsUnicode();
3664     for (const charcode in encoding) {
3665       // a) Map the character code to a character name.
3666       let glyphName = encoding[charcode];
3667       if (glyphName === "") {
3668         continue;
3669       }
3670       // b) Look up the character name in the Adobe Glyph List (see the
3671       //    Bibliography) to obtain the corresponding Unicode value.
3672       let unicode = glyphsUnicodeMap[glyphName];
3673       if (unicode !== undefined) {
3674         toUnicode[charcode] = String.fromCharCode(unicode);
3675         continue;
3676       }
3677       // (undocumented) c) Few heuristics to recognize unknown glyphs
3678       // NOTE: Adobe Reader does not do this step, but OSX Preview does
3679       let code = 0;
3680       switch (glyphName[0]) {
3681         case "G": // Gxx glyph
3682           if (glyphName.length === 3) {
3683             code = parseInt(glyphName.substring(1), 16);
3684           }
3685           break;
3686         case "g": // g00xx glyph
3687           if (glyphName.length === 5) {
3688             code = parseInt(glyphName.substring(1), 16);
3689           }
3690           break;
3691         case "C": // Cdd{d} glyph
3692         case "c": // cdd{d} glyph
3693           if (glyphName.length >= 3 && glyphName.length <= 4) {
3694             const codeStr = glyphName.substring(1);
3695 
3696             if (forceGlyphs) {
3697               code = parseInt(codeStr, 16);
3698               break;
3699             }
3700             // Normally the Cdd{d}/cdd{d} glyphName format will contain
3701             // regular, i.e. base 10, charCodes (see issue4550.pdf)...
3702             code = +codeStr;
3703 
3704             // ... however some PDF generators violate that assumption by
3705             // containing glyph, i.e. base 16, codes instead.
3706             // In that case we need to re-parse the *entire* encoding to
3707             // prevent broken text-selection (fixes issue9655_reduced.pdf).
3708             if (Number.isNaN(code) && Number.isInteger(parseInt(codeStr, 16))) {
3709               return this._simpleFontToUnicode(
3710                 properties,
3711                 /* forceGlyphs */ true
3712               );
3713             }
3714           }
3715           break;
3716         case "u": // 'uniXXXX'/'uXXXX{XX}' glyphs
3717           unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
3718           if (unicode !== -1) {
3719             code = unicode;
3720           }
3721           break;
3722         default:
3723           // Support (some) non-standard ligatures.
3724           switch (glyphName) {
3725             case "f_h":
3726             case "f_t":
3727             case "T_h":
3728               toUnicode[charcode] = glyphName.replaceAll("_", "");
3729               continue;
3730           }
3731           break;
3732       }
3733       if (code > 0 && code <= 0x10ffff && Number.isInteger(code)) {
3734         // If `baseEncodingName` is one the predefined encodings, and `code`
3735         // equals `charcode`, using the glyph defined in the baseEncoding
3736         // seems to yield a better `toUnicode` mapping (fixes issue 5070).
3737         if (baseEncodingName && code === +charcode) {
3738           const baseEncoding = getEncoding(baseEncodingName);
3739           if (baseEncoding && (glyphName = baseEncoding[charcode])) {
3740             toUnicode[charcode] = String.fromCharCode(
3741               glyphsUnicodeMap[glyphName]
3742             );
3743             continue;
3744           }
3745         }
3746         toUnicode[charcode] = String.fromCodePoint(code);
3747       }
3748     }
3749     return toUnicode;
3750   }
3751 
3752   /**
3753    * Builds a char code to unicode map based on section 9.10 of the spec.
3754    * @param {Object} properties Font properties object.
3755    * @returns {Promise} A Promise that is resolved with a
3756    *   {ToUnicodeMap|IdentityToUnicodeMap} object.
3757    */
3758   async buildToUnicode(properties) {
3759     properties.hasIncludedToUnicodeMap = properties.toUnicode?.length > 0;
3760 
3761     // Section 9.10.2 Mapping Character Codes to Unicode Values
3762     if (properties.hasIncludedToUnicodeMap) {
3763       // Some fonts contain incomplete ToUnicode data, causing issues with
3764       // text-extraction. For simple fonts, containing encoding information,
3765       // use a fallback ToUnicode map to improve this (fixes issue8229.pdf).
3766       if (!properties.composite && properties.hasEncoding) {
3767         properties.fallbackToUnicode = this._simpleFontToUnicode(properties);
3768       }
3769       return properties.toUnicode;
3770     }
3771 
3772     // According to the spec if the font is a simple font we should only map
3773     // to unicode if the base encoding is MacRoman, MacExpert, or WinAnsi or
3774     // the differences array only contains adobe standard or symbol set names,
3775     // in pratice it seems better to always try to create a toUnicode map
3776     // based of the default encoding.
3777     if (!properties.composite /* is simple font */) {
3778       return new ToUnicodeMap(this._simpleFontToUnicode(properties));
3779     }
3780 
3781     // If the font is a composite font that uses one of the predefined CMaps
3782     // listed in Table 118 (except Identity–H and Identity–V) or whose
3783     // descendant CIDFont uses the Adobe-GB1, Adobe-CNS1, Adobe-Japan1, or
3784     // Adobe-Korea1 character collection:
3785     if (
3786       properties.composite &&
3787       ((properties.cMap.builtInCMap &&
3788         !(properties.cMap instanceof IdentityCMap)) ||
3789         // The font is supposed to have a CIDSystemInfo dictionary, but some
3790         // PDFs don't include it (fixes issue 17689), hence the `?'.
3791         (properties.cidSystemInfo?.registry === "Adobe" &&
3792           (properties.cidSystemInfo.ordering === "GB1" ||
3793             properties.cidSystemInfo.ordering === "CNS1" ||
3794             properties.cidSystemInfo.ordering === "Japan1" ||
3795             properties.cidSystemInfo.ordering === "Korea1")))
3796     ) {
3797       // Then:
3798       // a) Map the character code to a character identifier (CID) according
3799       // to the font’s CMap.
3800       // b) Obtain the registry and ordering of the character collection used
3801       // by the font’s CMap (for example, Adobe and Japan1) from its
3802       // CIDSystemInfo dictionary.
3803       const { registry, ordering } = properties.cidSystemInfo;
3804       // c) Construct a second CMap name by concatenating the registry and
3805       // ordering obtained in step (b) in the format registry–ordering–UCS2
3806       // (for example, Adobe–Japan1–UCS2).
3807       const ucs2CMapName = Name.get(`${registry}-${ordering}-UCS2`);
3808       // d) Obtain the CMap with the name constructed in step (c) (available
3809       // from the ASN Web site; see the Bibliography).
3810       const ucs2CMap = await CMapFactory.create({
3811         encoding: ucs2CMapName,
3812         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3813         useCMap: null,
3814       });
3815       const toUnicode = [],
3816         buf = [];
3817       properties.cMap.forEach(function (charcode, cid) {
3818         if (cid > 0xffff) {
3819           throw new FormatError("Max size of CID is 65,535");
3820         }
3821         // e) Map the CID obtained in step (a) according to the CMap
3822         // obtained in step (d), producing a Unicode value.
3823         const ucs2 = ucs2CMap.lookup(cid);
3824         if (ucs2) {
3825           buf.length = 0;
3826           // Support multi-byte entries (fixes issue16176.pdf).
3827           for (let i = 0, ii = ucs2.length; i < ii; i += 2) {
3828             buf.push((ucs2.charCodeAt(i) << 8) + ucs2.charCodeAt(i + 1));
3829           }
3830           toUnicode[charcode] = String.fromCharCode(...buf);
3831         }
3832       });
3833       return new ToUnicodeMap(toUnicode);
3834     }
3835 
3836     // The viewer's choice, just use an identity map.
3837     return new IdentityToUnicodeMap(properties.firstChar, properties.lastChar);
3838   }
3839 
3840   async readToUnicode(cmapObj) {
3841     if (!cmapObj) {
3842       return null;
3843     }
3844     if (cmapObj instanceof Name) {
3845       const cmap = await CMapFactory.create({
3846         encoding: cmapObj,
3847         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3848         useCMap: null,
3849       });
3850 
3851       if (cmap instanceof IdentityCMap) {
3852         return new IdentityToUnicodeMap(0, 0xffff);
3853       }
3854       return new ToUnicodeMap(cmap.getMap());
3855     }
3856     if (cmapObj instanceof BaseStream) {
3857       try {
3858         const cmap = await CMapFactory.create({
3859           encoding: cmapObj,
3860           fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3861           useCMap: null,
3862         });
3863 
3864         if (cmap instanceof IdentityCMap) {
3865           return new IdentityToUnicodeMap(0, 0xffff);
3866         }
3867         const map = new Array(cmap.length);
3868         // Convert UTF-16BE
3869         // NOTE: cmap can be a sparse array, so use forEach instead of
3870         // `for(;;)` to iterate over all keys.
3871         cmap.forEach(function (charCode, token) {
3872           // Some cmaps contain *only* CID characters (fixes issue9367.pdf).
3873           if (typeof token === "number") {
3874             map[charCode] = String.fromCodePoint(token);
3875             return;
3876           }
3877           // Add back omitted leading zeros on odd length tokens
3878           // (fixes issue #18099)
3879           if (token.length % 2 !== 0) {
3880             token = "\u0000" + token;
3881           }
3882           const str = [];
3883           for (let k = 0; k < token.length; k += 2) {
3884             const w1 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
3885             if ((w1 & 0xf800) !== 0xd800) {
3886               // w1 < 0xD800 || w1 > 0xDFFF
3887               str.push(w1);
3888               continue;
3889             }
3890             k += 2;
3891             const w2 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
3892             str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);
3893           }
3894           map[charCode] = String.fromCodePoint(...str);
3895         });
3896         return new ToUnicodeMap(map);
3897       } catch (reason) {
3898         if (reason instanceof AbortException) {
3899           return null;
3900         }
3901         if (this.options.ignoreErrors) {
3902           warn(`readToUnicode - ignoring ToUnicode data: "${reason}".`);
3903           return null;
3904         }
3905         throw reason;
3906       }
3907     }
3908     return null;
3909   }
3910 
3911   readCidToGidMap(glyphsData, toUnicode) {
3912     // Extract the encoding from the CIDToGIDMap
3913 
3914     // Set encoding 0 to later verify the font has an encoding
3915     const result = [];
3916     for (let j = 0, jj = glyphsData.length; j < jj; j++) {
3917       const glyphID = (glyphsData[j++] << 8) | glyphsData[j];
3918       const code = j >> 1;
3919       if (glyphID === 0 && !toUnicode.has(code)) {
3920         continue;
3921       }
3922       result[code] = glyphID;
3923     }
3924     return result;
3925   }
3926 
3927   extractWidths(dict, descriptor, properties) {
3928     const xref = this.xref;
3929     let glyphsWidths = [];
3930     let defaultWidth = 0;
3931     const glyphsVMetrics = [];
3932     let defaultVMetrics;
3933     if (properties.composite) {
3934       const dw = dict.get("DW");
3935       defaultWidth = typeof dw === "number" ? Math.ceil(dw) : 1000;
3936 
3937       const widths = dict.get("W");
3938       if (Array.isArray(widths)) {
3939         for (let i = 0, ii = widths.length; i < ii; i++) {
3940           let start = xref.fetchIfRef(widths[i++]);
3941           if (!Number.isInteger(start)) {
3942             break; // Invalid /W data.
3943           }
3944           const code = xref.fetchIfRef(widths[i]);
3945 
3946           if (Array.isArray(code)) {
3947             for (const c of code) {
3948               const width = xref.fetchIfRef(c);
3949               if (typeof width === "number") {
3950                 glyphsWidths[start] = width;
3951               }
3952               start++;
3953             }
3954           } else if (Number.isInteger(code)) {
3955             const width = xref.fetchIfRef(widths[++i]);
3956             if (typeof width !== "number") {
3957               continue;
3958             }
3959             for (let j = start; j <= code; j++) {
3960               glyphsWidths[j] = width;
3961             }
3962           } else {
3963             break; // Invalid /W data.
3964           }
3965         }
3966       }
3967 
3968       if (properties.vertical) {
3969         const dw2 = dict.getArray("DW2");
3970         let vmetrics = isNumberArray(dw2, 2) ? dw2 : [880, -1000];
3971         defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
3972         vmetrics = dict.get("W2");
3973         if (Array.isArray(vmetrics)) {
3974           for (let i = 0, ii = vmetrics.length; i < ii; i++) {
3975             let start = xref.fetchIfRef(vmetrics[i++]);
3976             if (!Number.isInteger(start)) {
3977               break; // Invalid /W2 data.
3978             }
3979             const code = xref.fetchIfRef(vmetrics[i]);
3980 
3981             if (Array.isArray(code)) {
3982               for (let j = 0, jj = code.length; j < jj; j++) {
3983                 const vmetric = [
3984                   xref.fetchIfRef(code[j++]),
3985                   xref.fetchIfRef(code[j++]),
3986                   xref.fetchIfRef(code[j]),
3987                 ];
3988                 if (isNumberArray(vmetric, null)) {
3989                   glyphsVMetrics[start] = vmetric;
3990                 }
3991                 start++;
3992               }
3993             } else if (Number.isInteger(code)) {
3994               const vmetric = [
3995                 xref.fetchIfRef(vmetrics[++i]),
3996                 xref.fetchIfRef(vmetrics[++i]),
3997                 xref.fetchIfRef(vmetrics[++i]),
3998               ];
3999               if (!isNumberArray(vmetric, null)) {
4000                 continue;
4001               }
4002               for (let j = start; j <= code; j++) {
4003                 glyphsVMetrics[j] = vmetric;
4004               }
4005             } else {
4006               break; // Invalid /W2 data.
4007             }
4008           }
4009         }
4010       }
4011     } else {
4012       const widths = dict.get("Widths");
4013       if (Array.isArray(widths)) {
4014         let j = properties.firstChar;
4015         for (const w of widths) {
4016           const width = xref.fetchIfRef(w);
4017           if (typeof width === "number") {
4018             glyphsWidths[j] = width;
4019           }
4020           j++;
4021         }
4022         const missingWidth = descriptor.get("MissingWidth");
4023         defaultWidth = typeof missingWidth === "number" ? missingWidth : 0;
4024       } else {
4025         // Trying get the BaseFont metrics (see comment above).
4026         const baseFontName = dict.get("BaseFont");
4027         if (baseFontName instanceof Name) {
4028           const metrics = this.getBaseFontMetrics(baseFontName.name);
4029 
4030           glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
4031           defaultWidth = metrics.defaultWidth;
4032         }
4033       }
4034     }
4035 
4036     // Heuristic: detection of monospace font by checking all non-zero widths
4037     let isMonospace = true;
4038     let firstWidth = defaultWidth;
4039     for (const glyph in glyphsWidths) {
4040       const glyphWidth = glyphsWidths[glyph];
4041       if (!glyphWidth) {
4042         continue;
4043       }
4044       if (!firstWidth) {
4045         firstWidth = glyphWidth;
4046         continue;
4047       }
4048       if (firstWidth !== glyphWidth) {
4049         isMonospace = false;
4050         break;
4051       }
4052     }
4053     if (isMonospace) {
4054       properties.flags |= FontFlags.FixedPitch;
4055     } else {
4056       // Clear the flag.
4057       properties.flags &= ~FontFlags.FixedPitch;
4058     }
4059 
4060     properties.defaultWidth = defaultWidth;
4061     properties.widths = glyphsWidths;
4062     properties.defaultVMetrics = defaultVMetrics;
4063     properties.vmetrics = glyphsVMetrics;
4064   }
4065 
4066   isSerifFont(baseFontName) {
4067     // Simulating descriptor flags attribute
4068     const fontNameWoStyle = baseFontName.split("-", 1)[0];
4069     return (
4070       fontNameWoStyle in getSerifFonts() || /serif/gi.test(fontNameWoStyle)
4071     );
4072   }
4073 
4074   getBaseFontMetrics(name) {
4075     let defaultWidth = 0;
4076     let widths = Object.create(null);
4077     let monospace = false;
4078     const stdFontMap = getStdFontMap();
4079     let lookupName = stdFontMap[name] || name;
4080     const Metrics = getMetrics();
4081 
4082     if (!(lookupName in Metrics)) {
4083       // Use default fonts for looking up font metrics if the passed
4084       // font is not a base font
4085       lookupName = this.isSerifFont(name) ? "Times-Roman" : "Helvetica";
4086     }
4087     const glyphWidths = Metrics[lookupName];
4088 
4089     if (typeof glyphWidths === "number") {
4090       defaultWidth = glyphWidths;
4091       monospace = true;
4092     } else {
4093       widths = glyphWidths(); // expand lazy widths array
4094     }
4095 
4096     return {
4097       defaultWidth,
4098       monospace,
4099       widths,
4100     };
4101   }
4102 
4103   buildCharCodeToWidth(widthsByGlyphName, properties) {
4104     const widths = Object.create(null);
4105     const differences = properties.differences;
4106     const encoding = properties.defaultEncoding;
4107     for (let charCode = 0; charCode < 256; charCode++) {
4108       if (charCode in differences && widthsByGlyphName[differences[charCode]]) {
4109         widths[charCode] = widthsByGlyphName[differences[charCode]];
4110         continue;
4111       }
4112       if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
4113         widths[charCode] = widthsByGlyphName[encoding[charCode]];
4114         continue;
4115       }
4116     }
4117     return widths;
4118   }
4119 
4120   preEvaluateFont(dict) {
4121     const baseDict = dict;
4122     let type = dict.get("Subtype");
4123     if (!(type instanceof Name)) {
4124       throw new FormatError("invalid font Subtype");
4125     }
4126 
4127     let composite = false;
4128     let hash;
4129     if (type.name === "Type0") {
4130       // If font is a composite
4131       //  - get the descendant font
4132       //  - set the type according to the descendant font
4133       //  - get the FontDescriptor from the descendant font
4134       const df = dict.get("DescendantFonts");
4135       if (!df) {
4136         throw new FormatError("Descendant fonts are not specified");
4137       }
4138       dict = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df;
4139 
4140       if (!(dict instanceof Dict)) {
4141         throw new FormatError("Descendant font is not a dictionary.");
4142       }
4143       type = dict.get("Subtype");
4144       if (!(type instanceof Name)) {
4145         throw new FormatError("invalid font Subtype");
4146       }
4147       composite = true;
4148     }
4149 
4150     let firstChar = dict.get("FirstChar");
4151     if (!Number.isInteger(firstChar)) {
4152       firstChar = 0;
4153     }
4154     let lastChar = dict.get("LastChar");
4155     if (!Number.isInteger(lastChar)) {
4156       lastChar = composite ? 0xffff : 0xff;
4157     }
4158     const descriptor = dict.get("FontDescriptor");
4159     const toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");
4160 
4161     if (descriptor) {
4162       hash = new MurmurHash3_64();
4163 
4164       const encoding = baseDict.getRaw("Encoding");
4165       if (encoding instanceof Name) {
4166         hash.update(encoding.name);
4167       } else if (encoding instanceof Ref) {
4168         hash.update(encoding.toString());
4169       } else if (encoding instanceof Dict) {
4170         for (const entry of encoding.getRawValues()) {
4171           if (entry instanceof Name) {
4172             hash.update(entry.name);
4173           } else if (entry instanceof Ref) {
4174             hash.update(entry.toString());
4175           } else if (Array.isArray(entry)) {
4176             // 'Differences' array (fixes bug1157493.pdf).
4177             const diffLength = entry.length,
4178               diffBuf = new Array(diffLength);
4179 
4180             for (let j = 0; j < diffLength; j++) {
4181               const diffEntry = entry[j];
4182               if (diffEntry instanceof Name) {
4183                 diffBuf[j] = diffEntry.name;
4184               } else if (
4185                 typeof diffEntry === "number" ||
4186                 diffEntry instanceof Ref
4187               ) {
4188                 diffBuf[j] = diffEntry.toString();
4189               }
4190             }
4191             hash.update(diffBuf.join());
4192           }
4193         }
4194       }
4195 
4196       hash.update(`${firstChar}-${lastChar}`); // Fixes issue10665_reduced.pdf
4197 
4198       if (toUnicode instanceof BaseStream) {
4199         const stream = toUnicode.str || toUnicode;
4200         const uint8array = stream.buffer
4201           ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength)
4202           : new Uint8Array(
4203               stream.bytes.buffer,
4204               stream.start,
4205               stream.end - stream.start
4206             );
4207         hash.update(uint8array);
4208       } else if (toUnicode instanceof Name) {
4209         hash.update(toUnicode.name);
4210       }
4211 
4212       const widths = dict.get("Widths") || baseDict.get("Widths");
4213       if (Array.isArray(widths)) {
4214         const widthsBuf = [];
4215         for (const entry of widths) {
4216           if (typeof entry === "number" || entry instanceof Ref) {
4217             widthsBuf.push(entry.toString());
4218           }
4219         }
4220         hash.update(widthsBuf.join());
4221       }
4222 
4223       if (composite) {
4224         hash.update("compositeFont");
4225 
4226         const compositeWidths = dict.get("W") || baseDict.get("W");
4227         if (Array.isArray(compositeWidths)) {
4228           const widthsBuf = [];
4229           for (const entry of compositeWidths) {
4230             if (typeof entry === "number" || entry instanceof Ref) {
4231               widthsBuf.push(entry.toString());
4232             } else if (Array.isArray(entry)) {
4233               const subWidthsBuf = [];
4234               for (const element of entry) {
4235                 if (typeof element === "number" || element instanceof Ref) {
4236                   subWidthsBuf.push(element.toString());
4237                 }
4238               }
4239               widthsBuf.push(`[${subWidthsBuf.join()}]`);
4240             }
4241           }
4242           hash.update(widthsBuf.join());
4243         }
4244 
4245         const cidToGidMap =
4246           dict.getRaw("CIDToGIDMap") || baseDict.getRaw("CIDToGIDMap");
4247         if (cidToGidMap instanceof Name) {
4248           hash.update(cidToGidMap.name);
4249         } else if (cidToGidMap instanceof Ref) {
4250           hash.update(cidToGidMap.toString());
4251         } else if (cidToGidMap instanceof BaseStream) {
4252           hash.update(cidToGidMap.peekBytes());
4253         }
4254       }
4255     }
4256 
4257     return {
4258       descriptor,
4259       dict,
4260       baseDict,
4261       composite,
4262       type: type.name,
4263       firstChar,
4264       lastChar,
4265       toUnicode,
4266       hash: hash ? hash.hexdigest() : "",
4267     };
4268   }
4269 
4270   async translateFont({
4271     descriptor,
4272     dict,
4273     baseDict,
4274     composite,
4275     type,
4276     firstChar,
4277     lastChar,
4278     toUnicode,
4279     cssFontInfo,
4280   }) {
4281     const isType3Font = type === "Type3";
4282 
4283     if (!descriptor) {
4284       if (isType3Font) {
4285         const bbox = lookupNormalRect(dict.getArray("FontBBox"), [0, 0, 0, 0]);
4286         // FontDescriptor is only required for Type3 fonts when the document
4287         // is a tagged pdf. Create a barbebones one to get by.
4288         descriptor = new Dict(null);
4289         descriptor.set("FontName", Name.get(type));
4290         descriptor.set("FontBBox", bbox);
4291       } else {
4292         // Before PDF 1.5 if the font was one of the base 14 fonts, having a
4293         // FontDescriptor was not required.
4294         // This case is here for compatibility.
4295         let baseFontName = dict.get("BaseFont");
4296         if (!(baseFontName instanceof Name)) {
4297           throw new FormatError("Base font is not specified");
4298         }
4299 
4300         // Using base font name as a font name.
4301         baseFontName = baseFontName.name.replaceAll(/[,_]/g, "-");
4302         const metrics = this.getBaseFontMetrics(baseFontName);
4303 
4304         // Simulating descriptor flags attribute
4305         const fontNameWoStyle = baseFontName.split("-", 1)[0];
4306         const flags =
4307           (this.isSerifFont(fontNameWoStyle) ? FontFlags.Serif : 0) |
4308           (metrics.monospace ? FontFlags.FixedPitch : 0) |
4309           (getSymbolsFonts()[fontNameWoStyle]
4310             ? FontFlags.Symbolic
4311             : FontFlags.Nonsymbolic);
4312 
4313         const properties = {
4314           type,
4315           name: baseFontName,
4316           loadedName: baseDict.loadedName,
4317           systemFontInfo: null,
4318           widths: metrics.widths,
4319           defaultWidth: metrics.defaultWidth,
4320           isSimulatedFlags: true,
4321           flags,
4322           firstChar,
4323           lastChar,
4324           toUnicode,
4325           xHeight: 0,
4326           capHeight: 0,
4327           italicAngle: 0,
4328           isType3Font,
4329         };
4330         const widths = dict.get("Widths");
4331 
4332         const standardFontName = getStandardFontName(baseFontName);
4333         let file = null;
4334         if (standardFontName) {
4335           file = await this.fetchStandardFontData(standardFontName);
4336           properties.isInternalFont = !!file;
4337         }
4338         if (!properties.isInternalFont && this.options.useSystemFonts) {
4339           properties.systemFontInfo = getFontSubstitution(
4340             this.systemFontCache,
4341             this.idFactory,
4342             this.options.standardFontDataUrl,
4343             baseFontName,
4344             standardFontName,
4345             type
4346           );
4347         }
4348 
4349         const newProperties = await this.extractDataStructures(
4350           dict,
4351           properties
4352         );
4353         if (Array.isArray(widths)) {
4354           const glyphWidths = [];
4355           let j = firstChar;
4356           for (const w of widths) {
4357             const width = this.xref.fetchIfRef(w);
4358             if (typeof width === "number") {
4359               glyphWidths[j] = width;
4360             }
4361             j++;
4362           }
4363           newProperties.widths = glyphWidths;
4364         } else {
4365           newProperties.widths = this.buildCharCodeToWidth(
4366             metrics.widths,
4367             newProperties
4368           );
4369         }
4370         return new Font(baseFontName, file, newProperties);
4371       }
4372     }
4373 
4374     // According to the spec if 'FontDescriptor' is declared, 'FirstChar',
4375     // 'LastChar' and 'Widths' should exist too, but some PDF encoders seem
4376     // to ignore this rule when a variant of a standard font is used.
4377     // TODO Fill the width array depending on which of the base font this is
4378     // a variant.
4379 
4380     let fontName = descriptor.get("FontName");
4381     let baseFont = dict.get("BaseFont");
4382     // Some bad PDFs have a string as the font name.
4383     if (typeof fontName === "string") {
4384       fontName = Name.get(fontName);
4385     }
4386     if (typeof baseFont === "string") {
4387       baseFont = Name.get(baseFont);
4388     }
4389 
4390     const fontNameStr = fontName?.name;
4391     const baseFontStr = baseFont?.name;
4392     if (!isType3Font && fontNameStr !== baseFontStr) {
4393       info(
4394         `The FontDescriptor's FontName is "${fontNameStr}" but ` +
4395           `should be the same as the Font's BaseFont "${baseFontStr}".`
4396       );
4397       // - Workaround for cases where e.g. fontNameStr = 'Arial' and
4398       //   baseFontStr = 'Arial,Bold' (needed when no font file is embedded).
4399       //
4400       // - Workaround for cases where e.g. fontNameStr = 'wg09np' and
4401       //   baseFontStr = 'Wingdings-Regular' (fixes issue7454.pdf).
4402       if (
4403         fontNameStr &&
4404         baseFontStr &&
4405         (baseFontStr.startsWith(fontNameStr) ||
4406           (!isKnownFontName(fontNameStr) && isKnownFontName(baseFontStr)))
4407       ) {
4408         fontName = null;
4409       }
4410     }
4411     fontName ||= baseFont;
4412 
4413     if (!(fontName instanceof Name)) {
4414       throw new FormatError("invalid font name");
4415     }
4416 
4417     let fontFile, subtype, length1, length2, length3;
4418     try {
4419       fontFile = descriptor.get("FontFile", "FontFile2", "FontFile3");
4420 
4421       if (fontFile) {
4422         if (!(fontFile instanceof BaseStream)) {
4423           throw new FormatError("FontFile should be a stream");
4424         } else if (fontFile.isEmpty) {
4425           throw new FormatError("FontFile is empty");
4426         }
4427       }
4428     } catch (ex) {
4429       if (!this.options.ignoreErrors) {
4430         throw ex;
4431       }
4432       warn(`translateFont - fetching "${fontName.name}" font file: "${ex}".`);
4433       fontFile = null;
4434     }
4435     let isInternalFont = false;
4436     let glyphScaleFactors = null;
4437     let systemFontInfo = null;
4438     if (fontFile) {
4439       if (fontFile.dict) {
4440         const subtypeEntry = fontFile.dict.get("Subtype");
4441         if (subtypeEntry instanceof Name) {
4442           subtype = subtypeEntry.name;
4443         }
4444         length1 = fontFile.dict.get("Length1");
4445         length2 = fontFile.dict.get("Length2");
4446         length3 = fontFile.dict.get("Length3");
4447       }
4448     } else if (cssFontInfo) {
4449       // We've a missing XFA font.
4450       const standardFontName = getXfaFontName(fontName.name);
4451       if (standardFontName) {
4452         cssFontInfo.fontFamily = `${cssFontInfo.fontFamily}-PdfJS-XFA`;
4453         cssFontInfo.metrics = standardFontName.metrics || null;
4454         glyphScaleFactors = standardFontName.factors || null;
4455         fontFile = await this.fetchStandardFontData(standardFontName.name);
4456         isInternalFont = !!fontFile;
4457 
4458         // We're using a substitution font but for example widths (if any)
4459         // are related to the glyph positions in the font.
4460         // So we overwrite everything here to be sure that widths are
4461         // correct.
4462         baseDict = dict = getXfaFontDict(fontName.name);
4463         composite = true;
4464       }
4465     } else if (!isType3Font) {
4466       const standardFontName = getStandardFontName(fontName.name);
4467       if (standardFontName) {
4468         fontFile = await this.fetchStandardFontData(standardFontName);
4469         isInternalFont = !!fontFile;
4470       }
4471       if (!isInternalFont && this.options.useSystemFonts) {
4472         systemFontInfo = getFontSubstitution(
4473           this.systemFontCache,
4474           this.idFactory,
4475           this.options.standardFontDataUrl,
4476           fontName.name,
4477           standardFontName,
4478           type
4479         );
4480       }
4481     }
4482 
4483     const fontMatrix = lookupMatrix(
4484       dict.getArray("FontMatrix"),
4485       FONT_IDENTITY_MATRIX
4486     );
4487     const bbox = lookupNormalRect(
4488       descriptor.getArray("FontBBox") || dict.getArray("FontBBox"),
4489       undefined
4490     );
4491     let ascent = descriptor.get("Ascent");
4492     if (typeof ascent !== "number") {
4493       ascent = undefined;
4494     }
4495     let descent = descriptor.get("Descent");
4496     if (typeof descent !== "number") {
4497       descent = undefined;
4498     }
4499     let xHeight = descriptor.get("XHeight");
4500     if (typeof xHeight !== "number") {
4501       xHeight = 0;
4502     }
4503     let capHeight = descriptor.get("CapHeight");
4504     if (typeof capHeight !== "number") {
4505       capHeight = 0;
4506     }
4507     let flags = descriptor.get("Flags");
4508     if (!Number.isInteger(flags)) {
4509       flags = 0;
4510     }
4511     let italicAngle = descriptor.get("ItalicAngle");
4512     if (typeof italicAngle !== "number") {
4513       italicAngle = 0;
4514     }
4515 
4516     const properties = {
4517       type,
4518       name: fontName.name,
4519       subtype,
4520       file: fontFile,
4521       length1,
4522       length2,
4523       length3,
4524       isInternalFont,
4525       loadedName: baseDict.loadedName,
4526       composite,
4527       fixedPitch: false,
4528       fontMatrix,
4529       firstChar,
4530       lastChar,
4531       toUnicode,
4532       bbox,
4533       ascent,
4534       descent,
4535       xHeight,
4536       capHeight,
4537       flags,
4538       italicAngle,
4539       isType3Font,
4540       cssFontInfo,
4541       scaleFactors: glyphScaleFactors,
4542       systemFontInfo,
4543     };
4544 
4545     if (composite) {
4546       const cidEncoding = baseDict.get("Encoding");
4547       if (cidEncoding instanceof Name) {
4548         properties.cidEncoding = cidEncoding.name;
4549       }
4550       const cMap = await CMapFactory.create({
4551         encoding: cidEncoding,
4552         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
4553         useCMap: null,
4554       });
4555       properties.cMap = cMap;
4556       properties.vertical = properties.cMap.vertical;
4557     }
4558 
4559     const newProperties = await this.extractDataStructures(dict, properties);
4560     this.extractWidths(dict, descriptor, newProperties);
4561 
4562     return new Font(fontName.name, fontFile, newProperties);
4563   }
4564 
4565   static buildFontPaths(font, glyphs, handler, evaluatorOptions) {
4566     function buildPath(fontChar) {
4567       const glyphName = `${font.loadedName}_path_${fontChar}`;
4568       try {
4569         if (font.renderer.hasBuiltPath(fontChar)) {
4570           return;
4571         }
4572         handler.send("commonobj", [
4573           glyphName,
4574           "FontPath",
4575           font.renderer.getPathJs(fontChar),
4576         ]);
4577       } catch (reason) {
4578         if (evaluatorOptions.ignoreErrors) {
4579           warn(`buildFontPaths - ignoring ${glyphName} glyph: "${reason}".`);
4580           return;
4581         }
4582         throw reason;
4583       }
4584     }
4585 
4586     for (const glyph of glyphs) {
4587       buildPath(glyph.fontChar);
4588 
4589       // If the glyph has an accent we need to build a path for its
4590       // fontChar too, otherwise CanvasGraphics_paintChar will fail.
4591       const accent = glyph.accent;
4592       if (accent?.fontChar) {
4593         buildPath(accent.fontChar);
4594       }
4595     }
4596   }
4597 
4598   static get fallbackFontDict() {
4599     const dict = new Dict();
4600     dict.set("BaseFont", Name.get("Helvetica"));
4601     dict.set("Type", Name.get("FallbackType"));
4602     dict.set("Subtype", Name.get("FallbackType"));
4603     dict.set("Encoding", Name.get("WinAnsiEncoding"));
4604 
4605     return shadow(this, "fallbackFontDict", dict);
4606   }
4607 }
4608 
4609 class TranslatedFont {
4610   constructor({ loadedName, font, dict, evaluatorOptions }) {
4611     this.loadedName = loadedName;
4612     this.font = font;
4613     this.dict = dict;
4614     this._evaluatorOptions = evaluatorOptions || DefaultPartialEvaluatorOptions;
4615     this.type3Loaded = null;
4616     this.type3Dependencies = font.isType3Font ? new Set() : null;
4617     this.sent = false;
4618   }
4619 
4620   send(handler) {
4621     if (this.sent) {
4622       return;
4623     }
4624     this.sent = true;
4625 
4626     handler.send("commonobj", [
4627       this.loadedName,
4628       "Font",
4629       this.font.exportData(this._evaluatorOptions.fontExtraProperties),
4630     ]);
4631   }
4632 
4633   fallback(handler) {
4634     if (!this.font.data) {
4635       return;
4636     }
4637     // When font loading failed, fall back to the built-in font renderer.
4638     this.font.disableFontFace = true;
4639     // An arbitrary number of text rendering operators could have been
4640     // encountered between the point in time when the 'Font' message was sent
4641     // to the main-thread, and the point in time when the 'FontFallback'
4642     // message was received on the worker-thread.
4643     // To ensure that all 'FontPath's are available on the main-thread, when
4644     // font loading failed, attempt to resend *all* previously parsed glyphs.
4645     PartialEvaluator.buildFontPaths(
4646       this.font,
4647       /* glyphs = */ this.font.glyphCacheValues,
4648       handler,
4649       this._evaluatorOptions
4650     );
4651   }
4652 
4653   loadType3Data(evaluator, resources, task) {
4654     if (this.type3Loaded) {
4655       return this.type3Loaded;
4656     }
4657     if (!this.font.isType3Font) {
4658       throw new Error("Must be a Type3 font.");
4659     }
4660     // When parsing Type3 glyphs, always ignore them if there are errors.
4661     // Compared to the parsing of e.g. an entire page, it doesn't really
4662     // make sense to only be able to render a Type3 glyph partially.
4663     const type3Evaluator = evaluator.clone({ ignoreErrors: false });
4664     // Prevent circular references in Type3 fonts.
4665     const type3FontRefs = new RefSet(evaluator.type3FontRefs);
4666     if (this.dict.objId && !type3FontRefs.has(this.dict.objId)) {
4667       type3FontRefs.put(this.dict.objId);
4668     }
4669     type3Evaluator.type3FontRefs = type3FontRefs;
4670 
4671     const translatedFont = this.font,
4672       type3Dependencies = this.type3Dependencies;
4673     let loadCharProcsPromise = Promise.resolve();
4674     const charProcs = this.dict.get("CharProcs");
4675     const fontResources = this.dict.get("Resources") || resources;
4676     const charProcOperatorList = Object.create(null);
4677 
4678     const fontBBox = Util.normalizeRect(translatedFont.bbox || [0, 0, 0, 0]),
4679       width = fontBBox[2] - fontBBox[0],
4680       height = fontBBox[3] - fontBBox[1];
4681     const fontBBoxSize = Math.hypot(width, height);
4682 
4683     for (const key of charProcs.getKeys()) {
4684       loadCharProcsPromise = loadCharProcsPromise.then(() => {
4685         const glyphStream = charProcs.get(key);
4686         const operatorList = new OperatorList();
4687         return type3Evaluator
4688           .getOperatorList({
4689             stream: glyphStream,
4690             task,
4691             resources: fontResources,
4692             operatorList,
4693           })
4694           .then(() => {
4695             // According to the PDF specification, section "9.6.5 Type 3 Fonts"
4696             // and "Table 113":
4697             //  "A glyph description that begins with the d1 operator should
4698             //   not execute any operators that set the colour (or other
4699             //   colour-related parameters) in the graphics state;
4700             //   any use of such operators shall be ignored."
4701             if (operatorList.fnArray[0] === OPS.setCharWidthAndBounds) {
4702               this._removeType3ColorOperators(operatorList, fontBBoxSize);
4703             }
4704             charProcOperatorList[key] = operatorList.getIR();
4705 
4706             for (const dependency of operatorList.dependencies) {
4707               type3Dependencies.add(dependency);
4708             }
4709           })
4710           .catch(function (reason) {
4711             warn(`Type3 font resource "${key}" is not available.`);
4712             const dummyOperatorList = new OperatorList();
4713             charProcOperatorList[key] = dummyOperatorList.getIR();
4714           });
4715       });
4716     }
4717     this.type3Loaded = loadCharProcsPromise.then(() => {
4718       translatedFont.charProcOperatorList = charProcOperatorList;
4719       if (this._bbox) {
4720         translatedFont.isCharBBox = true;
4721         translatedFont.bbox = this._bbox;
4722       }
4723     });
4724     return this.type3Loaded;
4725   }
4726 
4727   /**
4728    * @private
4729    */
4730   _removeType3ColorOperators(operatorList, fontBBoxSize = NaN) {
4731     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
4732       assert(
4733         operatorList.fnArray[0] === OPS.setCharWidthAndBounds,
4734         "Type3 glyph shall start with the d1 operator."
4735       );
4736     }
4737     const charBBox = Util.normalizeRect(operatorList.argsArray[0].slice(2)),
4738       width = charBBox[2] - charBBox[0],
4739       height = charBBox[3] - charBBox[1];
4740     const charBBoxSize = Math.hypot(width, height);
4741 
4742     if (width === 0 || height === 0) {
4743       // Skip the d1 operator when its bounds are bogus (fixes issue14953.pdf).
4744       operatorList.fnArray.splice(0, 1);
4745       operatorList.argsArray.splice(0, 1);
4746     } else if (
4747       fontBBoxSize === 0 ||
4748       Math.round(charBBoxSize / fontBBoxSize) >= 10
4749     ) {
4750       // Override the fontBBox when it's undefined/empty, or when it's at least
4751       // (approximately) one order of magnitude smaller than the charBBox
4752       // (fixes issue14999_reduced.pdf).
4753       if (!this._bbox) {
4754         this._bbox = [Infinity, Infinity, -Infinity, -Infinity];
4755       }
4756       this._bbox[0] = Math.min(this._bbox[0], charBBox[0]);
4757       this._bbox[1] = Math.min(this._bbox[1], charBBox[1]);
4758       this._bbox[2] = Math.max(this._bbox[2], charBBox[2]);
4759       this._bbox[3] = Math.max(this._bbox[3], charBBox[3]);
4760     }
4761 
4762     let i = 0,
4763       ii = operatorList.length;
4764     while (i < ii) {
4765       switch (operatorList.fnArray[i]) {
4766         case OPS.setCharWidthAndBounds:
4767           break; // Handled above.
4768         case OPS.setStrokeColorSpace:
4769         case OPS.setFillColorSpace:
4770         case OPS.setStrokeColor:
4771         case OPS.setStrokeColorN:
4772         case OPS.setFillColor:
4773         case OPS.setFillColorN:
4774         case OPS.setStrokeGray:
4775         case OPS.setFillGray:
4776         case OPS.setStrokeRGBColor:
4777         case OPS.setFillRGBColor:
4778         case OPS.setStrokeCMYKColor:
4779         case OPS.setFillCMYKColor:
4780         case OPS.shadingFill:
4781         case OPS.setRenderingIntent:
4782           operatorList.fnArray.splice(i, 1);
4783           operatorList.argsArray.splice(i, 1);
4784           ii--;
4785           continue;
4786 
4787         case OPS.setGState:
4788           const [gStateObj] = operatorList.argsArray[i];
4789           let j = 0,
4790             jj = gStateObj.length;
4791           while (j < jj) {
4792             const [gStateKey] = gStateObj[j];
4793             switch (gStateKey) {
4794               case "TR":
4795               case "TR2":
4796               case "HT":
4797               case "BG":
4798               case "BG2":
4799               case "UCR":
4800               case "UCR2":
4801                 gStateObj.splice(j, 1);
4802                 jj--;
4803                 continue;
4804             }
4805             j++;
4806           }
4807           break;
4808       }
4809       i++;
4810     }
4811   }
4812 }
4813 
4814 class StateManager {
4815   constructor(initialState = new EvalState()) {
4816     this.state = initialState;
4817     this.stateStack = [];
4818   }
4819 
4820   save() {
4821     const old = this.state;
4822     this.stateStack.push(this.state);
4823     this.state = old.clone();
4824   }
4825 
4826   restore() {
4827     const prev = this.stateStack.pop();
4828     if (prev) {
4829       this.state = prev;
4830     }
4831   }
4832 
4833   transform(args) {
4834     this.state.ctm = Util.transform(this.state.ctm, args);
4835   }
4836 }
4837 
4838 class TextState {
4839   constructor() {
4840     this.ctm = new Float32Array(IDENTITY_MATRIX);
4841     this.fontName = null;
4842     this.fontSize = 0;
4843     this.loadedName = null;
4844     this.font = null;
4845     this.fontMatrix = FONT_IDENTITY_MATRIX;
4846     this.textMatrix = IDENTITY_MATRIX.slice();
4847     this.textLineMatrix = IDENTITY_MATRIX.slice();
4848     this.charSpacing = 0;
4849     this.wordSpacing = 0;
4850     this.leading = 0;
4851     this.textHScale = 1;
4852     this.textRise = 0;
4853   }
4854 
4855   setTextMatrix(a, b, c, d, e, f) {
4856     const m = this.textMatrix;
4857     m[0] = a;
4858     m[1] = b;
4859     m[2] = c;
4860     m[3] = d;
4861     m[4] = e;
4862     m[5] = f;
4863   }
4864 
4865   setTextLineMatrix(a, b, c, d, e, f) {
4866     const m = this.textLineMatrix;
4867     m[0] = a;
4868     m[1] = b;
4869     m[2] = c;
4870     m[3] = d;
4871     m[4] = e;
4872     m[5] = f;
4873   }
4874 
4875   translateTextMatrix(x, y) {
4876     const m = this.textMatrix;
4877     m[4] = m[0] * x + m[2] * y + m[4];
4878     m[5] = m[1] * x + m[3] * y + m[5];
4879   }
4880 
4881   translateTextLineMatrix(x, y) {
4882     const m = this.textLineMatrix;
4883     m[4] = m[0] * x + m[2] * y + m[4];
4884     m[5] = m[1] * x + m[3] * y + m[5];
4885   }
4886 
4887   carriageReturn() {
4888     this.translateTextLineMatrix(0, -this.leading);
4889     this.textMatrix = this.textLineMatrix.slice();
4890   }
4891 
4892   clone() {
4893     const clone = Object.create(this);
4894     clone.textMatrix = this.textMatrix.slice();
4895     clone.textLineMatrix = this.textLineMatrix.slice();
4896     clone.fontMatrix = this.fontMatrix.slice();
4897     return clone;
4898   }
4899 }
4900 
4901 class EvalState {
4902   constructor() {
4903     this.ctm = new Float32Array(IDENTITY_MATRIX);
4904     this.font = null;
4905     this.textRenderingMode = TextRenderingMode.FILL;
4906     this._fillColorSpace = ColorSpace.singletons.gray;
4907     this._strokeColorSpace = ColorSpace.singletons.gray;
4908     this.patternFillColorSpace = null;
4909     this.patternStrokeColorSpace = null;
4910   }
4911 
4912   get fillColorSpace() {
4913     return this._fillColorSpace;
4914   }
4915 
4916   set fillColorSpace(colorSpace) {
4917     this._fillColorSpace = this.patternFillColorSpace = colorSpace;
4918   }
4919 
4920   get strokeColorSpace() {
4921     return this._strokeColorSpace;
4922   }
4923 
4924   set strokeColorSpace(colorSpace) {
4925     this._strokeColorSpace = this.patternStrokeColorSpace = colorSpace;
4926   }
4927 
4928   clone() {
4929     return Object.create(this);
4930   }
4931 }
4932 
4933 class EvaluatorPreprocessor {
4934   static get opMap() {
4935     // Specifies properties for each command
4936     //
4937     // If variableArgs === true: [0, `numArgs`] expected
4938     // If variableArgs === false: exactly `numArgs` expected
4939     return shadow(
4940       this,
4941       "opMap",
4942       Object.assign(Object.create(null), {
4943         // Graphic state
4944         w: { id: OPS.setLineWidth, numArgs: 1, variableArgs: false },
4945         J: { id: OPS.setLineCap, numArgs: 1, variableArgs: false },
4946         j: { id: OPS.setLineJoin, numArgs: 1, variableArgs: false },
4947         M: { id: OPS.setMiterLimit, numArgs: 1, variableArgs: false },
4948         d: { id: OPS.setDash, numArgs: 2, variableArgs: false },
4949         ri: { id: OPS.setRenderingIntent, numArgs: 1, variableArgs: false },
4950         i: { id: OPS.setFlatness, numArgs: 1, variableArgs: false },
4951         gs: { id: OPS.setGState, numArgs: 1, variableArgs: false },
4952         q: { id: OPS.save, numArgs: 0, variableArgs: false },
4953         Q: { id: OPS.restore, numArgs: 0, variableArgs: false },
4954         cm: { id: OPS.transform, numArgs: 6, variableArgs: false },
4955 
4956         // Path
4957         m: { id: OPS.moveTo, numArgs: 2, variableArgs: false },
4958         l: { id: OPS.lineTo, numArgs: 2, variableArgs: false },
4959         c: { id: OPS.curveTo, numArgs: 6, variableArgs: false },
4960         v: { id: OPS.curveTo2, numArgs: 4, variableArgs: false },
4961         y: { id: OPS.curveTo3, numArgs: 4, variableArgs: false },
4962         h: { id: OPS.closePath, numArgs: 0, variableArgs: false },
4963         re: { id: OPS.rectangle, numArgs: 4, variableArgs: false },
4964         S: { id: OPS.stroke, numArgs: 0, variableArgs: false },
4965         s: { id: OPS.closeStroke, numArgs: 0, variableArgs: false },
4966         f: { id: OPS.fill, numArgs: 0, variableArgs: false },
4967         F: { id: OPS.fill, numArgs: 0, variableArgs: false },
4968         "f*": { id: OPS.eoFill, numArgs: 0, variableArgs: false },
4969         B: { id: OPS.fillStroke, numArgs: 0, variableArgs: false },
4970         "B*": { id: OPS.eoFillStroke, numArgs: 0, variableArgs: false },
4971         b: { id: OPS.closeFillStroke, numArgs: 0, variableArgs: false },
4972         "b*": { id: OPS.closeEOFillStroke, numArgs: 0, variableArgs: false },
4973         n: { id: OPS.endPath, numArgs: 0, variableArgs: false },
4974 
4975         // Clipping
4976         W: { id: OPS.clip, numArgs: 0, variableArgs: false },
4977         "W*": { id: OPS.eoClip, numArgs: 0, variableArgs: false },
4978 
4979         // Text
4980         BT: { id: OPS.beginText, numArgs: 0, variableArgs: false },
4981         ET: { id: OPS.endText, numArgs: 0, variableArgs: false },
4982         Tc: { id: OPS.setCharSpacing, numArgs: 1, variableArgs: false },
4983         Tw: { id: OPS.setWordSpacing, numArgs: 1, variableArgs: false },
4984         Tz: { id: OPS.setHScale, numArgs: 1, variableArgs: false },
4985         TL: { id: OPS.setLeading, numArgs: 1, variableArgs: false },
4986         Tf: { id: OPS.setFont, numArgs: 2, variableArgs: false },
4987         Tr: { id: OPS.setTextRenderingMode, numArgs: 1, variableArgs: false },
4988         Ts: { id: OPS.setTextRise, numArgs: 1, variableArgs: false },
4989         Td: { id: OPS.moveText, numArgs: 2, variableArgs: false },
4990         TD: { id: OPS.setLeadingMoveText, numArgs: 2, variableArgs: false },
4991         Tm: { id: OPS.setTextMatrix, numArgs: 6, variableArgs: false },
4992         "T*": { id: OPS.nextLine, numArgs: 0, variableArgs: false },
4993         Tj: { id: OPS.showText, numArgs: 1, variableArgs: false },
4994         TJ: { id: OPS.showSpacedText, numArgs: 1, variableArgs: false },
4995         "'": { id: OPS.nextLineShowText, numArgs: 1, variableArgs: false },
4996         '"': {
4997           id: OPS.nextLineSetSpacingShowText,
4998           numArgs: 3,
4999           variableArgs: false,
5000         },
5001 
5002         // Type3 fonts
5003         d0: { id: OPS.setCharWidth, numArgs: 2, variableArgs: false },
5004         d1: {
5005           id: OPS.setCharWidthAndBounds,
5006           numArgs: 6,
5007           variableArgs: false,
5008         },
5009 
5010         // Color
5011         CS: { id: OPS.setStrokeColorSpace, numArgs: 1, variableArgs: false },
5012         cs: { id: OPS.setFillColorSpace, numArgs: 1, variableArgs: false },
5013         SC: { id: OPS.setStrokeColor, numArgs: 4, variableArgs: true },
5014         SCN: { id: OPS.setStrokeColorN, numArgs: 33, variableArgs: true },
5015         sc: { id: OPS.setFillColor, numArgs: 4, variableArgs: true },
5016         scn: { id: OPS.setFillColorN, numArgs: 33, variableArgs: true },
5017         G: { id: OPS.setStrokeGray, numArgs: 1, variableArgs: false },
5018         g: { id: OPS.setFillGray, numArgs: 1, variableArgs: false },
5019         RG: { id: OPS.setStrokeRGBColor, numArgs: 3, variableArgs: false },
5020         rg: { id: OPS.setFillRGBColor, numArgs: 3, variableArgs: false },
5021         K: { id: OPS.setStrokeCMYKColor, numArgs: 4, variableArgs: false },
5022         k: { id: OPS.setFillCMYKColor, numArgs: 4, variableArgs: false },
5023 
5024         // Shading
5025         sh: { id: OPS.shadingFill, numArgs: 1, variableArgs: false },
5026 
5027         // Images
5028         BI: { id: OPS.beginInlineImage, numArgs: 0, variableArgs: false },
5029         ID: { id: OPS.beginImageData, numArgs: 0, variableArgs: false },
5030         EI: { id: OPS.endInlineImage, numArgs: 1, variableArgs: false },
5031 
5032         // XObjects
5033         Do: { id: OPS.paintXObject, numArgs: 1, variableArgs: false },
5034         MP: { id: OPS.markPoint, numArgs: 1, variableArgs: false },
5035         DP: { id: OPS.markPointProps, numArgs: 2, variableArgs: false },
5036         BMC: { id: OPS.beginMarkedContent, numArgs: 1, variableArgs: false },
5037         BDC: {
5038           id: OPS.beginMarkedContentProps,
5039           numArgs: 2,
5040           variableArgs: false,
5041         },
5042         EMC: { id: OPS.endMarkedContent, numArgs: 0, variableArgs: false },
5043 
5044         // Compatibility
5045         BX: { id: OPS.beginCompat, numArgs: 0, variableArgs: false },
5046         EX: { id: OPS.endCompat, numArgs: 0, variableArgs: false },
5047 
5048         // (reserved partial commands for the lexer)
5049         BM: null,
5050         BD: null,
5051         true: null,
5052         fa: null,
5053         fal: null,
5054         fals: null,
5055         false: null,
5056         nu: null,
5057         nul: null,
5058         null: null,
5059       })
5060     );
5061   }
5062 
5063   static MAX_INVALID_PATH_OPS = 10;
5064 
5065   constructor(stream, xref, stateManager = new StateManager()) {
5066     // TODO(mduan): pass array of knownCommands rather than this.opMap
5067     // dictionary
5068     this.parser = new Parser({
5069       lexer: new Lexer(stream, EvaluatorPreprocessor.opMap),
5070       xref,
5071     });
5072     this.stateManager = stateManager;
5073     this.nonProcessedArgs = [];
5074     this._isPathOp = false;
5075     this._numInvalidPathOPS = 0;
5076   }
5077 
5078   get savedStatesDepth() {
5079     return this.stateManager.stateStack.length;
5080   }
5081 
5082   // |operation| is an object with two fields:
5083   //
5084   // - |fn| is an out param.
5085   //
5086   // - |args| is an inout param. On entry, it should have one of two values.
5087   //
5088   //   - An empty array. This indicates that the caller is providing the
5089   //     array in which the args will be stored in. The caller should use
5090   //     this value if it can reuse a single array for each call to read().
5091   //
5092   //   - |null|. This indicates that the caller needs this function to create
5093   //     the array in which any args are stored in. If there are zero args,
5094   //     this function will leave |operation.args| as |null| (thus avoiding
5095   //     allocations that would occur if we used an empty array to represent
5096   //     zero arguments). Otherwise, it will replace |null| with a new array
5097   //     containing the arguments. The caller should use this value if it
5098   //     cannot reuse an array for each call to read().
5099   //
5100   // These two modes are present because this function is very hot and so
5101   // avoiding allocations where possible is worthwhile.
5102   //
5103   read(operation) {
5104     let args = operation.args;
5105     while (true) {
5106       const obj = this.parser.getObj();
5107       if (obj instanceof Cmd) {
5108         const cmd = obj.cmd;
5109         // Check that the command is valid
5110         const opSpec = EvaluatorPreprocessor.opMap[cmd];
5111         if (!opSpec) {
5112           warn(`Unknown command "${cmd}".`);
5113           continue;
5114         }
5115 
5116         const fn = opSpec.id;
5117         const numArgs = opSpec.numArgs;
5118         let argsLength = args !== null ? args.length : 0;
5119 
5120         // If the *previous* command wasn't a path operator, reset the heuristic
5121         // used with incomplete path operators below (fixes issue14917.pdf).
5122         if (!this._isPathOp) {
5123           this._numInvalidPathOPS = 0;
5124         }
5125         this._isPathOp = fn >= OPS.moveTo && fn <= OPS.endPath;
5126 
5127         if (!opSpec.variableArgs) {
5128           // Postscript commands can be nested, e.g. /F2 /GS2 gs 5.711 Tf
5129           if (argsLength !== numArgs) {
5130             const nonProcessedArgs = this.nonProcessedArgs;
5131             while (argsLength > numArgs) {
5132               nonProcessedArgs.push(args.shift());
5133               argsLength--;
5134             }
5135             while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
5136               if (args === null) {
5137                 args = [];
5138               }
5139               args.unshift(nonProcessedArgs.pop());
5140               argsLength++;
5141             }
5142           }
5143 
5144           if (argsLength < numArgs) {
5145             const partialMsg =
5146               `command ${cmd}: expected ${numArgs} args, ` +
5147               `but received ${argsLength} args.`;
5148 
5149             // Incomplete path operators, in particular, can result in fairly
5150             // chaotic rendering artifacts. Hence the following heuristics is
5151             // used to error, rather than just warn, once a number of invalid
5152             // path operators have been encountered (fixes bug1443140.pdf).
5153             if (
5154               this._isPathOp &&
5155               ++this._numInvalidPathOPS >
5156                 EvaluatorPreprocessor.MAX_INVALID_PATH_OPS
5157             ) {
5158               throw new FormatError(`Invalid ${partialMsg}`);
5159             }
5160             // If we receive too few arguments, it's not possible to execute
5161             // the command, hence we skip the command.
5162             warn(`Skipping ${partialMsg}`);
5163             if (args !== null) {
5164               args.length = 0;
5165             }
5166             continue;
5167           }
5168         } else if (argsLength > numArgs) {
5169           info(
5170             `Command ${cmd}: expected [0, ${numArgs}] args, ` +
5171               `but received ${argsLength} args.`
5172           );
5173         }
5174 
5175         // TODO figure out how to type-check vararg functions
5176         this.preprocessCommand(fn, args);
5177 
5178         operation.fn = fn;
5179         operation.args = args;
5180         return true;
5181       }
5182       if (obj === EOF) {
5183         return false; // no more commands
5184       }
5185       // argument
5186       if (obj !== null) {
5187         if (args === null) {
5188           args = [];
5189         }
5190         args.push(obj);
5191         if (args.length > 33) {
5192           throw new FormatError("Too many arguments");
5193         }
5194       }
5195     }
5196   }
5197 
5198   preprocessCommand(fn, args) {
5199     switch (fn | 0) {
5200       case OPS.save:
5201         this.stateManager.save();
5202         break;
5203       case OPS.restore:
5204         this.stateManager.restore();
5205         break;
5206       case OPS.transform:
5207         this.stateManager.transform(args);
5208         break;
5209     }
5210   }
5211 }
5212 
5213 export { EvaluatorPreprocessor, PartialEvaluator };
File:
src/core/operator_list.js
1 /* Copyright 2017 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import { ImageKind, OPS, RenderingIntentFlag, warn } from "../shared/util.js";
17 
18 function addState(parentState, pattern, checkFn, iterateFn, processFn) {
19   let state = parentState;
20   for (let i = 0, ii = pattern.length - 1; i < ii; i++) {
21     const item = pattern[i];
22     state = state[item] ||= [];
23   }
24   state[pattern.at(-1)] = {
25     checkFn,
26     iterateFn,
27     processFn,
28   };
29 }
30 
31 const InitialState = [];
32 
33 // This replaces (save, transform, paintInlineImageXObject, restore)+
34 // sequences with one |paintInlineImageXObjectGroup| operation.
35 addState(
36   InitialState,
37   [OPS.save, OPS.transform, OPS.paintInlineImageXObject, OPS.restore],
38   null,
39   function iterateInlineImageGroup(context, i) {
40     const fnArray = context.fnArray;
41     const iFirstSave = context.iCurr - 3;
42     const pos = (i - iFirstSave) % 4;
43     switch (pos) {
44       case 0:
45         return fnArray[i] === OPS.save;
46       case 1:
47         return fnArray[i] === OPS.transform;
48       case 2:
49         return fnArray[i] === OPS.paintInlineImageXObject;
50       case 3:
51         return fnArray[i] === OPS.restore;
52     }
53     throw new Error(`iterateInlineImageGroup - invalid pos: ${pos}`);
54   },
55   function foundInlineImageGroup(context, i) {
56     const MIN_IMAGES_IN_INLINE_IMAGES_BLOCK = 10;
57     const MAX_IMAGES_IN_INLINE_IMAGES_BLOCK = 200;
58     const MAX_WIDTH = 1000;
59     const IMAGE_PADDING = 1;
60 
61     const fnArray = context.fnArray,
62       argsArray = context.argsArray;
63     const curr = context.iCurr;
64     const iFirstSave = curr - 3;
65     const iFirstTransform = curr - 2;
66     const iFirstPIIXO = curr - 1;
67 
68     const count = Math.min(
69       Math.floor((i - iFirstSave) / 4),
70       MAX_IMAGES_IN_INLINE_IMAGES_BLOCK
71     );
72     if (count < MIN_IMAGES_IN_INLINE_IMAGES_BLOCK) {
73       return i - ((i - iFirstSave) % 4);
74     }
75 
76     // assuming that heights of those image is too small (~1 pixel)
77     // packing as much as possible by lines
78     let maxX = 0;
79     const map = [];
80     let maxLineHeight = 0;
81     let currentX = IMAGE_PADDING,
82       currentY = IMAGE_PADDING;
83     for (let q = 0; q < count; q++) {
84       const transform = argsArray[iFirstTransform + (q << 2)];
85       const img = argsArray[iFirstPIIXO + (q << 2)][0];
86       if (currentX + img.width > MAX_WIDTH) {
87         // starting new line
88         maxX = Math.max(maxX, currentX);
89         currentY += maxLineHeight + 2 * IMAGE_PADDING;
90         currentX = 0;
91         maxLineHeight = 0;
92       }
93       map.push({
94         transform,
95         x: currentX,
96         y: currentY,
97         w: img.width,
98         h: img.height,
99       });
100       currentX += img.width + 2 * IMAGE_PADDING;
101       maxLineHeight = Math.max(maxLineHeight, img.height);
102     }
103     const imgWidth = Math.max(maxX, currentX) + IMAGE_PADDING;
104     const imgHeight = currentY + maxLineHeight + IMAGE_PADDING;
105     const imgData = new Uint8Array(imgWidth * imgHeight * 4);
106     const imgRowSize = imgWidth << 2;
107     for (let q = 0; q < count; q++) {
108       const data = argsArray[iFirstPIIXO + (q << 2)][0].data;
109       // Copy image by lines and extends pixels into padding.
110       const rowSize = map[q].w << 2;
111       let dataOffset = 0;
112       let offset = (map[q].x + map[q].y * imgWidth) << 2;
113       imgData.set(data.subarray(0, rowSize), offset - imgRowSize);
114       for (let k = 0, kk = map[q].h; k < kk; k++) {
115         imgData.set(data.subarray(dataOffset, dataOffset + rowSize), offset);
116         dataOffset += rowSize;
117         offset += imgRowSize;
118       }
119       imgData.set(data.subarray(dataOffset - rowSize, dataOffset), offset);
120       while (offset >= 0) {
121         data[offset - 4] = data[offset];
122         data[offset - 3] = data[offset + 1];
123         data[offset - 2] = data[offset + 2];
124         data[offset - 1] = data[offset + 3];
125         data[offset + rowSize] = data[offset + rowSize - 4];
126         data[offset + rowSize + 1] = data[offset + rowSize - 3];
127         data[offset + rowSize + 2] = data[offset + rowSize - 2];
128         data[offset + rowSize + 3] = data[offset + rowSize - 1];
129         offset -= imgRowSize;
130       }
131     }
132 
133     const img = {
134       width: imgWidth,
135       height: imgHeight,
136     };
137     if (context.isOffscreenCanvasSupported) {
138       const canvas = new OffscreenCanvas(imgWidth, imgHeight);
139       const ctx = canvas.getContext("2d");
140       ctx.putImageData(
141         new ImageData(
142           new Uint8ClampedArray(imgData.buffer),
143           imgWidth,
144           imgHeight
145         ),
146         0,
147         0
148       );
149       img.bitmap = canvas.transferToImageBitmap();
150       img.data = null;
151     } else {
152       img.kind = ImageKind.RGBA_32BPP;
153       img.data = imgData;
154     }
155 
156     // Replace queue items.
157     fnArray.splice(iFirstSave, count * 4, OPS.paintInlineImageXObjectGroup);
158     argsArray.splice(iFirstSave, count * 4, [img, map]);
159 
160     return iFirstSave + 1;
161   }
162 );
163 
164 // This replaces (save, transform, paintImageMaskXObject, restore)+
165 // sequences with one |paintImageMaskXObjectGroup| or one
166 // |paintImageMaskXObjectRepeat| operation.
167 addState(
168   InitialState,
169   [OPS.save, OPS.transform, OPS.paintImageMaskXObject, OPS.restore],
170   null,
171   function iterateImageMaskGroup(context, i) {
172     const fnArray = context.fnArray;
173     const iFirstSave = context.iCurr - 3;
174     const pos = (i - iFirstSave) % 4;
175     switch (pos) {
176       case 0:
177         return fnArray[i] === OPS.save;
178       case 1:
179         return fnArray[i] === OPS.transform;
180       case 2:
181         return fnArray[i] === OPS.paintImageMaskXObject;
182       case 3:
183         return fnArray[i] === OPS.restore;
184     }
185     throw new Error(`iterateImageMaskGroup - invalid pos: ${pos}`);
186   },
187   function foundImageMaskGroup(context, i) {
188     const MIN_IMAGES_IN_MASKS_BLOCK = 10;
189     const MAX_IMAGES_IN_MASKS_BLOCK = 100;
190     const MAX_SAME_IMAGES_IN_MASKS_BLOCK = 1000;
191 
192     const fnArray = context.fnArray,
193       argsArray = context.argsArray;
194     const curr = context.iCurr;
195     const iFirstSave = curr - 3;
196     const iFirstTransform = curr - 2;
197     const iFirstPIMXO = curr - 1;
198 
199     // At this point, i is the index of the first op past the last valid
200     // quartet.
201     let count = Math.floor((i - iFirstSave) / 4);
202     if (count < MIN_IMAGES_IN_MASKS_BLOCK) {
203       return i - ((i - iFirstSave) % 4);
204     }
205 
206     let isSameImage = false;
207     let iTransform, transformArgs;
208     const firstPIMXOArg0 = argsArray[iFirstPIMXO][0];
209     const firstTransformArg0 = argsArray[iFirstTransform][0],
210       firstTransformArg1 = argsArray[iFirstTransform][1],
211       firstTransformArg2 = argsArray[iFirstTransform][2],
212       firstTransformArg3 = argsArray[iFirstTransform][3];
213 
214     if (firstTransformArg1 === firstTransformArg2) {
215       isSameImage = true;
216       iTransform = iFirstTransform + 4;
217       let iPIMXO = iFirstPIMXO + 4;
218       for (let q = 1; q < count; q++, iTransform += 4, iPIMXO += 4) {
219         transformArgs = argsArray[iTransform];
220         if (
221           argsArray[iPIMXO][0] !== firstPIMXOArg0 ||
222           transformArgs[0] !== firstTransformArg0 ||
223           transformArgs[1] !== firstTransformArg1 ||
224           transformArgs[2] !== firstTransformArg2 ||
225           transformArgs[3] !== firstTransformArg3
226         ) {
227           if (q < MIN_IMAGES_IN_MASKS_BLOCK) {
228             isSameImage = false;
229           } else {
230             count = q;
231           }
232           break; // different image or transform
233         }
234       }
235     }
236 
237     if (isSameImage) {
238       count = Math.min(count, MAX_SAME_IMAGES_IN_MASKS_BLOCK);
239       const positions = new Float32Array(count * 2);
240       iTransform = iFirstTransform;
241       for (let q = 0; q < count; q++, iTransform += 4) {
242         transformArgs = argsArray[iTransform];
243         positions[q << 1] = transformArgs[4];
244         positions[(q << 1) + 1] = transformArgs[5];
245       }
246 
247       // Replace queue items.
248       fnArray.splice(iFirstSave, count * 4, OPS.paintImageMaskXObjectRepeat);
249       argsArray.splice(iFirstSave, count * 4, [
250         firstPIMXOArg0,
251         firstTransformArg0,
252         firstTransformArg1,
253         firstTransformArg2,
254         firstTransformArg3,
255         positions,
256       ]);
257     } else {
258       count = Math.min(count, MAX_IMAGES_IN_MASKS_BLOCK);
259       const images = [];
260       for (let q = 0; q < count; q++) {
261         transformArgs = argsArray[iFirstTransform + (q << 2)];
262         const maskParams = argsArray[iFirstPIMXO + (q << 2)][0];
263         images.push({
264           data: maskParams.data,
265           width: maskParams.width,
266           height: maskParams.height,
267           interpolate: maskParams.interpolate,
268           count: maskParams.count,
269           transform: transformArgs,
270         });
271       }
272 
273       // Replace queue items.
274       fnArray.splice(iFirstSave, count * 4, OPS.paintImageMaskXObjectGroup);
275       argsArray.splice(iFirstSave, count * 4, [images]);
276     }
277 
278     return iFirstSave + 1;
279   }
280 );
281 
282 // This replaces (save, transform, paintImageXObject, restore)+ sequences
283 // with one paintImageXObjectRepeat operation, if the |transform| and
284 // |paintImageXObjectRepeat| ops are appropriate.
285 addState(
286   InitialState,
287   [OPS.save, OPS.transform, OPS.paintImageXObject, OPS.restore],
288   function (context) {
289     const argsArray = context.argsArray;
290     const iFirstTransform = context.iCurr - 2;
291     return (
292       argsArray[iFirstTransform][1] === 0 && argsArray[iFirstTransform][2] === 0
293     );
294   },
295   function iterateImageGroup(context, i) {
296     const fnArray = context.fnArray,
297       argsArray = context.argsArray;
298     const iFirstSave = context.iCurr - 3;
299     const pos = (i - iFirstSave) % 4;
300     switch (pos) {
301       case 0:
302         return fnArray[i] === OPS.save;
303       case 1:
304         if (fnArray[i] !== OPS.transform) {
305           return false;
306         }
307         const iFirstTransform = context.iCurr - 2;
308         const firstTransformArg0 = argsArray[iFirstTransform][0];
309         const firstTransformArg3 = argsArray[iFirstTransform][3];
310         if (
311           argsArray[i][0] !== firstTransformArg0 ||
312           argsArray[i][1] !== 0 ||
313           argsArray[i][2] !== 0 ||
314           argsArray[i][3] !== firstTransformArg3
315         ) {
316           return false; // transforms don't match
317         }
318         return true;
319       case 2:
320         if (fnArray[i] !== OPS.paintImageXObject) {
321           return false;
322         }
323         const iFirstPIXO = context.iCurr - 1;
324         const firstPIXOArg0 = argsArray[iFirstPIXO][0];
325         if (argsArray[i][0] !== firstPIXOArg0) {
326           return false; // images don't match
327         }
328         return true;
329       case 3:
330         return fnArray[i] === OPS.restore;
331     }
332     throw new Error(`iterateImageGroup - invalid pos: ${pos}`);
333   },
334   function (context, i) {
335     const MIN_IMAGES_IN_BLOCK = 3;
336     const MAX_IMAGES_IN_BLOCK = 1000;
337 
338     const fnArray = context.fnArray,
339       argsArray = context.argsArray;
340     const curr = context.iCurr;
341     const iFirstSave = curr - 3;
342     const iFirstTransform = curr - 2;
343     const iFirstPIXO = curr - 1;
344     const firstPIXOArg0 = argsArray[iFirstPIXO][0];
345     const firstTransformArg0 = argsArray[iFirstTransform][0];
346     const firstTransformArg3 = argsArray[iFirstTransform][3];
347 
348     // At this point, i is the index of the first op past the last valid
349     // quartet.
350     const count = Math.min(
351       Math.floor((i - iFirstSave) / 4),
352       MAX_IMAGES_IN_BLOCK
353     );
354     if (count < MIN_IMAGES_IN_BLOCK) {
355       return i - ((i - iFirstSave) % 4);
356     }
357 
358     // Extract the (x,y) positions from all of the matching transforms.
359     const positions = new Float32Array(count * 2);
360     let iTransform = iFirstTransform;
361     for (let q = 0; q < count; q++, iTransform += 4) {
362       const transformArgs = argsArray[iTransform];
363       positions[q << 1] = transformArgs[4];
364       positions[(q << 1) + 1] = transformArgs[5];
365     }
366 
367     // Replace queue items.
368     const args = [
369       firstPIXOArg0,
370       firstTransformArg0,
371       firstTransformArg3,
372       positions,
373     ];
374     fnArray.splice(iFirstSave, count * 4, OPS.paintImageXObjectRepeat);
375     argsArray.splice(iFirstSave, count * 4, args);
376 
377     return iFirstSave + 1;
378   }
379 );
380 
381 // This replaces (beginText, setFont, setTextMatrix, showText, endText)+
382 // sequences with (beginText, setFont, (setTextMatrix, showText)+, endText)+
383 // sequences, if the font for each one is the same.
384 addState(
385   InitialState,
386   [OPS.beginText, OPS.setFont, OPS.setTextMatrix, OPS.showText, OPS.endText],
387   null,
388   function iterateShowTextGroup(context, i) {
389     const fnArray = context.fnArray,
390       argsArray = context.argsArray;
391     const iFirstSave = context.iCurr - 4;
392     const pos = (i - iFirstSave) % 5;
393     switch (pos) {
394       case 0:
395         return fnArray[i] === OPS.beginText;
396       case 1:
397         return fnArray[i] === OPS.setFont;
398       case 2:
399         return fnArray[i] === OPS.setTextMatrix;
400       case 3:
401         if (fnArray[i] !== OPS.showText) {
402           return false;
403         }
404         const iFirstSetFont = context.iCurr - 3;
405         const firstSetFontArg0 = argsArray[iFirstSetFont][0];
406         const firstSetFontArg1 = argsArray[iFirstSetFont][1];
407         if (
408           argsArray[i][0] !== firstSetFontArg0 ||
409           argsArray[i][1] !== firstSetFontArg1
410         ) {
411           return false; // fonts don't match
412         }
413         return true;
414       case 4:
415         return fnArray[i] === OPS.endText;
416     }
417     throw new Error(`iterateShowTextGroup - invalid pos: ${pos}`);
418   },
419   function (context, i) {
420     const MIN_CHARS_IN_BLOCK = 3;
421     const MAX_CHARS_IN_BLOCK = 1000;
422 
423     const fnArray = context.fnArray,
424       argsArray = context.argsArray;
425     const curr = context.iCurr;
426     const iFirstBeginText = curr - 4;
427     const iFirstSetFont = curr - 3;
428     const iFirstSetTextMatrix = curr - 2;
429     const iFirstShowText = curr - 1;
430     const iFirstEndText = curr;
431     const firstSetFontArg0 = argsArray[iFirstSetFont][0];
432     const firstSetFontArg1 = argsArray[iFirstSetFont][1];
433 
434     // At this point, i is the index of the first op past the last valid
435     // quintet.
436     let count = Math.min(
437       Math.floor((i - iFirstBeginText) / 5),
438       MAX_CHARS_IN_BLOCK
439     );
440     if (count < MIN_CHARS_IN_BLOCK) {
441       return i - ((i - iFirstBeginText) % 5);
442     }
443 
444     // If the preceding quintet is (<something>, setFont, setTextMatrix,
445     // showText, endText), include that as well. (E.g. <something> might be
446     // |dependency|.)
447     let iFirst = iFirstBeginText;
448     if (
449       iFirstBeginText >= 4 &&
450       fnArray[iFirstBeginText - 4] === fnArray[iFirstSetFont] &&
451       fnArray[iFirstBeginText - 3] === fnArray[iFirstSetTextMatrix] &&
452       fnArray[iFirstBeginText - 2] === fnArray[iFirstShowText] &&
453       fnArray[iFirstBeginText - 1] === fnArray[iFirstEndText] &&
454       argsArray[iFirstBeginText - 4][0] === firstSetFontArg0 &&
455       argsArray[iFirstBeginText - 4][1] === firstSetFontArg1
456     ) {
457       count++;
458       iFirst -= 5;
459     }
460 
461     // Remove (endText, beginText, setFont) trios.
462     let iEndText = iFirst + 4;
463     for (let q = 1; q < count; q++) {
464       fnArray.splice(iEndText, 3);
465       argsArray.splice(iEndText, 3);
466       iEndText += 2;
467     }
468 
469     return iEndText + 1;
470   }
471 );
472 
473 class NullOptimizer {
474   constructor(queue) {
475     this.queue = queue;
476   }
477 
478   _optimize() {}
479 
480   push(fn, args) {
481     this.queue.fnArray.push(fn);
482     this.queue.argsArray.push(args);
483     this._optimize();
484   }
485 
486   flush() {}
487 
488   reset() {}
489 }
490 
491 class QueueOptimizer extends NullOptimizer {
492   constructor(queue) {
493     super(queue);
494     this.state = null;
495     this.context = {
496       iCurr: 0,
497       fnArray: queue.fnArray,
498       argsArray: queue.argsArray,
499       isOffscreenCanvasSupported: false,
500     };
501     this.match = null;
502     this.lastProcessed = 0;
503   }
504 
505   // eslint-disable-next-line accessor-pairs
506   set isOffscreenCanvasSupported(value) {
507     this.context.isOffscreenCanvasSupported = value;
508   }
509 
510   _optimize() {
511     // Process new fnArray item(s) chunk.
512     const fnArray = this.queue.fnArray;
513     let i = this.lastProcessed,
514       ii = fnArray.length;
515     let state = this.state;
516     let match = this.match;
517     if (!state && !match && i + 1 === ii && !InitialState[fnArray[i]]) {
518       // Micro-optimization for the common case: last item is not
519       // optimizable, just skipping it.
520       this.lastProcessed = ii;
521       return;
522     }
523 
524     const context = this.context;
525     while (i < ii) {
526       if (match) {
527         // Already find a block of potentially optimizable items, iterating...
528         const iterate = (0, match.iterateFn)(context, i);
529         if (iterate) {
530           i++;
531           continue;
532         }
533         // Found last items for the block, processing...
534         i = (0, match.processFn)(context, i + 1);
535         ii = fnArray.length;
536         match = null;
537         state = null;
538         if (i >= ii) {
539           break;
540         }
541       }
542       // Find the potentially optimizable items.
543       state = (state || InitialState)[fnArray[i]];
544       if (!state || Array.isArray(state)) {
545         i++;
546         continue;
547       }
548       // Found a start of the block based on addState rules.
549       context.iCurr = i;
550       i++;
551       if (state.checkFn && !(0, state.checkFn)(context)) {
552         // Check failed, continue search...
553         state = null;
554         continue;
555       }
556       match = state;
557       state = null;
558     }
559     this.state = state;
560     this.match = match;
561     this.lastProcessed = i;
562   }
563 
564   flush() {
565     while (this.match) {
566       const length = this.queue.fnArray.length;
567       this.lastProcessed = (0, this.match.processFn)(this.context, length);
568       this.match = null;
569       this.state = null;
570       // Repeat optimization until all chunks are exhausted.
571       this._optimize();
572     }
573   }
574 
575   reset() {
576     this.state = null;
577     this.match = null;
578     this.lastProcessed = 0;
579   }
580 }
581 
582 class OperatorList {
583   static CHUNK_SIZE = 1000;
584 
585   // Close to chunk size.
586   static CHUNK_SIZE_ABOUT = this.CHUNK_SIZE - 5;
587 
588   constructor(intent = 0, streamSink) {
589     this._streamSink = streamSink;
590     this.fnArray = [];
591     this.argsArray = [];
592     this.optimizer =
593       streamSink && !(intent & RenderingIntentFlag.OPLIST)
594         ? new QueueOptimizer(this)
595         : new NullOptimizer(this);
596     this.dependencies = new Set();
597     this._totalLength = 0;
598     this.weight = 0;
599     this._resolved = streamSink ? null : Promise.resolve();
600   }
601 
602   // eslint-disable-next-line accessor-pairs
603   set isOffscreenCanvasSupported(value) {
604     this.optimizer.isOffscreenCanvasSupported = value;
605   }
606 
607   get length() {
608     return this.argsArray.length;
609   }
610 
611   get ready() {
612     return this._resolved || this._streamSink.ready;
613   }
614 
615   /**
616    * @type {number} The total length of the entire operator list, since
617    *                `this.length === 0` after flushing.
618    */
619   get totalLength() {
620     return this._totalLength + this.length;
621   }
622 
623   addOp(fn, args) {
624     this.optimizer.push(fn, args);
625     this.weight++;
626     if (this._streamSink) {
627       if (this.weight >= OperatorList.CHUNK_SIZE) {
628         this.flush();
629       } else if (
630         this.weight >= OperatorList.CHUNK_SIZE_ABOUT &&
631         (fn === OPS.restore || fn === OPS.endText)
632       ) {
633         // Heuristic to flush on boundary of restore or endText.
634         this.flush();
635       }
636     }
637   }
638 
639   addImageOps(fn, args, optionalContent) {
640     if (optionalContent !== undefined) {
641       this.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
642     }
643 
644     this.addOp(fn, args);
645 
646     if (optionalContent !== undefined) {
647       this.addOp(OPS.endMarkedContent, []);
648     }
649   }
650 
651   addDependency(dependency) {
652     if (this.dependencies.has(dependency)) {
653       return;
654     }
655     this.dependencies.add(dependency);
656     this.addOp(OPS.dependency, [dependency]);
657   }
658 
659   addDependencies(dependencies) {
660     for (const dependency of dependencies) {
661       this.addDependency(dependency);
662     }
663   }
664 
665   addOpList(opList) {
666     if (!(opList instanceof OperatorList)) {
667       warn('addOpList - ignoring invalid "opList" parameter.');
668       return;
669     }
670     for (const dependency of opList.dependencies) {
671       this.dependencies.add(dependency);
672     }
673     for (let i = 0, ii = opList.length; i < ii; i++) {
674       this.addOp(opList.fnArray[i], opList.argsArray[i]);
675     }
676   }
677 
678   getIR() {
679     return {
680       fnArray: this.fnArray,
681       argsArray: this.argsArray,
682       length: this.length,
683     };
684   }
685 
686   get _transfers() {
687     const transfers = [];
688     const { fnArray, argsArray, length } = this;
689     for (let i = 0; i < length; i++) {
690       switch (fnArray[i]) {
691         case OPS.paintInlineImageXObject:
692         case OPS.paintInlineImageXObjectGroup:
693         case OPS.paintImageMaskXObject:
694           const arg = argsArray[i][0]; // First parameter in imgData.
695           if (!arg.cached && arg.data?.buffer instanceof ArrayBuffer) {
696             transfers.push(arg.data.buffer);
697           }
698           break;
699       }
700     }
701     return transfers;
702   }
703 
704   flush(lastChunk = false, separateAnnots = null) {
705     this.optimizer.flush();
706     const length = this.length;
707     this._totalLength += length;
708 
709     this._streamSink.enqueue(
710       {
711         fnArray: this.fnArray,
712         argsArray: this.argsArray,
713         lastChunk,
714         separateAnnots,
715         length,
716       },
717       1,
718       this._transfers
719     );
720 
721     this.dependencies.clear();
722     this.fnArray.length = 0;
723     this.argsArray.length = 0;
724     this.weight = 0;
725     this.optimizer.reset();
726   }
727 }
728 
729 export { OperatorList };
</code>

Test file:
<test_file>
File:
test/unit/evaluator_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { createIdFactory, XRefMock } from "./test_utils.js";
import { Dict, Name } from "../../src/core/primitives.js";
import { FormatError, OPS } from "../../src/shared/util.js";
import { Stream, StringStream } from "../../src/core/stream.js";
import { OperatorList } from "../../src/core/operator_list.js";
import { PartialEvaluator } from "../../src/core/evaluator.js";
import { WorkerTask } from "../../src/core/worker.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

