it("should correctly handle images with SMaskMask entries", async () => {
  const { PDFDocument } = await import("../../src/core/document.js");
  const { PartialEvaluator } = await import("../../src/core/evaluator.js");
  const { OperatorList } = await import("../../src/core/operator_list.js");
  const { OPS } = await import("../../src/shared/util.js");

  // Create a sample PDF with an image that includes an SMask
  const pdfData = new Uint8Array([
    0x25, 0x50, 0x44, 0x46, 0x2D, 0x31, 0x2E, 0x30, 0x0A, 0x25, 0x5E, 0x2D, 0x5E, 0x2D, 0x0A,
    0x31, 0x30, 0x20, 0x6F, 0x62, 0x6A, 0x0A, 0x24, 0x2F, 0x53, 0x4D, 0x61, 0x73, 0x6B, 0x0A,
    0x32, 0x30, 0x20, 0x6F, 0x62, 0x6A, 0x0A, 0x24, 0x2F, 0x54, 0x79, 0x70, 0x65, 0x0A,
    0x2F, 0x53, 0x75, 0x62, 0x74, 0x79, 0x70, 0x65, 0x2F, 0x58, 0x4F, 0x62, 0x6A, 0x0A,
    0x3E, 0x3C, 0x58, 0x4F, 0x5A, 0x3E, 0x0A, 0x26, 0x31, 0x30, 0x20, 0x52, 0x45, 0x46, 0x0A,
    0x25, 0x50, 0x44, 0x46, 0x2D, 0x31, 0x2E, 0x30, 0x0A, 0x25, 0x5E, 0x2D, 0x5E, 0x2D, 0x0A,
    0x31, 0x30, 0x20, 0x6F, 0x62, 0x6A, 0x0A, 0x24, 0x2F, 0x53, 0x4D, 0x61, 0x73, 0x6B, 0x0A,
    0x32, 0x30, 0x20, 0x6F, 0x62, 0x6A, 0x0A, 0x24, 0x2F, 0x54, 0x79, 0x70, 0x65, 0x0A,
    0x2F, 0x53, 0x75, 0x62, 0x74, 0x79, 0x70, 0x65, 0x2F, 0x58, 0x4F, 0x62, 0x6A, 0x0A,
    0x3E, 0x3C, 0x58, 0x4F, 0x5A, 0x3E, 0x0A
  ]);

  const pdf = await PDFDocument.load(pdfData);
  const evaluator = new PartialEvaluator({
    xref: pdf.xref,
    handler: null,
    pageIndex: 0,
    idFactory: pdf.idFactory,
    fontCache: new Map(),
    builtInCMapCache: new Map(),
    standardFontDataCache: new Map(),
    globalImageCache: new Map(),
    systemFontCache: new Map(),
    options: {}
  });

  const operatorList = new OperatorList();
  const page = pdf.getPage(1);
  await evaluator.getOperatorList({
    stream: page.stream,
    task: page,
    resources: page.resources,
    operatorList: operatorList
  });

  const ops = operatorList.fnArray;
  const expectedSequence = [
    OPS.save,
    OPS.setGState,
    OPS.paintImageXObject,
    OPS.restore
  ];

  let found = 0;
  for (let i = 0; i < ops.length; i++) {
    if (ops[i] === expectedSequence[found]) {
      found++;
      if (found === expectedSequence.length) break;
    }
  }

  expect(found).toBe(expectedSequence.length);
});